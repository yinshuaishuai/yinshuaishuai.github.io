<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java运算符</title>
    <url>/2022/01/18/java%E5%9F%BA%E7%A1%80/Java%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<h1 id="（a-a-b）位或"><a href="#（a-a-b）位或" class="headerlink" title="|= （a = a | b）位或"></a>|= （a = a | b）位或</h1><p><strong>描述：</strong>  </p>
<blockquote>
<p>两个二进制对应位为0时，该位为0，否则为1。拿5的二进制<code>0000 0101</code>和3的二进制<code>0000 0011</code>进行<code>|</code>运算，后三位的对应位都不是同时等于0，所以最终结果为<code>0000 0111</code>也就是7的二进制。</p>
</blockquote>
<p>代码示例如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static void test() &#123;</span><br><span class="line">    int a = 5;//0000 0101</span><br><span class="line">    int b = 3;//0000 0011</span><br><span class="line">    a |= b;//0000 0111</span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="amp-（a-a-amp-b）位与"><a href="#amp-（a-a-amp-b）位与" class="headerlink" title="&amp;= （a = a &amp; b）位与"></a>&amp;= （a = a &amp; b）位与</h1><p><strong>描述：</strong>  </p>
<blockquote>
<p>两个二进制对应位都为1时，结果为1，否则结果都是0。拿5的二进制<code>0000 0101</code>和3的二进制<code>0000 0011</code>进行<code>&amp;</code>运算，只有最后一位都是1，则最终结果为<code>0000 0001</code>也就是1的二进制。</p>
</blockquote>
<p>代码示例：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static void test1() &#123;</span><br><span class="line">    int a = 5;//0000 0101</span><br><span class="line">    int b = 3;//0000 0011</span><br><span class="line">    a &amp;= b;//0000 0001</span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="（a-a-b）异或运算符"><a href="#（a-a-b）异或运算符" class="headerlink" title="^= （a = a ^ b）异或运算符"></a>^= （a = a ^ b）异或运算符</h1><p><strong>描述：</strong>  </p>
<blockquote>
<p>两个二进制对应位相同时，结果为0，否则结果为1。拿5的二进制<code>0000 0101</code>和3的二进制<code>0000 0011</code>进行<code>^</code>运算，<code>1-5</code>位对应位都是0，所以<code>1-5</code>位都是0，第8位都为1所以第8位也为0，其他的对应位都不相等所以为1，则最终结果为<code>0000 0110</code>也就是6的二进制。</p>
</blockquote>
<p>代码示例：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static void test2() &#123;</span><br><span class="line">    int a = 5;//0000 0101</span><br><span class="line">    int b = 3;//0000 0011</span><br><span class="line">    a ^= b;//0000 0110</span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><ul>
<li>|=：两个二进制对应位都为0时，结果为0，否则结果为1；</li>
<li>&amp;=：两个二进制的对应位都为1时，结果为1，否则结果等于0；</li>
<li>^=：两个二进制的对应位相同时，结果为0，否则结果为1。</li>
</ul>
<h1 id="（取反运算符）"><a href="#（取反运算符）" class="headerlink" title="~ （取反运算符）"></a>~ （取反运算符）</h1><p><strong>描述：</strong>  </p>
<blockquote>
<p>把数字转为二进制，然后取反，就是1变0,0变1</p>
</blockquote>
<p>代码示例：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ~</span><br><span class="line">private static void test6() &#123;</span><br><span class="line">    //4  0000 0000 0000 0000 0000 0000 0000 0100</span><br><span class="line">    //   1111 1111 1111 1111 1111 1111 1111 1011</span><br><span class="line">    System.out.println(Integer.parseInt(&quot;-1111111111111111111111111111011&quot;,2));</span><br><span class="line">    System.out.println(~4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="gt-gt-（带符号右移）"><a href="#gt-gt-（带符号右移）" class="headerlink" title="&gt;&gt; （带符号右移）"></a>&gt;&gt; （带符号右移）</h1><p><strong>描述：</strong>  </p>
<blockquote>
<p>符号前面的数字的二进制数，向右移动符号右边的数字位数，正数高位用0补，负数高位用1补。 </p>
</blockquote>
<p>代码示例：   </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static void test3() &#123;</span><br><span class="line">    //4  0000 0000 0000 0000 0000 0000 0000 0100</span><br><span class="line">    //   00000 0000 0000 0000 0000 0000 0000 010</span><br><span class="line">    System.out.println(4&gt;&gt;1);</span><br><span class="line">    //-4  1111 1111 1111 1111 1111 1111 1111 1100</span><br><span class="line">    //    11111 1111 1111 1111 1111 1111 1111 110</span><br><span class="line">    System.out.println(-4&gt;&gt;1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="lt-lt-（带符号左移）"><a href="#lt-lt-（带符号左移）" class="headerlink" title="&lt;&lt; （带符号左移）"></a>&lt;&lt; （带符号左移）</h1><p><strong>描述：</strong>  </p>
<blockquote>
<p>符号前面的数字的二进制数，向左移动符号右边的数字位数，正数高位用0补，负数高位用1补。</p>
</blockquote>
<p>代码示例：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static void test4() &#123;</span><br><span class="line">    //4  0000 0000 0000 0000 0000 0000 0000 0100</span><br><span class="line">    //   000 0000 0000 0000 0000 0000 0000 01000</span><br><span class="line">    System.out.println(4&lt;&lt;1);</span><br><span class="line">    //-4  1111 1111 1111 1111 1111 1111 1111 1100</span><br><span class="line">    //    111 1111 1111 1111 1111 1111 1111 11011</span><br><span class="line">    System.out.println(-4&lt;&lt;1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="gt-gt-gt-（无符号右移）"><a href="#gt-gt-gt-（无符号右移）" class="headerlink" title="&gt;&gt;&gt; （无符号右移）"></a>&gt;&gt;&gt; （无符号右移）</h1><p><strong>描述：</strong>  </p>
<blockquote>
<p>符号前面的数字的二进制数，向右移动符号右边的数字位数，正数高位用0补，负数忽略符号高位也用0补。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// &gt;&gt;&gt;</span><br><span class="line">private static void test5() &#123;</span><br><span class="line">    //4  0000 0000 0000 0000 0000 0000 0000 0100</span><br><span class="line">    //   00000 0000 0000 0000 0000 0000 0000 010</span><br><span class="line">    System.out.println(4&gt;&gt;&gt;1);</span><br><span class="line">    //-4  1111 1111 1111 1111 1111 1111 1111 1100</span><br><span class="line">    //    01111 1111 1111 1111 1111 1111 1111 110</span><br><span class="line">    System.out.println(-4&gt;&gt;&gt;1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="负数取值"><a href="#负数取值" class="headerlink" title="负数取值"></a>负数取值</h1><p>Java中负数是以原码的补码形式表达的。  </p>
<p><strong>原码：</strong>   </p>
<ul>
<li>一个正数，按照绝对值大小转换成的二进制；</li>
<li>一个负数，按照绝对值大小转换成二进制，然后最高位补1，称为原码。</li>
</ul>
<p>比如Java中Integer是32位，所以5的二进制为：0000 0000 0000 0000 0000 0000 0000 0101<br>5的原码是：0000 0000 0000 0000 0000 0000 0000 0101<br>所以，对应的-5的原码是：1000 0000 0000 0000 0000 0000 0000 0101  </p>
<p><strong>反码：</strong>  </p>
<ul>
<li>正数的反码与原码相同，负数的反码为该数的原码除符号位外其他位取反；</li>
<li>取反操作指：原为1，得0，原为0，得1,；（1变0,0变1）</li>
</ul>
<p>比如正数5的反码还是：0000 0000 0000 0000 0000 0000 0000 0101<br>负数-5，1000 0000 0000 0000 0000 0000 0000 0101的反码是：1111 1111 1111 1111 1111 1111 1111 1010<br>称1000 0000 0000 0000 0000 0000 0000 0101和1111 1111 1111 1111 1111 1111 1111 1010互为反码  </p>
<p><strong>补码：</strong>  </p>
<ul>
<li>正数的补码与原码相同</li>
<li>负数的补码为该数的反码然后在最后一位加1</li>
</ul>
<p>比如，1000 0000 0000 0000 0000 0000 0000 0101的反码是1111 1111 1111 1111 1111 1111 1111 1010<br>那么补码为：<br>1111 1111 1111 1111 1111 1111 1111 1010 + 1 = 1111 1111 1111 1111 1111 1111 1111 1011  </p>
<p>所以-5在Java中表达为：1111 1111 1111 1111 1111 1111 1111 1011  </p>
<p><strong>如-1在java中的表示:</strong>    </p>
<ul>
<li>先取-1的原码：1000 0000 0000 0000 0000 0000 0000 0001  </li>
<li>取反码：1111 1111 1111 1111 1111 1111 1111 1110  </li>
<li>补码：1111 1111 1111 1111 1111 1111 1111 1111   </li>
</ul>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令</title>
    <url>/2021/10/20/linux/Linux%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h2><p>就是list的缩写，通过ls命令不仅可以查看linux文件夹包含的文件，而且可以查看文件的权限，查看目录等信息  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -a     # 列出所有目录所有文件，包含.开始的隐藏文件</span><br><span class="line">ls -A     # 列出除.及..的其他文件</span><br><span class="line">ls -r     # 反序排列</span><br><span class="line">ls -t     # 以文件修改时间排序</span><br><span class="line">ls -S     # 以文件大小排序</span><br><span class="line">ls -h     # 以易读大小排序</span><br><span class="line">ls -l     # 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来</span><br></pre></td></tr></table></figure>

<h2 id="ll命令"><a href="#ll命令" class="headerlink" title="ll命令"></a>ll命令</h2><p>相当于<code>ls -l</code>命令的缩写，具体参数和<code>ls</code>命令相同</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ll</span><br></pre></td></tr></table></figure>

<h2 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h2><p>cd命令语法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd [目录名]</span><br></pre></td></tr></table></figure>
<p>进入根目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /</span><br></pre></td></tr></table></figure>
<p>进入用户目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~</span><br></pre></td></tr></table></figure>

<h2 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h2><p>查看当前工作目录路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwd         # 查看当前路径</span><br><span class="line">pwd -P      # 查看软连接的实际路径</span><br></pre></td></tr></table></figure>

<h2 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h2><p>用于创建文件夹<br>可用选项：</p>
<ul>
<li><strong>-m</strong>：对新建目录设置存取权限，也可以使用<code>chmod</code>命令设置</li>
<li><strong>-p</strong>：可以是一个路径名称，此时若路径中的某些目录尚不存在，加上此选项后，系统将自动创建那些不存在的目录，即一次可以创建多层目录<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir t                     # 在当前工作目录下创建文件夹名称为t的目录</span><br><span class="line">mkdir -p /tmp/test/t1/t     # 创建多层目录</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h2><p>删除一个目录中的一个或者多个文件或者目录，如果没有使用-r选项，则rm不会删除目录。如果使用rm来删除文件，通常仍可以将该文件恢复原状。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm [选项] 文件...</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm -i *.log         # 删除所有.log文件，删除前逐一询问确认</span><br><span class="line">rm -rf test         # 删除test目录以及其子目录中的所有文件并不用一一确认</span><br><span class="line">rm -- -f*           # 删除所有以f开头的文件</span><br></pre></td></tr></table></figure>

<h2 id="rmdir命令"><a href="#rmdir命令" class="headerlink" title="rmdir命令"></a>rmdir命令</h2><p>从一个目录中删除一个或者多个子目录，删除某个目录时必须拥有其父目录的写权限（不能删除非空目录）  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rmdir -p parent/chid/chid1      # 当parent子目录被删除后，它也成为空目录的话，也会一并删除</span><br></pre></td></tr></table></figure>

<h2 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h2><p>移动文件或者修改文件名，根据第二个参数类型（如目录，则移动文件，如为文件名，则重命名该文件）<br>当第二个参数为目录时，第一个参数可以是多个以空格分隔的文件或者目录，然后移动第一个参数指定的多个文件到第二个参数指定的目录中。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv test.log test1.txt                   # 将test.log重命名为test1.txt</span><br><span class="line">mv log1.txt log2.txt log3.txt /test     # 将log1.txt log2.txt log3.txt三个文件移动到根目录下的test目录中</span><br><span class="line">mv -i log1.txt log2.txt                 # 将文件1改名为文件2，如果文件2已经存在，则询问是否覆盖</span><br><span class="line">mv * ../                                # 移动当前文件夹下的所有文件到上一级目录</span><br></pre></td></tr></table></figure>

<h2 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h2><p>将源文件复制至目标文件，或将多个源文件复制到目标目录<br>注意：命令行复制，如果目标文件已经存在，会提示是否覆盖，而在shell脚本中，如果不加<code>-i</code>参数，则不会提示，而是直接覆盖</p>
<ul>
<li><strong>-i</strong>：提示</li>
<li><strong>-r</strong>：复制目录及目录中的所有文件</li>
<li><strong>-a</strong>：复制的文件与源文件时间保持一致<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp -ai a.txt test       # 复制a.txt到test目录下，保持源文件时间，如果源文件存在，提示是否覆盖</span><br><span class="line">cp -s a.txt link_a.txt  # 为a.txt建立一个连接（快捷方式）</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h2><p>cat命令三大功能：<br>1.一次显示整个文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat filename</span><br></pre></td></tr></table></figure>
<p>2.从键盘创建一个文件(只能创建文件，不能编辑已存在的文件)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat &gt; filename</span><br></pre></td></tr></table></figure>
<p>3.将几个文件合并成一个文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat file1 file2 &gt; file</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>-b</strong>：对非空输出行号</li>
<li><strong>-n</strong>：输出所有行号<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat -n log1.log log2.log        # 将log1.log的文件内容加上行号后输入到log2.log文件里面</span><br><span class="line">cat -b log1.lo log2.lo log.log  # 将log1.log和log2.log的文件内容加上行号（空白行不加）之后将内容附加到log.log里面</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="more命令"><a href="#more命令" class="headerlink" title="more命令"></a>more命令</h2><p>功能类似于cat，more会一页一页的显示方便使用者逐页阅读，而最基本的指令就算按空白键（space）就往下一页显示，按b键就会往回（back）一页显示<br><strong>命令参数：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+n          # 从第n行开始显示</span><br><span class="line">-n          # 定义屏幕大小未n行</span><br><span class="line">+/pattern   # 再每个档案显示前搜索该字符串（pattern），然后从该字符串前两行之后开始显示</span><br><span class="line">-c          # 从顶部清屏，然后显示</span><br><span class="line">-d          # 提示“Press space to continue &#x27;q&#x27; to quit(按空格键继续，按q键退出)”，禁用响铃功能</span><br><span class="line">-l          # 忽略Ctrl+l（换页）字符</span><br><span class="line">-p          # 通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似</span><br><span class="line">-s          # 把连续的多个空行显示为一行</span><br><span class="line">-u          # 把文件内容中的下划线去掉</span><br></pre></td></tr></table></figure>
<p><strong>常用的操作命令：</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Enter       # 向下n行，需要定义，默认为1行</span><br><span class="line">Ctrl+f      # 向下滚动一屏</span><br><span class="line">空格键       # 向下滚动一屏</span><br><span class="line">Ctrl+B      # 返回上一屏</span><br><span class="line">=           # 输出当前行的行号</span><br><span class="line">:f          # 输出文件名和当前行号</span><br><span class="line">V           # 调用vi编辑器</span><br><span class="line">!           # 调用shell，并执行命令</span><br><span class="line">q           # 退出more</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">more +3 text.txt        # 显示文件中从第三行开始的内容</span><br><span class="line">ls -l | more -5         # 再所列出的文件目录信息中，借助管道符每次显示5行</span><br></pre></td></tr></table></figure>

<h2 id="less命令"><a href="#less命令" class="headerlink" title="less命令"></a>less命令</h2><p>less与more类似，但使用less可以随意浏览文件，而more仅能向前移动，却不能向后移动，而且less在查看直接之前不会加载整个文件<br><strong>常用命令参数：</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-i          # 忽略搜索时的大小写</span><br><span class="line">-N          # 显示每行的行号</span><br><span class="line">-o          # &lt;文件名&gt; 将less输出的内容在指定文件中保存起来</span><br><span class="line">-s          # 显示连续空行为一行</span><br><span class="line">/字符串      # 向下搜索字符串的功能</span><br><span class="line">?字符串      # 向上搜索字符串的功能</span><br><span class="line">n           # 重复前一个搜索</span><br><span class="line">N           # 反向重复前一个搜索</span><br><span class="line">-x          # &lt;数字&gt; 将“tab”键显示为规定的数字空格</span><br><span class="line">b           # 向后翻一页</span><br><span class="line">d           # 向后翻半页</span><br><span class="line">h           # 显示帮助界面</span><br><span class="line">Q           # 退出less命令</span><br><span class="line">u           # 向前滚动半页</span><br><span class="line">y           # 向前滚动一行</span><br><span class="line">空格键       # 滚动一行</span><br><span class="line">回车键       # 滚动一行</span><br><span class="line">[pagediwn]  # 向下翻动一页</span><br><span class="line">[pageup]    # 向上翻动一页</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -aux | less -N       # ps查看进程信息，并通过less分页显示</span><br><span class="line">less 1.log z.log        # 查看多个文件(可以通过n查看下一个，p查看前一个)</span><br></pre></td></tr></table></figure>





















































































]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>synchronized关键字</title>
    <url>/2021/11/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h1 id="synchronized的作用"><a href="#synchronized的作用" class="headerlink" title="synchronized的作用"></a>synchronized的作用</h1><ul>
<li><p>官网解释翻译</p>
<blockquote>
<p>同步方法支持一种简单的策略来防止线程干扰和内存一致性错误：如果一个对象对多个线程可见，则对该对象变量的所有读取或写入都是通过同步方法完成的。</p>
</blockquote>
</li>
<li><p>通俗解释</p>
<blockquote>
<p>能够保证在同一时刻最多只有一个线程执行该段代码，以达到保证并发安全的效果。</p>
</blockquote>
</li>
</ul>
<h1 id="synchronized的地位"><a href="#synchronized的地位" class="headerlink" title="synchronized的地位"></a>synchronized的地位</h1><ul>
<li>synchronized的java的关键字，被java语言原生支持  </li>
<li>是最基本的互斥同步手段  </li>
<li>是并发编程种的元老级角色，是并发编程的必学内容 </li>
</ul>
<h1 id="synchronized的两种用法"><a href="#synchronized的两种用法" class="headerlink" title="synchronized的两种用法"></a>synchronized的两种用法</h1><h2 id="对象锁"><a href="#对象锁" class="headerlink" title="对象锁"></a>对象锁</h2><ul>
<li>包括方法锁（默认锁对象为this当前实例对象）和同步代码块锁（自己指定锁对象）</li>
</ul>
<h3 id="代码块形式"><a href="#代码块形式" class="headerlink" title="代码块形式"></a>代码块形式</h3><ul>
<li>手动指定锁对象<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedObjectCodeBlock2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        SynchronizedObjectCodeBlock2 s = <span class="keyword">new</span> SynchronizedObjectCodeBlock2();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(s);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(s);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;运行结束&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="方法锁形式"><a href="#方法锁形式" class="headerlink" title="方法锁形式"></a>方法锁形式</h3><ul>
<li>synchronized修饰普通方法，锁对象默认为this<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedObjectCodeBlock2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        SynchronizedObjectCodeBlock2 s = <span class="keyword">new</span> SynchronizedObjectCodeBlock2();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(s);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(s);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;运行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="类锁"><a href="#类锁" class="headerlink" title="类锁"></a>类锁</h2><ul>
<li>指synchronized修饰静态的方法或指定锁为class对象  </li>
</ul>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li>Java类可能有很多实例对象，但只有1个class对象</li>
<li>所谓的类锁，不过是class对象的锁而已  </li>
<li>类锁只能在同一时间被一个对象拥有  </li>
</ul>
<ul>
<li>synchronized加在static方法上<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedObjectCodeBlock2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        SynchronizedObjectCodeBlock2 s1 = <span class="keyword">new</span> SynchronizedObjectCodeBlock2();</span><br><span class="line">        SynchronizedObjectCodeBlock2 s2 = <span class="keyword">new</span> SynchronizedObjectCodeBlock2();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(s1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(s2);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;运行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>synchronized（*.class）代码块<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedObjectCodeBlock2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SynchronizedObjectCodeBlock2 s1 = <span class="keyword">new</span> SynchronizedObjectCodeBlock2();</span><br><span class="line">        SynchronizedObjectCodeBlock2 s2 = <span class="keyword">new</span> SynchronizedObjectCodeBlock2();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(s1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(s2);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedObjectCodeBlock2.class) &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;运行结束&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="多线程访问同步方法的7种情况"><a href="#多线程访问同步方法的7种情况" class="headerlink" title="多线程访问同步方法的7种情况"></a>多线程访问同步方法的7种情况</h1><h2 id="两个线程同时访问一个对象的同步方法"><a href="#两个线程同时访问一个对象的同步方法" class="headerlink" title="两个线程同时访问一个对象的同步方法"></a>两个线程同时访问一个对象的同步方法</h2><ul>
<li>会串行执行</li>
<li>同步方法默认锁的是this，也就是当前对象，每次只能有一个线程获取到锁</li>
</ul>
<h2 id="两个线程访问的是两个对象的同步方法"><a href="#两个线程访问的是两个对象的同步方法" class="headerlink" title="两个线程访问的是两个对象的同步方法"></a>两个线程访问的是两个对象的同步方法</h2><ul>
<li>会并行执行</li>
<li>默认锁的是this，也就是当前对象，由于是来个对象，也就是不同的锁，所以两个线程会同时执行</li>
</ul>
<h2 id="两个线程访问的是synchronized的静态方法"><a href="#两个线程访问的是synchronized的静态方法" class="headerlink" title="两个线程访问的是synchronized的静态方法"></a>两个线程访问的是synchronized的静态方法</h2><ul>
<li>会串行执行</li>
<li>静态方法锁的是class对象，class对象只有一个，所以两个线程是同一把锁  </li>
</ul>
<h2 id="两个线程同时访问同步方法与非同步方法"><a href="#两个线程同时访问同步方法与非同步方法" class="headerlink" title="两个线程同时访问同步方法与非同步方法"></a>两个线程同时访问同步方法与非同步方法</h2><ul>
<li>会并行执行</li>
<li>同步方法会受到保护，非同步方法不会上锁，所以会并行执行</li>
</ul>
<h2 id="访问同一个对象的不同的普通同步方法"><a href="#访问同一个对象的不同的普通同步方法" class="headerlink" title="访问同一个对象的不同的普通同步方法"></a>访问同一个对象的不同的普通同步方法</h2><ul>
<li>会串行执行</li>
<li>同步方法锁的是this当前对象，即便是不同的方法，锁的也是同一个对象，所以会串行执行</li>
</ul>
<h2 id="同时访问静态synchronized和非静态synchronized方法"><a href="#同时访问静态synchronized和非静态synchronized方法" class="headerlink" title="同时访问静态synchronized和非静态synchronized方法"></a>同时访问静态synchronized和非静态synchronized方法</h2><ul>
<li>并行执行</li>
<li>静态方法锁的class类，非静态方锁的是当前对象，两个方法并不是同一个锁，所以会并行执行</li>
</ul>
<h2 id="方法抛异常后，会释放锁"><a href="#方法抛异常后，会释放锁" class="headerlink" title="方法抛异常后，会释放锁"></a>方法抛异常后，会释放锁</h2><ul>
<li>异常之后会释放锁，不会影响后续的执行</li>
<li>先抛出异常，后面才能进入同步方法</li>
</ul>
<h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><h2 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h2><ul>
<li>什么是可重入：指的是同一个线程的外层函数获得锁之后，内层函数可以直接再次获取该锁  </li>
<li>好处：避免死锁，提升封装性  <blockquote>
<p>比如方法1被synchronized修饰，在方法里面递归调用该方法，也是可以重入的<br>方法1和方法2都被synchronized修饰，那么在方法1中也是可以调用方法2的  </p>
</blockquote>
</li>
</ul>
<h2 id="不可中断"><a href="#不可中断" class="headerlink" title="不可中断"></a>不可中断</h2><ul>
<li>一旦这个锁已经被别人获得了，如果我还想获得，我只能选择等待或者阻塞，直到别人的线程释放这个锁，如果别人永远不释放锁，那么我只能永远地等待下去。</li>
</ul>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="加锁和释放锁的原理"><a href="#加锁和释放锁的原理" class="headerlink" title="加锁和释放锁的原理"></a>加锁和释放锁的原理</h2><ul>
<li>获取呵呵释放锁的时机：进入和退出同步代码块（运行完毕或者抛出异常）</li>
<li>等价代码（使用lock锁必须要显示的上锁解锁，并且需要考虑异常情况，synchronized则不需要考虑这些）</li>
<li>看字节码：monitor相关指令<br>使用<code>javac xxx.java</code>将java文件编译成class文件<br>再使用<code>java -v xxx.class</code>反编译class文件<br>具体代码如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decompilation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Thread thread)</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
反编译后，insert方法如下：<br><img src="/2021/11/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/Decompilation%E5%8F%8D%E7%BC%96%E8%AF%91%E5%86%85%E5%AE%B9.png" alt="Decompilation反编译内容"><br>从图中可以看出，第6行monitorenter指令，上锁<br>第8行monitorexit指令，释放锁<br>第14行monitorexit指令，则是在抛出异常的情况下释放锁</li>
</ul>
<h2 id="可重入原理：加锁次数计数器"><a href="#可重入原理：加锁次数计数器" class="headerlink" title="可重入原理：加锁次数计数器"></a>可重入原理：加锁次数计数器</h2><ul>
<li>JVN会记录被加锁大的次数</li>
<li>第一次加锁时，次数从0变为1，之后如果再次加锁，就从1变成2，以次类推</li>
<li>退出一层同步代码块时，计数减一，当计数为0的时候表示锁释放  </li>
</ul>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><ul>
<li>一个线程执行的结果，另一个线程不一定可见</li>
<li>线程1操作x=5，之后线程2可能读取到之前的数据x=3</li>
<li>synchronized可以保证可见性  </li>
</ul>
<h1 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h1><ul>
<li>效率低：锁的释放情况少，试图获得锁时不能设定超时、不能中断一个正在试图获得锁的线程。  </li>
<li>不够灵活（读写锁更灵活）：加锁和释放的时机单一，每个锁仅有单一的条件（某个对象），可能是不够的。 </li>
<li>无法知道是否成功获取到锁</li>
</ul>
<h1 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h1><ul>
<li>使用注意点：锁的范围不宜过大、避免锁的嵌套</li>
<li>如何选择Look和synchronized关键字？<blockquote>
<p>如果synchronized能够满足需求的话，优先使用synchronized，无法满足再使用Lock锁</p>
</blockquote>
</li>
<li>多线程访问同步方法的各种具体情况<blockquote>
<p>上面所述的七种情况  </p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>通过gitee和hexo搭建个人博客</title>
    <url>/2021/06/12/%E5%89%8D%E7%AB%AF/%E9%80%9A%E8%BF%87gitee%E5%92%8Chexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul>
<li>git（提供git命令）<a href="https://git-scm.com/">git官网</a></li>
<li>node（hexo依赖）<a href="https://nodejs.org/en/">nodejs官网</a></li>
<li>gitee（事先注册码云账号）<a href="https://gitee.com/">码云主页</a></li>
<li>编辑器（根据个人喜好使用即可）</li>
</ul>
<h2 id="码云配置"><a href="#码云配置" class="headerlink" title="码云配置"></a>码云配置</h2><p>在gitee上创建一个仓库<br><img src="/2021/06/12/%E5%89%8D%E7%AB%AF/%E9%80%9A%E8%BF%87gitee%E5%92%8Chexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/gitee%E6%96%B0%E5%BB%BA%E4%BB%93%E5%BA%93.png" alt="gitee新建仓库"><br>点击Gitee Pages配置博客地址<br><img src="/2021/06/12/%E5%89%8D%E7%AB%AF/%E9%80%9A%E8%BF%87gitee%E5%92%8Chexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/gitee%E9%85%8D%E7%BD%AE%E5%8D%9A%E5%AE%A2.png" alt="gitee配置博客"><br>具体命名格式可查看下面连接<br><a href="https://gitee.com/help/articles/4136#article-header0">gitee帮助中心</a>  </p>
<h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><blockquote>
<p>其他软件安装步骤省略，此处只说说hexo的安装和配置  </p>
</blockquote>
<ul>
<li>通过npm安装hexo<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g hexo 		# -g 指定全局安装，可以使用hexo命令</span><br></pre></td></tr></table></figure></li>
<li>打开工作文件夹，执行以下命令<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo init test		# 初始化创建，会在工作文件夹下创建test文件夹</span><br><span class="line">cd test				# 进入test目录</span><br><span class="line">npm install			# 进一步安装hexo所需文件</span><br></pre></td></tr></table></figure></li>
<li>安装之后可以启动进行预览<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo clean			# 清除所有记录</span><br><span class="line">hexo generate		# 生成静态网页</span><br><span class="line">hexo server     	# 启动服务,默认是在4000端口启动，可使用-p参数指定启动端口</span><br></pre></td></tr></table></figure></li>
<li>访问<a href="http://localhost:4000/">http://localhost:4000</a>预览<br><img src="/2021/06/12/%E5%89%8D%E7%AB%AF/%E9%80%9A%E8%BF%87gitee%E5%92%8Chexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A1%B5.png" alt="hexo默认主页">  </li>
</ul>
<blockquote>
<p>想要更换主题可以访问 <a href="https://hexo.io/themes/">hexo官网主题</a> 预览下载<br>将下载的主题放到themes文件夹下，然后更改_config.yml配置即可</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">sky</span>   <span class="comment">#值为你放在themes文件夹里的主题文件夹名称</span></span><br></pre></td></tr></table></figure>
<p>其他配置可以参考<a href="https://hexo.io/zh-cn/docs/">hexo官方文档</a></p>
<p>新建文章</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new test		# 会在test/source/_posts下会生成test.md文件</span><br></pre></td></tr></table></figure>

<h2 id="上传gitee"><a href="#上传gitee" class="headerlink" title="上传gitee"></a>上传gitee</h2><ul>
<li>需要先安装一个插件  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save  #安装git插件</span><br></pre></td></tr></table></figure></li>
<li>复制刚刚gitee创建的项目的url，打开_config.yml文件进行配置<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://gitee.com/ysymj/ysymj</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo deploy	# 上传到gitee</span><br><span class="line"><span class="meta">#</span><span class="bash">上传时会提示输入gitee的账户密码</span></span><br></pre></td></tr></table></figure></li>
<li>点击仓库主页-&gt;服务-&gt;Gitee Pages<br><img src="/2021/06/12/%E5%89%8D%E7%AB%AF/%E9%80%9A%E8%BF%87gitee%E5%92%8Chexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/gitee%E9%85%8D%E7%BD%AE%E5%8D%9A%E5%AE%A2.png" alt="gitee配置博客">  </li>
<li>点击更新，之后就可以通过配置的网址进行访问了<br><img src="/2021/06/12/%E5%89%8D%E7%AB%AF/%E9%80%9A%E8%BF%87gitee%E5%92%8Chexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2.png" alt="更新博客"></li>
</ul>
<h2 id="hexo博客访问图片问题"><a href="#hexo博客访问图片问题" class="headerlink" title="hexo博客访问图片问题"></a>hexo博客访问图片问题</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-image --save	# 安装hexo插件</span><br></pre></td></tr></table></figure>

<ul>
<li>修改_config.yml配置<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li>
<li>打开<code>/node_modules/hexo-asset-image/index.js</code>文件，将文件内容替换为一下内容<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">&#x27;cheerio&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPosition</span>(<span class="params">str, m, i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.split(m, i).join(m).length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> version = <span class="built_in">String</span>(hexo.version).split(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">hexo.extend.filter.register(<span class="string">&#x27;after_post_render&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> config = hexo.config;</span><br><span class="line">  <span class="keyword">if</span>(config.post_asset_folder)&#123;</span><br><span class="line">        <span class="keyword">var</span> link = data.permalink;</span><br><span class="line">    <span class="keyword">if</span>(version.length &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">Number</span>(version[<span class="number">0</span>]) == <span class="number">3</span>)</span><br><span class="line">       <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">       <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.</span></span><br><span class="line">    <span class="keyword">var</span> endPos = link.lastIndexOf(<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line">    link = link.substring(beginPos, endPos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> toprocess = [<span class="string">&#x27;excerpt&#x27;</span>, <span class="string">&#x27;more&#x27;</span>, <span class="string">&#x27;content&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; toprocess.length; i++)&#123;</span><br><span class="line">      <span class="keyword">var</span> key = toprocess[i];</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">var</span> $ = cheerio.load(data[key], &#123;</span><br><span class="line">        <span class="attr">ignoreWhitespace</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">xmlMode</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">lowerCaseTags</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">decodeEntities</span>: <span class="literal">false</span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      $(<span class="string">&#x27;img&#x27;</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ($(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>))&#123;</span><br><span class="line">            <span class="comment">// For windows style path, we replace &#x27;\&#x27; to &#x27;/&#x27;.</span></span><br><span class="line">            <span class="keyword">var</span> src = $(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span>(!<span class="regexp">/http[s]*.*|\/\/.*/</span>.test(src) &amp;&amp;</span><br><span class="line">               !<span class="regexp">/^\s*\//</span>.test(src)) &#123;</span><br><span class="line">              <span class="comment">// For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed.</span></span><br><span class="line">              <span class="comment">// In addition, to support multi-level local directory.</span></span><br><span class="line">              <span class="keyword">var</span> linkArray = link.split(<span class="string">&#x27;/&#x27;</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">              &#125;);</span><br><span class="line">              <span class="keyword">var</span> srcArray = src.split(<span class="string">&#x27;/&#x27;</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span> &amp;&amp; elem != <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">              &#125;);</span><br><span class="line">              <span class="keyword">if</span>(srcArray.length &gt; <span class="number">1</span>)</span><br><span class="line">                srcArray.shift();</span><br><span class="line">              src = srcArray.join(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">              $(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>, config.root + link + src);</span><br><span class="line">              <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">&quot;update link as:--&gt;&quot;</span>+config.root + link + src);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">&quot;no src attr, skipped...&quot;</span>);</span><br><span class="line">            <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info($(<span class="built_in">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      data[key] = $.html();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new test		# 生成新的文章</span><br></pre></td></tr></table></figure>
<p>执行命令生成新的文章，在生成新的文章的时候，会在同级目录下生成一个同名的文件夹，将图片放在文件夹中，md文件中图片配置为同级目录即可</p>
<h2 id="博客评论功能"><a href="#博客评论功能" class="headerlink" title="博客评论功能"></a>博客评论功能</h2><p>本博客评论功能是基于<code>valine</code>实现。<br>1.注册账号<br>需要登录leancloud（<a href="https://console.leancloud.cn/">https://console.leancloud.cn/</a> ）网站注册账号<br><img src="/2021/06/12/%E5%89%8D%E7%AB%AF/%E9%80%9A%E8%BF%87gitee%E5%92%8Chexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/leancloud%E7%99%BB%E5%BD%95.png" alt="leancloud登录"></p>
<p>2.创建应用<br>登录后点击创建应用，应用名称随便填，一般免费版使用开发板即可，使用商用版也可以，不过需要费出一定的费用。<br><img src="/2021/06/12/%E5%89%8D%E7%AB%AF/%E9%80%9A%E8%BF%87gitee%E5%92%8Chexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/leancloud%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8.png" alt="leancloud创建应用"></p>
<p>3.查看应用key<br>一次点击<code>新建的应用-设置-应用凭证</code>，可以看到入下图，复制AppID和AppKey一会需要用到。<br><img src="/2021/06/12/%E5%89%8D%E7%AB%AF/%E9%80%9A%E8%BF%87gitee%E5%92%8Chexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/leancloud-key%E6%9F%A5%E7%9C%8B.png" alt="leancloud-key查看"></p>
<p>4.改代码<br>在项目的<code>_config.yml</code>中增加以下配置，其中的appId和appKey就是上面复制的AppID和AppKey。    </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">comment:</span></span><br><span class="line">  <span class="attr">appId:</span> <span class="string">leancloud中的AppID</span></span><br><span class="line">  <span class="attr">appKey:</span> <span class="string">leancloud中的AppKey</span></span><br></pre></td></tr></table></figure>
<p>修改模板文件，在对应的模板中增加以下代码，作者的是<code>post.ejs</code>，具体应该会根据模板的不同而有所不同。  </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;comment-container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&#x27;//unpkg.com/valine/dist/Valine.min.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Valine(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">&#x27;#comment-container&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">appId</span>: <span class="string">&#x27;&lt;%- config.comment.appId %&gt;&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">appKey</span>: <span class="string">&#x27;&lt;%- config.comment.appKey %&gt;&#x27;</span></span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>中介者模式</title>
    <url>/2021/10/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>定义一个封装一组对象如何交互的对象；<br>通过使对象明确地相互引用来促进松散耦合，并允许独立的改变它们的交互；<br>行为型</p>
</blockquote>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li>系统对象之间存在复杂的引用关系，产生的相互依赖关系结构混乱且难以理解；</li>
<li>交互的公共行为，如果需要改变行为则可以增加新的中介类。</li>
</ul>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>将一对多转化成了一对一，降低程序复杂度</li>
<li>类之间的解耦</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>中介者过多，导致系统复杂</li>
</ul>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><ul>
<li><strong>抽象中介者角色</strong>：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。</li>
<li><strong>具体中介者角色</strong>：实现中介者接口，定义一个List来管理同事对象，协调各个同事之间的交互关系，因此它依赖于同事角色。</li>
<li><strong>抽象同事类角色</strong>：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。</li>
<li><strong>具体同事类角色</strong>：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>假设有一个中介小刘，做房产中介，有两个房东来找租客<br>抽象中介者角色，可以理解为中介这一个行业  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Colleague colleague)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">relay</span><span class="params">(Colleague cl)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体中介者角色<br>中介小刘，聚合了同事角色，也就是聚合了房东，保留房东的联系方式，两个方法，一个保存房东联系方式，一个给房东联系的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoLiuMediator</span> <span class="keyword">extends</span> <span class="title">Mediator</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Colleague&gt; colleagues = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Colleague colleague)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!colleagues.contains(colleague)) &#123;</span><br><span class="line">            colleagues.add(colleague);</span><br><span class="line">            colleague.setMedium(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">relay</span><span class="params">(Colleague cl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Colleague ob : colleagues) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ob.equals(cl)) &#123;</span><br><span class="line">                ob.receive();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抽象同事类角色<br>聚合了一个中介，有三个方法，一个是保存中介信息，一个是联系中介租房的，一个是讨价还价的  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Mediator mediator;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMedium</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体同事类角色1  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LandlordColleague1</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;2000少一分都不行。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我有房子要出租。&quot;</span>);</span><br><span class="line">        mediator.relay(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体同事类角色2  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LandlordColleague2</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1800一分都不能少。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我也有房子要出租。&quot;</span>);</span><br><span class="line">        mediator.relay(<span class="keyword">this</span>); <span class="comment">//请中介者转发</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端调用  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Mediator mediator = <span class="keyword">new</span> XiaoLiuMediator();</span><br><span class="line"></span><br><span class="line">        Colleague l1 = <span class="keyword">new</span> LandlordColleague1();</span><br><span class="line">        Colleague l2 = <span class="keyword">new</span> LandlordColleague2();</span><br><span class="line"></span><br><span class="line">        mediator.register(l1);</span><br><span class="line">        mediator.register(l2);</span><br><span class="line"></span><br><span class="line">        l1.send();</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------&quot;</span>);</span><br><span class="line">        l2.send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我有房子要出租。</span><br><span class="line">1800一分都不能少。</span><br><span class="line">-------------------</span><br><span class="line">我也有房子要出租。</span><br><span class="line">2000少一分都不行。</span><br></pre></td></tr></table></figure>

<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><img src="http://www.plantuml.com/plantuml/svg/bP9FQuCm6CRl-HJlCIjKsAxhXB6hEss7mTZXhRv883KbUNKhnUy-jJKnLXcx1Nt-_F8exXrRp1boZSx1AnKAsLWuYsEzroe770MDKGLOAfLZilB5Q4rOrWJvUBfxNFDeF4qDkbEsGbmQFnIQJDM-c7wOgYAGT21MDSW4MTUyyp5fA7Rm11LzmxErU1fKgGmmVtF3kPs9Ru1xIOUCyLf1qbCQffof21iUheSOnH7tYleWRuHT3RHh8-Qa6f9h8xjkD3dTDSEgqCOMdl7UJnjXH_U-Tim7kOGFSElv3__9X-M2IVuxEGv-nyYZ-82gacziLLL-VW7QqerEF-XccmOA4NXssut_F48iJ9GaQH0iN35wFmrEalcVBCHmXSZXdtZdBm00">




























]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>享元模式</title>
    <url>/2021/09/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>运用共享技术来有效地支持大量细粒度对象的复用；<br>它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率。</p>
</blockquote>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li>常常应用于系统底层的开发，以便解决系统的性能问题；  </li>
<li>系统有大量相似对象、需要缓冲池的场景。  </li>
</ul>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>减少对象的创建，降低内存中对象的数量，降低系统的内存，提高效率；  </li>
<li>减少内存之外的其他资源占用。  </li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>关注内/外部状态、关注线程安全问题</li>
<li>使系统、程序逻辑复杂化</li>
</ul>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>享元模式的定义提出了两个要求，细粒度和共享对象。因为要求细粒度，所以不可避免地会使对象数量多且性质相似，此时我们就将这些对象的信息分为两个部分：<strong>内部状态</strong>和<strong>外部状态</strong>  </p>
<ul>
<li><strong>内部状态</strong>： 指对象共享出来的信息，存储在享元信息内部，并且不会随环境的改变而改变。  </li>
<li><strong>外部状态</strong>： 指对象得以依赖的一个标记，随环境的改变而改变，不可共享。 </li>
</ul>
<p>主要角色：<br><strong>抽象享元角色</strong>： 是所有的具体享元类的基类，为具体享元规范要求实现的公共接口，非享元的外部状态以参数的形式通过方法传入；<br><strong>具体享元角色</strong>：实现抽象享元角色中所规定的接口；<br><strong>非享元角色</strong>： 是不可共享的外部状态，它以参数的形式注入具体享元的相关方法中；<br><strong>享元工厂角色</strong>： 负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检查系统中是否存在符合要求的享元对象，如果存在则提供给客户，如果不存在的话，则创建一个新的享元对象。  </p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>我们在工作中，经常有一些需求文档，设计文档，接口文档等等，其实每次的文档格式是基本一样的只是内容不同，所以我们可以把文档模板做成享元对象，只需要每次在里面填充不同的内容即可  </p>
<p>首先我们创建非享元角色，文档内容，就算模板相同，每个模板的具体内容也是不同，属于外部状态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DocContent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DocContent</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建抽象享元角色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Template</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createDoc</span><span class="params">(DocContent content)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体享元角色，其中的<code>templateName</code>字段就是内部状态，每个模板的模板名称是相同的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DocTemplate</span> <span class="keyword">implements</span> <span class="title">Template</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String templateName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DocTemplate</span><span class="params">(String templateName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.templateName = templateName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createDoc</span><span class="params">(DocContent content)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前模板是：&quot;</span>+templateName+<span class="string">&quot;  内容是：&quot;</span>+content.getContent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建享元工厂，这里是使用<code>HashMap</code>来做享元对象的存储，<code>HashMap</code>属于非线程安全的，所以如果是在并发的情况下，可能会有并发问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DocFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String,DocTemplate&gt; TEMPLATE_MAP = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Template <span class="title">getTemplate</span><span class="params">(String templateName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!TEMPLATE_MAP.containsKey(templateName))&#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;新建模板：&quot;</span>+templateName+<span class="string">&quot;   &quot;</span>);</span><br><span class="line">            TEMPLATE_MAP.put(templateName,<span class="keyword">new</span> DocTemplate(templateName));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> TEMPLATE_MAP.get(templateName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体调用，这里使用随机数连续10次调用来查看输出内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] templateNames = &#123;<span class="string">&quot;需求文档&quot;</span>,<span class="string">&quot;接口文档&quot;</span>,<span class="string">&quot;设计文档&quot;</span>,<span class="string">&quot;简历&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DocFactory factory = <span class="keyword">new</span> DocFactory();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            String templateName = templateNames[(<span class="keyword">int</span>) (Math.random() * templateNames.length)];</span><br><span class="line">            Template template = factory.getTemplate(templateName);</span><br><span class="line">            template.createDoc(<span class="keyword">new</span> DocContent(templateName+<span class="string">&quot;的内容是&quot;</span>+i+<span class="string">&quot;.....&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果，从结果中可以看出，每一种模板在第一次使用的时候会创建新的，但是后续再次调用的时候就不会再新创建对象，而模板的内容每次调用都是不一样的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">新建模板:  接口文档   当前模板是:  接口文档  内容是:  接口文档的内容是0.....</span><br><span class="line">新建模板:  设计文档   当前模板是:  设计文档  内容是:  设计文档的内容是1.....</span><br><span class="line">新建模板:  需求文档   当前模板是:  需求文档  内容是:  需求文档的内容是2.....</span><br><span class="line">当前模板是:  设计文档  内容是:  设计文档的内容是3.....</span><br><span class="line">当前模板是:  设计文档  内容是:  设计文档的内容是4.....</span><br><span class="line">当前模板是:  接口文档  内容是:  接口文档的内容是5.....</span><br><span class="line">新建模板:  简历   当前模板是:  简历  内容是:  简历的内容是6.....</span><br><span class="line">当前模板是:  接口文档  内容是:  接口文档的内容是7.....</span><br><span class="line">当前模板是:  设计文档  内容是:  设计文档的内容是8.....</span><br><span class="line">当前模板是:  设计文档  内容是:  设计文档的内容是9.....</span><br></pre></td></tr></table></figure>

<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><img src="http://www.plantuml.com/plantuml/svg/XKzB3e8m4Dtt5BC4eru0D25-ua8CYUnDhICsWK9AnHZYtQrIclgBgqxdpVkndDOrp4isAuL2eQ0bbUGDLGXR9Rd8W7L0G6w4S3tA8sK8AHPL_hXgILFo0p29-gTrF4VBKFqdb_LEbihrYuK-gAtSXxiom8OM693glCyvW_-EqDvUF9UKgL9UdNP7BcWECQt2pcde99j2keYJTPGkTd6Km0G4Nc15wzFZVEhvDeYjag7gP-zBSh-BumGDnsFBVjyxIGYn5WOnJPvYlx0NQ3GQEDWT">




]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>代理模式</title>
    <url>/2021/09/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>为其他对象提供一种代理，以控制对这个对象的访问<br>代理对象在客户端和目标对象之间起到中介的作用  </p>
</blockquote>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>代理模式能将代理对象与真实被调用的目标对象分离</li>
<li>一定程度上降低了系统的耦合度，扩展性好</li>
<li>保护目标对象</li>
<li>增强目标对象</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>代理模式会造成系统设计中类的数目增加   </li>
<li>在客户端和目标对象增加一个代理对象，会造成请求处理速度变慢  </li>
<li>增加系统的复杂度  </li>
</ul>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><blockquote>
<p>JDk的静态代理要求目标对象和代理对象都要实现相同的接口。然后提供给客户端使用。这个代理对客户端是可见的。</p>
</blockquote>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>假设一个场景，现在我们要保存一个用户信息，想要在保存用户之前或者之后做一些校验处理<br>建一个接口，里面是我们要实现的方法  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">saveUser</span><span class="params">(<span class="keyword">int</span> age,String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个接口的实现，也就是要被代理的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">saveUser</span><span class="params">(<span class="keyword">int</span> age, String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用户名：&quot;</span> + name + <span class="string">&quot;  用户年龄：&quot;</span> + age);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再创建一个接口的实现，这个就是我们的代理类，这里将被代理的类通过构造函数传入，如果集成了spring，可以通过注入的方式来做  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImplProxy</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceImplProxy</span><span class="params">(UserService userService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">saveUser</span><span class="params">(<span class="keyword">int</span> age, String name)</span> </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        <span class="keyword">int</span> saveUser = userService.saveUser(age, name);</span><br><span class="line">        after();</span><br><span class="line">        <span class="keyword">return</span> saveUser;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置处理&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;后置处理&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserService userService = <span class="keyword">new</span> UserServiceImplProxy(<span class="keyword">new</span> UserServiceImpl());</span><br><span class="line">        userService.saveUser(<span class="number">18</span>, <span class="string">&quot;小明&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果展示，可以在调用被代理的方法之前或者之后做一些处理</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">前置处理</span><br><span class="line">用户名: 小明  用户年龄: 18</span><br><span class="line">后置处理</span><br></pre></td></tr></table></figure>

<h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><img src="http://www.plantuml.com/plantuml/svg/bP1H2i8m343_UufyLd4dc1VmJnWU8AlP27JTIBkYZDtTJHXExGH_GfAIbvUo2oGL6eAB9ob88a_veDW5y1Xfxkgvm9eEHH1sDJXiQ9UhKIbZqVlrvAdfBF0Kg24N_0UqwqlB1f9iMCDX63VnPsblznyxX2E6ztFwLvul4YcgtXXw-lmblrZ4bgzGKjKAwUy7hARFrykrw-N7BDid5Hy0">


<h2 id="JDk动态代理"><a href="#JDk动态代理" class="headerlink" title="JDk动态代理"></a>JDk动态代理</h2><blockquote>
<p>JDk的动态代理要求目标对象必须实现接口，因为它创建代理对象的时候是根据接口创建的，如果不实现接口，jdk无法给目标对象创建代理对象，被代理对象可以实现多个接口，创建代理时指定创建某个接口的代理对象就可以调用该接口中定义的方法了。</p>
</blockquote>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>同样以上面的例子为例，我们要在保存用户信息之前以及之后做一些校验  </p>
<p>建一个接口，里面是我们要实现的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">saveUser</span><span class="params">(<span class="keyword">int</span> age,String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个接口的实现，也就是要被代理的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">saveUser</span><span class="params">(<span class="keyword">int</span> age, String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用户名：&quot;</span> + name + <span class="string">&quot;  用户年龄：&quot;</span> + age);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDk动态代理，需要代理类实现<code>InvocationHandler</code>接口，并实现里面的<code>invoke</code>方法，<code>invoke</code>方法里面有三个参数，分别是当前代理类对象，要代理的方法，方法的参数<br>通过<code>build()</code>方法获取当前的代理类，会通过<code>Proxy</code>的静态方法生成一个代理类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImplProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceImplProxy</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Class&lt;?&gt; aClass = target.getClass();</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(aClass.getClassLoader(), aClass.getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        before();</span><br><span class="line">        Object obj = method.invoke(target, args);</span><br><span class="line">        after();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置处理&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;后置处理&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">前置处理</span><br><span class="line">用户名: 小明  用户年龄: 18</span><br><span class="line">后置处理</span><br></pre></td></tr></table></figure>

<h2 id="CGLib动态代理"><a href="#CGLib动态代理" class="headerlink" title="CGLib动态代理"></a>CGLib动态代理</h2><blockquote>
<p>jdk给目标类提供动态代理要求目标类必须实现接口，当一个目标类不实现接口时，jdk是无法为其提供动态代理的，cglib却能给这样的类提供动态代理。Spring在给某个类提供动态代理时，会自动在jdk动态代理和cglib动态代理中动态选择。</p>
</blockquote>
<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>需要先添加maven依赖（如果直接导入jar包的话，可能会有一些关联的jar包无法引入从而引起一些错误）  </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><p>同样使用上述的例子，不过CGLIB代理主要用于被代理类没有实现接口的情况下，我们被代理类不再实现接口  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">saveUser</span><span class="params">(<span class="keyword">int</span> age, String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用户名：&quot;</span> + name + <span class="string">&quot;  用户年龄：&quot;</span> + age);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写代理类，实现<code>MethodInterceptor</code>接口，并重写里面的<code>intercept</code>方法  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImplProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceImplProxy</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">//设置父类，因为cglib是针对指定的类生成一个子类，所以需要指定父类</span></span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);<span class="comment">//设置回调</span></span><br><span class="line">        Object obj = enhancer.create();<span class="comment">//创建并返回代理对象</span></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置处理&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;后置处理&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        Object invoke = method.invoke(target, objects);</span><br><span class="line">        after();</span><br><span class="line">        <span class="keyword">return</span> invoke;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserServiceImpl userService = (UserServiceImpl) <span class="keyword">new</span> UserServiceImplProxy(<span class="keyword">new</span> UserServiceImpl()).build();</span><br><span class="line">        userService.saveUser(<span class="number">18</span>, <span class="string">&quot;小明&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">前置处理</span><br><span class="line">用户名: 小明  用户年龄: 18</span><br><span class="line">后置处理</span><br></pre></td></tr></table></figure>




















]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2021/07/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>单例模式是java中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。这种模式设计到一个单一的类，该类负责创建自己的对象，同时保证只有单个对象被创建，这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。  </p>
<ul>
<li>单例类只能有一个实例。</li>
<li>单例类必须自己创建自己的唯一实例。</li>
<li>单例类必须给所有其他对象提供这一实例。</li>
</ul>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>意图：</strong> 保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br><strong>主要解决：</strong> 一个全局使用的类频繁地创建与销毁。<br><strong>何时使用：</strong> 当你想控制实例数目，节省系统资源的时候。  </p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul>
<li>构造函数私有。  </li>
<li>判断系统是否已经有这个单例，如果有则返回，如果没有则创建。  </li>
</ul>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例；</li>
<li>避免对资源的多重占用。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</li>
</ul>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>创建一个Singleton类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个Singleton对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取唯一可以用对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//让构造函数私有化，这样改类就不能在外部实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从Singleton类中获取唯一对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//无法通过new调用</span></span><br><span class="line">        <span class="comment">//Singleton singleton = new Singleton();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取唯一可用对象</span></span><br><span class="line">        Singleton instance = Singleton.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><img src="http://www.plantuml.com/plantuml/svg/Iyv9B2vM2CxCIyz9BSdFg-PwshhYwSQ6frFMFzdHy7Bkp6SDZK_NpNkohrj1eQ0eioon95MXk2In93CPeKSXCmyeb9US2jIxvcdhHeYkPzDsFjiy5QYhD2a7g1f3KtfgYITKduOcr_FbZS_cT3wRr_AoOS7JzhtFfcv0s0VNew6fKArGorNBXJ15rmx9I2kuIm00">

<h3 id="单例模式的几种实现方式"><a href="#单例模式的几种实现方式" class="headerlink" title="单例模式的几种实现方式"></a>单例模式的几种实现方式</h3><h4 id="1-饿汉式（静态变量）"><a href="#1-饿汉式（静态变量）" class="headerlink" title="1.饿汉式（静态变量）"></a>1.饿汉式（静态变量）</h4><p><strong>是否懒加载：</strong> 否<br><strong>是否线程安全：</strong> 是<br><strong>描述：</strong> 这种方式比较常用，但是容易产生垃圾。<br><strong>优点：</strong> 没有加锁，执行效率会提高。<br><strong>缺点：</strong> 类加载时就初始化，浪费内存空间。<br>它基于classloader机制避免了多线程的同步问题，不过，instance在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用getInstance方法，但是也不能确定有其他的方式（或其他的静态方法）导致类装载，这时候初始化instance显然没有达到懒加载的效果。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-饿汉式（静态代码块）"><a href="#2-饿汉式（静态代码块）" class="headerlink" title="2.饿汉式（静态代码块）"></a>2.饿汉式（静态代码块）</h4><p><strong>是否懒加载：</strong> 否<br><strong>是否线程安全：</strong> 是<br><strong>描述：</strong> 这种方式比较常用，但是容易产生垃圾。<br><strong>优点：</strong> 没有加锁，执行效率会提高。<br><strong>缺点：</strong> 类加载时就初始化，浪费内存空间。<br>这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候就执行静态代码块中的代码，初始化类的实例。优点和缺点和上面也是一样的。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-懒汉式，线程不安全"><a href="#3-懒汉式，线程不安全" class="headerlink" title="3.懒汉式，线程不安全"></a>3.懒汉式，线程不安全</h4><p><strong>是否懒加载：</strong> 是<br><strong>是否线程安全：</strong> 否<br><strong>描述：</strong> 这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁synchronize，所以严格意义上它并不算单例模式。这种方式懒加载很明显，不要求线程安全，在多线程不能正常工作。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-懒汉式，线程安全"><a href="#4-懒汉式，线程安全" class="headerlink" title="4.懒汉式，线程安全"></a>4.懒汉式，线程安全</h4><p><strong>是否懒加载：</strong> 是<br><strong>是否多线程安全：</strong> 是<br><strong>描述：</strong> 这种方式具备很好的lazy loading，能够在多线程中很好的工作，但是效率很低，99%情况下不需要同步。<br><strong>优点：</strong> 第一次调用才初始化，避免内存浪费。<br><strong>缺点：</strong> 必须加锁synchronize才能保证单例，但加锁会影响效率。<br>getInstance()的性能对应用程序不是很关键（该方法使用不太频繁）。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-双重锁-双重校验锁"><a href="#5-双重锁-双重校验锁" class="headerlink" title="5.双重锁/双重校验锁"></a>5.双重锁/双重校验锁</h4><p>是否懒加载：是<br>是否多线程安全：是<br>描述：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。<br>getInstance()的性能对应用程序很关键，参数需要添加volatile关键字防止指令重排  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-登记式-静态内部类"><a href="#6-登记式-静态内部类" class="headerlink" title="6.登记式/静态内部类"></a>6.登记式/静态内部类</h4><p><strong>是够懒加载：</strong> 是<br><strong>是否多线程安全：</strong> 是<br><strong>描述：</strong> 这种方式能达到双检锁方式一样的效果，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式，这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。<br>这种方式利用了classloader机制来保证初始化instance时只有一个线程，它跟饿汉式不同的是：饿汉式只要类被装载了，那么instance就会被实例化（没有达到懒加载的效果），而这种方式是Singleton类被装载了，instance不一定被初始化，因为SingletonHolder类没有被主动使用，自由通过显式调用getInstance方法时，才会显式装载SingletonHolder类，从而实例化instance。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-枚举"><a href="#7-枚举" class="headerlink" title="7.枚举"></a>7.枚举</h4><p><strong>是否懒加载：</strong> 是<br><strong>是否多线程安全：</strong> 是<br><strong>描述：</strong> 这种方式还没有被广泛使用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。这种方式是Effective Java作者Josh Bloch提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    INSTANCE;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whateverMethod</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="通过反射或序列化破解单例"><a href="#通过反射或序列化破解单例" class="headerlink" title="通过反射或序列化破解单例"></a>通过反射或序列化破解单例</h3><h4 id="反射破解"><a href="#反射破解" class="headerlink" title="反射破解"></a>反射破解</h4><p>单例类（以双检锁为例）：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException, InvocationTargetException, NoSuchMethodException </span>&#123;</span><br><span class="line">        Singleton instance = Singleton.getInstance();</span><br><span class="line">        System.out.println(instance);</span><br><span class="line">        Class c1 = instance.getClass();</span><br><span class="line">        Constructor constructor1 = c1.getDeclaredConstructor(<span class="keyword">null</span>);</span><br><span class="line">        constructor1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        System.out.println(constructor1.newInstance());</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; c2 = Class.forName(<span class="string">&quot;com.Singleton&quot;</span>);</span><br><span class="line">        Constructor constructor2 = c2.getDeclaredConstructor(<span class="keyword">null</span>);</span><br><span class="line">        constructor2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        System.out.println(constructor2.newInstance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过<code>getClass()</code>或者<code>Class.forName()</code>获取class对象，然后通过无参构造创建对象。  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">com.Singleton@1b6d3586</span><br><span class="line">com.Singleton@4554617c</span><br><span class="line">com.Singleton@74a14482</span><br></pre></td></tr></table></figure>

<h4 id="反序列化破解"><a href="#反序列化破解" class="headerlink" title="反序列化破解"></a>反序列化破解</h4><p>如果单例类实现了<code>Serializable</code>接口进行序列化，可以通过反序列化破解。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先将对象序列化到文件，然后从文件中读取对象。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        Singleton instance = Singleton.getInstance();</span><br><span class="line">        System.out.println(instance);</span><br><span class="line">        ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;D:/test.txt&quot;</span>));</span><br><span class="line">        objectOutputStream.writeObject(instance);</span><br><span class="line"></span><br><span class="line">        ObjectInputStream ous = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:/test.txt&quot;</span>));</span><br><span class="line">        Object o = ous.readObject();</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">com.Singleton@1b6d3586</span><br><span class="line">com.Singleton@312b1dae</span><br></pre></td></tr></table></figure>

<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><blockquote>
<p>反射破解是通过调用构造方法进行实例化，只需要在构造方法中跑出异常即可。  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>反序列化方式可以通过增加<code>readResolve()</code>方法解决，这个方法是基于回调的，反序列化时，如果定义了<code>readResolve()</code>则直接返回此方法指定的对象，而不需要再创建新的对象。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用第六种枚举类型实现单例模式，可以避免反射和序列化破解。  </p>
</blockquote>
<ul>
<li>jdk在反射的底层代码中限制了枚举不能通过<code>newInstance()</code>方法获取对象，里面判断类型是否是枚举，如果是直接抛出异常。  </li>
<li>枚举类型在序列化时是将枚举值的name存放到文件中的，反序列化时通过调用<code>valueOf()</code>方法获取对象。  </li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>原型模式</title>
    <url>/2021/09/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。<br>不需要知道任何细节，不调用构造函数。  </p>
</blockquote>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li>类初始化消耗较多资源  </li>
<li>new产生的一个对象需要非常繁琐的过程，（数据准备，访问权限等）  </li>
<li>构造函数比较复杂  </li>
<li>循环体重生产大量对象  </li>
</ul>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>原型模式性能比直接new一个对象性能高  </li>
<li>简化创建过程  </li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>必须配备克隆方法  </li>
<li>对克隆复杂对象或对克隆出的对象进行复杂改造时，容易引入风险  </li>
<li>深拷贝、浅拷贝要运用得当    </li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>假设一个场景，我们要发送大量邮件，邮件的标题发送地址内容，都是不同的或者有部分相同，而创建一个邮件对象假如耗时比较长，我们就可以用克隆来实现   </p>
<p>只要对象类实现<code>Cloneable</code>接口，然后重写<code>clone</code>方法就可以实现简单的克隆</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mail</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line">    <span class="keyword">private</span> String mailAddress;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMailAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mailAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMailAddress</span><span class="params">(String mailAddress)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mailAddress = mailAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTitle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mail <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Mail) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>clone</code>方法中可以根据具体情况添加业务逻辑，具体调用如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Mail mail = <span class="keyword">new</span> Mail();</span><br><span class="line">        Mail clone = mail.clone();</span><br><span class="line">        System.out.println(mail);</span><br><span class="line">        System.out.println(clone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">com.ys.Mail@7f31245a</span><br><span class="line">com.ys.Mail@6d6f6e28</span><br></pre></td></tr></table></figure>

<p>原型模式的克隆是分深克隆和浅克隆的，需要注意使用场景；</p>
<ul>
<li><strong>浅克隆</strong> ：创建一个新的对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。</li>
<li><strong>深克隆</strong> ：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。</li>
</ul>
<p>假设我们给对象类增加一个发送日期的字段，并给日期设置值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Mail mail = <span class="keyword">new</span> Mail();</span><br><span class="line">        mail.setDate(<span class="keyword">new</span> Date(<span class="number">0L</span>));</span><br><span class="line">        Mail clone = mail.clone();</span><br><span class="line">        System.out.println(mail);</span><br><span class="line">        System.out.println(clone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Mail&#123;date=Thu Jan 01 08:00:00 CST 1970&#125;com.ys.Mail@330bedb4</span><br><span class="line">Mail&#123;date=Thu Jan 01 08:00:00 CST 1970&#125;com.ys.Mail@2503dbd3</span><br></pre></td></tr></table></figure>

<p>修改我们克隆出来的对象的日期</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Mail mail = <span class="keyword">new</span> Mail();</span><br><span class="line">        mail.setDate(<span class="keyword">new</span> Date(<span class="number">0L</span>));</span><br><span class="line">        Mail clone = mail.clone();</span><br><span class="line">        clone.getDate().setTime(<span class="number">1630809727754L</span>);</span><br><span class="line">        System.out.println(mail);</span><br><span class="line">        System.out.println(clone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Mail&#123;date=Sun Sep 05 10:42:07 CST 2021&#125;com.ys.Mail@330bedb4</span><br><span class="line">Mail&#123;date=Sun Sep 05 10:42:07 CST 2021&#125;com.ys.Mail@2503dbd3</span><br></pre></td></tr></table></figure>

<p>会发现两个对象依然是不同的对象，但是日期却同时都被修改了<br>在debug模式下可以看出原因，两个对象引用的日期对象依然是同一个对象，就导致两个对象同时被修改<br><img src="/2021/09/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8Fdubug%E5%9B%BE.png" alt="原型模式dubug图"></p>
<p>解决办法就可以使用深克隆</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mail</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line">    <span class="keyword">private</span> String mailAddress;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> Date date;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Mail&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;date=&quot;</span> + date +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>+<span class="keyword">super</span>.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDate</span><span class="params">(Date date)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.date = date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMailAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mailAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMailAddress</span><span class="params">(String mailAddress)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mailAddress = mailAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTitle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mail <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Mail clone = (Mail) <span class="keyword">super</span>.clone();</span><br><span class="line">            clone.date = (Date) date.clone();</span><br><span class="line">            <span class="keyword">return</span> clone;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点看<code>clone</code>方法中的修改，对日期类型也进行了克隆。<br><img src="/2021/09/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E6%B7%B1%E5%85%8B%E9%9A%86debug%E5%9B%BE.png" alt="原型模式深克隆debug图"><br>从图中可以看到，日期类型已经不是同一个对象了。</p>
<h4 id="使用序列化实现深克隆"><a href="#使用序列化实现深克隆" class="headerlink" title="使用序列化实现深克隆"></a>使用序列化实现深克隆</h4><p>上面所描述的深克隆方法，每次如果添加了对象属性都需要在<code>clone</code>方法中进行维护才能实现深克隆，通过序列化实现深克隆可以解决这种问题<br>对象类实现<code>Serializable</code>接口<br>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mail</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line">    <span class="keyword">private</span> String mailAddress;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> Date date;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Mail&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;date=&quot;</span> + date +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>+<span class="keyword">super</span>.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mail <span class="title">mailClone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建流对象</span></span><br><span class="line">        ByteArrayOutputStream bos = <span class="keyword">null</span>;</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayInputStream bis = <span class="keyword">null</span>;</span><br><span class="line">        ObjectInputStream ois= <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//序列化</span></span><br><span class="line">            bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line">            oos.writeObject(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//反序列化</span></span><br><span class="line">            bis = <span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">            ois = <span class="keyword">new</span> ObjectInputStream(bis);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (Mail) ois.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (bos != <span class="keyword">null</span>)</span><br><span class="line">                    bos.close();</span><br><span class="line">                <span class="keyword">if</span> (oos != <span class="keyword">null</span>)</span><br><span class="line">                    oos.close();</span><br><span class="line">                <span class="keyword">if</span> (bis != <span class="keyword">null</span>)</span><br><span class="line">                    bis.close();</span><br><span class="line">                <span class="keyword">if</span> (ois != <span class="keyword">null</span>)</span><br><span class="line">                    ois.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDate</span><span class="params">(Date date)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.date = date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMailAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mailAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMailAddress</span><span class="params">(String mailAddress)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mailAddress = mailAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTitle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义mailClone方法，通过对当前对象序列化然后反序列化的方法，来达到深克隆的目的，这种方法如果在对象类中新增了对象属性，不需要再进行刻意维护<br>调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Mail mail = <span class="keyword">new</span> Mail();</span><br><span class="line">        mail.setDate(<span class="keyword">new</span> Date(<span class="number">0L</span>));</span><br><span class="line">        Mail clone = mail.mailClone();</span><br><span class="line">        clone.getDate().setTime(<span class="keyword">new</span> Date().getTime());</span><br><span class="line">        System.out.println(mail);</span><br><span class="line">        System.out.println(clone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Mail&#123;date=Thu Jan 01 08:00:00 CST 1970&#125;com.ys.Mail@7ea987ac</span><br><span class="line">Mail&#123;date=Sat Sep 11 19:06:14 CST 2021&#125;com.ys.Mail@5b480cf9</span><br></pre></td></tr></table></figure>


<h2 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h2><img src="http://www.plantuml.com/plantuml/svg/oymhIIrAIqnELN3EoSzBJKpAIQskvU9ApaaiBbRmJSpCKSZCBSX9pKtDAob6KiBrTDsyvtqRu0BF-fO-xL_yihttQTlCP93WisaxdssUoWKs0IoWeQa0D1XkT4XgSKarLq5fKavcia9nIM89a2hBpqnHo4tCpDC8BYdAp4kFZbL8B4elXca4csMZfmVMomK0">

<h2 id="克隆模式破解单例"><a href="#克隆模式破解单例" class="headerlink" title="克隆模式破解单例"></a>克隆模式破解单例</h2><p>以最简单的饿汉式单例为例，当单例类实现了<code>Cloneable</code>接口，并实现了<code>clone</code>方法就可以克隆产生多个实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Singleton clone = (Singleton) <span class="keyword">super</span>.clone();</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> copy mutable state here, so the clone can&#x27;t change the internals of the original</span></span><br><span class="line">            <span class="keyword">return</span> clone;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton instance = Singleton.getInstance();</span><br><span class="line">        Singleton clone = instance.clone();</span><br><span class="line">        System.out.println(instance);</span><br><span class="line">        System.out.println(clone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">com.ys.Singleton@7f31245a</span><br><span class="line">com.ys.Singleton@6d6f6e28</span><br></pre></td></tr></table></figure>

<p>解决办法：第一，不实现Cloneable接口，第二，在clone方法中返回会getInstance()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">com.ys.Singleton@7f31245a</span><br><span class="line">com.ys.Singleton@7f31245a</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>命令模式</title>
    <url>/2021/10/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>将”请求“封装成对象，以便于使用不同的请求。<br>命令模式解决了应用程序中对象的职责以及它们之间的通信方式<br>行为型</p>
</blockquote>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li>请求调用者和请求接收者需要解耦，使得调用者和接收者不直接交互</li>
<li>需要抽象出等待执行的行为</li>
</ul>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>降低耦合</li>
<li>容易扩展新命令或者一组命令</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>命令的无限扩展会增加类的数量，提高系统实现复杂度</li>
</ul>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><ul>
<li><strong>抽象命令类角色</strong>：声明执行命令的接口，拥有执行命令的抽象方法<code>execute()</code>。</li>
<li><strong>具体命令类角色</strong>：是抽象命令类的具体实现类，它拥有接收者对象，开通过调用接收者的功能来完成命令要执行的操作。</li>
<li><strong>实现者/接收者角色</strong>：执行命令功能的相关操作，是具体命令对象业务的真正实现者。</li>
<li><strong>调用者/请求者角色</strong>：是请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者。</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>假设我们有一台电脑，电脑接收命令，就是接收者，操作人员发送命令，就是调用者<br>创建 抽象命令类角色  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建电脑，也就是具体命令的实现，具体命令类角色  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Computer</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot;被打开了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot;被关闭了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建具体命令角色，开机  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OpenCommand</span> <span class="keyword">implements</span> <span class="title">Command</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Computer computer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OpenCommand</span><span class="params">(Computer computer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.computer = computer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        computer.open();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体命令角色，关机   </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloseCommand</span> <span class="keyword">implements</span> <span class="title">Command</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Computer computer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CloseCommand</span><span class="params">(Computer computer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.computer = computer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        computer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用者，收集命令并执行  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Operator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Command&gt; commands = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCommand</span><span class="params">(Command command)</span></span>&#123;</span><br><span class="line">        commands.add(command);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeCommand</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Command command : commands) &#123;</span><br><span class="line">            command.execute();</span><br><span class="line">        &#125;</span><br><span class="line">        commands.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Computer computer = <span class="keyword">new</span> Computer(<span class="string">&quot;编号为A的电脑 &quot;</span>);</span><br><span class="line">        OpenCommand openCommand = <span class="keyword">new</span> OpenCommand(computer);</span><br><span class="line">        CloseCommand closeCommand = <span class="keyword">new</span> CloseCommand(computer);</span><br><span class="line">        Operator operator = <span class="keyword">new</span> Operator();</span><br><span class="line">        operator.addCommand(openCommand);</span><br><span class="line">        operator.addCommand(closeCommand);</span><br><span class="line">        operator.executeCommand();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">编号为A的电脑 被打开了</span><br><span class="line">编号为A的电脑 被关闭了</span><br></pre></td></tr></table></figure>

<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><img src="http://www.plantuml.com/plantuml/svg/dP5BYiCm38RtEeMMII4dw0DAjeLPp0bSHos6-87jTgO4txrnY1ttiMbtGh_qwvFKQcakdYnkcgPPuOyXrMefcUgWVPJQNZjA6WWrAYV62USK3d3LeaFw9pvsLVKQ0W3lcNEOdGOmLboP9_prLgWpAYPf3UPox0NFPLKXrZY4f4_-UYIiwgSaZsnZ5iCoj5W5XJGzILBU9To59CFnESWyXKFrKlK2bXUFGe0qEj_LCgzjlaXnp2_fIelFyPOZJLp5Pmx2-Stikuj-CN2uHKL_kBUMtQQANVnmEO1rNK4pBJOtr-zHKdMKmnq0">













]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>备忘录模式</title>
    <url>/2021/10/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>保存一个对象的某个状态，以便于在适当的时候恢复对象。<br>“后悔药”<br>行为型</p>
</blockquote>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li>保存及恢复数据相关业务场景</li>
<li>后悔的时候，即像恢复到之前的状态</li>
</ul>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>为用户提供一种可恢复机制</li>
<li>存档信息的封装</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>资源占用。如果类的成员过多，势必会占用比较大大的资源，而且每一次保存都会消耗一定的内存。</li>
</ul>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><ul>
<li><strong>发起人角色</strong>：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里面的所有信息。</li>
<li><strong>备忘录角色</strong>：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。</li>
<li><strong>管理者角色</strong>：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内同进行访问与修改。</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>假设一个场景，我们有一个文档，需要保存不同的版本内容，方便进行回滚操作<br>创建发起人角色： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Word</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Word</span><span class="params">(String title, String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTitle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构建需要保存的备忘录对象，或者直接存数据库</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WordMemento <span class="title">saveToMemento</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WordMemento(<span class="keyword">this</span>.title,<span class="keyword">this</span>.content);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//回退</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undoFormMemento</span><span class="params">(WordMemento wordMemento)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.title = wordMemento.getTitle();</span><br><span class="line">        <span class="keyword">this</span>.content = wordMemento.getContent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Word&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;title=&#x27;&quot;</span> + title + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, content=&#x27;&quot;</span> + content + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建备忘录角色：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordMemento</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WordMemento</span><span class="params">(String title, String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTitle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;WordMemento&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;title=&#x27;&quot;</span> + title + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, content=&#x27;&quot;</span> + content + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建管理者角色：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordMementoManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Stack&lt;WordMemento&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回备忘录保存的上一个版本</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WordMemento <span class="title">getMemento</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMemento</span><span class="params">(WordMemento wordMemento)</span></span>&#123;</span><br><span class="line">        stack.push(wordMemento);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WordMementoManager wordMementoManager = <span class="keyword">new</span> WordMementoManager();</span><br><span class="line">        Word word = <span class="keyword">new</span> Word(<span class="string">&quot;java设计模式A&quot;</span>,<span class="string">&quot;设计模式内同A&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;创建文档，文档内容：&quot;</span>+word);</span><br><span class="line">        WordMemento wordMemento = word.saveToMemento();</span><br><span class="line">        wordMementoManager.addMemento(wordMemento);</span><br><span class="line">        System.out.println(<span class="string">&quot;保存第一版文档，文档内容：&quot;</span>+wordMemento);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;修改文档&quot;</span>);</span><br><span class="line"></span><br><span class="line">        word.setTitle(<span class="string">&quot;java设计模式B&quot;</span>);</span><br><span class="line">        word.setContent(<span class="string">&quot;设计模式内同B&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第二版文档，文档内容：&quot;</span>+word);</span><br><span class="line">        WordMemento wordMemento1 = word.saveToMemento();</span><br><span class="line">        wordMementoManager.addMemento(wordMemento1);</span><br><span class="line">        System.out.println(<span class="string">&quot;保存第二版文档，文档内容：&quot;</span>+wordMemento1);</span><br><span class="line"></span><br><span class="line">        word.setTitle(<span class="string">&quot;java设计模式C&quot;</span>);</span><br><span class="line">        word.setContent(<span class="string">&quot;设计模式内同C&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第三版文档，文档内容：&quot;</span>+word);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        WordMemento memento = wordMementoManager.getMemento();</span><br><span class="line">        word.undoFormMemento(memento);</span><br><span class="line">        System.out.println(<span class="string">&quot;文档回退，回退后内容：&quot;</span>+word);</span><br><span class="line"></span><br><span class="line">        WordMemento memento1 = wordMementoManager.getMemento();</span><br><span class="line">        word.undoFormMemento(memento1);</span><br><span class="line">        System.out.println(<span class="string">&quot;文档再次回退，回退后内容：&quot;</span>+word);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建文档，文档内容：Word&#123;title=&#x27;java设计模式A&#x27;, content=&#x27;设计模式内同A&#x27;&#125;</span><br><span class="line">保存第一版文档，文档内容：WordMemento&#123;title=&#x27;java设计模式A&#x27;, content=&#x27;设计模式内同A&#x27;&#125;</span><br><span class="line">修改文档</span><br><span class="line">第二版文档，文档内容：Word&#123;title=&#x27;java设计模式B&#x27;, content=&#x27;设计模式内同B&#x27;&#125;</span><br><span class="line">保存第二版文档，文档内容：WordMemento&#123;title=&#x27;java设计模式B&#x27;, content=&#x27;设计模式内同B&#x27;&#125;</span><br><span class="line">第三版文档，文档内容：Word&#123;title=&#x27;java设计模式C&#x27;, content=&#x27;设计模式内同C&#x27;&#125;</span><br><span class="line">----------------------------------</span><br><span class="line">文档回退，回退后内容：Word&#123;title=&#x27;java设计模式B&#x27;, content=&#x27;设计模式内同B&#x27;&#125;</span><br><span class="line">文档再次回退，回退后内容：Word&#123;title=&#x27;java设计模式A&#x27;, content=&#x27;设计模式内同A&#x27;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><img src="http://www.plantuml.com/plantuml/svg/Iyv9B2vM2CylIb6evYeeoYnBB4bL22ufoinBLoZ9BCb9jKONJSxFAqdDAm6AboRbP2Q3zMeWwz11KwcfK5sBhDWtDHSecgzGd5YM6f8FvMbe8XILvMUcA9JcfUIxvHVbmkIHTPOZs21jjLnSoN1lmDHGu1kObGGzXSrYtyIynFJK8YJxqpBp4dE0sXEJissG5Def58E456mLybBBeT9s6fhMNFhwB_PFUJfxtjCbxK_tptYwT-gJ_NEVhftnV5RBanrTJtOqFDcnwdbdnxCvQx05Qdfg2I945L23D34bXOZGHFWg9BMu1EGFY150rvR0JCfDpCo31azqh49YKNenE3n0Mi59IK_F3jbLNCZMsUZgQc49CAXE6pqziBrS809e36R80W00">





















]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂方法模式</title>
    <url>/2021/08/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>工厂方法模式属于类的创建型模式又被称为多态工厂模式。工厂方法模式的意义在于定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类中，核心工厂类不再负责产品的创建，仅负责声明具体工厂子类必须实现的接口。<br>这样进一步抽象画的好处是使得工厂方法模式可以使系统在不修改具体工厂角色的情况下引进新的产品。</p>
</blockquote>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><blockquote>
<p>1）创建对象需要大量重复的代码<br>2）客户端（应用层）不依赖于产品类实例如何被创建、实现等细节<br>3）一个类通过其子类来指定创建哪个对象  </p>
</blockquote>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>用户只需要关系所需产品对应的工厂，无须关心创建细节。  </li>
<li>加入新产品符合开闭原则，提高可扩展性。  </li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>类的个数容易过多，增加复杂度。  </li>
<li>增加了系统的抽象性和理解难度。  </li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="创建抽象产品类"><a href="#创建抽象产品类" class="headerlink" title="创建抽象产品类"></a>创建抽象产品类</h4><blockquote>
<p>我们创建一个电脑的抽象产品类，他有一个抽象方法用于启动电脑</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产品的抽象方法，由具体的产品类去实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建具体产品类"><a href="#创建具体产品类" class="headerlink" title="创建具体产品类"></a>创建具体产品类</h4><blockquote>
<p>接着我们创建各个品牌的电脑，他们都继承了他们的父类Computer，并实现了父类的start方法。</p>
</blockquote>
<p><strong>联想电脑</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LenovoComputer</span> <span class="keyword">extends</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;联想电脑启动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>惠普电脑</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HpComputer</span> <span class="keyword">extends</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;惠普电脑启动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>华硕电脑</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsusComputer</span> <span class="keyword">extends</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;华硕电脑启动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>创建一个工厂抽象类，具体创建产品的代码由工厂抽象类的子类去实现</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工厂方法创建产品接口抽象化，将具体创建产品的代码写到工厂方法子类中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Computer <span class="title">createComputer</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>创建联想电脑的工厂实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LenovoComputerFactory</span> <span class="keyword">extends</span> <span class="title">ComputerFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">createComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LenovoComputer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>创建惠普电脑的工厂实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HpComputerFactory</span> <span class="keyword">extends</span> <span class="title">ComputerFactory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">createComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HpComputer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>创建华硕电脑的工厂实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsusComputerFactory</span> <span class="keyword">extends</span> <span class="title">ComputerFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">createComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AsusComputer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>客户端调用</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过工厂方法的子类去创建对应的工厂类</span></span><br><span class="line">        <span class="comment">//每次增加新的产品，只需要新建一个抽象工厂方法的子类即可，不会对现有的产品产生影响</span></span><br><span class="line">        ComputerFactory computerFactory = <span class="keyword">new</span> HpComputerFactory();</span><br><span class="line">        Computer computer = computerFactory.createComputer();</span><br><span class="line">        computer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h2><img src="http://www.plantuml.com/plantuml/svg/IqmgBYbAJ2vHICv9B2vMSCxFBIWjIIsgvdewjUtfvCPdNNjVR5puRDhEPvkdlj_Jywn_mfDziv_ldlzaHmEor8jrAvzEQ7coOnL4rzDryvxtRU0gA4tAoKnMI8HPKPQVcQ9GN99OLAAXQSrLoyK5iTEnkBGOPgz2QaL9QbuAfaE0baDCXLZ-V5OBilrS3lvbgKL5cIcf2b1BaUsghaLOvfEQbr-MJpVhF0heO5KYzZXq0mhb5rKg02tQllHfNzFpZRiX9WCPHCKbMDVJjHE0wd74ADnpoKMfYIMfC2xEw8Kv2Jqi44w5k0JPQlpX0vBjcFrqzwvdyoU0P9VtGa8LvbISBiITA0Qf8n59QP0wC2IrkAGQfWEOG4jWYJKtCJDF8xYaA3ClFJfM8R4elLXJ0QAH2oNls-ZfOKijN6Xv5gGCQunn8UKsa2AC44Er3nPS8AKWjtDXJmPmQSm8W4a10000">
















































]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>外观模式</title>
    <url>/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>外观模式又叫门面模式，是一种通过为多个复杂子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体细节，这样会大大降低应用程序的复杂度，提高程序的可维护性。</p>
</blockquote>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>外观模式包含以下主要角色：  </p>
<ul>
<li>外观角色： 为多个子系统提供一个共同的接口。  </li>
<li>子系统角色： 实现系统的部分功能，客户可以通过外观角色访问它。  </li>
<li>客户角色： 通过一个外观角色访问各个子系统的功能。   </li>
</ul>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li>子系统越来越复杂，增加外观模式提供简单调用接口。  </li>
<li>构建多层系统结构，利用外观对象作为每层的入口，简化层间调用。  </li>
</ul>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>简化了调用过程，无需深入了解子系统，防止带来风险。  </li>
<li>减少系统依赖、松散耦合。  </li>
<li>更好的划分访问层次。  </li>
<li>符合迪米特法则，即最少知道原则。  </li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>增加子系统、扩展子系统行为容易引入风险。  </li>
<li>不符合开闭原则。  </li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>假设我们现在有三个系统，<code>SubSystem01</code>、<code>SubSystem02</code>、<code>SubSystem03</code>，每个系统里面都有各自的逻辑处理方法；<br>我们现在有一个需求，需要调用三个系统联合去处理一个业务，那么就需要分别创建出<code>SubSystem01</code>、<code>SubSystem02</code>、<code>SubSystem03</code>系统的实例，然后调用对应的方法执行业务逻辑，<br>如果对象的创建，或者需要调用的方法很繁琐，那么每次处理逻辑，都要进行这块调用的处理，就很麻烦；<br>所以我们可以将这几个系统作为子系统，然后以一个高层系统(外观角色)进行封装，对外暴露一个相对简单的接口。</p>
<p>子系统1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubSystem01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子系统01的method1方法被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子系统2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubSystem02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子系统02的method2方法被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子系统3：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubSystem03</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子系统03的method3方法被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>外观角色：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Facade</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    SubSystem01 obj1 = <span class="keyword">new</span> SubSystem01();</span><br><span class="line">    SubSystem02 obj2 = <span class="keyword">new</span> SubSystem02();</span><br><span class="line">    SubSystem03 obj3 = <span class="keyword">new</span> SubSystem03();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        obj1.method1();</span><br><span class="line">        obj2.method2();</span><br><span class="line">        obj3.method3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Facade facade = <span class="keyword">new</span> Facade();</span><br><span class="line">        facade.method();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">子系统01的method1方法被调用</span><br><span class="line">子系统02的method2方法被调用</span><br><span class="line">子系统03的method3方法被调用</span><br></pre></td></tr></table></figure>

<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><img src="http://www.plantuml.com/plantuml/svg/TT6n3e8m40RW_PxYHXWmqeugeo-0ct4eq60DK4ABnY3lhXL2ggKtzl-QtlKWhvXIU6GvApWE0FYfjC_IfzAytiOeirkC1spumpuEmjsV94OIHn9NKYEf8wcHNzhsMILol4jHOCtrLHP1E8mm0apDskqDuEhOnyag9pvELpdzvIUkzCAKPdhHJ3H1gZlHbESBigvK8KuNvy_Ulw8eiOVn1SGNK03pF6wIUO5l">


]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>创建者模式</title>
    <url>/2021/08/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。<br>它是将一个复杂的对象分解为多个简答的对象，然后一步一步构建而成。<br>它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。</p>
</blockquote>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>封装性号，构建和表示分离。</li>
<li>扩展性好，各个具体的建造者相互独立，有利于系统的解耦。</li>
<li>客户端不必知道产品内部组成的细节，建造者可以对创建过程逐步细化，而不对其他模块产生任何影响，便于控制细节风险。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>产品的组成部分必须相同，这限制了其使用范围。</li>
<li>如果产品的内部变化复杂，如果产品内部发生变化，则建造者也要同步修改，后期维护成本较大。</li>
</ul>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><blockquote>
<p>比如我们有一个计算机类，类里面有些属性是必填参数，有些是选填的，那么我们按照传统方式进行创建的话一般有两种方式：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String cpu;<span class="comment">//必须</span></span><br><span class="line">    <span class="keyword">private</span> String ram;<span class="comment">//必须</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> usbCount;<span class="comment">//可选</span></span><br><span class="line">    <span class="keyword">private</span> String keyboard;<span class="comment">//可选</span></span><br><span class="line">    <span class="keyword">private</span> String display;<span class="comment">//可选</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>第一种：折叠构造函数模式，通过重写含有不同参数的构造函数进行赋值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String cpu;<span class="comment">//必须</span></span><br><span class="line">    <span class="keyword">private</span> String ram;<span class="comment">//必须</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> usbCount;<span class="comment">//可选</span></span><br><span class="line">    <span class="keyword">private</span> String keyboard;<span class="comment">//可选</span></span><br><span class="line">    <span class="keyword">private</span> String display;<span class="comment">//可选</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Computer</span><span class="params">(String cpu, String ram)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(cpu,ram,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Computer</span><span class="params">(String cpu, String ram, <span class="keyword">int</span> usbCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(cpu,ram,usbCount,<span class="string">&quot;罗技键盘&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Computer</span><span class="params">(String cpu, String ram, <span class="keyword">int</span> usbCount, String keyboard)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(cpu,ram,usbCount,keyboard,<span class="string">&quot;三星显示器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Computer</span><span class="params">(String cpu, String ram, <span class="keyword">int</span> usbCount, String keyboard, String display)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cpu = cpu;</span><br><span class="line">        <span class="keyword">this</span>.ram = ram;</span><br><span class="line">        <span class="keyword">this</span>.usbCount = usbCount;</span><br><span class="line">        <span class="keyword">this</span>.keyboard = keyboard;</span><br><span class="line">        <span class="keyword">this</span>.display = display;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种：Javabean模式，通过使用set方法进行赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String cpu;<span class="comment">//必须</span></span><br><span class="line">    <span class="keyword">private</span> String ram;<span class="comment">//必须</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> usbCount;<span class="comment">//可选</span></span><br><span class="line">    <span class="keyword">private</span> String keyboard;<span class="comment">//可选</span></span><br><span class="line">    <span class="keyword">private</span> String display;<span class="comment">//可选</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCpu</span><span class="params">(String cpu)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cpu = cpu;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRam</span><span class="params">(String ram)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ram = ram;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsbCount</span><span class="params">(<span class="keyword">int</span> usbCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.usbCount = usbCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKeyboard</span><span class="params">(String keyboard)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.keyboard = keyboard;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDisplay</span><span class="params">(String display)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.display = display;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="弊端"><a href="#弊端" class="headerlink" title="弊端"></a>弊端</h3><blockquote>
<p>第一种主要是使用及阅读不方便，当你想要使用一个类的构造函数的时候，你首先要想清楚自己需要使用哪一个，然后还要搞清楚这个函数里面参数的含义，很容易混淆。<br>第二种主要是在构建类的过程中是分两步进行的，这个操作容易导致操作失误，出现问题。</p>
</blockquote>
<h2 id="建造者模式代码实现"><a href="#建造者模式代码实现" class="headerlink" title="建造者模式代码实现"></a>建造者模式代码实现</h2><h3 id="结构组成"><a href="#结构组成" class="headerlink" title="结构组成"></a>结构组成</h3><ul>
<li><strong>产品角色</strong>：它是包含多个组成部件的复杂对象，由具体创建者来创建其各个零部件。</li>
<li><strong>抽象建造者</strong>：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品方法的getResult()。</li>
<li><strong>具体建造者</strong>：实现Builder接口，完成复杂产品的各个部件的具体创建方法。</li>
<li><strong>指挥者</strong>：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。</li>
</ul>
<h3 id="第一种实现："><a href="#第一种实现：" class="headerlink" title="第一种实现："></a>第一种实现：</h3><p>首先创建目标类，也就是我们的产品角色，要实现的产品定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 产品角色</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String cpu;<span class="comment">//必须</span></span><br><span class="line">    <span class="keyword">private</span> String ram;<span class="comment">//必须</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> usbCount;<span class="comment">//可选</span></span><br><span class="line">    <span class="keyword">private</span> String keyboard;<span class="comment">//可选</span></span><br><span class="line">    <span class="keyword">private</span> String display;<span class="comment">//可选</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Computer</span><span class="params">(String cpu, String ram)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cpu = cpu;</span><br><span class="line">        <span class="keyword">this</span>.ram = ram;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsbCount</span><span class="params">(<span class="keyword">int</span> usbCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.usbCount = usbCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKeyboard</span><span class="params">(String keyboard)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.keyboard = keyboard;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDisplay</span><span class="params">(String display)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.display = display;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Computer&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;cpu=&#x27;&quot;</span> + cpu + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, ram=&#x27;&quot;</span> + ram + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, usbCount=&quot;</span> + usbCount +</span><br><span class="line">                <span class="string">&quot;, keyboard=&#x27;&quot;</span> + keyboard + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, display=&#x27;&quot;</span> + display + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后创建抽象建造者，对具体建造实现类的一个抽象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象创建者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">getUsbCount</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">getKeyboard</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">getDisplay</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Computer <span class="title">getComputer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>指挥者负责创建流程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指挥者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerDirector</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeComputer</span><span class="params">(ComputerBuilder builder)</span> </span>&#123;</span><br><span class="line">        builder.getKeyboard();</span><br><span class="line">        builder.getDisplay();</span><br><span class="line">        builder.getUsbCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体建造者，建造者的具体实现，创建产品对象，定义具体产品的创建规则，这已创建电脑举例</p>
<p>华硕电脑创建者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体创建者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsusComputerBuilder</span> <span class="keyword">extends</span> <span class="title">ComputerBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Computer computer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AsusComputerBuilder</span><span class="params">(String cpu, String ram)</span> </span>&#123;</span><br><span class="line">        computer = <span class="keyword">new</span> Computer(cpu, ram);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUsbCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        computer.setUsbCount(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getKeyboard</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        computer.setKeyboard(<span class="string">&quot;华硕键盘&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getDisplay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        computer.setDisplay(<span class="string">&quot;华硕显示器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">getComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> computer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>联想电脑建造者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体创建者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LenovoComputerBuilder</span> <span class="keyword">extends</span> <span class="title">ComputerBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Computer computer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LenovoComputerBuilder</span><span class="params">(String cpu, String ram)</span> </span>&#123;</span><br><span class="line">        computer = <span class="keyword">new</span> Computer(cpu, ram);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUsbCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        computer.setUsbCount(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getKeyboard</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        computer.setKeyboard(<span class="string">&quot;联想键盘&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getDisplay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        computer.setDisplay(<span class="string">&quot;联想显示器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">getComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> computer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ComputerDirector director = <span class="keyword">new</span> ComputerDirector();</span><br><span class="line"></span><br><span class="line">        ComputerBuilder asusBuilder = <span class="keyword">new</span> AsusComputerBuilder(<span class="string">&quot;英特尔i7&quot;</span>,<span class="string">&quot;金士顿&quot;</span>);</span><br><span class="line">        director.makeComputer(asusBuilder);</span><br><span class="line">        Computer asusComputer = asusBuilder.getComputer();</span><br><span class="line">        System.out.println(asusComputer);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ComputerBuilder lenovoBuilder = <span class="keyword">new</span> LenovoComputerBuilder(<span class="string">&quot;英特尔i8&quot;</span>,<span class="string">&quot;三星&quot;</span>);</span><br><span class="line">        director.makeComputer(lenovoBuilder);</span><br><span class="line">        Computer lenovoComputer = lenovoBuilder.getComputer();</span><br><span class="line">        System.out.println(lenovoComputer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第一种方法UML类图"><a href="#第一种方法UML类图" class="headerlink" title="第一种方法UML类图"></a>第一种方法UML类图</h3><img src="http://www.plantuml.com/plantuml/svg/pP8nJiCm68Ltdy9Z8z7s09KgGRl11ao8mN6io6fYH_RlYAggnCB0n1au0GTWu3GClGK9CNRYE4mCJ8dotl_olT-c1T4QRsHP6M0A7r2bU4s0uMjGNEIOLcQrN7v-F9rUtqDDaNAiSG7Ow7GZZO1MVNaxFJw7apksJoLHsQGXuxegoBwdcxJWr87EFDvP3oT1HuH8ga4H2fWEkbqONcHTnIxB-Mh9CvmpkBNOisGrwRcqvBzvjXrypE8MtTXSbyRNO7Uqvzhea9Wz01DPj8dTcekbziNzEP8tkJixCbv7gFWbX8gh7XxOiB3lUyM4hELVDeuc_glEFz-sN34AidSbloDBicDkBDn0sZtRj2xiXcbmyne8-1WkREsxUqnKhXDyEBOKiJicv_Er0qFnKnbwqAX6gmSp2BLyUB5OZrfx9SBZnIZA5m00">


<h3 id="第二种方法："><a href="#第二种方法：" class="headerlink" title="第二种方法："></a>第二种方法：</h3><p>在<code>Computer</code>类中创建一个静态内部类<code>ComputerBuilder</code>，<code>ComputerBuilder</code>类的属性和<code>Computer</code>类相同，在<code>ComputerBuilder</code>类中创建设置函数，函数的返回类型为<code>ComputerBuilder</code>类型，通过设置函数对可选参数进行赋值，也可以把必选参数也用设置函数赋值，不过这里使用了<br>有参构造进行赋值，创建一个<code>build()</code>方法用来在<code>ComputerBuilder</code>中构建<code>Computer</code>实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String cpu;<span class="comment">//必须</span></span><br><span class="line">    <span class="keyword">private</span> String ram;<span class="comment">//必须</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> usbCount;<span class="comment">//可选</span></span><br><span class="line">    <span class="keyword">private</span> String keyboard;<span class="comment">//可选</span></span><br><span class="line">    <span class="keyword">private</span> String display;<span class="comment">//可选</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Computer</span><span class="params">(ComputerBuilder computerBuilder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cpu = computerBuilder.cpu;</span><br><span class="line">        <span class="keyword">this</span>.ram = computerBuilder.ram;</span><br><span class="line">        <span class="keyword">this</span>.usbCount = computerBuilder.usbCount;</span><br><span class="line">        <span class="keyword">this</span>.keyboard = computerBuilder.keyboard;</span><br><span class="line">        <span class="keyword">this</span>.display = computerBuilder.display;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerBuilder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String cpu;</span><br><span class="line">        <span class="keyword">private</span> String ram;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> usbCount;</span><br><span class="line">        <span class="keyword">private</span> String keyboard;</span><br><span class="line">        <span class="keyword">private</span> String display;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ComputerBuilder</span><span class="params">(String cpu, String ram)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.cpu = cpu;</span><br><span class="line">            <span class="keyword">this</span>.ram = ram;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> ComputerBuilder <span class="title">setUsbCount</span><span class="params">(<span class="keyword">int</span> usbCount)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.usbCount = usbCount;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> ComputerBuilder <span class="title">setKeyboard</span><span class="params">(String keyboard)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.keyboard = keyboard;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> ComputerBuilder <span class="title">setDisplay</span><span class="params">(String display)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.display = display;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Computer <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> Computer(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Computer&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;cpu=&#x27;&quot;</span> + cpu + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, ram=&#x27;&quot;</span> + ram + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, usbCount=&quot;</span> + usbCount +</span><br><span class="line">                <span class="string">&quot;, keyboard=&#x27;&quot;</span> + keyboard + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, display=&#x27;&quot;</span> + display + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第二种方法UML类图"><a href="#第二种方法UML类图" class="headerlink" title="第二种方法UML类图"></a>第二种方法UML类图</h3><img src="http://www.plantuml.com/plantuml/svg/VP0z3i8m38Ntdi9ZAdvw09Y0ZH6O44EQHYYYVqeSfAf2Oc5WuWoSW0CmS1e6RW6506recUBe-TdVCmkfKZ1CebGZbv0xgHHhYXmcA4My19RgdkTTBxlRyMnhaaQ_ceWHjFA7YOwnK0-dstPlErSyynCgWyQ6GAWqf5b9rtues0UKl8k15c7m06VLl-ji75Q9PeJQW7N1wWCr1caAO8CR3FBTtYvjTHlQGN6S6GPI1lfd61isOh7-yunUsAIQuiS1Vc4XnPNDcQTSOVvkKqZnyQmJ4K14HMp6pHT0vLAva6yAusTOgzEnMHoRhT_jFdVS0G00">















































]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象工厂模式</title>
    <url>/2021/08/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>抽象工厂模式提供一个创建一系列相关或者相互依赖对象的接口<br>无须指定他们具体的类</p>
</blockquote>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><blockquote>
<p>1）客户端（应用层）不依赖于产品类实例如何被创建、实现等细节。<br>2）强调一系列相关的产品对象（属于同一产品族）一起使用创建对象需要大量重复的代码。<br>3）提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。  </p>
</blockquote>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>具体产品在应用层代码隔离，无须关心创建细节</li>
<li>将一个系列的产品族统一到一起创建</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂的接口。  </li>
<li>增加了系统的抽象性和理解难度。  </li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>假设有一个生产电脑的工厂，电脑是由显示器和主机组成，同一个品牌下的主机和显示器，被称为同一个产品族，如，惠普主机和惠普显示器；不同品牌下的同一商品，被称为同一产品等级结构，如，惠普显示器和华硕显示器。  </p>
<p>创建一个抽象工厂（或者接口都可以，这个看具体需要），里面包含电脑和主机两个方法。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ComputerFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//显示器</span></span><br><span class="line">    <span class="function">Displayer <span class="title">getDisplayer</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//主机</span></span><br><span class="line">    <span class="function">Mainframe <span class="title">getMainframe</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个显示器的抽象类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Displayer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个主机的抽象类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Mainframe</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个品牌的工厂实现，如惠普  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HpComputerFactory</span> <span class="keyword">implements</span> <span class="title">ComputerFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Displayer <span class="title">getDisplayer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HpDisplayer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mainframe <span class="title">getMainframe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HpMainframe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建品牌下的显示器实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HpDisplayer</span> <span class="keyword">extends</span> <span class="title">Displayer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;惠普电脑显示器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建品牌下的主机实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HpMainframe</span> <span class="keyword">extends</span> <span class="title">Mainframe</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;惠普电脑主机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一些其他的品牌，如华硕等<br>工厂实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsusComputerFactory</span> <span class="keyword">implements</span> <span class="title">ComputerFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Displayer <span class="title">getDisplayer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AsusDisplayer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mainframe <span class="title">getMainframe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AsusMainframe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显示器实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsusDisplayer</span> <span class="keyword">extends</span> <span class="title">Displayer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;华硕电脑显示器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主机实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsusDisplayer</span> <span class="keyword">extends</span> <span class="title">Displayer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;华硕电脑显示器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>具体调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过具体的某个工厂实现来获取这个工厂</span></span><br><span class="line">        ComputerFactory computerFactory = <span class="keyword">new</span> HpComputerFactory();</span><br><span class="line">        <span class="comment">//通过这个工厂获取这个工厂下的显示器</span></span><br><span class="line">        Displayer displayer = computerFactory.getDisplayer();</span><br><span class="line">        <span class="comment">//通过工厂获取工厂下的主机</span></span><br><span class="line">        Mainframe mainframe = computerFactory.getMainframe();</span><br><span class="line">        <span class="comment">//具体业务</span></span><br><span class="line">        displayer.start();</span><br><span class="line">        mainframe.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h2><img src="http://www.plantuml.com/plantuml/svg/hLAzRi8m4Dxz53VI9I_G2WcrGbsOoeOOZd14bcB7ybqGAEBT6nVYf25fAi5u-VxkEqTR8N_0bE2zCAwiXoMcKlWpLEf3iylnJ1uoaZZCNbxL2hKzU3GKa3W4vA8KxbXyRG9fZipGkbJAbRjSfn0PnqBlWGMz36lRd2bj45yrdwxVH1kNao4ht2yPNSUgGdKPBHkmJcfhGISXk-yqZp7TdNloDgMHno_JyWMN_EJMDyg_oeVuX-e7WuSEi2QMoAe9qf1DxJ7x4gzjjja2-emRuVr_aYJpxZkECk9UIWqTFf1-NUHFreJPMvByb1jOfe6-0G00">









]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>桥接模式</title>
    <url>/2021/09/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>将抽象部分与它的具体实现部分分离，使它们都可以独立的变化<br>通过组合的方式建立两个类之间联系，而不是继承  </p>
</blockquote>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li>抽象和具体实现之间增加更多的灵活性</li>
<li>一个类存在两个（或多个）独立变化的维度，且这两个（或多个）维度都需要独立进行扩展</li>
<li>不希望使用继承，或因为多层继承导致系统类的个数剧增</li>
</ul>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>分离抽象部分以及其具体实现部分  </li>
<li>提高了系统可扩展性  </li>
<li>符合开闭原则  </li>
<li>符合合成复用原则  </li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>增加了系统的理解与设计难度</li>
<li>需要正确的识别出系统中两个独立变化的维度</li>
</ul>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><strong>抽象化角色</strong>： 定义抽象类，并包含一个对实例化对象的引用<br><strong>扩展抽象化角色</strong>： 是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法<br><strong>实现化角色</strong>： 定义实现化角色的接口，供扩展抽象化角色调用<br><strong>具体实现化角色</strong>： 给出实现化角色接口的具体实现</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>有多个电脑品牌，每个品牌下有不同的电脑类型，比如迷你电脑、台式机、笔记本等，如果我们使用一个类去表示一个品牌下的一种电脑类型，那么类会非常多；<br>这里我们就可以使用桥接模式来实现，首先我们创建一个电脑的接口，定义电脑的行为操作，开机、玩游戏<br>实现化角色  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">games</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义电脑品牌抽象类，里面组合电脑接口(其中的行为方法可以与电脑接口一样，也可以不一样，这里演示使用，写成一样)<br>抽象化角色  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Brand</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Computer computer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Brand</span><span class="params">(Computer computer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.computer = computer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Computer <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建电脑类型的实现类（具体实现化角色）<br>迷你电脑主机：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiniComputer</span> <span class="keyword">implements</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;   迷你电脑开机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">games</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;   迷你电脑玩游戏&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>笔记本电脑： （具体实现化角色）  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotebookComputer</span> <span class="keyword">implements</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;   笔记本电脑开机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">games</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;   笔记本电脑玩游戏&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建厂商品牌的实现（扩展抽象化角色）<br>惠普电脑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HpBrand</span> <span class="keyword">extends</span> <span class="title">Brand</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HpBrand</span><span class="params">(Computer computer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(computer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;打开惠普电脑&quot;</span>);</span><br><span class="line">        computer.open();</span><br><span class="line">        <span class="keyword">return</span> computer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>联想电脑：  （扩展抽象化角色）  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LenovoBrand</span> <span class="keyword">extends</span> <span class="title">Brand</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LenovoBrand</span><span class="params">(Computer computer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(computer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;打开联想电脑&quot;</span>);</span><br><span class="line">        computer.open();</span><br><span class="line">        <span class="keyword">return</span> computer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Brand brand = <span class="keyword">new</span> HpBrand(<span class="keyword">new</span> MiniComputer());</span><br><span class="line">        Computer computer = brand.open();</span><br><span class="line">        computer.games();</span><br><span class="line"></span><br><span class="line">        Brand brand1 = <span class="keyword">new</span> LenovoBrand(<span class="keyword">new</span> NotebookComputer());</span><br><span class="line">        Computer computer1 = brand1.open();</span><br><span class="line">        computer1.games();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">打开惠普电脑   迷你电脑开机   迷你电脑玩游戏</span><br><span class="line">打开联想电脑   笔记本电脑开机   笔记本电脑玩游戏</span><br></pre></td></tr></table></figure>

<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><img src="http://www.plantuml.com/plantuml/svg/hL512i8m4Bpd5JbQmHSKFEZ5W_g7D5abs6H3aXOXzEzMqwv1eGVnjilCpWopeWdH2ncvR4K8VEU5LJmnvp62ZA3u7eth8dWkfw5chcjQBJDtzOLNF0qpHSpgn487TbNLR63QZlj5I7Y3YVMe5N5UorKO2Fc2vOm7brF2FO9LK-OqMqxeSgwFE4-4v8zWiSSbYuBnkyr9MqsuDgu50pO6kY6tef92kkmcwsRPy_Yt1l7sLscMsrXljlIh1m00">














]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>模板方法模式</title>
    <url>/2021/10/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>定义了一个算法的骨架，并允许子类为一个或多个步骤提供实现；<br>模板方法使得子类可以在不改变算法结构的情况下，重新定义算法的某些步骤。</p>
</blockquote>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li>一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现；</li>
<li>各个子类中公共的行为被提取出来并集中到一个公共父类中，从而避免代码重复。</li>
</ul>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类实现，而把可变部分算法由子类继承实现，便于子类继续扩展。</li>
<li>它在父类中提取了公共部分代码，便于代码复用；</li>
<li>部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>对每个不同的实现都需要定义一个子类，这会导致类的数量增加，系统更加庞大，设计也更加抽象，间接增加的系统实现的复杂度。</li>
<li>父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码的阅读难度。</li>
<li>由于继承关系自身的缺点，如果父类添加新的抽象方法，则所有子类都需要改一遍。</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>假设一个场景，我们要生产电脑，每个厂家生产电脑配置的东西不一样</p>
<p>首先创建抽象类，限制创建电脑的模板</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AComputer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模板方法，声明成final是不希望子类覆盖这个类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">assembleComputer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//限制方法的调用，不让子类重写</span></span><br><span class="line">        principal();</span><br><span class="line">        displayer();</span><br><span class="line">        keyboard();</span><br><span class="line">        <span class="keyword">if</span> (needMouse())&#123;</span><br><span class="line">            mouse();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产主机，每个电脑都必须的，所以也声明成final</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">principal</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产主机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显示器，每个电脑也都需要，所以也声明成final</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">displayer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产显示器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 键盘配置，由子类来实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">keyboard</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 鼠标为非必须品，可以通过钩子方法来判断是否需要</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">mouse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产鼠标&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 鼠标的钩子方法，默认返回false，如果子类需要，重写该方法即可</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">needMouse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建子类，继承抽象类，实现抽像方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsusComputer</span> <span class="keyword">extends</span> <span class="title">AComputer</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产键盘</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">keyboard</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;华硕机械键盘&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类重写钩子方法，控制父类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LenovoComputer</span> <span class="keyword">extends</span> <span class="title">AComputer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">keyboard</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;联想键盘&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 联想生产键盘，同时也生产鼠标，重写鼠标钩子方法，返回true即可</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">needMouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者通过入参来控制父类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HpComputer</span> <span class="keyword">extends</span> <span class="title">AComputer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> needMouseFlag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HpComputer</span><span class="params">(<span class="keyword">boolean</span> needMouseFlag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.needMouseFlag = needMouseFlag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 惠普生产键盘，但是鼠标可能生产可能不生产，可以将钩子的值作为变量通过构造函数设置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">keyboard</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;惠普键盘&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">needMouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.needMouseFlag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><img src="http://www.plantuml.com/plantuml/svg/fP31QiCm44Jl_eezEjzG2Ws1q4DAls4bJOBeMYiasSIO_7jCI5BNTN9eppFxTcROv9BO5hB2ETDweqri2n8DLKnQO0iSxNrWeKwzez64nWXklderd9QTCVbWVMHvR74-H-7-Ik5Rb8lsXTue9rUlNfQF6sqpPcoZAk100N0VT_rKLTTskSttWZWM13UfF5HldnrIyWxp23Ibx12qqpzpliMdkN-yV8_FterBTrpmcx8LFj0hxLaonXLR8zvEMFNYmIpaVnkS0G00">
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>状态模式</title>
    <url>/2021/10/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>允许一个对象在其内部状态改变时，改变它的行为；<br>行为型</p>
</blockquote>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li>一个对象存在多个状态（不同状态下行为不同），且状态可相互转换</li>
</ul>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>将不同的状态隔离</li>
<li>把各种状态的转换逻辑，分布到State子类中，减少相互间依赖</li>
<li>增加新的状态非常简单</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>状态对的业务场景等导致类数据增加，系统变复杂</li>
</ul>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><ul>
<li><strong>环境类角色</strong>：也称为上下文，它定义了客户端需要大的接口，内部维护一个当前状态，并负责具体的状态切换；</li>
<li><strong>抽象状态角色</strong>：定义一个接口，用以封装环境对象中大的特定状态所对应的行为，可以有一个或多个行为。</li>
<li><strong>具体状态角色</strong>：实现抽象状态所对应的行为，并且在需要的情况下进行状态切换。</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>假设我们播放一个视频，一共有四种状态，播放、快进、暂停、停止，这四种状态，有的可以相互切换，有的不行<br>环境类角色，上下文，缓存一个当前状态，并负责切换状态  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VideoContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> VideoState videoState;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> VideoState <span class="title">getVideoState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> videoState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVideoState</span><span class="params">(VideoState videoState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.videoState = videoState;</span><br><span class="line">        <span class="keyword">this</span>.videoState.setVideoContext(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.videoState.play();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.videoState.speed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.videoState.pause();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.videoState.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抽象状态角色，组合有上下文类，方便子类使用  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">VideoState</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> VideoContext videoContext;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVideoContext</span><span class="params">(VideoContext videoContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.videoContext = videoContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;<span class="comment">//播放</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">speed</span><span class="params">()</span></span>;<span class="comment">//快进</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span></span>;<span class="comment">//暂停</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;<span class="comment">//停止</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体状态角色<br>播放状态，可以和另外三种状态进行切换  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlayState</span> <span class="keyword">extends</span> <span class="title">VideoState</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正常播放视频状态&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.videoContext.setVideoState(<span class="keyword">new</span> SpeedState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.videoContext.setVideoState(<span class="keyword">new</span> PauseState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.videoContext.setVideoState(<span class="keyword">new</span> StopState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>快进状态，可以和另外三种状态切换  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpeedState</span> <span class="keyword">extends</span> <span class="title">VideoState</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.videoContext.setVideoState(<span class="keyword">new</span> PlayState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;快进播放视频状态&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.videoContext.setVideoState(<span class="keyword">new</span> PauseState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.videoContext.setVideoState(<span class="keyword">new</span> StopState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>暂停状态，可以和另外三种状态切换  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PauseState</span> <span class="keyword">extends</span> <span class="title">VideoState</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.videoContext.setVideoState(<span class="keyword">new</span> PlayState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.videoContext.setVideoState(<span class="keyword">new</span> SpeedState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;暂停播放视频状态&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.videoContext.setVideoState(<span class="keyword">new</span> StopState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>停止状态，只能和播放状态切换，停止的情况下不能快进和暂停  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopState</span> <span class="keyword">extends</span> <span class="title">VideoState</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.videoContext.setVideoState(<span class="keyword">new</span> PlayState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ERROR, 停止状态不能快进&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ERROR，停止状态不能暂停&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;停止播放视频状态&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试，视频开始是播放状态，我们有事需要离开一会，可以切换成暂停状态，回来想要快进看，由暂停直接切换到快进状态，看完之后切换到停止状态，从停止状态再切换到快进状态是不允许的。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        VideoContext videoContext = <span class="keyword">new</span> VideoContext();</span><br><span class="line">        videoContext.setVideoState(<span class="keyword">new</span> PlayState());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;当前状态：&quot;</span>+videoContext.getVideoState().getClass().getSimpleName());</span><br><span class="line"></span><br><span class="line">        videoContext.pause();</span><br><span class="line">        System.out.println(<span class="string">&quot;当前状态：&quot;</span>+videoContext.getVideoState().getClass().getSimpleName());</span><br><span class="line"></span><br><span class="line">        videoContext.speed();</span><br><span class="line">        System.out.println(<span class="string">&quot;当前状态：&quot;</span>+videoContext.getVideoState().getClass().getSimpleName());</span><br><span class="line"></span><br><span class="line">        videoContext.stop();</span><br><span class="line">        System.out.println(<span class="string">&quot;当前状态：&quot;</span>+videoContext.getVideoState().getClass().getSimpleName());</span><br><span class="line"></span><br><span class="line">        videoContext.speed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当前状态：PlayState</span><br><span class="line">当前状态：PauseState</span><br><span class="line">当前状态：SpeedState</span><br><span class="line">当前状态：StopState</span><br><span class="line">ERROR, 停止状态不能快进</span><br></pre></td></tr></table></figure>

<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><img src="http://www.plantuml.com/plantuml/svg/rLGnRi8m5Drz2ezf9U00OQZK0nGfg4l5O18hifGcbls9YX03FKBLgMNgMd65SXgY7gDsJ1A7s7lPxF_-Vtx_VTjnHgJ4ZooXnNsH0tq1l45Si980DU48zB9ibo7YgsN6OXjDANIxu0PljarIMR04onxiP1tKy8oi7KoSqcGOvcGbNUT2mKrqYn1PIX0a1XntBHiLkk42Q0mqwJjHMflGsT4P3BnbjgPMWTLWE9bKRuVg_SUTTEvNPPsEtx_7Jm-LQLzpVRoUTdiFL-s6fjhjgyENziHOCLDAZ1DACCsJ2tFk7aegX8fWztpSU3ifxCkmXkQXiCTdf4QQrQVrVqcTwPhha1gfq7KedLDPVr0cIog1JV8pONaGWM1v-hJ0HAIogUokztGqkkszS6JTfo5elG85NgBMV1syhQD33FK-Y-buN7Vr1m00">]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>策略模式</title>
    <url>/2021/10/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>定义了算法家族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化不会影响到使用算法的用户。<br>行为型</p>
</blockquote>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li>系统由很多类，而他们的区别仅仅在于他们的行为不同；</li>
<li>一个系统需要动态地在几种算法中选择一种。</li>
</ul>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>符合开闭原则</li>
<li>避免使用多重条件转移语句</li>
<li>提高算法的保密性和安全性</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。</li>
<li>会产生很多策略类。</li>
</ul>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><ul>
<li><strong>抽象策略类</strong>：定义了一个公共接口，各种不同的算法以不同的方法实现这个接口，环境角色使用这个接口调用不同的算法，一般使用接口或者抽象类实现。</li>
<li><strong>环境策略类</strong>：实现了抽象策略定义的接口，提供具体的算法实现。</li>
<li><strong>环境类</strong>：持有一个策略类的引用，最终给客户端调用。</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>假设有一个饭店，里面有许多中菜，都是由大厨来做的，根据不同的策略，大厨就可以做出来不同的菜<br>抽象策略类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span>  <span class="title">friedDish</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>菜肴1<br>具体策略类   </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bouilli</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">friedDish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;红烧肉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>菜肴2<br>具体策略类  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoastDuck</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">friedDish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;烤鸭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>菜肴3<br>具体策略类  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShreddedPotatoes</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">friedDish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;土豆丝&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>厨房<br>环境类：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Restaurant</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Restaurant</span><span class="params">(Strategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">friedDish</span><span class="params">()</span></span>&#123;</span><br><span class="line">        strategy.friedDish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Restaurant restaurant = <span class="keyword">new</span> Restaurant(<span class="keyword">new</span> Bouilli());</span><br><span class="line">        restaurant.friedDish();</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Restaurant restaurant1 = <span class="keyword">new</span> Restaurant(<span class="keyword">new</span> ShreddedPotatoes());</span><br><span class="line">        restaurant1.friedDish();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">红烧肉</span><br><span class="line">-------------------</span><br><span class="line">土豆丝</span><br></pre></td></tr></table></figure>

<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><img src="http://www.plantuml.com/plantuml/svg/fP112i9034NtSueiLV041HVI0uWzGPn9RN3QAPDCGKhlRcdL5jrfLe7yztyIRfHYYPQWq8XArplqfWli0Ch8v7AMQhFDp62CzIW2nv3OUmQkMqyrDIfliZTjkdYsCF4h7FfXCJW75CsJlVrkKLIHd2Dt2eeQIFvOXaGnHMnqF1l6QYDt8xzyGvvDDezdpmNRV0cdW9NsCt-ENmNlzeUNoGC0">






















]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>简单工厂模式</title>
    <url>/2021/07/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类中。<br>我们把被创建的对象称为”产品“，把创建产品的对象称为”工厂“，如果创建的产品不多，只要一个工厂类就可以完成，这种模式交”简单工厂模式“。<br>在简单工厂模式中，创建实例的方法通常为静态方法，因此简单工厂模式又叫做“静态工厂方法模式”。  </p>
</blockquote>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>工厂类包含必要的逻辑判断，可以决定在什么时候创建哪一个产品的实例，客户端可以免除直接创建产品对象的职责，很方便的创建出相应的产品，工厂和产品的区分明确。  </li>
<li>客户端无需知道所创建具体产品的类名，只需要知道参数即可。  </li>
<li>也可以引入配置文件，在不修改客户端代码的情况下，更换和添加新的具体产品类。  </li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>简单工厂模式的工厂类单一，负责所有产品的创建，职责过重，一旦异常，整个系统将受影响。且工厂类代码会非常臃肿，违背开闭原则。  </li>
<li>使用简单工厂模式会正价系统中；类的个数（引入新的工厂类），增加系统的复杂度和理解难度。  </li>
<li>系统扩展困难，一旦增加新产品不得不修改工厂逻辑，在产品类型较多时，可能造成逻辑过于复杂。  </li>
<li>简单工厂模式使用了static工厂方法，造成工厂角色无法形成基于继承的等级结构。  </li>
</ul>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>对于产品种类相对比较少的情况，考虑使用简单工厂模式，使用简单工厂模式的客户端只需要传入工厂类的参数，不需要关系如何创建对象的逻辑，可以很方便的创建所需产品。  </li>
</ul>
<h2 id="模式的结构与实现"><a href="#模式的结构与实现" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h2><h3 id="简单工厂模式的主要角色如下"><a href="#简单工厂模式的主要角色如下" class="headerlink" title="简单工厂模式的主要角色如下"></a>简单工厂模式的主要角色如下</h3><ul>
<li>简单工厂：是简单工厂模式的核心，负责实现创建所有实例的内部逻辑。工厂的创建产品类的方法可以被外界直接调用，创建所需的产品对象。  </li>
<li>抽象产品：是简单工厂创建的所有对象的父类，负责描述所有实例共有的公共接口。  </li>
<li>具体产品：是简单工厂模式的创建目标。  </li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="创建抽象产品类"><a href="#创建抽象产品类" class="headerlink" title="创建抽象产品类"></a>创建抽象产品类</h4><p>我们创建一个电脑的抽象产品类，他有一个抽象方法用于启动电脑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产品的抽象方法，由具体的产品类去实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建具体产品类"><a href="#创建具体产品类" class="headerlink" title="创建具体产品类"></a>创建具体产品类</h4><p>接着我们创建各个品牌的电脑，他们都继承了他们的父类Computer，并实现了父类的start方法。</p>
<p><strong>联想电脑</strong>  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LenovoComputer</span> <span class="keyword">extends</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;联想电脑启动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>惠普电脑</strong>  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HpComputer</span> <span class="keyword">extends</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;惠普电脑启动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>华硕电脑</strong>  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsusComputer</span> <span class="keyword">extends</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;华硕电脑启动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建工厂类"><a href="#创建工厂类" class="headerlink" title="创建工厂类"></a>创建工厂类</h4><p>接下来创建一个工厂类，它提供了一个静态方法createComputer用来生产电脑，你只需要传入你想生产的电脑品牌，它就会实例化对象品牌的电脑对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Computer <span class="title">createComputer</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        Computer computer = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (type)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;lenovo&quot;</span>:</span><br><span class="line">                computer = <span class="keyword">new</span> LenovoComputer();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;hp&quot;</span>:</span><br><span class="line">                computer = <span class="keyword">new</span> HpComputer();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;asus&quot;</span>:</span><br><span class="line">                computer = <span class="keyword">new</span> AsusComputer();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> computer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="客户端调用工厂类"><a href="#客户端调用工厂类" class="headerlink" title="客户端调用工厂类"></a>客户端调用工厂类</h4><p>客户端调用工厂类，传入“hp”生产出惠普电脑并调用该电脑的start对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ComputerFactory.createComputer(<span class="string">&quot;hp&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第二种实现方式"><a href="#第二种实现方式" class="headerlink" title="第二种实现方式"></a>第二种实现方式</h4><p>为了节省内存和创建的时间，我们可以将computer事先创建好缓存起来。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String,Computer&gt; COMPUTER_MAP = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        COMPUTER_MAP.put(<span class="string">&quot;lenovo&quot;</span>,<span class="keyword">new</span> LenovoComputer());</span><br><span class="line">        COMPUTER_MAP.put(<span class="string">&quot;hp&quot;</span>,<span class="keyword">new</span> HpComputer());</span><br><span class="line">        COMPUTER_MAP.put(<span class="string">&quot;asus&quot;</span>,<span class="keyword">new</span> AsusComputer());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Computer <span class="title">createComputer</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="keyword">null</span> || type.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//返回null或者抛异常看业务情况判断</span></span><br><span class="line">        &#125;</span><br><span class="line">        Computer computer = COMPUTER_MAP.get(type.toLowerCase());</span><br><span class="line">        <span class="keyword">return</span> computer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第三种实现"><a href="#第三种实现" class="headerlink" title="第三种实现"></a>第三种实现</h4><p>因为每次新增产品的实现之后，都需要修改工厂类里面实例创建的代码，所以简单工厂方法并不符合开闭原则，第三种方法在一定程度上解决了这个问题  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Computer <span class="title">createComputer</span><span class="params">(Class clazz)</span></span>&#123;</span><br><span class="line">        Computer computer = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            computer = (Computer)Class.forName(clazz.getName()).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException | ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> computer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体调用如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ComputerFactory3.createComputer(HpComputer.class).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="UML结构图"><a href="#UML结构图" class="headerlink" title="UML结构图"></a>UML结构图</h3><img src="http://www.plantuml.com/plantuml/svg/IqmgBYbAJ2vHICv9B2vMSCxFBIWjIIsgvdewjUtfvCPdNNjVR5puRDhEPvkdlj_Jywn_mfDziv_ldlzaHmEor8jrAvzEQ7coOnL4rzDryvxtRU0gA4tAoKnMI8HPKPQVcQ9GN99OLAAXQSrLomMnqh6uj1XchK9gHKbgNWgcEu1sGmo5sFryLWkozLmE_cMfHKMPAQaAK3kHhOBRv9EQbr-MJn-xF0heOm_CK3TW0ESNLIe03T--z6bVq_EDk-7nzRHrpTFMZI_dpdpMq0Wn_FcK-KzsBOSu0nPDG9DBW1JSsSb5gOabgJ2kHd19KMPUka99PK4go7Okb6YpqTD3TmaNMcXZKu8KI5Ya0G00">
















]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>组合模式</title>
    <url>/2021/09/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>将对象组合成树形结构以表示“整体-部分”的层次结构<br>组合模式使客户端对单个对象和组合对象保持一致的方式处理  </p>
</blockquote>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li>希望客户端可以忽略组合对象与单个对象的差异时  </li>
<li>处理一个树形结构时   </li>
</ul>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>清楚地定义分层次的复杂对象，表示对象的全部或部分层次  </li>
<li>让客户端忽略了层次的差异，方便对整个层次结构进行控制  </li>
<li>简化客户端代码  </li>
<li>符合开闭原则  </li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>限制类型时会较为复杂  </li>
<li>使设计变得更加抽象  </li>
</ul>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>主要角色：<br><strong>抽象构件角色</strong>： 它的主要作用是为树叶构件和树枝构件声明公共接口，并实现他们的默认行为。在透明式的组合模式中抽象构件还声明访问和管理之类的接口；在安全式的组合模式中不声明访问和管理子类的接口，管理工作由树枝构件完成。（总的抽象类或接口，定义一些通用的方法，比如新增、删除）<br><strong>树叶构件角色</strong>： 是组合中的叶节点对象，它没有子节点，用于继承或实现抽象构件。<br><strong>树枝构件角色</strong>： 是组合中的分支节点对象，它有子节点，用户继承和实现抽象构件。它的主要作用是存储和管理子部件，通常包含<code>add()</code>、<code>remove()</code>、<code>getChild()</code>等方法。  </p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>假设我们现在有一个文件夹，里面有若干个文件，我们现在需要用对象来存储，需要表示清楚其中的层级关系<br>首先创建抽象构件角色，根据业务情况，来控制方法是否是必须需要重写的，也可以使用接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FileComponent</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(FileComponent fileComponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;无权操作添加方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(FileComponent fileComponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;无权操作删除方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;无权操作获取名称方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;无权操获取大小方法除方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建树叶构件角色，文件类，属于叶子节点，不存在删除或者添加的方法，所以我们只需要实现获取名称和大小的方法即可，另外文件本身是拥有名称和大小属性的，也可以根据实际情况将属性上提  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDoc</span> <span class="keyword">extends</span> <span class="title">FileComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileDoc</span><span class="params">(String name, Integer size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;文件的名称是：&quot;</span> + <span class="keyword">this</span>.name + <span class="string">&quot;   文件的大小是：&quot;</span> + <span class="keyword">this</span>.size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>树枝构件角色，文件夹类，可以存放或者删除文件，拥有名称和层级属性，文件夹本身是没有大小的，但是可以依托下面文件的大小来计算大小，所以文件夹类可以实现所有的方法  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FolderDoc</span> <span class="keyword">extends</span> <span class="title">FileComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;FileComponent&gt; components = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer level;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FolderDoc</span><span class="params">(String name, Integer level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> components.stream().mapToInt(FileComponent::getSize).sum();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(FileComponent fileComponent)</span> </span>&#123;</span><br><span class="line">        components.add(fileComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(FileComponent fileComponent)</span> </span>&#123;</span><br><span class="line">        components.remove(fileComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;  size=&quot;</span> + getSize());</span><br><span class="line">        <span class="keyword">for</span> (FileComponent component : components) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.level != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.level; i++) &#123;</span><br><span class="line">                    System.out.print(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            component.print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体调用，我们在<code>视频</code>文件夹下存放了两部电影，以及一个<code>火影忍者</code>文件夹，文件夹下又有三集电视剧</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FileComponent fileComponent = <span class="keyword">new</span> FileDoc(<span class="string">&quot;倩女幽魂&quot;</span>,<span class="number">400</span>);</span><br><span class="line">        FileComponent fileComponent1 = <span class="keyword">new</span> FileDoc(<span class="string">&quot;僵尸先生&quot;</span>,<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">        FileComponent fileComponent2 = <span class="keyword">new</span> FolderDoc(<span class="string">&quot;火影忍者&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        FileComponent fileComponent3 = <span class="keyword">new</span> FileDoc(<span class="string">&quot;火影忍者第一集&quot;</span>,<span class="number">45</span>);</span><br><span class="line">        FileComponent fileComponent4 = <span class="keyword">new</span> FileDoc(<span class="string">&quot;火影忍者第二集&quot;</span>,<span class="number">56</span>);</span><br><span class="line">        FileComponent fileComponent5 = <span class="keyword">new</span> FileDoc(<span class="string">&quot;火影忍者第三集&quot;</span>,<span class="number">47</span>);</span><br><span class="line"></span><br><span class="line">        fileComponent2.add(fileComponent3);</span><br><span class="line">        fileComponent2.add(fileComponent4);</span><br><span class="line">        fileComponent2.add(fileComponent5);</span><br><span class="line"></span><br><span class="line">        FileComponent folder = <span class="keyword">new</span> FolderDoc(<span class="string">&quot;视频&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        folder.add(fileComponent);</span><br><span class="line">        folder.add(fileComponent1);</span><br><span class="line">        folder.add(fileComponent2);</span><br><span class="line"></span><br><span class="line">        folder.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">视频  size=848</span><br><span class="line">  文件的名称是: 倩女幽魂   文件的大小是: 400</span><br><span class="line">  文件的名称是: 僵尸先生   文件的大小是: 300</span><br><span class="line">  火影忍者  size=148</span><br><span class="line">    文件的名称是: 火影忍者第一集   文件的大小是: 45</span><br><span class="line">    文件的名称是: 火影忍者第二集   文件的大小是: 56</span><br><span class="line">    文件的名称是: 火影忍者第三集   文件的大小是: 47</span><br></pre></td></tr></table></figure>

<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><img src="http://www.plantuml.com/plantuml/svg/lLBBJiCm4BpxA_QO8hK_a589WP2G49ToGnoszZQovDYHlOH7rN_7SJ1fGX55GfmSxyncPdQDcy0U9OCq609SQqENhcwS9Skm4urtJ999GUkq0bIg65EsXxSPxFRJ5a-rQ-aNNMlssbPG4TzXJSK4lR5C5VaENkktBp3cE4cxYN_YObQAlH13lYidWLwOh3gMLxV8b4tOwA3yB6Rj48LZzMbZj3nkjuT-y7feiKC6ayueygVOt6gB1cvruEM8iWAPFmESWwLdkF0UNnDprKtafA26MZBbN-tctrxGjuEzfv2crwydC78y4hj6ROi-tSCZeAz2xXpBBkVpis4_Kt2nI19YM60izPMFTvSfxm00">































]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>装饰器模式</title>
    <url>/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>在不改变原有对象的基础之上，将功能附加到对象上；<br>提供了比继承更有弹性的替代方案（扩展原有对象功能）  </p>
</blockquote>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li>扩展一个类的功能或给一个类添加附加职责  </li>
<li>动态的给一个对象添加功能，这些功能可以再动态的撤销  </li>
</ul>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>继承的有力补充，比继承灵活，不改变原有对象的情况下给一个对象扩展功能；  </li>
<li>通过使用不同装饰类以及这些装饰类的排列组合，可以试想不同效果；  </li>
<li>符合开闭原则。  </li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>会出现更多的代码，更多的类，增加程序复杂性；  </li>
<li>动态装饰时，多层装饰时会更复杂。  </li>
</ul>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><ul>
<li>抽象构件角色： 定义一个抽象接口以规范准备接收附加责任的对象。  </li>
<li>具体构件角色： 实现抽象构件，通过装饰角色为其添加一些职责。  </li>
<li>抽象装饰角色： 继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。  </li>
<li>具体装饰角色： 实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。  </li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>假设我们去买煎饼，一个煎饼8元钱，可以加鸡蛋和香肠，以传统方式来实现，如果用户只是买一个煎饼，我们建一个煎饼类即可实现，如果用户想要加一个鸡蛋，可以新建一个类继承煎饼类来实现，但是如果用户想再加香肠呢？再鸡蛋呢？两个、三个…<br>很明显，如果再以简单的继承来去实现，我们的类会爆炸式的增加，所以我们可以引入装饰者模式，把鸡蛋和香肠作为装饰，可以动态添加。</p>
<p>首先创建一个抽象构件角色：(煎饼以及作为装饰的抽象类)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">APancakes</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> String <span class="title">getDesc</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">cost</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体构件角色：(具体煎饼类，可以有多种煎饼)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pancakes</span> <span class="keyword">extends</span> <span class="title">APancakes</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;煎饼&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象装饰角色：(具体装饰角色的抽象类，也可以使用对象类，具体根据业务情况决定)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractDecorator</span> <span class="keyword">extends</span> <span class="title">APancakes</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> APancakes aPancakes;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractDecorator</span><span class="params">(APancakes aPancakes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.aPancakes = aPancakes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> aPancakes.getDesc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> aPancakes.cost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>具体装饰角色：(装饰角色的具体实现)<br>鸡蛋实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EggDecorator</span> <span class="keyword">extends</span> <span class="title">AbstractDecorator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EggDecorator</span><span class="params">(APancakes aPancakes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(aPancakes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getDesc() + <span class="string">&quot;  加一个鸡蛋&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.cost() + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>香肠实现：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SausageDecorator</span> <span class="keyword">extends</span> <span class="title">AbstractDecorator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SausageDecorator</span><span class="params">(APancakes aPancakes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(aPancakes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getDesc() + <span class="string">&quot;  加一根香肠&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.cost() + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        APancakes aPancakes = <span class="keyword">new</span> Pancakes();</span><br><span class="line">        aPancakes = <span class="keyword">new</span> EggDecorator(aPancakes);</span><br><span class="line">        aPancakes = <span class="keyword">new</span> EggDecorator(aPancakes);</span><br><span class="line">        aPancakes = <span class="keyword">new</span> SausageDecorator(aPancakes);</span><br><span class="line"></span><br><span class="line">        System.out.println(aPancakes.getDesc()+aPancakes.cost());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如代码所示，想要加几个鸡蛋或者香肠，可以动态的去实现</p>
<p>结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">煎饼  加一个鸡蛋  加一个鸡蛋  加一根香肠 12</span><br></pre></td></tr></table></figure>

<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><img src="http://www.plantuml.com/plantuml/svg/hP8n3u8m48Nt_eeRTI6HLHSItKrmCmv7kJIDM4pl82R4_ow820eBqQdjlTntxrsA2Oj7BQ0pP8PeZqxZcHWgXPqKYxVEW27P4kl5SjrBrjMTEKjJl2lLGZh62kWcvD81jbBVCAZkggSqhn4d_94JlTnkIUSU9VTJlAkt9GeDDe3TRJrdsCwOYJaZ1xC2n5Wm6lexzq0iTV8YoQm65fJwA7ERmWMjMxIWumdG6-uQF-9jWk39K2E3RwN_2wDI-2uz0000">










]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>观察者模式</title>
    <url>/2021/10/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>定义了对象之间的一对多依赖，让多个观察者对象同时监听某一个主题对象，当主题对象发生变化时，它的所有依赖者（观察者）都会收到通知并更新。<br>行为型</p>
</blockquote>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立的改变和复用。</li>
<li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间大的耦合度。</li>
<li>一个对象必须通知其他对象，而并不知道这些对象是谁。</li>
<li>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为影响C对象….，可以适用观察者模式创建一种链式触发机制。</li>
</ul>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>观察者和被观察者之间建立一个抽象的耦合</li>
<li>观察者模式支持广播通信</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>观察者时间有过多的细节依赖、提高时间消耗及程序复杂度</li>
<li>使用要得当，要避免循环调用</li>
</ul>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><ul>
<li><strong>抽象主题角色</strong>：也叫重选ing目标类，它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法。</li>
<li><strong>具体主题角色</strong>：也叫具体目标类，它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。</li>
<li><strong>抽象观察者角色</strong>：它是一个抽象类或者接口，它包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。</li>
<li><strong>具体观察者角色</strong>：实现首相观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="自定义抽象类实现观察者"><a href="#自定义抽象类实现观察者" class="headerlink" title="自定义抽象类实现观察者"></a>自定义抽象类实现观察者</h3><p>抽象目标  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line">    <span class="comment">//增加观察者方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除观察者方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span></span>; <span class="comment">//通知观察者方法</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体目标：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">extends</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体目标发生改变...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object obs : observers) &#123;</span><br><span class="line">            ((Observer) obs).response();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抽象观察者  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">response</span><span class="params">()</span></span>; <span class="comment">//反应</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体观察者1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver1</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">response</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体观察者1作出反应！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体观察者2  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver2</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">response</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体观察者2作出反应！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">具体目标发生改变...</span><br><span class="line">--------------</span><br><span class="line">具体观察者1作出反应！</span><br><span class="line">具体观察者2作出反应！</span><br></pre></td></tr></table></figure>

<h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><img src="http://www.plantuml.com/plantuml/svg/dL0zJyD03DtlLtXCaHg9hWGan8h4KBQAuN9ngqF9NMIxALNK_qvIuYXf2mCt-UptuMURiv1r0gwqpB3Uvv_O_LfJKvIkmW9UFKlsbZDIW_G4SQWO7Y7W0Pw9x76EIHOFfjxdfNVGH5-0BOf4XoD_0UrfXYAiOeD_0wskUsQ4A7vxL4BlUZBc9yXB38vGK0FXbs0ePW4drfT2lMCdvOCWRQr369TgpR0hrp4mtlHKy3tugYwnmY0yLPY7Lg71yxRKwlzIxyXzN0FT6-0iLfHLMH-IjP0Fkyq7MDgnqaURRBcyqyDDkcawDcVTz6nfzDAPDgxFy-jeTJswbFi6">

<h3 id="使用jdk提供类实现观察者"><a href="#使用jdk提供类实现观察者" class="headerlink" title="使用jdk提供类实现观察者"></a>使用jdk提供类实现观察者</h3><p>假设一个场景，学生向老师提问问题，那么老师就是观察者，需要观察学生是否有问题并及时做出回应，学生就是被观察者<br>创建学生类，被观察者，继承jdk的<code>Observable</code>类  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produceQuestion</span><span class="params">(String question)</span></span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot; 同生提出了一个问题：&quot;</span>+question);</span><br><span class="line">        setChanged();</span><br><span class="line">        notifyObservers(question);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察者老师，继承jdk的<code>Observer</code>类  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Teacher</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span> </span>&#123;</span><br><span class="line">        Student student = (Student) o;</span><br><span class="line">        String question = (String) arg;</span><br><span class="line">        System.out.println(name+<span class="string">&quot; 老师收到了一个 &quot;</span>+student.getName()+<span class="string">&quot;同学提出的问题：&quot;</span>+question);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体调用测试：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student(<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">        Teacher teacher = <span class="keyword">new</span> Teacher(<span class="string">&quot;王老师&quot;</span>);</span><br><span class="line">        Teacher teacher1 = <span class="keyword">new</span> Teacher(<span class="string">&quot;刘老师&quot;</span>);</span><br><span class="line">        student.addObserver(teacher);</span><br><span class="line">        student.addObserver(teacher1);</span><br><span class="line">        student.produceQuestion(<span class="string">&quot;天为什么是蓝的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">小明 同生提出了一个问题：天为什么是蓝的</span><br><span class="line">刘老师 老师收到了一个 小明同学提出的问题：天为什么是蓝的</span><br><span class="line">王老师 老师收到了一个 小明同学提出的问题：天为什么是蓝的</span><br></pre></td></tr></table></figure>
<h3 id="UML类图-1"><a href="#UML类图-1" class="headerlink" title="UML类图"></a>UML类图</h3><img src="http://www.plantuml.com/plantuml/svg/XL5BRi8m4Dtx5BCCgC01u0ojgdQ7M4piQMgQEAuzZf0Y3iMQ0t4Dd3HEtKfLbtw_UJEMDNeFJwKdrs5PKoys6pYgZzlbAiv2QCFatb3I927tIo17_mi7HOQ1Jan6vNdG2-jqXqnHvBIfm613Ms53MMkPZ4N6BQ0_VzCZN14_HgR8gQxL2gnhLP3q7CYpRasA-PpUYoYVExuIodToe1jRKnE7-dcdVqfEphzAZas2LT5UP8kt3p7_I981NHNryAEBvs7eLu1dv9JJe4vhx0-3qu-ZedCkkrkjbjc5CsAzpd6HbHceOQX8LvY1z7K9k0C0">























]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>解释器模式</title>
    <url>/2021/10/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>给定一个语言，定义它的文法大的一种表示，并定义一个解释器，这个解释器使用该表示类解释语言中的句子。<br>为了解释一种语言，而为语言创建的解释器。<br>类型：行为型</p>
</blockquote>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li>某个特定类型问题发生频率足够高</li>
</ul>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>扩展性好。由于在解释器模式中适用类来表示语言的文法规则，因此可以通过继承等机制类改变或者扩展文法。</li>
<li>容易实现。在语法树中的每个表达式节点都是类似的，所以实现其文法较为容易。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>执行效率较低。解释器模式中通常适用大量的循环和递归调用，担当要解释大的句子较复杂时，其运行速度很慢，且代码的调试过程也比较麻烦。</li>
<li>会引起类膨胀。解释器模式中的每条规则至少定义一个类，担当包含的文法规则很多时，类的个数将急剧增加，导致系统难以管理和维护。</li>
<li>可应用大的场景比较少。在软件开发中，需要定义语言文法大的应用实力非常少，所以这种模式很少被适用到。 </li>
</ul>
<h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><ul>
<li><strong>抽象表达式角色</strong>：定义解释器的接口，约定解释器的解释操作，主要包含解释方法<code>interpret()</code>。</li>
<li><strong>终结符表达式角色</strong>：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。</li>
<li><strong>非终结符表示式角色</strong>：也是抽象表达式的子类，用来表现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符 表达式。</li>
<li><strong>环境角色</strong>：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。</li>
<li><strong>客户端</strong>：主要任务是将需要分析的句子表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>比如我们创建一个对<code>6 100 11 + *</code>这个式子的解释器，解释规则是如果是数字就入栈，如果是符号就将入栈的后两个数字（先进后出）进行计算<br>抽象表达式类  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interpreter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">interpret</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非终结符号表达式类<br>加法解释器类  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddInterpreter</span> <span class="keyword">implements</span> <span class="title">Interpreter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Interpreter firstExpression, secondExpression;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AddInterpreter</span><span class="params">(Interpreter firstExpression, Interpreter secondExpression)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.firstExpression = firstExpression;</span><br><span class="line">        <span class="keyword">this</span>.secondExpression = secondExpression;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interpret</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.firstExpression.interpret() + <span class="keyword">this</span>.secondExpression.interpret();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;+&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非终结符号表达式类<br>乘法解释器类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiInterpreter</span> <span class="keyword">implements</span> <span class="title">Interpreter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Interpreter firstExpression, secondExpression;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MultiInterpreter</span><span class="params">(Interpreter firstExpression, Interpreter secondExpression)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.firstExpression = firstExpression;</span><br><span class="line">        <span class="keyword">this</span>.secondExpression = secondExpression;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interpret</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.firstExpression.interpret() * <span class="keyword">this</span>.secondExpression.interpret();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;*&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>终结符号表达式类  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberInterpreter</span> <span class="keyword">implements</span> <span class="title">Interpreter</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumberInterpreter</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumberInterpreter</span><span class="params">(String number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = Integer.parseInt(number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interpret</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>环境类  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExpressionParser</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Interpreter&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">parse</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        String[] strItemArray = str.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String symbol : strItemArray) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isOperator(symbol)) &#123;</span><br><span class="line">                Interpreter numberInterpreter = <span class="keyword">new</span> NumberInterpreter(symbol);</span><br><span class="line">                stack.push(numberInterpreter);</span><br><span class="line">                System.out.printf(<span class="string">&quot;入栈：%d%n&quot;</span>, numberInterpreter.interpret());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Interpreter firstExpression = stack.pop();</span><br><span class="line">                Interpreter secondExpression = stack.pop();</span><br><span class="line">                System.out.printf(<span class="string">&quot;出栈：%d 和 %d%n&quot;</span>, firstExpression.interpret(), secondExpression.interpret());</span><br><span class="line">                Interpreter expressionObject = getExpressionObject(firstExpression, secondExpression, symbol);</span><br><span class="line">                System.out.printf(<span class="string">&quot;应用运算符：%s%n&quot;</span>, expressionObject.toString());</span><br><span class="line">                <span class="keyword">int</span> result = expressionObject.interpret();</span><br><span class="line">                NumberInterpreter resultExpression = <span class="keyword">new</span> NumberInterpreter(result);</span><br><span class="line">                stack.push(resultExpression);</span><br><span class="line">                System.out.println(String.format(<span class="string">&quot;阶段结果入栈： %d&quot;</span>,resultExpression.interpret()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = stack.pop().interpret();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOperator</span><span class="params">(String symbol)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (symbol.equals(<span class="string">&quot;+&quot;</span>) || symbol.equals(<span class="string">&quot;*&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Interpreter <span class="title">getExpressionObject</span><span class="params">(Interpreter firstExpression, Interpreter secondExpression, String symbol)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (symbol.equals(<span class="string">&quot;+&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AddInterpreter(firstExpression, secondExpression);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (symbol.equals(<span class="string">&quot;*&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MultiInterpreter(firstExpression, secondExpression);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>客户端  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String inputStr = <span class="string">&quot;6 100 11 + *&quot;</span>;</span><br><span class="line">        ExpressionParser expressionParser = <span class="keyword">new</span> ExpressionParser();</span><br><span class="line">        <span class="keyword">int</span> result = expressionParser.parse(inputStr);</span><br><span class="line">        System.out.println(<span class="string">&quot;解释器计算结果：&quot;</span> + result);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">入栈：6</span><br><span class="line">入栈：100</span><br><span class="line">入栈：11</span><br><span class="line">出栈：11 和 100</span><br><span class="line">应用运算符：+</span><br><span class="line">阶段结果入栈： 111</span><br><span class="line">出栈：111 和 6</span><br><span class="line">应用运算符：*</span><br><span class="line">阶段结果入栈： 666</span><br><span class="line">解释器计算结果：666</span><br></pre></td></tr></table></figure>

<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><img src="http://www.plantuml.com/plantuml/svg/lLEnJiCm4Dtz5JUcYEO76YenC30K8PKDCRY9Mvr87CjtAKXL_vqOcjgnep0WiJZEtRlt_CvdrApiNfOA7jtEMDMlS1Ae6N28P8kLE0jHrf88xgigX69ZQjKepHGn68j7oMFUFLhYXy_-ZmXRVGkaobPNFh8IfjlLM4OgsIn9c8m95t0w3voH9vUvkjfqDUC_-8fr_kGCvgnvRqzTirFsTtFUcwFJtrNNWoSacGU5JKvnMxQe3nFGkVlmFf-bfL7ZjopBzo9GM0Ev4Do1LX-NzDhDRA1Z7Cjm568xLdjHn4xX1z-pSVyvjbX18r5VobxVGDe33PLXFulbyYQvsXGn7kg88i_pnBL8nhAOGaLFSXAJ3i4aJ2IDTp3Ndoy0">]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2021/07/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><strong>设计模式：</strong> 是一套被反复使用、多人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦一块块砖石一样。项目中合理的运用设计模式可以完美的解决很多问题，每种模式在现在中都有相应的原理来与之对应，每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是他能被广泛应用的原因。  </p>
<h2 id="设计模式的目的"><a href="#设计模式的目的" class="headerlink" title="设计模式的目的"></a>设计模式的目的</h2><p>编写软件过程中，程序员面临着来自耦合性、内聚性以及可维护性、可扩展性、重用性、灵活性等多方面额挑战，设计模式是为了让<strong>程序（软件）</strong>，具有更好的：<br>1）代码重用性（相同的代码不用多次编写）<br>2）可读性（编程规范性，便有其他程序员的阅读和理解）<br>3）可扩展性（当需要增加新的功能时，非常方便）<br>4）可靠性（当我们增加新的功能后，对原本的功能没有影响）<br>5）使程序呈现高内聚，低耦合懂得特性  </p>
<h2 id="设计模式七大原则"><a href="#设计模式七大原则" class="headerlink" title="设计模式七大原则"></a>设计模式七大原则</h2><p>设计模式的原则其实就是程序员在编程时，应该准守的原则，也是各种设计模式的基础（即：设计模式为什么这样设计的依据）<br><strong>1）单一职责原则</strong>      </p>
<blockquote>
<p>1）降低类的复杂度，一个类只负责一项职责<br>2）提高类的可读性，可维护性<br>3）降低变更引起的风险<br>4）通常情况下，我们应该准守单一职责原则，只有在逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法层面保持单一职责原则  </p>
</blockquote>
<p><strong>2）接口隔离原则</strong>    </p>
<blockquote>
<p>客户端不应该依赖他不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上</p>
</blockquote>
<p><strong>3）依赖倒转（倒置）原则</strong>    </p>
<blockquote>
<p>1）高层模块不应该依赖底层模块，二者都应该依赖其抽象<br>2）抽象不应该依赖细节，细节应该依赖抽象<br>3）依赖倒转（倒置）的中心思想是面向接口编程<br>4）依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础搭建懂得架构要稳定的多。在java中，抽象指的是接口或者抽象类，细节就是具体的实现类<br>5）使用接口或抽象类的目的是制定好规范，而不涉及任何具体操作，把展示细节的任务交给他们的实现类去完成。  </p>
</blockquote>
<p><strong>4）里氏替换原则</strong>    </p>
<blockquote>
<p>1）如果每个类型T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。换句话说，所有引用基类的地方必须能透明的使用其子类对象。<br>2）在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法。<br>3）里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过聚合，组合，依赖来解决问题。  </p>
</blockquote>
<p><strong>5）开闭原则</strong>    </p>
<blockquote>
<p>1）开闭原则是编程中最基础、最重要的设计原则。<br>2）一个软件实体，如类、模块和函数应该对扩展开放（对提供方），对修改关闭（对使用方）。用抽象构建框架，用实现扩展细节。<br>3）当软件需要变化时，尽量通过快照软件实体的行为类实现变化，而不是通过修改已有的代码来实现变化。<br>4）编程中遵循其他原则，以及使用设计模式的目的就是遵循开闭原则。  </p>
</blockquote>
<p><strong>6）迪米特原则</strong>    </p>
<blockquote>
<p>1）一个对象应该对其他对象保持最少的了解。<br>2）类与类关系越密切，耦合度越大。<br>3）迪米特法则，又叫最少知道原则，即一个类对自己依赖的类知道的越少越好，也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的public方法不对外泄露任何信息。<br>4）迪米特法则还有个更简单的定义：只与直接朋友通信。<br>5）直接朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式有很多，依赖、关联、组合、聚合等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。  </p>
</blockquote>
<p><strong>7）合成复用原则</strong>    </p>
<blockquote>
<p>尽量使用合成、聚合的方式，而不是使用继承。</p>
</blockquote>
<h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><blockquote>
<p>对象实例化的模式，创建型模式用于解耦对象的实例化过程。<br>这些设计模式提供一种在创建对象的同时隐藏创建逻辑的方式，而不是使用new运算符直接实例化对象，这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。  </p>
</blockquote>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><ul>
<li>某个类只能有一个实例，提供一个全局的访问点。<br><a href="https://ysymj.gitee.io/2021/07/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">点击阅读&gt;&gt;</a></li>
</ul>
<h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><ul>
<li>一个工厂类根据传入的参量决定创建出那一种产品类的实例。<br><a href="https://ysymj.gitee.io/2021/07/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/">点击阅读&gt;&gt;</a></li>
</ul>
<h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><ul>
<li>定义一个创建对象的接口，让子类决定实例化那个类。<br><a href="https://ysymj.gitee.io/2021/08/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/">点击阅读&gt;&gt;</a></li>
</ul>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><ul>
<li>创建相关或依赖对象的家族，而无需明确指定具体类。<br><a href="https://ysymj.gitee.io/2021/08/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/">点击阅读&gt;&gt;</a></li>
</ul>
<h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><ul>
<li>封装一个复杂对象的构建过程，并可以按步骤构造。<br><a href="https://ysymj.gitee.io/2021/08/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/">点击阅读&gt;&gt;</a></li>
</ul>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><ul>
<li>通过复制现有的实例来创建新的实例。<br><a href="https://ysymj.gitee.io/2021/09/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/">点击阅读&gt;&gt;</a></li>
</ul>
<h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><blockquote>
<p>把类或对象结合在一起形成一个更大的结构。<br>这些设计模式关注类和对象等的结合，继承的概念被用来组合接口和定义组合对象获得新功能的方式。  </p>
</blockquote>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><ul>
<li>将一个类的方法接口转换成客户希望的另外一个接口。<br><a href="https://ysymj.gitee.io/2021/09/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/">点击阅读&gt;&gt;</a></li>
</ul>
<h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><ul>
<li>将抽象部分和它的实现部分分离，使它们都可以独立的变化。<br><a href="https://ysymj.gitee.io/2021/09/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/">点击阅读&gt;&gt;</a></li>
</ul>
<h3 id="过滤器模式"><a href="#过滤器模式" class="headerlink" title="过滤器模式"></a>过滤器模式</h3><ul>
<li>这种设计模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来。  </li>
</ul>
<h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><ul>
<li>将对象组合成树形结构以表示“部分-整体”的层次结构。<br><a href="https://ysymj.gitee.io/2021/09/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/">点击阅读&gt;&gt;</a></li>
</ul>
<h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><ul>
<li>动态的给对象添加新的功能。<br><a href="https://ysymj.gitee.io/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/">点击阅读&gt;&gt;</a></li>
</ul>
<h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><ul>
<li>对外提供一个统一的方法，来访问子系统中的一群接口。<br><a href="https://ysymj.gitee.io/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/">点击阅读&gt;&gt;</a></li>
</ul>
<h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><ul>
<li>通过共享技术来有效的支持大量细粒度的对象。<br><a href="https://ysymj.gitee.io/2021/09/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/">点击阅读&gt;&gt;</a></li>
</ul>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><ul>
<li>为其他对象提供一个代理以便控制整个对象的访问。<br><a href="https://ysymj.gitee.io/2021/09/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/">点击阅读&gt;&gt;</a></li>
</ul>
<h2 id="行为模式"><a href="#行为模式" class="headerlink" title="行为模式"></a>行为模式</h2><blockquote>
<p>类和对象如何交互，及划分责任和算法。<br>这些设计模式特别关注对象之间的通信。  </p>
</blockquote>
<h3 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h3><ul>
<li>在不改变数据结构的前提下，增加作用于一组对象元素的新功能。<br><a href="https://ysymj.gitee.io/2021/10/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/">点击阅读&gt;&gt;</a></li>
</ul>
<h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><ul>
<li>定义一个算法结构，而将一些步骤延迟到子类实现。<br><a href="https://ysymj.gitee.io/2021/10/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/">点击阅读&gt;&gt;</a></li>
</ul>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><ul>
<li>定义一系列算法，把他们封装起来，并且使他们可以互相替换。<br><a href="https://ysymj.gitee.io/2021/10/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/">点击阅读&gt;&gt;</a></li>
</ul>
<h3 id="空对象模式"><a href="#空对象模式" class="headerlink" title="空对象模式"></a>空对象模式</h3><ul>
<li>一个空对象取代NULL对象实例的检查。  </li>
</ul>
<h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><ul>
<li>允许一个对象在其对象内部状态改变时改变它的行为。<br><a href="https://ysymj.gitee.io/2021/10/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/">点击阅读&gt;&gt;</a></li>
</ul>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><ul>
<li>对象间的一对多的依赖关系。<br><a href="https://ysymj.gitee.io/2021/10/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/">点击阅读&gt;&gt;</a></li>
</ul>
<h3 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h3><ul>
<li>在不破坏封装的前提下，保持对象的内部状态。<br><a href="https://ysymj.gitee.io/2021/10/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/">点击阅读&gt;&gt;</a></li>
</ul>
<h3 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h3><ul>
<li>用一个中介对象来封装一系列的对象交互。<br><a href="https://ysymj.gitee.io/2021/10/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/">点击阅读&gt;&gt;</a></li>
</ul>
<h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><ul>
<li>一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。<br><a href="https://ysymj.gitee.io/2021/10/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/">点击阅读&gt;&gt;</a></li>
</ul>
<h3 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h3><ul>
<li>给定一个语言，定义它的文法的一种表示，并定义一个解释器。<br><a href="https://ysymj.gitee.io/2021/10/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/">点击阅读&gt;&gt;</a></li>
</ul>
<h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><ul>
<li>将命令请求封装为一个对象，使得可以用不同的请求来进行参数化。<br><a href="https://ysymj.gitee.io/2021/10/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/">点击阅读&gt;&gt;</a></li>
</ul>
<h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><ul>
<li>将请求的发送者和接收者解耦，使的多个对象都有处理这个请求的机会。<br><a href="https://ysymj.gitee.io/2021/10/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/">点击阅读&gt;&gt;</a></li>
</ul>
<h2 id="J2EE模式"><a href="#J2EE模式" class="headerlink" title="J2EE模式"></a>J2EE模式</h2><blockquote>
<p>这些设计模式特别关注表示层，这些模式是由Sun Java Center鉴定的。</p>
</blockquote>
<h3 id="MVC模式"><a href="#MVC模式" class="headerlink" title="MVC模式"></a>MVC模式</h3><ul>
<li>MVC模式代表Model-View-Controller(模型-视图-控制器)模式。这种模式用于应用程序的分层开发。  </li>
</ul>
<h3 id="业务代表模式"><a href="#业务代表模式" class="headerlink" title="业务代表模式"></a>业务代表模式</h3><ul>
<li>用于对表示层和业务层解耦。  </li>
</ul>
<h3 id="组合实体模式"><a href="#组合实体模式" class="headerlink" title="组合实体模式"></a>组合实体模式</h3><ul>
<li>用在EJB持久化机制中，一个组合实体是一个EJB实体bean，代表了对象的图解。  </li>
</ul>
<h3 id="数据访问对象模式"><a href="#数据访问对象模式" class="headerlink" title="数据访问对象模式"></a>数据访问对象模式</h3><ul>
<li>用于把低级的数据访问API或操作从高级的业务服务中分离出来。  </li>
</ul>
<h3 id="前端控制器模式"><a href="#前端控制器模式" class="headerlink" title="前端控制器模式"></a>前端控制器模式</h3><ul>
<li>用来提供一个集中的请求处理机制，所有的请求都将由一个单一的处理程序处理。  </li>
</ul>
<h3 id="拦截过滤器模式"><a href="#拦截过滤器模式" class="headerlink" title="拦截过滤器模式"></a>拦截过滤器模式</h3><ul>
<li>用于对应用程序的请求或响应做一些预处理/后处理。  </li>
</ul>
<h3 id="服务定位器模式"><a href="#服务定位器模式" class="headerlink" title="服务定位器模式"></a>服务定位器模式</h3><ul>
<li>用在我们想使用JNDI查询定位各种服务的时候。  </li>
</ul>
<h3 id="传输对象模式"><a href="#传输对象模式" class="headerlink" title="传输对象模式"></a>传输对象模式</h3><ul>
<li>用于从客户端向服务器一次性传递带有多个属性的数据。  </li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>访问者模式</title>
    <url>/2021/10/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>封装作用于某数据结构（如List/Set/Map等）中的各元素的操作；<br>可以在不改变各元素的类的前提下，定义作用于这些元素的操作；<br>行为型</p>
</blockquote>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li>一个数据结构（如List/Set/Map等）包含很多类型对象</li>
<li>数据结构与数据操作分离</li>
</ul>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>增加新的操作很容易，即增加一个新的访问者</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>增加新的数据结构困难</li>
<li>具体元素变更比较麻烦</li>
</ul>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><ul>
<li><strong>抽象访问者角色</strong>：定义一个访问具体元素的接口，为每个具体元素类对应一个访问操作visit()，该操作中的参数类型标识了被访问的具体元素；</li>
<li><strong>具体访问者角色</strong>：实现抽象访问者角色中声明的各个访问操作，确定访问者访问一个元素时该做什么；</li>
<li><strong>抽象元素角色</strong>：声明一个包含接受操作accept()的接口，被接受的访问者对象作为accept()方法的参数；</li>
<li><strong>具体元素角色</strong>：实现抽象元素角色提供的accept()操作，其方法通常都是visitor.visit(this)，另外具体元素中可能还包含本身业务逻辑的相关操作。</li>
<li><strong>对象结构角色</strong>：是一个包含元素角色的容器，提供让访问者对象遍历容器中的多有元素的方法，通常由List/Set/Map等聚合类实现。</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>假设一个场景，双十一购物，有几个小伙伴买了商品，有的想给差评，有的想给好评<br>抽象访问者角色<br>想要做出的评论的抽象，比如好评、差评  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementA element)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementB element)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体访问者角色<br>具体的评论，比如好评差评  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteVisitorA</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementA element)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体访问者A访问--&gt;&quot;</span> + element.operationA());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementB element)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体访问者A访问--&gt;&quot;</span> + element.operationB());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体访问者  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteVisitorB</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementA element)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体访问者B访问--&gt;&quot;</span> + element.operationA());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementB element)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体访问者B访问--&gt;&quot;</span> + element.operationB());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抽象元素角色<br>用户的抽象，里面有一个评论的方法  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体元素<br>用户实现具体的评论，并记录有用户的名称</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteElementA</span> <span class="keyword">implements</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">operationA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;具体元素A的操作。&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteElementB</span> <span class="keyword">implements</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">operationB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;具体元素B的操作。&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对象结构角色<br>记录有所有的购买用户，只有这些用户可以进行评价  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectStructure</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Element&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        Iterator&lt;Element&gt; i = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">            ((Element) i.next()).accept(visitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Element element)</span> </span>&#123;</span><br><span class="line">        list.add(element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Element element)</span> </span>&#123;</span><br><span class="line">        list.remove(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ObjectStructure os = <span class="keyword">new</span> ObjectStructure();</span><br><span class="line">        os.add(<span class="keyword">new</span> ConcreteElementA());</span><br><span class="line">        os.add(<span class="keyword">new</span> ConcreteElementB());</span><br><span class="line">        Visitor visitor = <span class="keyword">new</span> ConcreteVisitorA();</span><br><span class="line">        os.accept(visitor);</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------&quot;</span>);</span><br><span class="line">        visitor = <span class="keyword">new</span> ConcreteVisitorB();</span><br><span class="line">        os.accept(visitor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">具体访问者A访问--&gt;具体元素A的操作。</span><br><span class="line">具体访问者A访问--&gt;具体元素B的操作。</span><br><span class="line">------------------------</span><br><span class="line">具体访问者B访问--&gt;具体元素A的操作。</span><br><span class="line">具体访问者B访问--&gt;具体元素B的操作。</span><br></pre></td></tr></table></figure>

<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><img src="http://www.plantuml.com/plantuml/svg/nPBDJeGm4CVlFCKSws5v0P44Z3SJ3nelnaEtZ9inq99sg36RVNVPXRALW1y7umdQ_Zh_3o3DQ5-aGdWaHsmix1Dlg09_N8fhevL5nfiQ6zHS00ul5vTVK6L47P94rT8v2CmeKm0rxK2vIBhjjZKf-8a3s1--nyjF-9gPyf_Cq5J-I8JofLBOiWXM_F1SgdDo4YKu3uijhSoCdD-p9Rq3qwALJ4ONOhcrASuVQ9OppRljAohkgKvnP_4utvANZ71BZhDHDeUwNy4LQ7o3mbhvVZhDHL_Px_mCM5M946Zj2rjiZCT5R3B_W2vgn76VSBpTID9YoFxq3DBkNBWPl6Lf7afDvYMOpUPyU1B9qXaJjjFmFty0">







]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>责任链模式</title>
    <url>/2021/10/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>为请求创建一个接收此次请求对象的链；<br>行为型</p>
</blockquote>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li>一个请求的处理需要多个对象当中的一个或几个协同处理；</li>
</ul>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>请求的发送者和接收者（请求的处理）解耦</li>
<li>责任链可以动态组合</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>责任链太长或者处理时间过长，影响性能；</li>
<li>责任链有可能过多。</li>
</ul>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><ul>
<li><strong>抽象处理者角色</strong>：定义一个处理请求的接口，包含抽象处理方法和一个后续连接。</li>
<li><strong>具体处理者角色</strong>：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。</li>
<li><strong>客户类角色</strong>：创建处理链，并向链头的具体处理对象提交请求，它不关心处理细节和请求的传递过程。</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>假设我们有一个文档，需要审核标题和内容，先审核标题，后审核内容，标题不合格直接结束<br>文档实体：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Word</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTitle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抽象处理者角色：<br>里面保存了下一级审核的对象指向，以及审核的具体逻辑实现方法  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Handler handler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(Handler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">examine</span><span class="params">(Word word)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体处理者角色：<br>标题审核，如果通过进行下一步审核，如果不通过，直接结束  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TitleHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">examine</span><span class="params">(Word word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (word.getTitle() != <span class="keyword">null</span> &amp;&amp; !<span class="string">&quot;&quot;</span>.equals(word.getTitle()))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;标题合格，通用审核&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="keyword">null</span>)&#123;</span><br><span class="line">                handler.examine(word);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;标题不合格，不通过审核&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体处理者角色：<br>内容审核，如果通过进行下一步，如果不通过，结束  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContentHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">examine</span><span class="params">(Word word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (word.getContent() != <span class="keyword">null</span> &amp;&amp; !<span class="string">&quot;&quot;</span>.equals(word.getContent()))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;内容合格，通用审核&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="keyword">null</span>)&#123;</span><br><span class="line">                handler.examine(word);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;内容不合格，不通过审核&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户角色类：<br>组装具体的责任链，设置审核先后层级  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TitleHandler titleHandler = <span class="keyword">new</span> TitleHandler();</span><br><span class="line">        ContentHandler contentHandler = <span class="keyword">new</span> ContentHandler();</span><br><span class="line">        titleHandler.setNext(contentHandler);</span><br><span class="line"></span><br><span class="line">        Word word = <span class="keyword">new</span> Word();</span><br><span class="line">        word.setTitle(<span class="string">&quot;责任链模式&quot;</span>);</span><br><span class="line"><span class="comment">//        word.setContent(&quot;责任链模式内容&quot;);</span></span><br><span class="line"></span><br><span class="line">        titleHandler.examine(word);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">标题合格，通用审核</span><br><span class="line">内容不合格，不通过审核</span><br></pre></td></tr></table></figure>
<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><img src="http://www.plantuml.com/plantuml/svg/fP2n3e8m48RtFiMDiF02kBaukKZYO1oEze9Di9ZsH1B2kqlRK974oQLD_zvzz_ydMtGEpfrLC8g7rJqomOcjDWsmvfRAhIexmsIu59CGM3ksA1bam1pGg9Pi87LCaaabxHRl6VUiMosXxxG2HtoaWRDDKGxZz667IXhmhWrbmUbhFl9W8CwjlD65CVF8g6Hc53_w_On4sCTGVp4gSkoZntoEaPUOTzGcY-kxN05juvREWDeLnJ8f2SN6qkfZdLQ8ZNFFyaR4rqwIkgBCppS0">


]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代器模式</title>
    <url>/2021/10/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>提供一种方法，顺序访问一个集合对象中的各个元素，而又不暴露该的对象的内部表示。<br>行为型</p>
</blockquote>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li>访问一个集合对象的内容而无需暴露它的内部表示</li>
<li>为遍历不同的集合结构提供一个统一的接口</li>
</ul>
<p>##优点和缺点</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>分离了集合对象的遍历行为</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>类的个数成对增加</li>
</ul>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><ul>
<li>*<em>抽象聚合角色</em> ：定义存储、添加、删除、集合对象以及创建迭代器对象的接口</li>
<li><strong>具体聚合角色</strong> ：实现抽象集合，返回一个具体迭代器的实例</li>
<li><strong>抽象迭代器角色</strong> ：定义访问和遍历聚合元素的接口，通常包括hasNext()，first()，next()等方法</li>
<li><strong>具体迭代器角色</strong> ：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>创建抽象聚合接口，定义方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Aggregate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object obj)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Object obj)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">getIterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现抽象聚合接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteAggregate</span> <span class="keyword">implements</span> <span class="title">Aggregate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        list.add(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        list.remove(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">getIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">new</span> ConcreteIterator(list));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建迭代器接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">first</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Object <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建迭代器接口具体实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; list = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteIterator</span><span class="params">(List&lt;Object&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; list.size() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">first</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        Object obj = list.get(index);</span><br><span class="line">        ;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object obj = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.hasNext()) &#123;</span><br><span class="line">            obj = list.get(++index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用迭代器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Aggregate ag = <span class="keyword">new</span> ConcreteAggregate();</span><br><span class="line">        ag.add(<span class="string">&quot;中山大学&quot;</span>);</span><br><span class="line">        ag.add(<span class="string">&quot;华南理工&quot;</span>);</span><br><span class="line">        ag.add(<span class="string">&quot;韶关学院&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;聚合的内容有：&quot;</span>);</span><br><span class="line">        Iterator it = ag.getIterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            Object ob = it.next();</span><br><span class="line">            System.out.println(ob.toString() + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">聚合的内容有:</span><br><span class="line">中山大学	</span><br><span class="line">华南理工	</span><br><span class="line">韶关学院	</span><br></pre></td></tr></table></figure>

<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><img src="http://www.plantuml.com/plantuml/svg/XL7BZi8m3BptAtmi1v3sp4D2Urff1T-GfgORb2R8CGLKyU-aK4BQ8FOGoSuuuvc9Ceoq4n9XNLM4bM24DZiS2wqaD5QL8CeotnPxb0oss4_c0v2mjWs-nNyyiM1BK24_wzp3rooJMZW7tzP8GiRNObKVDDPes0tLa6gwwbSvNZnMhK3x1fPWy0Hh8d69mNoaScG1ski_9gA9zpQw0Mz4XVJ2M9lrF3j5ZZibVM_mV6yBQpKA0t_2RVgh99B05YKIRVWOo57hUPZm0lqfyUoHwLT8PRmdJvZY21B54JOqcm8cFF0cqn-VhH8jDm00">

































]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>适配器模式</title>
    <url>/2021/09/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口兼容而不能一起工作的那些类能一起工作。<br>适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。  </p>
</blockquote>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li>已经存在的类，它的方法和需求不匹配时（方法结果相似或相同）；  </li>
<li>不是软件设计阶段考虑的设计模式，是随着软件维护，由于不同产品、不同厂家造成功能类似而接口不相同情况下的解决方案。  </li>
</ul>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>客户端通过适配器可以透明地调用目标接口；  </li>
<li>复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类；  </li>
<li>将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题；  </li>
<li>符合开闭原则。  </li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>适配器编写过程需要全面考虑，可能会增加系统的复杂性；  </li>
<li>增加系统代码可读的难度。  </li>
</ul>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><ul>
<li><strong>目标接口：</strong> 当前系统业务所期待的接口，它可以是抽象类或者接口；  </li>
<li><strong>适配者类：</strong> 它是被访问和适配的现存组件库中的组件接口；  </li>
<li><strong>适配器类：</strong> 它是一个转换器，通过继承或者引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。   </li>
</ul>
<h2 id="类结构型模式"><a href="#类结构型模式" class="headerlink" title="类结构型模式"></a>类结构型模式</h2><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>我们生活中经常会给手机充电，但是标准电压是交流电220V，但是我们的手机一般是使用直流电5V的，我们可以用代码来演示一下这个过程的实现。  </p>
<p>首先我们创建一个适配者类，也就是我们220V交流电</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AC220</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">outputAC220V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> output = <span class="number">220</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;输出交流电&quot;</span> + output + <span class="string">&quot;V&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们创建目标接口，也就是我们需要的5V直流电  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DC5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">outputDC5V</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建适配器类，也就是实现我们交流200V转换直流5V的类，可以理解为手机充电器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PowerAdapter</span> <span class="keyword">extends</span> <span class="title">AC220</span> <span class="keyword">implements</span> <span class="title">DC5</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">outputDC5V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> adapterInput = <span class="keyword">super</span>.outputAC220V();</span><br><span class="line">        <span class="comment">//业务处理</span></span><br><span class="line">        <span class="keyword">int</span> adapterOutput = adapterInput / <span class="number">44</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用PowerAdapter输入AC: &quot;</span> + adapterInput + <span class="string">&quot;V；输出DC: &quot;</span> + adapterOutput + <span class="string">&quot;V&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> adapterOutput;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DC5 dc5 = <span class="keyword">new</span> PowerAdapter();</span><br><span class="line">        dc5.outputDC5V();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">输出交流电220V</span><br><span class="line">使用PowerAdapter输入AC: 220V; 输出DC: 5V</span><br></pre></td></tr></table></figure>

<h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><img src="http://www.plantuml.com/plantuml/svg/POwn2i8m48RtFCMDTIbISDAbr0SG51TnYCbP3jea95SLIj_Tj6afudJaxlk_FwgH8K1P5SKMUk6wHqCAo33OZbt7q-6QRQ0Vn214FA1_IeLmh7QHNy7uZjX-XDIaFDat-b9B5nE07qQZbnvgNOCj6WwpvgyssURIvBjWu1KDB3cEboKDhIIJdTcJgMztaBuEItAq7_8yPK7yV6dPYoy0">


<h2 id="对象结构型模式"><a href="#对象结构型模式" class="headerlink" title="对象结构型模式"></a>对象结构型模式</h2><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>同样以上述实例做演示，代码实现只有适配器类中有所不同</p>
<p>首先我们创建一个适配者类，也就是我们220V交流电</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AC220</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">outputAC220V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> output = <span class="number">220</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;输出交流电&quot;</span> + output + <span class="string">&quot;V&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们创建目标接口，也就是我们需要的5V直流电</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DC5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">outputDC5V</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建适配器类，也就是实现我们交流200V转换直流5V的类，可以理解为手机充电器<br><code>类结构型模式</code>是通过继承<code>AC220</code>类来调用方法的，<code>对象结构模式则</code>是通过组合来做的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PowerAdapter</span> <span class="keyword">implements</span> <span class="title">DC5</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AC220 ac220 = <span class="keyword">new</span> AC220();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">outputDC5V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> adapterInput = ac220.outputAC220V();</span><br><span class="line">        <span class="comment">//业务处理</span></span><br><span class="line">        <span class="keyword">int</span> adapterOutput = adapterInput / <span class="number">44</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用PowerAdapter输入AC: &quot;</span> + adapterInput + <span class="string">&quot;V；输出DC: &quot;</span> + adapterOutput + <span class="string">&quot;V&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> adapterOutput;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DC5 dc5 = <span class="keyword">new</span> PowerAdapter();</span><br><span class="line">        dc5.outputDC5V();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">输出交流电220V</span><br><span class="line">使用PowerAdapter输入AC: 220V; 输出DC: 5V</span><br></pre></td></tr></table></figure>

<h3 id="UML类图-1"><a href="#UML类图-1" class="headerlink" title="UML类图"></a>UML类图</h3><img src="http://www.plantuml.com/plantuml/svg/POwz2eCm4CVtFCMDRK4fGgVQGUm355gwb0xNc4f0OqXE7SHtRs8KaIuvSlV_-F4AhOKiJv8Z34otdqfoa8gWQKctD1sUkpqC8niPSmTXliW5NFEJqwz2ztUoinVnAVBMzC9a1Mhd05dhIjH2aPsDsiWEISp5oFrx0INwiF59VooXOYO99GzXQSMsXEH6ryW2QfHgToSZLVbw0vhIBivGcKRHOSF8c2TButWAPHlyPVi3">


<h2 id="接口适配器"><a href="#接口适配器" class="headerlink" title="接口适配器"></a>接口适配器</h2><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><p>接口适配器和上面两种略有不同<br>假设我们现在有一个接口，里面有多个方法，但是我们只想使用其中的一个方法，那么就可以使用一个抽象类，来继承这个接口，并实现这个接口的所有方法，不做任何业务逻辑处理，<br>我们具体想要实现逻辑的类，就可以继承这个抽象类，然后去重写自己想要使用的方法即可。</p>
<p>首先有一个接口，里面有多个方法  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interface1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m4</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m5</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们只想用其中的<code>m1</code>方法，如果直接实现接口的话，需要实现所有的方法<br>我们就可以先创建一个抽象类，去实现这个接口，然后空实现所有的方法  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAdapter</span> <span class="keyword">implements</span> <span class="title">Interface1</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们具体的业务类就可以继承这个抽象类，实现自己需要的方法就可以了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">AbstractAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//业务逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h3><img src="http://www.plantuml.com/plantuml/svg/ROwz3i8m30RtF8L76FitCNLavmNSn4YHaX3L1Y5LUVUsQajKaUryWx-pGMXyeYQu7rHDwlEo1dnrkTvsh3Cs6TkCtOf9AHnOHjG2sY4pzFlP6upBUx0-El8KX4zxyJqug-4t2rCwkxhWce9h2wxRt1AtDJs81UWh5Cn_OBabpG00">




]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>图灵课堂MongoDB(一)</title>
    <url>/2022/11/04/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%9B%BE%E7%81%B5%E8%AF%BE%E5%A0%82mongodb/%E5%9B%BE%E7%81%B5%E8%AF%BE%E5%A0%82MongoDB/</url>
    <content><![CDATA[<h1 id="MongoDB介绍"><a href="#MongoDB介绍" class="headerlink" title="MongoDB介绍"></a>MongoDB介绍</h1><h2 id="什么是MongoDb"><a href="#什么是MongoDb" class="headerlink" title="什么是MongoDb"></a>什么是MongoDb</h2><p>MongoDB是一个文档数据库（以json为数据模型），由C++语言编写，旨在为WEB应用提供可扩展的高性能数据存储解决方案。</p>
<p>MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库中功能最丰富，最像关系数据库的。它支持的数据结构非常松散，数据格式是BSON，一种类似JSON的二进制形式的存储格式，简称Binary JSON，和JSON一样支持内嵌的文档对象和数组对象，因此可以存储比较复杂的数据类型。MongoDB最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似于关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。<br><strong>原则上Oracle和MySQL能做的事情，MongoDB都能做（包括ACID事物）</strong></p>
<p>MongoDB概念与关系型数据非常类似：</p>
<table>
<thead>
<tr>
<th align="center">SQL概念</th>
<th align="center">MongoDB概念</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">数据库（database）</td>
<td align="center">数据库（database）</td>
<td align="center">最外层的概念，可以理解为逻辑上的名称空间，一个数据库包含多个不同名称的集合</td>
</tr>
<tr>
<td align="center">表（table）</td>
<td align="center">集合（collection）</td>
<td align="center">相当于SQL中的表，一个集合中可以存放多个不同额文档</td>
</tr>
<tr>
<td align="center">行（row）</td>
<td align="center">文档（document）</td>
<td align="center">一个文档相当于表中的一行，由多个不同的字段组成</td>
</tr>
<tr>
<td align="center">列（column）</td>
<td align="center">字段（field）</td>
<td align="center">文档中的一个属性，等同于列（column）</td>
</tr>
<tr>
<td align="center">索引（index）</td>
<td align="center">索引（index）</td>
<td align="center">独立的检索式数据库结构，与SQL概念一致</td>
</tr>
<tr>
<td align="center">主键（primary key）</td>
<td align="center">_id(字段)</td>
<td align="center">每个文档中都拥有一个唯一的id字段，相当于sql中的主键（primary key）</td>
</tr>
<tr>
<td align="center">视图（view）</td>
<td align="center">视图（view）</td>
<td align="center">可以看做一种虚拟的（非真实存在的）集合，与SQL中的视图类似，从MongoDB3.4半包开始提供了视图功能，其通过聚合管道技术实现</td>
</tr>
<tr>
<td align="center">表连接（table joins）</td>
<td align="center">聚合操作（$lookup）</td>
<td align="center">MongoDB用于实现“类似”表连接（table join）的聚合操作</td>
</tr>
</tbody></table>
<p>尽管这些概念大多与SQL标志定义类似，但MongoDB与传统的RDBMS仍然存在不少差异，包括：</p>
<ul>
<li>半结构化，在一个集合中，文档所拥有的字段并不需要是相同的，而且也不需要对所用的字段进行声明。因此，MongoDB具有很明显的半结构化特点。除了松散的表结构，文档还可以支持多级嵌套、数组等灵活的数据类型，非常契合面向对象编程模型。</li>
<li>弱关系，MongoDB没有外键的约束，也没有非常强大的表连接能力，类似的功能需要使用聚合管道技术来弥补</li>
</ul>
<h2 id="MongoDB技术优势"><a href="#MongoDB技术优势" class="headerlink" title="MongoDB技术优势"></a>MongoDB技术优势</h2><blockquote>
<p>MongoDB基于灵活的JSON文档模型，非常适合敏捷式的快速开发。<br>与此同时，其与生俱来的高可用、高水平扩展能力使得它在处理海量、高并发的数据应用时颇具优势。</p>
</blockquote>
<ul>
<li>Json结构和对象模型接近，开发代码量低。</li>
<li>Json的动态模型意味着更容易响应新的业务需求。</li>
<li>复制集提供99.999%高可用</li>
<li>分片架构支持海量数据和无缝扩容</li>
</ul>
<h2 id="MongoDB应用场景"><a href="#MongoDB应用场景" class="headerlink" title="MongoDB应用场景"></a>MongoDB应用场景</h2><ul>
<li>游戏场景：使用MongoDB存储游戏用户信息、用户的装备、积分等直接以内嵌文档的形式存储，方便查询、更新；</li>
<li>物流场景：使用MongoDB存储订单信息，订单状态在运送过程中会不断更新，以MongoDB内嵌数组的形式来存储，一次查询就能将订单所有的变更读取出来；</li>
<li>社交场景：使用MongoDB存储用户信息，以及用户发表的朋友圈信息，通过地理位置索引实现附近的人、地点等功能；</li>
<li>物联网场景：使用MongoDB存储所有接入的智能设备信息，以及设备汇报的日志信息，并对这些信息进行多维度的分析；</li>
<li>视频直播：使用MongoDB存储用户信息、礼物信息等；</li>
<li>大数据应用：使用云数据库MongoDB作为大数据的云存储系统，随时进行数据提取分析，掌握行业动态。</li>
</ul>
<p><strong>如何考虑是否选择MongoDB？</strong></p>
<ul>
<li>应用不需要复杂的/长事物以及join支持</li>
<li>新应用，需求会变，数据模型无法确定，想要快速迭代开发</li>
<li>应用需要2000-3000以上的读写QPS（更高也可以）</li>
<li>应用需要TB甚至PB级别数据存储</li>
<li>引用发展迅速，需要能快速水平扩展</li>
<li>应用要求存储的数据不丢失</li>
<li>应用需要99.999%高可用</li>
<li>应用需要大量的地理位置查询、文本查询</li>
</ul>
<h2 id="MongoDB的快速开始"><a href="#MongoDB的快速开始" class="headerlink" title="MongoDB的快速开始"></a>MongoDB的快速开始</h2><h3 id="Mongo-Shell的使用方法"><a href="#Mongo-Shell的使用方法" class="headerlink" title="Mongo Shell的使用方法"></a>Mongo Shell的使用方法</h3><p>mongo是MongoDB的交互JavaScript Shell界面，它为系统管理员提供强大的界面，并为开发人员提供了直接测试数据库查询和操作的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mongo --port=27017</span><br></pre></td></tr></table></figure>
<blockquote>
<p>–port：指定端口号，默认27017<br>–host：指定链接的主机地址，默认127.0.0.1<br>-u：指定用户名<br>-p：指定密码</p>
</blockquote>
<h4 id="JavaScript的支持"><a href="#JavaScript的支持" class="headerlink" title="JavaScript的支持"></a>JavaScript的支持</h4><p>mongo shell是基于JavaScript语法的，MongoDB使用了SpoiderMonkey作为JavaScript解释器引擎，这是由Mozilla官方提供的JavaScript内核解释器，该解释器也被同样用于大名鼎鼎的Firefox浏览器产品之中。<br>可以通过以下命令查看JavaScript解释器的版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; interpreterVersion()</span><br><span class="line">MozJS-60</span><br></pre></td></tr></table></figure>

<h4 id="Mongo-Shell常用命令"><a href="#Mongo-Shell常用命令" class="headerlink" title="Mongo Shell常用命令"></a>Mongo Shell常用命令</h4><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">show dbs | show databases</td>
<td align="center">显示数据库列表</td>
</tr>
<tr>
<td align="center">use 数据库名</td>
<td align="center">切换数据库，如果不存在创建数据库</td>
</tr>
<tr>
<td align="center">db.dropDatabase()</td>
<td align="center">删除数据库</td>
</tr>
<tr>
<td align="center">show collections | show tables</td>
<td align="center">显示当前数据库的集合列表</td>
</tr>
<tr>
<td align="center">db.集合.stats()</td>
<td align="center">查看当前集合详情</td>
</tr>
<tr>
<td align="center">db.集合.drop()</td>
<td align="center">删除集合</td>
</tr>
<tr>
<td align="center">show users</td>
<td align="center">显示当前数据库的用户列表</td>
</tr>
<tr>
<td align="center">show roles</td>
<td align="center">显示当前数据库的角色列表</td>
</tr>
<tr>
<td align="center">show profile</td>
<td align="center">显示最近发生的操作非</td>
</tr>
<tr>
<td align="center">load(“xxx.js”)</td>
<td align="center">执行JavaScript脚本文件</td>
</tr>
<tr>
<td align="center">exit | quit()</td>
<td align="center">退出当前Shell</td>
</tr>
<tr>
<td align="center">help</td>
<td align="center">查看mongodb支持哪些命令</td>
</tr>
<tr>
<td align="center">db.help()</td>
<td align="center">查询当前数据库支持的方法</td>
</tr>
<tr>
<td align="center">db.version()</td>
<td align="center">查看数据库版本</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>mongodb</category>
      </categories>
      <tags>
        <tag>图灵课堂MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发成神之路-精通JUC并发工具十八般武艺——AQS(八)</title>
    <url>/2021/12/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94AQS/</url>
    <content><![CDATA[<h1 id="为什么需要AQS"><a href="#为什么需要AQS" class="headerlink" title="为什么需要AQS"></a>为什么需要AQS</h1><ul>
<li><code>ReentrantLock</code>、<code>Semaphore</code>、<code>CountDownLatch</code>、<code>ReentrantReadWriteLock</code></li>
<li>上面那些协作类，它们有很多工作都是类似的，所以如果能提取出一个工具类，那么就可以直接用，对于<code>ReentrantLock</code>和<code>Semaphore</code>而言就可以屏蔽很多细节，只关注它们自己“业务逻辑”就可以了</li>
</ul>
<h1 id="Semaphore和AQS的关系"><a href="#Semaphore和AQS的关系" class="headerlink" title="Semaphore和AQS的关系"></a><code>Semaphore</code>和AQS的关系</h1><ul>
<li><code>Semaphore</code>内部有一个<code>Sync</code>类，<code>Sync</code>类继承了AQS</li>
<li><code>CountDownLatch</code>和<code>ReentrantLock</code>也是一样的，内部有一个<code>Sync</code>类，<code>Sync</code>类继承了AQS</li>
</ul>
<h1 id="AQS的作用"><a href="#AQS的作用" class="headerlink" title="AQS的作用"></a>AQS的作用</h1><ul>
<li>AQS是一个用于构建锁、同步器、协作工具类的工具类（框架）。有了AQS以后，更多的协作工具类都可以很方便得被写出来</li>
<li>一句话总结：有了AQS，构建线程协作类就容易多了</li>
</ul>
<h1 id="AQS内部原理解析"><a href="#AQS内部原理解析" class="headerlink" title="AQS内部原理解析"></a>AQS内部原理解析</h1><ul>
<li>AQS最核心的就是三大部分</li>
</ul>
<h2 id="state状态"><a href="#state状态" class="headerlink" title="state状态"></a>state状态</h2><ul>
<li>这里的<code>state</code>的具体含义，会根据具体实现类的不同而不同，比如啊<code>Semaphore</code>里，它表示“剩余的许可证的数量”，而在<code>CountDownLatch</code>里，它表示“还需要倒数的数量”</li>
<li><code>state</code>是<code>volatile</code>修饰的，会被并发地修改，所以多有修改<code>state</code>的方法都需要保证线程安全，比如<code>getState</code>、<code>setState</code>以及<code>compareAndSetState</code>操作来读取和更新这个状态，这些方法都依赖于<code>j.u.c.atomic</code>包的支持</li>
<li>在<code>ReentrantLock</code>中，<code>state</code>用来表示“锁”的占有情况，包括可重入计数，当<code>state</code>的值为0的时候，表示该<code>Lock</code>不被任何线程占有</li>
</ul>
<h2 id="控制线程抢锁和配合的FIFO队列"><a href="#控制线程抢锁和配合的FIFO队列" class="headerlink" title="控制线程抢锁和配合的FIFO队列"></a>控制线程抢锁和配合的FIFO队列</h2><ul>
<li>这个队列用来存放“等待的线程”，AQS就是“排队管理器”，当多个线程争用同一把锁时，必须有排队机制将那些没能拿到锁的线程串在一起。当锁释放时，锁管理器就会挑选一个合适的线程来占有这个刚刚释放的锁</li>
<li>AQS会维护一个等待的线程队列，把线程都放到这个队列里</li>
</ul>
<h2 id="期望协作工具类去实现的获取-释放等重要方法"><a href="#期望协作工具类去实现的获取-释放等重要方法" class="headerlink" title="期望协作工具类去实现的获取/释放等重要方法"></a>期望协作工具类去实现的获取/释放等重要方法</h2><ul>
<li>这里的获取和释放方法，是利用AQS的协作工具类里最重要的方法，是由协作类自己去实现的，并且含义各不相同</li>
<li>获取方法<ul>
<li>获取操作会依赖<code>state</code>变量，经常会阻塞（比如获取不到锁）</li>
<li>在<code>Semaphore</code>中，获取就是<code>acquire</code>方法，作用是获取一个许可证</li>
<li>而在<code>CountDownLatch</code>里面，获取就是<code>await</code>方法，作用是“等待，直到倒数结束”</li>
</ul>
</li>
<li>释放方法<ul>
<li>释放操作不会阻塞</li>
<li>在<code>Semaphore</code>中，释放方法就是<code>release</code>方法，作用是释放一个许可证</li>
<li><code>CountDownLatch</code>里面，释放就是<code>countDown</code>方法，作用是“倒数一个数”</li>
</ul>
</li>
</ul>
<h1 id="AQS源码分析"><a href="#AQS源码分析" class="headerlink" title="AQS源码分析"></a>AQS源码分析</h1><h2 id="AQS在CountDownLatch中的应用"><a href="#AQS在CountDownLatch中的应用" class="headerlink" title="AQS在CountDownLatch中的应用"></a>AQS在<code>CountDownLatch</code>中的应用</h2><ul>
<li>构造函数<br><code>CountDownLatch</code>的构造函数如下图所示，首先需要传进去一个数字，这个数字表示倒数几次，而构造函数中直接调用了<code>Sync</code>类的构造函数，从第二个图中可以看出，<code>Sync</code>的构造函数是调用了AQS的<code>setState</code>方法，直接给<code>state</code>赋值<br><img src="/2021/12/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94AQS/CountDownLatch%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%BA%90%E7%A0%81%E5%9B%BE%E7%A4%BA.png" alt="CountDownLatch构造函数源码图示"></li>
</ul>
<p><img src="/2021/12/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94AQS/CountDownLatch-Sync%E7%B1%BB%E6%BA%90%E7%A0%81%E5%9B%BE%E7%A4%BA.png" alt="CountDownLatch-Sync类源码图示"></p>
<ul>
<li><code>getCount</code><br>如下图所示，<code>CountDownLatch.getCount()</code>方法直接调用<code>Sync</code>的<code>getCount()</code>方法，而从上面的Sync类源码图可以看出，<code>Sync.getCount()</code>方法直接调用了AQS的<code>getState</code>方法，获取<code>state</code>的值<br><img src="/2021/12/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94AQS/CountDownLatch%E7%9A%84getCount%E6%96%B9%E6%B3%95%E5%9B%BE%E7%A4%BA.png" alt="CountDownLatch的getCount方法图示"></li>
<li><code>countDown</code><br>如下图所示，<code>CountDownLatch</code>的<code>countDown</code>方法直接调用了继承自AQS的<code>releaseShared</code>方法，而<code>releaseShared</code>方法中会判断<code>tryReleaseShared</code>返回值进行判断，如果为true进入判断调用<code>doReleaseShared</code>方法，唤醒被阻塞的线程，<code>tryReleaseShared</code>的具体代码可以看上面的Sync类源码图，可以看出是使用for循环做的一个CAS自旋锁，将<code>state</code>减一，然后去更新，之后判断是否已经等于0了，如果减一后等于0了那么说明这是最后一次计数，就会返回true，然后调用<code>doReleaseShared</code>唤醒线程<br><img src="/2021/12/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94AQS/CountDownLatch%E7%9A%84countDown%E6%96%B9%E6%B3%95%E5%9B%BE%E7%A4%BA.png" alt="CountDownLatch的countDown方法图示"></li>
</ul>
<p><img src="/2021/12/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94AQS/AQS%E7%9A%84releaseShared%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81%E5%9B%BE%E7%A4%BA.png" alt="AQS的releaseShared方法源码图示"></p>
<ul>
<li><code>await</code><br>如下图所示，<code>CountDownLatch</code>的<code>await</code>方法直接调用了继承自AQS的<code>acquireSharedInterruptibly</code>方法，而<code>acquireSharedInterruptibly</code>方法中会判断<code>tryAcquireShared</code>方法的返回值是否小于0，如果小于0则进入判断，将当前线程挂起，如果不小于0，则直接跳过，可以从上面的<code>Sync</code>类源码图中看出，其实现的<code>tryAcquireShared</code>方法是直接判断state值是否等于0，如果等于0，就返回1，否则返回-1，也就是说state等于0，直接跳过<code>acquireSharedInterruptibly</code>中的判断，不等于0，就将线程挂起<br><img src="/2021/12/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94AQS/CountDownLatch%E7%9A%84await%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81%E5%9B%BE%E7%A4%BA.png" alt="CountDownLatch的await方法源码图示"><br><img src="/2021/12/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94AQS/AQS%E7%9A%84acquireSharedInterruptibly%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81%E5%9B%BE%E7%A4%BA.png" alt="AQS的acquireSharedInterruptibly方法源码图示"></li>
</ul>
<h3 id="AQS在CountDownLatch的总结"><a href="#AQS在CountDownLatch的总结" class="headerlink" title="AQS在CountDownLatch的总结"></a>AQS在<code>CountDownLatch</code>的总结</h3><ul>
<li>调用<code>CountDownLatch</code>的<code>await</code>方法时，便会尝试获取“共享锁”，不过一开始是获取不到该锁的，于是线程被阻塞</li>
<li>而“共享锁”可获取到的条件，就是“锁计数器”的值为0</li>
<li>而“锁计数器”的初值为<code>count</code>，每当一个线程调用该<code>CountDownLatch</code>对象的<code>countDown()</code>方法时，才将“锁计数器”-1</li>
<li><code>count</code>个线程调用<code>countDown()</code>之后，“锁计数器”才为0，而前面提到的等待获取共享锁的线程才能继续运行</li>
</ul>
<h2 id="AQS在Semaphore中的应用"><a href="#AQS在Semaphore中的应用" class="headerlink" title="AQS在Semaphore中的应用"></a>AQS在<code>Semaphore</code>中的应用</h2><ul>
<li>在<code>Semaphore</code>中，<code>state</code>表示许可证的剩余数量</li>
<li>看<code>tryAcquire</code>方法，判断<code>nonfairTryAcquireShared</code>大于等于0的话，代表成功</li>
<li>这里会先检查剩余许可证数量够不够这次需要的，用减法来计算，如果直接不够，那就返回负数，表示失败，如果够了，就用自旋加<code>compareAndSetState</code>来改变<code>state</code>的状态，直到改变成功就返回整数，或者是期间如果被其他人修改导致剩余数量不够了，那也返回负数代表获取失败</li>
</ul>
<h2 id="AQS在ReentrantLock中的应用"><a href="#AQS在ReentrantLock中的应用" class="headerlink" title="AQS在ReentrantLock中的应用"></a>AQS在<code>ReentrantLock</code>中的应用</h2><ul>
<li><code>unlock()</code><br>方法具体情况如下图所示，<code>unlock</code>方法直接调用了<code>Sync</code>类继承于AQS的<code>release</code>方法，方法中首先会判断<code>tryRelease</code>方法的返回值，如果是true，就会执行下面的<code>unparkSuccessor</code>方法，唤醒等待的线程，<code>tryRelease</code>方法被<code>ReentrantLock.Sync</code>类重写，首先会将<code>state</code>减1，因为<code>ReentrantLock</code>是可重入锁，解锁一次就是将<code>state</code>减1，然后判断当前线程是不是正在执行的线程，如果是当前线程，判断计算后的<code>state</code>是否等于0，也就是判断这次解锁是不是最后一层锁，如果不是，直接修改<code>state</code>的值，然后返回false，如果是就会调用<code>setExclusiveOwnerThread</code>方法，将当前运行的线程设置为null，并返回true，唤醒其他的线程<br><img src="/2021/12/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94AQS/ReentrantLock%E7%9A%84unlock%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81%E5%9B%BE%E7%A4%BA.png" alt="ReentrantLock的unlock方法源码图示"><br><img src="/2021/12/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94AQS/AQS%E7%9A%84release%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81%E5%9B%BE%E7%A4%BA.png" alt="AQS的release方法源码图示"><br><img src="/2021/12/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94AQS/ReentrantLock-Sync%E7%B1%BB%E7%9A%84tryRelease%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81%E5%9B%BE%E7%A4%BA.png" alt="ReentrantLock-Sync类的tryRelease方法源码图示"></li>
<li><code>lock()</code>（以非公平锁为例）<br>如下图可以看出，<code>ReentrantLock</code>的<code>lock</code>方法中直接调用了内部类<code>Sync</code>的<code>lock</code>方法，而第二个图中也可以看出，<code>Sync.lock()</code>方法是一个<code>abstract</code>方法，由它的两个子类实现(<code>NonfairSync</code>和<code>FairSync</code>,这里仅以<code>NonfairSync</code>为例讲述)<br><img src="/2021/12/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94AQS/ReentrantLock%E7%9A%84lock%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81%E5%9B%BE%E7%A4%BA.png" alt="ReentrantLock的lock方法源码图示"><br><img src="/2021/12/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94AQS/ReentrantLock-Sync%E7%B1%BB%E7%9A%84lock%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81%E5%9B%BE%E7%A4%BA.png" alt="ReentrantLock-Sync类的lock方法源码图示"><br>如下图可以看出，<code>NonfairSync</code>中的<code>lock</code>方法首先会调用CAS方法更新<code>state</code>的值，如果更新成功了，就直接将当前线程设置为执行线程，如果失败了，会去执行<code>acquire</code>方法，<code>acquire</code>方法是AQS的一个方法<br><img src="/2021/12/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94AQS/ReentrantLock-NonfairSync%E7%B1%BB%E6%BA%90%E7%A0%81%E5%9B%BE%E7%A4%BA.png" alt="ReentrantLock-NonfairSync类源码图示"><br>首先方法还会去调用<code>tryAcquire</code>方法，<code>tryAcquire</code>在<code>ReentrantLock</code>中会有公平和非公平两种实现方式，如果<code>tryAcquire</code>方法返回的是true，因为前面的非，则会变成false，直接跳过判断，如果<code>tryAcquire</code>返回的false，加上前面的非，则是true，就会去执行后的语句，<code>addWaiter</code>方法是将当前线程进行封装，<code>acquireQueued</code>方法则是将封装后的Node节点对象，放到等待队列中，等待别的线程释放锁之后将他唤醒<br><img src="/2021/12/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94AQS/AQS%E7%9A%84acquire%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="AQS的acquire方法源码示意图"><br>非公平类中<code>tryAcquire</code>方法会去调用<code>nonfairTryAcquire</code>方法，这个方法是由<code>Sync</code>类实现的，方法中首先会判断<code>state</code>是否等于0，如果等于0表示当前锁没有被任何线程持有，就会直接通过CAS修改<code>state</code>的值，然后将持锁线程设置为当前线程，如果当前锁已经被持有，就会判断是否为当前线程持有，如果是，就会将<code>state</code>加入参，也就是1，然后重新设置值，如果不是表示当前锁已经被其他线程持有，直接返回false<br><img src="/2021/12/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94AQS/ReentrantLock-Sync%E7%B1%BB%E7%9A%84nonfairTryAcquire%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81%E5%9B%BE%E7%A4%BA.png" alt="ReentrantLock-Sync类的nonfairTryAcquire方法源码图示"></li>
</ul>
<h3 id="分析释放锁的方法tryRelease"><a href="#分析释放锁的方法tryRelease" class="headerlink" title="分析释放锁的方法tryRelease"></a>分析释放锁的方法<code>tryRelease</code></h3><ul>
<li>由于当前是可重入锁，所以<code>state</code>代表重入次数，每次释放锁，先判断是不是当前持有锁的线程释放的，如果不是就抛异常，如果是的话，重入次数减一，如果减到了0，就说明完全释放了，于是free就是true了，并且把<code>state</code>设置为0</li>
</ul>
<h3 id="加锁的方法"><a href="#加锁的方法" class="headerlink" title="加锁的方法"></a>加锁的方法</h3><ul>
<li>判断当前<code>state</code>是不是等于0，判断当前线程是不是持有锁的线程，如果都不是就代表当前线程拿不到锁，就会放进线程等待</li>
</ul>
<h1 id="利用AQS实现一个自己的Latch门闩"><a href="#利用AQS实现一个自己的Latch门闩" class="headerlink" title="利用AQS实现一个自己的Latch门闩"></a>利用AQS实现一个自己的Latch门闩</h1><p>如下代码就是用AQS自己实现的门闩功能代码，我们要实现的功能很简单，就是当线程调用<code>await</code>方法的时候，将线程挂起，然后等待执行了<code>signal</code>方法，将所有线程唤醒，因为是可重入的，直接调用AQS的<code>releaseShared</code>方法和<code>acquireShared</code>方法来实现，查看AQS的源码可以看到，<code>acquireShared</code>方法会判断<code>tryAcquireShared(arg) &lt; 0</code>的结果，如果为true就会将线程挂起，所以我们重写AQS的<code>tryAcquireShared</code>方法，判断<code>state</code>的值，如果为1，就返回1，1大于0，直接跳过判断，否则就返回-1，-1小于0，会进入判断，将线程挂起，而<code>state</code>默认值为0，肯定不等于1。<br>而唤醒线程的<code>signal</code>方法直接调用了AQS的<code>releaseShared</code>方法，这个方法会判断<code>tryReleaseShared(arg)</code>方法的返回值，如果是true，就调用判断中的方法唤醒被挂起的线程，否则就不处理，所以我们实现<code>tryReleaseShared</code>方法，如果只是实现唤醒的话，直接返回true就可以，但是我们要实现门闩只能使用一次的功能，门闩被打开后，再执行<code>await</code>方法不会将线程挂起，所以将<code>state</code>的值设置为1，这样<code>state</code>的时候就是等于1，然后就直接返回1，1大于0，就不会进入判断，也就不会将线程挂起</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneShotLatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>&#123;</span><br><span class="line">        sync.releaseShared(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span></span>&#123;</span><br><span class="line">        sync.acquireShared(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            setState(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (getState() == <span class="number">1</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        OneShotLatch oneShotLatch = <span class="keyword">new</span> OneShotLatch();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;尝试获取latch&quot;</span>);</span><br><span class="line">                    oneShotLatch.await();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;开闸放行，继续前进&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        oneShotLatch.signal();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;尝试获取latch&quot;</span>);</span><br><span class="line">                oneShotLatch.await();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;开闸放行，继续前进&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>精通JUC并发工具十八般武艺</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发成神之路-精通JUC并发工具十八般武艺——CAS和不变性(五)</title>
    <url>/2021/12/04/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94CAS%E5%92%8C%E4%B8%8D%E5%8F%98%E6%80%A7/</url>
    <content><![CDATA[<h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><h2 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h2><ul>
<li>应用于并发场合，是一种思想一种算法，主要用于并发编程中，实现不可被打断的数据交换操作，从而避免多线程情况下由于线程顺序执行不能缺点而引起的问题</li>
<li>我认为V的值应该是A，如果是的话那我就把它改成B，如果不是A（说明被别人修改过了），那我就不修改了，避免多人同时修改导致出错</li>
<li>CAS有三个操作数：内存值V，预期值A，要修改的值B，当且仅当预期值A和内存值V相同时，才将内存值修改为B，否则什么都不做，最后返回现在的V值</li>
<li>CPU的特殊指令（CAS会先进行比较，然后更新，由CPU保证原子性）<blockquote>
<p>CAS的等价代码如下所示，compareAndSwap方法发是由synchronized锁来保证原子性，而对于CAS来说，是由CPU保证的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimulatedCAS</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">compareAndSwap</span><span class="params">(<span class="keyword">int</span> expectedValue,<span class="keyword">int</span> newValue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> oldValue = value;</span><br><span class="line">        <span class="keyword">if</span> (oldValue == expectedValue) &#123;</span><br><span class="line">            value = newValue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li>乐观锁</li>
<li>并发容器</li>
<li>原子类</li>
</ul>
<h2 id="分析在Java中是如何利用CAS实现原子操作的"><a href="#分析在Java中是如何利用CAS实现原子操作的" class="headerlink" title="分析在Java中是如何利用CAS实现原子操作的"></a>分析在Java中是如何利用CAS实现原子操作的</h2><ul>
<li><code>AtomicInteger</code>加载<code>Unsafe</code>工具，用来直接操作内存数据</li>
<li>用<code>Unsafe</code>来实现底层操作</li>
<li>用<code>volatile</code>修饰<code>value</code>字段，保证可见性</li>
<li>Unsafe类中的compareAndSwapInt方法<ul>
<li>方法中先想办法拿到变量value在内存中的地址</li>
<li>通过Atomic::cmpxchg实现原子性的比较和替换，其中参数x是即将更新的值，参数e是原内存的值，至此，最终完成CAS的全过程</li>
</ul>
</li>
</ul>
<h3 id="Unsafe类"><a href="#Unsafe类" class="headerlink" title="Unsafe类"></a>Unsafe类</h3><ul>
<li><code>Unsafe</code>是CAS的核心类，Java无法直接访问底层操作系统，而是通过本地(native)方法来访问。不过尽管如此，JVM还是开了一个后门，JDK中有一个<code>Unsafe</code>，它提供了硬件级别的原子操作</li>
<li><code>valueOffset</code>表示的是变量值在内存中的偏移地址，因为<code>Unsafe</code>就是根据内存偏移地址获取数据的原值的，这样我们就能通过<code>Unsafe</code>来实现CAS了</li>
</ul>
<h3 id="CAS缺点"><a href="#CAS缺点" class="headerlink" title="CAS缺点"></a>CAS缺点</h3><ul>
<li>ABA问题(CAS只会判断当前值是否是期待的值，并不会去判断中间是都有过更改，假设当前期待的是5，之前是5，被一个线程改成了7，然后又被一个线程改成5，此时已经被改了两次，无法判断)</li>
<li>自旋时间过长(如果一直拿不到锁，就会一直自旋，可能会占用比较多的CPU)</li>
</ul>
<h1 id="以不变应万变（不可变性）"><a href="#以不变应万变（不可变性）" class="headerlink" title="以不变应万变（不可变性）"></a>以不变应万变（不可变性）</h1><h2 id="什么是不变性"><a href="#什么是不变性" class="headerlink" title="什么是不变性"></a>什么是不变性</h2><ul>
<li>如果对象在被创建后，状态就不能被修改，那么它就是不可变的</li>
<li>具有不变性的对象一定是线程安全的，我们不需要对其采取任何额外的安全措施，也能保证线程安全</li>
</ul>
<h2 id="final的作用"><a href="#final的作用" class="headerlink" title="final的作用"></a>final的作用</h2><ul>
<li>类防止被继承、方法防止被重写、变量防止被修改</li>
<li>天生是线程安全的，而不需要额外的同步开销</li>
</ul>
<h2 id="3中用法：修饰变量、方法、类"><a href="#3中用法：修饰变量、方法、类" class="headerlink" title="3中用法：修饰变量、方法、类"></a>3中用法：修饰变量、方法、类</h2><h3 id="final修饰变量"><a href="#final修饰变量" class="headerlink" title="final修饰变量"></a>final修饰变量</h3><ul>
<li>被final修饰的变量，意味着值不能被修改，如果变量是对象，那么对象的引用不能变，但是对象自身的内容依然可以变化</li>
<li>属性被声明为final后，该变量则只能被赋值一次，且一旦被赋值，final的变量就不能再被改变，无论如何也不会变化</li>
<li>类中的final属性<ul>
<li>第一种是在声明变量的等号右边直接赋值</li>
<li>第二种就是构造函数中赋值</li>
<li>第三种就是在类的初始代码块中赋值（不常用）</li>
<li>如果不采用第一种赋值方法，那么就必须在2和3中挑一个来赋值，而不能不赋值，这是final的语法所规定的</li>
</ul>
</li>
<li>类中的static final属性<ul>
<li>第一种是在声明变量的等号右边直接赋值</li>
<li>第二种是在static初始代码块中赋值，但是不能使用普通代码块赋值</li>
</ul>
</li>
<li>方法中final变量<ul>
<li>和前面两种不同，由于这里的变量是在方法里面的，所以没有构造函数，也不存在初始代码块</li>
<li>不规定赋值时机，只要求在使用前必须赋值，这和方法中的非final变量的要求也是一样的</li>
</ul>
</li>
</ul>
<h4 id="为什么要规定赋值时机"><a href="#为什么要规定赋值时机" class="headerlink" title="为什么要规定赋值时机"></a>为什么要规定赋值时机</h4><ul>
<li>如果初始化不赋值，后续赋值，就是从null变成你的赋值，这就违反了final不变原则了</li>
</ul>
<h3 id="final修饰方法"><a href="#final修饰方法" class="headerlink" title="final修饰方法"></a>final修饰方法</h3><ul>
<li>构造方法不允许final修饰</li>
<li>不可被重写，也就是不能被override，即便子类有同样名字的方法发，那也不是override，这个和static方法是一个道理</li>
<li>引申：静态方法不能被重写（但是可以写重名的方法）</li>
</ul>
<p>###final修饰类</p>
<ul>
<li>不可被继承</li>
<li>例如典型的String类就是final的，我们从没见过那个类是继承String</li>
</ul>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ul>
<li>final修饰对象的时候，只是对象的引用不变，而对象本身的属性是可以变化的</li>
<li>final使用原则：良好的编程习惯</li>
</ul>
<h2 id="不变性和final的关系"><a href="#不变性和final的关系" class="headerlink" title="不变性和final的关系"></a>不变性和final的关系</h2><ul>
<li>不变性并不意味着，简单地用final修饰就是不可变<ul>
<li>对于基本数据类型，确实被final修饰后就具有不可变性</li>
<li>但是对于对象类型，需要该对象保证自身被创建后，状态永远不会变才可以</li>
</ul>
</li>
<li>满足一下条件时，对象才是不可变的<ul>
<li>对象创建后，其状态就不能修改</li>
<li>所有属性都是final修饰的</li>
<li>对象创建过程中没有发发生逸出</li>
</ul>
</li>
</ul>
<h2 id="把变量写在线程内部——栈封闭"><a href="#把变量写在线程内部——栈封闭" class="headerlink" title="把变量写在线程内部——栈封闭"></a>把变量写在线程内部——栈封闭</h2><ul>
<li>在方法里面新建的局部变量，实际上是存储在每个线程私有的栈空间，而每个栈的占用空间是不能被其他线程所访问到的，所以不会有线程安全问题，这就是著名的“栈封闭”技术，是“线程封闭”技术的一种情况</li>
<li>方法内部的变量是不会有并发问题的（栈封闭）</li>
</ul>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>精通JUC并发工具十八般武艺</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发成神之路-精通JUC并发工具十八般武艺——原子类(四)</title>
    <url>/2021/12/04/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94%E5%8E%9F%E5%AD%90%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="什么是原子类，有什么作用？"><a href="#什么是原子类，有什么作用？" class="headerlink" title="什么是原子类，有什么作用？"></a>什么是原子类，有什么作用？</h1><ul>
<li>不可分割</li>
<li>一个操作是不可中断的，即便是多线程的情况下也可以保证</li>
<li>java.util.concurrent.atomic</li>
<li>原子类的作用和锁类似，是为了保证并发情况下线程安全。不过原子类相比于锁，有一定的优势：<ul>
<li>粒度更细：原子变量可以把竞争范围缩小到变量级别，这是我们可以获得的最细粒度的情况了，通常锁的粒度都要大于原子变量的粒度</li>
<li>效率更高：通常，使用原子类的效率会比使用锁的效率更高，除了高度竞争的情况</li>
</ul>
</li>
</ul>
<h1 id="6类原子类纵览"><a href="#6类原子类纵览" class="headerlink" title="6类原子类纵览"></a>6类原子类纵览</h1><table>
<thead>
<tr>
<th align="left">类型描述</th>
<th align="left">原子类</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Atomic*基本类型原子类</td>
<td align="left">AtomicInteger<br>AtomicLong<br>AtomicBoolean</td>
</tr>
<tr>
<td align="left">Atomic*array数组类型原子类</td>
<td align="left">AtomicIntegerArray<br>AtomicLongArray<br>AtomicReferenceArray</td>
</tr>
<tr>
<td align="left">Atomic*Reference引用类型原子类</td>
<td align="left">AtomicReference<br>AtomicStampedReference<br>AtomicMarkableReference</td>
</tr>
<tr>
<td align="left">Atomic*FieldUpdater升级类型原子类</td>
<td align="left">AtomicIntegerFieldUpdater<br>AtomicLongFieldUpdater<br>AtomicReferenceFieldUpdater</td>
</tr>
<tr>
<td align="left">Adder累加器</td>
<td align="left">LongAdder<br>DoubleAdder</td>
</tr>
<tr>
<td align="left">Accumulator累加器</td>
<td align="left">LongAccumulator<br>DoubleAccumulator</td>
</tr>
</tbody></table>
<h1 id="Atomic-基本类型原子类，以AtomicInteger为例"><a href="#Atomic-基本类型原子类，以AtomicInteger为例" class="headerlink" title="Atomic*基本类型原子类，以AtomicInteger为例"></a>Atomic*基本类型原子类，以AtomicInteger为例</h1><h2 id="AtomicInteger常用方法"><a href="#AtomicInteger常用方法" class="headerlink" title="AtomicInteger常用方法"></a>AtomicInteger常用方法</h2><ul>
<li>public final int get()//获取当前的值</li>
<li>public final int getAndSet()//获取当前的值，并设置新值</li>
<li>public final int getAndIncrement()//获取当前的值，并自增</li>
<li>public final int getAndDecrement()//获取当前值，并自减</li>
<li>public final int getAndAdd(int delta)//获取当前值，并加上预期的值</li>
<li>boolean compareAndSet(int expect,int update)//如果输入的数组等于预期值，则以原子方式将该值设置为输入值(先判断当前值是否是expect，如果是则修改为update的值，不是返回false)</li>
</ul>
<h1 id="Atomic-Array数组类型原子类"><a href="#Atomic-Array数组类型原子类" class="headerlink" title="Atomic*Array数组类型原子类"></a>Atomic*Array数组类型原子类</h1><ul>
<li>里面的每个元素都是原子类，都是线程安全的</li>
</ul>
<h1 id="Atomic-Reference引用类型原子类"><a href="#Atomic-Reference引用类型原子类" class="headerlink" title="Atomic*Reference引用类型原子类"></a>Atomic*Reference引用类型原子类</h1><ul>
<li>AtomicReference：AtomicReference类的作用，和AtomicInteger并没有本质区别，AtomicInteger可以让一个整数保证原子性，而AtomicReference可以让一个对象保证原子性，当然AtomicReference的功能明显比AtomicInteger强，因为一个对象里面可以包含很多属性。</li>
<li>用法和AtomicInteger类似<blockquote>
<p>代码如下所示：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Thread&gt; sign = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        <span class="keyword">while</span> (!sign.compareAndSet(<span class="keyword">null</span>, thread)) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        sign.compareAndSet(thread, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpinLock spinLock = <span class="keyword">new</span> SpinLock();</span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始尝试获取自旋锁&quot;</span>);</span><br><span class="line">                spinLock.lock();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获得自旋锁&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">300</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    spinLock.unlock();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;释放了自旋锁&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(runnable).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(runnable).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="把普通变量升级为原子类：用AtomicIntegerFieldUpdater升级原有变量"><a href="#把普通变量升级为原子类：用AtomicIntegerFieldUpdater升级原有变量" class="headerlink" title="把普通变量升级为原子类：用AtomicIntegerFieldUpdater升级原有变量"></a>把普通变量升级为原子类：用<code>AtomicIntegerFieldUpdater</code>升级原有变量</h1></li>
<li><code>AtomicIntegerFieldUpdater</code>对普通变量进行升级</li>
<li>使用场景：偶尔需要一个原子get-set操作（大多数情况的时候不会有并发情况，只有在某一时间段，或者某一个操作的时候才会有）<blockquote>
<p>代码如下所示，在使用的时候使用<code>AtomicIntegerFieldUpdater</code>处理即可</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerFieldUpdaterDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Candidate tom;</span><br><span class="line">    <span class="keyword">static</span> Candidate peter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AtomicIntegerFieldUpdater&lt;Candidate&gt; sourceUpdater =</span><br><span class="line">            AtomicIntegerFieldUpdater.newUpdater(Candidate.class, <span class="string">&quot;score&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            peter.score++;</span><br><span class="line">            sourceUpdater.getAndIncrement(tom);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Candidate</span> </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        tom = <span class="keyword">new</span> Candidate();</span><br><span class="line">        peter = <span class="keyword">new</span> Candidate();</span><br><span class="line">        AtomicIntegerFieldUpdaterDemo a = <span class="keyword">new</span> AtomicIntegerFieldUpdaterDemo();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(a);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(a);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;普通变量：&quot;</span>+peter.score);</span><br><span class="line">        System.out.println(<span class="string">&quot;升级后的记过：&quot;</span>+tom.score);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="AtomicIntegerFieldUpdater的注意点"><a href="#AtomicIntegerFieldUpdater的注意点" class="headerlink" title="AtomicIntegerFieldUpdater的注意点"></a>AtomicIntegerFieldUpdater的注意点</h2></li>
<li>可见范围（如果变量是不可见的就不能操作）</li>
<li>不支持static</li>
</ul>
<h1 id="Adder累加器"><a href="#Adder累加器" class="headerlink" title="Adder累加器"></a>Adder累加器</h1><ul>
<li>是Java8中引入的，相对是比较新的一个类</li>
<li>高并发下LongAdder比AtomicLong效率高，不过本质是空间换时间</li>
<li>竞争激烈的时候，LongAdder把不同的线程对应到不同的Cell上进行修改，降低了冲突的概率，是多段锁的概念，提高了并发性<blockquote>
<p>使用<code>AtomicLong</code>和<code>LongAdder</code>进行自增操作，如下代码所示<br>使用20个线程执行10000个任务，每个任务里面是自增一万次，总计一亿次<br><code>LongAdder</code>的耗时要远远低于<code>AtomicLong</code><br><code>AtomicLong</code>每次执行加1之后，都需要把结果刷到主内存中，以保证其他线程可见<br><code>LongAdder</code>则不需要，只是每个线程单独计数，之后在进行汇总</p>
</blockquote>
</li>
</ul>
<p>AtomicLong  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicLongDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        AtomicLong counter = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            executorService.submit(<span class="keyword">new</span> Task(counter));</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        <span class="keyword">while</span> (!executorService.isTerminated())&#123;&#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(counter.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;AtomicLong耗时：&quot;</span>+(end-start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> AtomicLong count;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(AtomicLong count)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.count = count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                count.getAndIncrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">100000000</span><br><span class="line">AtomicLong耗时：1773</span><br></pre></td></tr></table></figure>
<p>LongAdder  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongAdderDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        LongAdder counter = <span class="keyword">new</span> LongAdder();</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            executorService.submit(<span class="keyword">new</span> Task(counter));</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        <span class="keyword">while</span> (!executorService.isTerminated())&#123;&#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(counter.sum());</span><br><span class="line">        System.out.println(<span class="string">&quot;LongAdder 耗时：&quot;</span>+(end-start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> LongAdder count;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(LongAdder count)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.count = count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                count.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">100000000</span><br><span class="line">LongAdder 耗时：172</span><br></pre></td></tr></table></figure>

<h2 id="LongAdder带来的改进和原理"><a href="#LongAdder带来的改进和原理" class="headerlink" title="LongAdder带来的改进和原理"></a>LongAdder带来的改进和原理</h2><ul>
<li>在内部，这个<code>LongAdder</code>的实现原理和刚才的<code>AtomicLong</code>是有不同的，刚才的<code>AtomicLong</code>的实现原理是每一次加法都需要做同步，所以在高并发的时候会导致冲突比较多，也就降低了效率</li>
<li>而此时的<code>LongAdder</code>，每个线程会有自己的一个计数器，仅用来在自己线程内计数，这样一来就不会有其他线程的计数器干扰</li>
<li>第一线程的计数器数值为1的时候，可能线程2的计数器的值已经是3了，他们之间并不存在竞争关系，所以在加和的过程中，根本不需要同步机制，也不需要刚才的flush和refresh，这里也没有一个公共的counter来给所有线程统一计数</li>
<li><code>LongAdder</code>引入分段累加的概念，内部有一个<code>base</code>变量和一个<code>Cell[]</code>数组共同参与计数：<ul>
<li><code>base</code>变量：竞争不激烈，直接累加到该变量上</li>
<li><code>Cell[]</code>数组：竞争激烈，各个线程分散累加到自己的槽<code>Cell[i]</code>中</li>
</ul>
</li>
<li><code>sum()</code>方法源码<blockquote>
<p>如下图所示，方法注释中也有讲解，由于是将Cell[]数组和base中的所有值相加，当循环Cell[]数组的时候，如果里面的值又有变动，最终获得结果就可能不精确，循环过的对象在发生改变，无法将值再累计到结果上<br>如果调用方法的时候Cell[]数组不会再发生改变，得到的值就是精确结果 </p>
</blockquote>
</li>
</ul>
<p><img src="/2021/12/04/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94%E5%8E%9F%E5%AD%90%E7%B1%BB/LongAdder%E7%B1%BBsum%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81.png" alt="LongAdder类sum方法源码"></p>
<h2 id="对比AtomicLong和LongAdder"><a href="#对比AtomicLong和LongAdder" class="headerlink" title="对比AtomicLong和LongAdder"></a>对比<code>AtomicLong</code>和<code>LongAdder</code></h2><ul>
<li>在低争用下，<code>AtomicLong</code>和<code>LongAdder</code>这两个类具有相似的特征，但是在竞争激烈的情况下，<code>LongAdder</code>的预期吞吐量要高的多，但要消耗更多的空间</li>
<li><code>LongAdder</code>适合的场景是统计求和和计数的场景，而且<code>LongAdder</code>基本只提供了add方法，而<code>AtomicLong</code>还具有cas方法</li>
</ul>
<h1 id="Accumulator累加器"><a href="#Accumulator累加器" class="headerlink" title="Accumulator累加器"></a>Accumulator累加器</h1><ul>
<li><code>Accumulator</code>和<code>Adder</code>非常相似，<code>Accumulator</code>就是一个更通用版本的<code>Adder</code><blockquote>
<p>具体代码实现如下所示，可以实现1-9的叠加，构造函数中的表达式里面的算法可以根据需要进行更该</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongAccumulatorDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LongAccumulator accumulator = <span class="keyword">new</span> LongAccumulator((x, y) -&gt; x + y, <span class="number">0</span>);</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">8</span>);</span><br><span class="line">        IntStream.range(<span class="number">1</span>,<span class="number">10</span>).forEach(i-&gt;executorService.submit(()-&gt;accumulator.accumulate(i)));</span><br><span class="line">        System.out.println(accumulator.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2></li>
<li>适用于需要大量计算，并且可以并行计算的场景</li>
<li>不保证计算的顺序（如上代码，使用了线程池，不能保证那个线程先执行，也许是1+3+4+2…）</li>
</ul>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>精通JUC并发工具十八般武艺</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发成神之路-精通JUC并发工具十八般武艺——ThreadLocal(二)</title>
    <url>/2021/11/28/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94ThreadLocal/</url>
    <content><![CDATA[<h1 id="两大使用场景——ThreadLocal的用途"><a href="#两大使用场景——ThreadLocal的用途" class="headerlink" title="两大使用场景——ThreadLocal的用途"></a>两大使用场景——ThreadLocal的用途</h1><ul>
<li>场景1：每个线程需要一个独享的对象（通常是工具类，典型需要使用的类有SimpleDateFormat和Random）<blockquote>
<p>SimpleDateFormat为线程不安全的，如果在方法中每次都创建一个SimpleDateFormat对象<br>如果访问量较高，会导致格式化出来的时间有部分是重复的<br>可以通过使用ThreadLocal，针对每一个线程创建一个SimpleDateFormat对象，这样同一个线程的不同任务是排队进行的，不同线程使用的是不同的对象，就可以解决并发问题  </p>
</blockquote>
</li>
<li>场景2：每个线程内需要保存全局变量（例如在拦截器中获取用户信息，可以让不同方法直接使用，避免参数传递的麻烦）<blockquote>
<p>假设当前用户信息需要被线程内所有方法共享，一个比较繁琐的解决发难就是把user作为阐述层层传递，从方法1到方法2到方法3，以次类推，但是这样做代码冗余，且不利于维护<br>使用ThreadLocal，当前线程中公共变量，可以在当前线程中的任何一个方法中调用获取相应的变量值</p>
</blockquote>
</li>
</ul>
<h2 id="ThreadLocal的两个作用"><a href="#ThreadLocal的两个作用" class="headerlink" title="ThreadLocal的两个作用"></a>ThreadLocal的两个作用</h2><ul>
<li>让某个需要用到的对象在线程间隔离（每个线程都有自己的独立的对象）</li>
<li>在任何方法中都可以轻松的获取到对象</li>
</ul>
<h2 id="根据共享对象的生产时机不同，选择initialValue或set来保存对象"><a href="#根据共享对象的生产时机不同，选择initialValue或set来保存对象" class="headerlink" title="根据共享对象的生产时机不同，选择initialValue或set来保存对象"></a>根据共享对象的生产时机不同，选择<code>initialValue</code>或<code>set</code>来保存对象</h2><ul>
<li>场景一：<code>initialValue</code><blockquote>
<p>在ThreadLocal第一个get的时候，把对象给初始化出来，对象的初始化时机可以由我们控制</p>
</blockquote>
</li>
<li>场景二：<code>set</code><blockquote>
<p>如果需要保存到ThreadLocal里面的对象的生产时机不由我们随意控制，例如拦截器生成的用户信息，用ThreadLocal.set()直接放到我们的ThreadLocal中去，以便后续使用</p>
</blockquote>
</li>
</ul>
<h1 id="使用ThreadLocal带来的好处"><a href="#使用ThreadLocal带来的好处" class="headerlink" title="使用ThreadLocal带来的好处"></a>使用ThreadLocal带来的好处</h1><ul>
<li>达到线程安全的目的</li>
<li>不需要加锁，提高执行效率</li>
<li>更高效的利用内存、节省开销：相比于每一个任务都新建一个SimpleDateFormat，显然用ThreadLocal可以节省内存和开销</li>
<li>免去传参的繁琐：无论是场景一的工具类，还是场景二的用户名，都可以在任何地方直接通过ThreadLocal拿到，再也不需要每次都传同样的参数，ThreadLocal使得代码耦合度更低，更优雅</li>
</ul>
<h1 id="主要方法介绍"><a href="#主要方法介绍" class="headerlink" title="主要方法介绍"></a>主要方法介绍</h1><ul>
<li><p><code>T initialValue()</code></p>
<blockquote>
<p>该方法会返回当前线程对应的”初始值“，这是一个延迟加载的方法，只有再调用<code>get()</code>的时候，才会触发<br>当线程第一个吃用<code>get()</code>方法访问变量时，将调用此方法，除非线程先调用了<code>set()</code>方法，在这种情况下，不会为线程调用本<code>initialValue()</code>方法<br>通常每个线程最调用一次此方法，但如果已经调用了<code>remove()</code>，再调用<code>get()</code>，则可以再次调用此方法<br>如果不重写本方法，这个放回就会返回null，一般使用匿名内部类的方法来重写<code>initialValue()</code>方法，以便再后续使用中，可以初始化副本对象<br>该方法没有默认实现，如果我们需要到该方法，需要自己实现，通常使用匿名内部类的方式</p>
</blockquote>
</li>
<li><p><code>void set(T t)</code></p>
<blockquote>
<p>为这个线程设置一个新值</p>
</blockquote>
</li>
<li><p><code>T get()</code></p>
<blockquote>
<p>得到这个线程对应的value，如果是首次调用<code>get()</code>（没有调用<code>set()</code>方法直接调用<code>get()</code>），则会调用<code>initialValue()</code>方法获取这个值<br><code>get()</code>方法是先取出当前线程的<code>ThreadLocalMap</code>，然后调用<code>map.getEntry</code>方法，把本<code>ThreadLocal</code>的引用作为参数传进去，取出map中属于本<code>ThreadLocal</code>的value<br>注意，这个map以及map中的key和value都是保存再线程中的，而不是保存再ThreadLocal中的</p>
</blockquote>
</li>
<li><p><code>void remove()</code></p>
<blockquote>
<p>删除对应这个线程的值</p>
</blockquote>
</li>
</ul>
<h1 id="ThreadLocalMap类"><a href="#ThreadLocalMap类" class="headerlink" title="ThreadLocalMap类"></a>ThreadLocalMap类</h1><ul>
<li>ThreadLocalMap类是每个线程Thread类里面的变量，里面最重要的是一个键值对数组<code>Entry[] table</code>，可以认为是一个map，键值对：<ul>
<li>键：这个ThreadLocal</li>
<li>值：实际需要的成员变量，比如user或者SimpleDateFormat对象</li>
</ul>
</li>
<li>当发现hash冲突的时候，ThreadLocalMap采用的是线性探测法，也就是如果发生冲突，就继续找下一个空位置，而不是采用链表拉链</li>
</ul>
<h1 id="ThreadLocal注意点"><a href="#ThreadLocal注意点" class="headerlink" title="ThreadLocal注意点"></a>ThreadLocal注意点</h1><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><ul>
<li>什么是内存泄漏：某个对象不再有用，但是占用的内存却不能被回收</li>
<li>key的泄漏：ThreadLocalMap中的Entry继承自WeakReference，是弱引用<ul>
<li>弱引用的特点是，如果这个对象只被弱引用关联（没有任何强引用关联），那么这个对象就可以被回收，所以弱引用不会阻止GC</li>
</ul>
</li>
<li>value的泄漏<ul>
<li>ThreadLocalMap的每个Entry都是一个对key的弱引用，同时，每个Entry都包含了一个对value的强引用</li>
<li>正常情况下，当线程终止，保存再ThreadLocal里面的value会被垃圾回收，因为没有任何强引用了</li>
<li>但是如果线程不终止（比如线程需要保持很久，使用线程池的场景，线程一直被重复使用），那么key对应的value就不能被回收，因为又以下的调用链：<ul>
<li>Thread -&gt; ThreadLocalMap -&gt; Entry(key为null) -&gt; value</li>
</ul>
</li>
<li>因为value和Thread之间还存在这个强引用链路，所以导致value无法回收，就可能出现OOM</li>
<li>JDK已经考虑到了这个问题，多以在set，remove，rehash方法中会扫描key为null的Entry，并把相应的value设置成null，这样value对象就可以被回收</li>
<li>但是如果一个ThreadLocal不被使用，那么实际上set,remove,rehash方法也不会被调用到，如果同时线程又不停止，那么调用链就一直存在，那么就导致了value的内存泄漏</li>
</ul>
</li>
</ul>
<h2 id="如何避免内存泄漏（阿里规约）"><a href="#如何避免内存泄漏（阿里规约）" class="headerlink" title="如何避免内存泄漏（阿里规约）"></a>如何避免内存泄漏（阿里规约）</h2><ul>
<li>调用remove方法，就会删除相应的Entry对象，可以避免内存泄漏，所以使用完ThreadLocal之后，应该调用remove方法</li>
</ul>
<h2 id="空指针问题"><a href="#空指针问题" class="headerlink" title="空指针问题"></a>空指针问题</h2><ul>
<li>当ThreadLocal.get()方法出来的值，直接被基本类型接受的时候，如果值是空，那么在转为基本类型的时候会抛出控制在异常</li>
</ul>
<h2 id="共享对象"><a href="#共享对象" class="headerlink" title="共享对象"></a>共享对象</h2><ul>
<li>如果每个线程中ThreadLocal.set()进去的东西本来就是多个线程共享的同一个对象，比如static对象，那么多个线程的ThreadLocal.get()取的还是这个共享对象本身，还是会有并发访问的问题</li>
</ul>
<h2 id="如果使用ThreadLocal就可以解决问题，那么不要强制使用"><a href="#如果使用ThreadLocal就可以解决问题，那么不要强制使用" class="headerlink" title="如果使用ThreadLocal就可以解决问题，那么不要强制使用"></a>如果使用ThreadLocal就可以解决问题，那么不要强制使用</h2><ul>
<li>例如在任务数很少的时候，在局部变量中可以新建对象就可以解决问题，那么就不需要使用到ThreadLocal</li>
</ul>
<h2 id="优先使用框架的支持，而不是自己创造"><a href="#优先使用框架的支持，而不是自己创造" class="headerlink" title="优先使用框架的支持，而不是自己创造"></a>优先使用框架的支持，而不是自己创造</h2><ul>
<li>例如spring中，如果可以使用RequestContextHolder，那么就不需要自己维护ThreadLocal，因为自己可能会忘记调用remove()方法，造成内存泄漏</li>
</ul>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>精通JUC并发工具十八般武艺</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发成神之路-精通JUC并发工具十八般武艺——并发容器(六)</title>
    <url>/2021/12/04/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h1 id="并发容器概念"><a href="#并发容器概念" class="headerlink" title="并发容器概念"></a>并发容器概念</h1><ul>
<li><code>ConcurrentHashMap</code>：线程安全的HashMap</li>
<li><code>CopyOnWriteArrayList</code>：线程安全的List</li>
<li><code>BlockingQueue</code>：这是一个接口，表示阻塞队列，非常适合用于作为数据共享的通道</li>
<li><code>ConcurrentLinkedQueue</code>：高效的非阻塞队列，使用链表实现。可以看作一个线程安全的LinkedList</li>
<li><code>ConcurrentSkipListMap</code>：是一个Map，使用跳表的数据结构进行快速查找</li>
</ul>
<h1 id="趣说集合类的历史——古老和过时的同步容器"><a href="#趣说集合类的历史——古老和过时的同步容器" class="headerlink" title="趣说集合类的历史——古老和过时的同步容器"></a>趣说集合类的历史——古老和过时的同步容器</h1><ul>
<li>Vector和Hashtable<ul>
<li>主要通过在方法上面添加<code>synchronized</code>关键字，来实现线程安全，效率很差  </li>
</ul>
</li>
<li>HashMap和ArrayList<ul>
<li>HashMap和ArrayList是线程不安全的，不过可以通过<code>Collections.synchronizedList(new ArrayList&lt;E&gt;())</code>和<code>Collections.synchronizedMap(new HashMap&lt;K,V&gt;())</code>使之变成线程安全的</li>
<li>使用这两个方法包装之后，其实也是使用的<code>synchronized</code>，只不过锁的是同步代码块，效率并不会有所提升</li>
</ul>
</li>
<li><code>ConcurrentHashMap</code>和<code>CopyOnWriteArrayList</code><ul>
<li>取代同步的HashMap和同步的ArrayList</li>
</ul>
</li>
</ul>
<h1 id="ConcurrentHashMap-重点、面试常考"><a href="#ConcurrentHashMap-重点、面试常考" class="headerlink" title="ConcurrentHashMap(重点、面试常考)"></a>ConcurrentHashMap(重点、面试常考)</h1><h2 id="Map简介"><a href="#Map简介" class="headerlink" title="Map简介"></a>Map简介</h2><img src="http://www.plantuml.com/plantuml/svg/POv13a0m44NtJj7ZM6331OP-J5H9En69k3iMcghb_7b_vh4Lk9uwg9BMuymwGzwhdFnupuhdrM265VzP5smdw1V2Bh0wb6wAmz5wSG8TKobHqSO3jGOn56hXPUE0n2XkVipb2N_k5m00">

<ul>
<li>HashMap：是根据key的hashCode进行存储的，键允许一个null值，value不做限制，线程非安全</li>
<li>Hashtable：功能和HashMap一致，线程安全，不过性能比较差</li>
<li>LinkedHashMap：保存记录的插入顺序</li>
<li>TreeMap：根据key进行排序，有默认排序规则，也可以自动逸排序规则</li>
</ul>
<h2 id="为什么HashMap是线程不安全的？"><a href="#为什么HashMap是线程不安全的？" class="headerlink" title="为什么HashMap是线程不安全的？"></a>为什么HashMap是线程不安全的？</h2><ul>
<li>同时put碰撞导致数据丢失<ul>
<li>如果两个线程同时存储，key的hashCode相同，会导致有一个的值丢失，只会存储一个</li>
</ul>
</li>
<li>同时put扩容导致数据丢失<ul>
<li>如果两个线程同时对hashMap进行了扩容，那么扩容只会的数组只有一个能被保存下来，导致另外一个的数据丢失</li>
</ul>
</li>
<li>死循环造成CPU 100%<ul>
<li>多线程的情况下会照成循环链表最终导致死循环</li>
<li>原因分析: <a href="https://coolshell.cn/articles/9606.html">点击查看</a><blockquote>
<p>死循环的实现代码如下所示:<br>具体复现方式: 首先需要将JDk切换成1.7版本,然后按下图所示打上断点,并将断点设置为线程级别,当两个线程都走到第二各断点的时候,放过所有断点,就会复现循环链表的情况</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p><img src="/2021/12/04/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/HashMap%E6%AD%BB%E5%BE%AA%E7%8E%AF%E5%A4%8D%E7%8E%B0%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="HashMap死循环复现示意图"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapEndlessloop</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;Integer,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span>,<span class="number">1.5f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        map.put(<span class="number">5</span>,<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        map.put(<span class="number">7</span>,<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>,<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                map.put(<span class="number">15</span>,<span class="string">&quot;D&quot;</span>);</span><br><span class="line">                System.out.println(map);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;Thread 1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                map.put(<span class="number">1</span>,<span class="string">&quot;E&quot;</span>);</span><br><span class="line">                System.out.println(map);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;Thread 2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="HashMap分析"><a href="#HashMap分析" class="headerlink" title="HashMap分析"></a>HashMap分析</h2><ul>
<li>在1.7版本的JDK中,底层数据结构是数组加链表</li>
<li>在1.8中,当链表的长度达到一定的阈值之后,就会转变成红黑树<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3></li>
<li>每个节点要么是红色,要么是黑色,但是根节点永远是黑色</li>
<li>红色节点不能连续(也即是,红色节点的孩子和父亲都不能是红色)</li>
<li>从任意节点到其子树中每个叶子节点的路径都包含了数量相同的黑色节点</li>
<li>所有的叶子节点都是黑色的</li>
</ul>
<h3 id="HashMap关于并发的特点"><a href="#HashMap关于并发的特点" class="headerlink" title="HashMap关于并发的特点"></a>HashMap关于并发的特点</h3><ul>
<li>非线程安全</li>
<li>迭代时不允许修改内容</li>
<li>只读的并发是安全的</li>
<li>如果一定要把HashMap用在并发环境,用Collection.synchronizedMap(new HashMap&lt;K,V&gt;())</li>
</ul>
<h2 id="JDK1-7的ConcurrentHashMap实现和分析"><a href="#JDK1-7的ConcurrentHashMap实现和分析" class="headerlink" title="JDK1.7的ConcurrentHashMap实现和分析"></a>JDK1.7的ConcurrentHashMap实现和分析</h2><ul>
<li>Java7中的ConcurrentHashMap最外层是多个segment,每个segment的底层数据结构与HashMap类似,仍然是数组和链表组成的拉链法</li>
<li>每个segment独立上ReentrantLock锁,每个segment之间互不影响,提高了并发效率</li>
<li>ConcurrentHashMap默认有16各segment,所以最多可以同时支持16个线程并发写(从中分别分布在不同segment上).这个默认值可以在初始化的时候设置为其他值,但是一旦初始化以后,是不可以扩容的</li>
</ul>
<h2 id="JDK1-8的ConcurrentHashMap实现和分析"><a href="#JDK1-8的ConcurrentHashMap实现和分析" class="headerlink" title="JDK1.8的ConcurrentHashMap实现和分析"></a>JDK1.8的ConcurrentHashMap实现和分析</h2><h3 id="putValue流程"><a href="#putValue流程" class="headerlink" title="putValue流程"></a>putValue流程</h3><ul>
<li>判断key  value不为空</li>
<li>计算Hash值</li>
<li>根据对应位置节点的类型,来赋值,或者helpTransfer,或者增长链表,或者给红黑树增加节点</li>
<li>检查满足阈值就”红黑树化”</li>
<li>返回oldVal</li>
</ul>
<h3 id="get流程"><a href="#get流程" class="headerlink" title="get流程"></a>get流程</h3><ul>
<li>计算hash值</li>
<li>找到对应的位置,根据情况进行:<ul>
<li>直接取值</li>
<li>红黑树里找值</li>
<li>遍历链表找值</li>
<li>返回找到的结果</li>
</ul>
</li>
</ul>
<h3 id="为什么要把1-7的结构改成了1-8的结构"><a href="#为什么要把1-7的结构改成了1-8的结构" class="headerlink" title="为什么要把1.7的结构改成了1.8的结构"></a>为什么要把1.7的结构改成了1.8的结构</h3><ul>
<li>数据结构(7是segment加链表的结构,8是数组加链表,链表长度达到8之后,会转为红黑树,7的并发度是根据segment的个数决定的,8是每个Node都是独立的)</li>
<li>Hash碰撞(7是直接使用链表,8是先使用链表,数量达到8之后,会转成红黑树)</li>
<li>保证并发安全(7是使用分段锁,继承于Lock,8中是使用CAS加synchronized来保证的)</li>
<li>查询复杂度(7查询链表是O(n),8为链表的是相同,为红黑树的时候降为O(logn))</li>
<li>为什么超过8的时候转成红黑树?<ul>
<li>没有最开始就使用红黑树而是要后面转,是因为红黑树占用空间比链表大两倍</li>
<li>作者有在注释中描述,链表最终的长度能达到8个概率只有千万分之一,这种概率已经很小了,为了应对这种极端情况,才会转成红黑树,但是一般链表长度根本不会到8</li>
</ul>
</li>
</ul>
<h2 id="组合操作"><a href="#组合操作" class="headerlink" title="组合操作"></a>组合操作</h2><ul>
<li><code>replace</code> (把一个值根据当前值的情况判断是否要替换)</li>
<li><code>putIfAbsent</code> (如果当前key不存在值,就放进去,否则就取出来)</li>
</ul>
<h1 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h1><h2 id="诞生的历史和原因"><a href="#诞生的历史和原因" class="headerlink" title="诞生的历史和原因"></a>诞生的历史和原因</h2><ul>
<li>代替<code>Vector</code>和<code>SynchronizedList</code>,就和<code>ConcurrentHashMap</code>代替<code>SynchronizedMap</code>的原因一样</li>
<li><code>Vector</code>和<code>SynchronizedList</code>的锁粒度太大,并发效率相对比较低,并且迭代时无法编辑</li>
<li>Copy-On-Write并发容器还包括<code>CopyOnWriteArraySet</code>,用来代替同步<code>Set</code></li>
</ul>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li>读操作可以尽可能地块,而写即使慢一些也没有太大关系</li>
<li>读多写少: 黑名单,每日更新;监听器: 迭代操作远多余修改操作</li>
</ul>
<h2 id="读写规则"><a href="#读写规则" class="headerlink" title="读写规则"></a>读写规则</h2><ul>
<li>读写锁规则的升级: 读取是完全不用加锁的,并且更厉害的是写入也不会阻塞读取操作,只有写入和写入之间需要进行同步等待</li>
<li><code>ArrayList</code>在迭代的时候是不允许修改的,检测到修改会直接异常</li>
<li><code>CopyOnWriteArrayList</code>可以在迭代中修改,不过迭代的依然是未修改时的内容</li>
</ul>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><ul>
<li>CopyOnWrite的含义<ul>
<li>每次修改或者添加数据都会创建一个新的容器,之后再把变量的引用指向新的容器,旧的就可以回收,旧的容器也不会改变</li>
</ul>
</li>
<li>创建新副本,读写分离<br>+在写入的时候,会将原本的数组整个复制,然后将修改写入原本的数组中,最后再替换回去</li>
<li>“不可变”原理<ul>
<li>因为每次修改都是一个新的容器,所以对旧的容器来说就是不可变的</li>
</ul>
</li>
<li>迭代的时候<ul>
<li>在迭代的时候,如果原本的数组已经被修改过了,但是迭代器是不知道的,它使用的依然是最开始的时候的旧数组(可能会出现数据过期的问题)</li>
</ul>
</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>数据一致性问题: CopyOnWrite容器只能保证数据的最终一致性,不能保证数据的实时一直性,所以如果你希望写入的数据,马上就能读到,请不要使用CopyOnWrite容器</li>
<li>内存占用问题: 因为CopyOnWrite的写是复制机制,所以在进行写操作的时候,内存里会同时驻扎两个对象的内存</li>
</ul>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><ul>
<li>底层是基于数组实现的</li>
<li>添加数据的时候,如下图所示,使用Lock锁进行上锁,然后将新建一个比原本数组长1的数组,然后将原本数组的内容全部复制进去,然后将新数据保存到数据的最后一位</li>
</ul>
<p><img src="/2021/12/04/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/CopyOnWriteArrayList%E7%9A%84add%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="CopyOnWriteArrayList的add方法源码示意图"></p>
<h1 id="并发队列Queue-阻塞队列、非阻塞队列"><a href="#并发队列Queue-阻塞队列、非阻塞队列" class="headerlink" title="并发队列Queue(阻塞队列、非阻塞队列)"></a>并发队列Queue(阻塞队列、非阻塞队列)</h1><h2 id="为什么要使用队列"><a href="#为什么要使用队列" class="headerlink" title="为什么要使用队列"></a>为什么要使用队列</h2><ul>
<li>用队列可以在线程间传递数据: 生产者消费者模式,银行转账</li>
<li>考虑锁等线程安全问题的重任从”你”转移到了”队列”上</li>
</ul>
<h2 id="各并发队列关系图"><a href="#各并发队列关系图" class="headerlink" title="各并发队列关系图"></a>各并发队列关系图</h2><img src="http://www.plantuml.com/plantuml/svg/bOrB3i8m34Jtd29NuRDa0Ue98dS0gwaDTY9HLTmTn2TIrKtPphmtmv9XfqW8nuA2yR7YccoIKiToVZS1zmnflNAKedjOcyLX2d9_JUWXsQSBrJaOgt7-LzkpT6X_tGwt9L8p25rCHOillDcgK35x4P_3cVR5dm00">

<h2 id="阻塞队列BlockingQueue"><a href="#阻塞队列BlockingQueue" class="headerlink" title="阻塞队列BlockingQueue"></a>阻塞队列<code>BlockingQueue</code></h2><h3 id="什么是阻塞队列"><a href="#什么是阻塞队列" class="headerlink" title="什么是阻塞队列"></a>什么是阻塞队列</h3><ul>
<li>阻塞队列是具有阻塞功能的队列,所以它首先是一个队列,其次是具有阻塞功能</li>
<li>通常,阻塞队列的一端是给生产者方数据用,另一端给消费者拿数据用,阻塞队列是线程安全的,所以生产者和消费者都可以是多线程的</li>
<li>阻塞功能: 最具有特色的两个带有阻塞功能的方法:<ul>
<li><code>take()</code>方法: 获取并移除队列的头结点,一旦如果执行take的时候,队列里无数据,则阻塞,直到队列里有数据</li>
<li><code>put()</code>方法: 插入元素,但是如果队列已满,那么就无法继续插入,则阻塞,直到队列里有了空闲空间</li>
</ul>
</li>
<li>是否有界(容量有多大): 这是一个非常重要的属性,无界队列意味着里面可以容纳非常多(<code>Integer.MAX_VALUE</code>,约为2的31次方,是一个非常大的数,可以近似认为是无限容量)</li>
<li>阻塞队列和线程池的关系: 阻塞队列是线程池的重要组成部分</li>
</ul>
<h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a><code>ArrayBlockingQueue</code></h3><ul>
<li>有界</li>
<li>指定容量</li>
<li>公平：还可以指定是否需要保证公平，如果想要保证公平的话，那么等待了最长时间的线程会被优先处理，不过这会同时带来一定的性能损耗</li>
<li>示例代码如下所示：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueueDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayBlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        Interviewer interviewer = <span class="keyword">new</span> Interviewer(queue);</span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer(queue);</span><br><span class="line">        <span class="keyword">new</span> Thread(interviewer).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(consumer).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interviewer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    BlockingQueue&lt;String&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Interviewer</span><span class="params">(BlockingQueue&lt;String&gt; queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;10个候选人都来了&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                String candidate = <span class="string">&quot;Candidate &quot;</span> + i;</span><br><span class="line">                queue.put(candidate);</span><br><span class="line">                System.out.println(candidate + <span class="string">&quot; 安排好了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            queue.put(<span class="string">&quot;stop&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    BlockingQueue&lt;String&gt; queue;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(BlockingQueue&lt;String&gt; queue)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.queue = queue;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">             String msg;</span><br><span class="line">             <span class="keyword">while</span> (!(msg = queue.take()).equals(<span class="string">&quot;stop&quot;</span>))&#123;</span><br><span class="line">                 System.out.println(msg+<span class="string">&quot;面试结束----&quot;</span>);</span><br><span class="line">             &#125;</span><br><span class="line">             System.out.println(<span class="string">&quot;所有候选人面试结束&quot;</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>ArrayBlockingQueue</code>的put方法源码如下，首先判断值是否为空，然后获取锁，之后判断队列是否满了，如果满了就进行等待，如果没满就把值放进去</p>
</blockquote>
</li>
</ul>
<p><img src="/2021/12/04/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/ArrayBlockingQueue%E7%9A%84put%E6%BA%90%E7%A0%81%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="ArrayBlockingQueue的put源码示意图"></p>
<h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a><code>LinkedBlockingQueue</code></h3><ul>
<li>无界</li>
<li>容量<code>Integer.MAX_VALUE</code></li>
<li>内部结构：<code>Node</code>、两把锁</li>
<li>由下图中可以看出，<code>LinkedBlockingQueue</code>中是有两把锁的，所以存放和获取是互不干扰的</li>
</ul>
<p><img src="/2021/12/04/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/LinkedBlockingQueue%E4%B8%A4%E6%8A%8A%E9%94%81%E6%BA%90%E7%A0%81%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="LinkedBlockingQueue两把锁源码示意图"></p>
<ul>
<li>从图中可以看出，存值的时候首先会判断值是否为空，然后将其封装成一个node，然后获取putLock锁</li>
<li>再然后判断当前长度是否等于最大长度，是就进行等待，不是就开始存值操作，然后再判断存值之后的长度是否小于最大长度，是的话就唤醒其他的线程继续运行</li>
</ul>
<p><img src="/2021/12/04/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/LinkedBlockingQueue%E7%9A%84put%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="LinkedBlockingQueue的put方法源码示意图"></p>
<h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a><code>PriorityBlockingQueue</code></h3><ul>
<li>支持优先级</li>
<li>自然排序（而不是先进先出）</li>
<li>无界队列</li>
<li><code>PriorityQueue</code>的线程安全版本</li>
</ul>
<h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a><code>SynchronousQueue</code></h3><ul>
<li>它的容量为0</li>
<li>需要注意的是，<code>SynchronousQueue</code>的容量不是1而是0，因为<code>SynchronousQueue</code>不需要去持有元素，它所作的就是直接传递</li>
<li>效率很高</li>
<li><code>SynchronousQueue</code>没有peek等函数，因为peek的含义是取出头结点，但是<code>SynchronousQueue</code>的容量是0，所以连头结点都没有，也就没有peek方法，同理，也没有iterate相关方法</li>
<li>是一个极好用的直接传递的并发数据结构</li>
<li><code>SynchronousQueue</code>是线程池<code>Executors.newCachedThreadPool()</code>使用的阻塞队列</li>
</ul>
<h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><ul>
<li>无界</li>
<li>延迟队列，根据延迟时间排序</li>
<li>元素需要实现Delayed接口，规定排序规则</li>
</ul>
<h2 id="非阻塞队列"><a href="#非阻塞队列" class="headerlink" title="非阻塞队列"></a>非阻塞队列</h2><ul>
<li>并发包中的非阻塞队列只有ConcurrentLinkedQueue这一种，顾名思义ConcurrentLinkedQueue是使用链表作为其数据结构的，使用CAS非阻塞算法来实现线程安全（不具备阻塞功能），适合用在对性能要求较高的并发场景，用的相对比较少一些</li>
<li>看源码的offer方法的CAS思想，内有p.casNext方法，用了UNSAFE.compareAndSwapObject</li>
</ul>
<h2 id="如何选择适合自己的队列"><a href="#如何选择适合自己的队列" class="headerlink" title="如何选择适合自己的队列"></a>如何选择适合自己的队列</h2><ul>
<li>边界（根据业务情况判断需要的队列的大小）</li>
<li>空间</li>
<li>吞吐量</li>
</ul>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>精通JUC并发工具十八般武艺</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发成神之路-精通JUC并发工具十八般武艺——获取子线程的执行结果(九)</title>
    <url>/2021/12/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94%E8%8E%B7%E5%8F%96%E5%AD%90%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C/</url>
    <content><![CDATA[<h1 id="Future和Callable——治理线程第二大法宝"><a href="#Future和Callable——治理线程第二大法宝" class="headerlink" title="Future和Callable——治理线程第二大法宝"></a><code>Future</code>和<code>Callable</code>——治理线程第二大法宝</h1><h2 id="Runnable的缺陷"><a href="#Runnable的缺陷" class="headerlink" title="Runnable的缺陷"></a><code>Runnable</code>的缺陷</h2><ul>
<li>不能返回有个返回值</li>
<li>也不能抛出checked Exception</li>
</ul>
<h2 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a><code>Callable</code>接口</h2><ul>
<li>类似<code>Runnable</code>，被其他线程执行的任务</li>
<li>实现<code>call</code>方法</li>
<li>有返回值</li>
</ul>
<h2 id="Future类"><a href="#Future类" class="headerlink" title="Future类"></a><code>Future</code>类</h2><h3 id="Callable和Future的关系"><a href="#Callable和Future的关系" class="headerlink" title="Callable和Future的关系"></a><code>Callable</code>和<code>Future</code>的关系</h3><ul>
<li>我们可以用<code>Future.get()</code>类获取<code>Callable</code>接口返回的执行结果，还可以通过<code>Future.isDone()</code>来判断任务是否已经执行完了，以及取消这个任务，限时获取任务的结果等</li>
<li>在<code>call()</code>未执行完毕之前，调用<code>get()</code>的线程（假定此时是主线程）会被阻塞，直到<code>call()</code>方法返回了结果后，此时<code>future.get()</code>才会得到该结果，然后主线程才会切换到<code>runnable</code>状态</li>
<li>所以<code>Future</code>是一个存储器，它存储了<code>call()</code>这个任务的结果，而这个任务的执行时间是无法提前确定的，因为这完全取决于<code>call()</code>方法执行的情况</li>
</ul>
<h2 id="Future的主要方法，一共5个"><a href="#Future的主要方法，一共5个" class="headerlink" title="Future的主要方法，一共5个"></a><code>Future</code>的主要方法，一共5个</h2><h3 id="get-方法：获取结果"><a href="#get-方法：获取结果" class="headerlink" title="get()方法：获取结果"></a><code>get()</code>方法：获取结果</h3><p><code>get</code>方法的行为取决于<code>Callable</code>任务的状态，只有一下这5中情况：</p>
<ul>
<li>任务正常完成：<code>get</code>方法会立刻返回结果</li>
<li>任务尚未完成（任务还没有开始或者进行中）：<code>get</code>方法将阻塞并直到任务完成</li>
<li>任务执行过程中抛出<code>Exception</code>：<code>get</code>方法会抛出<code>ExecutionException</code>:这里的抛出一次，是<code>call()</code>执行时产生的那个一次，看到这个异常的类型是<code>java.util.concurrent.ExecutionException</code>。不论<code>call()</code>执行时抛出的异常是什么，最后<code>get()</code>方法抛出的异常类型都是<code>ExecutionException</code>.</li>
<li>任务去取消：<code>get</code>方法会抛出<code>CancellationException</code></li>
<li>任务超时：<code>get</code>方法有一个重载方法，是传入一个延迟时间，如果时间到了还没有获得结果，<code>get</code>方法就会抛出<code>TimeoutException</code></li>
</ul>
<h3 id="get-long-timeout-TimeUnit-unit-有超时的获取"><a href="#get-long-timeout-TimeUnit-unit-有超时的获取" class="headerlink" title="get(long timeout,TimeUnit unit): 有超时的获取"></a><code>get(long timeout,TimeUnit unit)</code>: 有超时的获取</h3><ul>
<li>用<code>get(long timeout,TimeUnit unit)</code>方法时，如果<code>call()</code>在规定时间内完成了任务，那么就会正常获取到返回值，而如果在指定时间内没有计算出结果，那么就会抛出<code>TimeoutException</code></li>
<li>超时不获取，任务需取消</li>
</ul>
<h3 id="cancel-方法"><a href="#cancel-方法" class="headerlink" title="cancel()方法"></a><code>cancel()</code>方法</h3><ul>
<li>如果这个任务还没有开始执行，那么这种情况最简单，任务会被正常取消，未来也不会被执行，方法返回true</li>
<li>如果热舞已经完成，或者已经取消：那么<code>cancel()</code>方法会执行失败，方法返回false</li>
<li>如果这个任务已经开始执行了，那么这个取消方法将不会直接取消该任务，而是会根据我们填的参数<code>mayInterruptIfRunning</code>做判断<ul>
<li>如果参数传入false，会等待正在运行的任务运行结束</li>
<li>如果传入true，会直接给正在运行的线程一个中断信号，由任务线程获取到后进行相应的处理<br><code>future.cancel(true)</code>适用于：</li>
</ul>
</li>
<li>确定当前任务的方法能够处理中断信号<br><code>Future.cancel(false)</code>仅用于避免启动尚未启动的任务，适用于：</li>
<li>未能处理interrupt的任务</li>
<li>不清楚任务是否支持取消</li>
<li>需要等待已经开始的任务执行完成</li>
</ul>
<h3 id="isDone-方法：判断线程是否执行完毕"><a href="#isDone-方法：判断线程是否执行完毕" class="headerlink" title="isDone()方法：判断线程是否执行完毕"></a><code>isDone()</code>方法：判断线程是否执行完毕</h3><ul>
<li>任务成功执行完毕</li>
<li>任务失败，异常了也算是执行完毕</li>
<li>任务被取消了，也算是执行完毕</li>
</ul>
<h3 id="isCancelled-方法：判断是否被取消"><a href="#isCancelled-方法：判断是否被取消" class="headerlink" title="isCancelled()方法：判断是否被取消"></a><code>isCancelled()</code>方法：判断是否被取消</h3><ul>
<li>判断这个任务是不是被取消了</li>
</ul>
<h2 id="用法1：线程池的submit方法返回Future对象"><a href="#用法1：线程池的submit方法返回Future对象" class="headerlink" title="用法1：线程池的submit方法返回Future对象"></a>用法1：线程池的<code>submit</code>方法返回<code>Future</code>对象</h2><ul>
<li>首先，我们要给线程池提交我们的任务，提交时线程池会立刻返回给我们一个空的<code>Future</code>容器，当线程的任务一旦执行完毕，也就是当我们可以获取结果的时候，线程池便会把该结果填入到之前给我们的那个<code>Future</code>中去（而不是创建一个新的<code>Future</code>），我们此时便可以从该<code>Future</code>中获得任务执行的结果</li>
</ul>
<h2 id="用法2：用FutureTask来创建Future"><a href="#用法2：用FutureTask来创建Future" class="headerlink" title="用法2：用FutureTask来创建Future"></a>用法2：用<code>FutureTask</code>来创建<code>Future</code></h2><ul>
<li>用<code>FutureTask</code>来获取<code>Future</code>和任务的结果</li>
<li><code>FutureTask</code>是一种包装器，可以把<code>Callable</code>转化成<code>Future</code>和<code>Runnable</code>，它同时实现二者的接口</li>
<li>所以它既可以作为<code>Runnable</code>被线程执行，又可以作为<code>Future</code>得到<code>Callable</code>的返回值</li>
<li>把<code>Callable</code>实例当作参数，生成<code>FutureTask</code>的对象，然后把这个对象当作一个<code>Runnable</code>对象，用线程池或另起线程去执行这个<code>Runnable</code>对象，最后通过<code>FutureTask</code>获取刚才执行的结果</li>
<li>代码实现如下，直接创建线程，或者使用线程池提交都可以<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTaskDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Task task = <span class="keyword">new</span> Task();</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(task);</span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(futureTask.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程正在计算&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Future的注意点"><a href="#Future的注意点" class="headerlink" title="Future的注意点"></a><code>Future</code>的注意点</h2><ul>
<li>当for循环批量获取<code>Future</code>的结果时，容易发生一部分线程很慢的情况，<code>get</code>方法调用时应使用<code>timeout</code>限制</li>
<li><code>Future</code>的生命周期不能后退<ul>
<li>生命周期只能前进，不能后退，就和线程池的生命周期一样，一旦完成了任务，它就永远停在了“已完成”的状态，不能重头再来</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>精通JUC并发工具十八般武艺</tag>
      </tags>
  </entry>
  <entry>
    <title>Java字节码指令大全</title>
    <url>/2021/11/16/java%E5%9F%BA%E7%A1%80/Java%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<h1 id="二进制指令表"><a href="#二进制指令表" class="headerlink" title="二进制指令表"></a>二进制指令表</h1><h2 id="常量入栈指令"><a href="#常量入栈指令" class="headerlink" title="常量入栈指令"></a>常量入栈指令</h2><table>
<thead>
<tr>
<th align="center">指令码</th>
<th align="center">操作码（助记符）</th>
<th align="center">操作数</th>
<th align="left">描述（栈指操作数栈）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0x01</td>
<td align="center">aconst_null</td>
<td align="center"></td>
<td align="left">null值入栈</td>
</tr>
<tr>
<td align="center">0x02</td>
<td align="center">iconst_m1</td>
<td align="center"></td>
<td align="left">-1(int)值入栈</td>
</tr>
<tr>
<td align="center">0x03</td>
<td align="center">iconst_0</td>
<td align="center"></td>
<td align="left">0(int)值入栈</td>
</tr>
<tr>
<td align="center">0x04</td>
<td align="center">iconst_1</td>
<td align="center"></td>
<td align="left">1(int)值入栈</td>
</tr>
<tr>
<td align="center">0x05</td>
<td align="center">iconst_2</td>
<td align="center"></td>
<td align="left">2(int)值入栈</td>
</tr>
<tr>
<td align="center">0x06</td>
<td align="center">iconst_3</td>
<td align="center"></td>
<td align="left">3(int)值入栈</td>
</tr>
<tr>
<td align="center">0x07</td>
<td align="center">iconst_4</td>
<td align="center"></td>
<td align="left">4(int)值入栈</td>
</tr>
<tr>
<td align="center">0x08</td>
<td align="center">iconst_5</td>
<td align="center"></td>
<td align="left">5(int)值入栈</td>
</tr>
<tr>
<td align="center">0x09</td>
<td align="center">lconst_0</td>
<td align="center"></td>
<td align="left">0(long)值入栈</td>
</tr>
<tr>
<td align="center">0x0a</td>
<td align="center">lconst_1</td>
<td align="center"></td>
<td align="left">1(long)值入栈</td>
</tr>
<tr>
<td align="center">0x0b</td>
<td align="center">fconst_0</td>
<td align="center"></td>
<td align="left">0(float)值入栈</td>
</tr>
<tr>
<td align="center">0x0c</td>
<td align="center">fconst_1</td>
<td align="center"></td>
<td align="left">1(float)值入栈</td>
</tr>
<tr>
<td align="center">0x0d</td>
<td align="center">fconst_2</td>
<td align="center"></td>
<td align="left">2(float)值入栈</td>
</tr>
<tr>
<td align="center">0x0e</td>
<td align="center">dconst_0</td>
<td align="center"></td>
<td align="left">0(double)值入栈</td>
</tr>
<tr>
<td align="center">0x0f</td>
<td align="center">dconst_1</td>
<td align="center"></td>
<td align="left">1(double)值入栈</td>
</tr>
<tr>
<td align="center">0x10</td>
<td align="center">bipush</td>
<td align="center">valuebyte</td>
<td align="left">valuebyte值带符号扩展成int值入栈</td>
</tr>
<tr>
<td align="center">0x11</td>
<td align="center">sipush</td>
<td align="center">valuebyte1 <br> valuebyte2</td>
<td align="left">(valuebyte1&lt;&lt;8) &#124; valuebyte2值带符合扩展成int值入栈</td>
</tr>
<tr>
<td align="center">0x12</td>
<td align="center">ldc</td>
<td align="center">indexbyte1</td>
<td align="left">常量池中的常量值（int、float、string、reference、object reference）入栈</td>
</tr>
<tr>
<td align="center">0x13</td>
<td align="center">ldc_w</td>
<td align="center">indexbyte1 <br> indexByte2</td>
<td align="left">常量池中的常量（int、float、string、reference、object reference）入栈</td>
</tr>
<tr>
<td align="center">0x14</td>
<td align="center">ldc2_w</td>
<td align="center">indexbyte1 <br> indexbyte2</td>
<td align="left">常量池中常量（long、double）入栈</td>
</tr>
</tbody></table>
<blockquote>
<p>int类型在-1到5，使用iconst_x指令<br>int类型在-128到127，使用bipush指令<br>int类型在-32768到32767，使用sipush指令<br>在其他范围，使用ldc指令</p>
</blockquote>
<h2 id="局部变量值转载到栈中指令"><a href="#局部变量值转载到栈中指令" class="headerlink" title="局部变量值转载到栈中指令"></a>局部变量值转载到栈中指令</h2><table>
<thead>
<tr>
<th align="center">指令码</th>
<th align="center">操作码（助记符）</th>
<th align="center">操作数</th>
<th align="left">描述（栈指操作数栈）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0x19</td>
<td align="center">(wide)aload</td>
<td align="center">indexbyte</td>
<td align="left">从局部变量indexbyte中装载引用类型值入栈</td>
</tr>
<tr>
<td align="center">0x2a</td>
<td align="center">aload_0</td>
<td align="center"></td>
<td align="left">从局部变量0中装载引用类型值入栈</td>
</tr>
<tr>
<td align="center">0x2b</td>
<td align="center">aload_1</td>
<td align="center"></td>
<td align="left">从局部变量1中装载引用类型值入栈</td>
</tr>
<tr>
<td align="center">0x2c</td>
<td align="center">aload_2</td>
<td align="center"></td>
<td align="left">从局部变量2中装载引用类型值入栈</td>
</tr>
<tr>
<td align="center">0x2d</td>
<td align="center">aload_3</td>
<td align="center"></td>
<td align="left">从局部变量3中装载引用类型值入栈</td>
</tr>
<tr>
<td align="center">0x15</td>
<td align="center">(wide)iload</td>
<td align="center">indexbyte</td>
<td align="left">从局部变量indexbyte中装载int类型入栈</td>
</tr>
<tr>
<td align="center">0x1a</td>
<td align="center">iload_0</td>
<td align="center"></td>
<td align="left">从局部变量0中装载int类型值入栈</td>
</tr>
<tr>
<td align="center">0x1b</td>
<td align="center">iload_1</td>
<td align="center"></td>
<td align="left">从局部变量1中装载int类型值入栈</td>
</tr>
<tr>
<td align="center">0x1c</td>
<td align="center">iload_2</td>
<td align="center"></td>
<td align="left">从局部变量2中装载int类型值入栈</td>
</tr>
<tr>
<td align="center">0x1d</td>
<td align="center">iload_3</td>
<td align="center"></td>
<td align="left">从局部变量3中装载int类型值入栈</td>
</tr>
<tr>
<td align="center">0x16</td>
<td align="center">(wide)lload</td>
<td align="center">indexbyte</td>
<td align="left">从局部变量indexbyte中装载long类型值入栈</td>
</tr>
<tr>
<td align="center">0x1e</td>
<td align="center">lload_0</td>
<td align="center"></td>
<td align="left">从局部变量0中装载long类型值入栈</td>
</tr>
<tr>
<td align="center">0x1f</td>
<td align="center">lload_1</td>
<td align="center"></td>
<td align="left">从局部变量1中装载long类型值入栈</td>
</tr>
<tr>
<td align="center">0x20</td>
<td align="center">lload_2</td>
<td align="center"></td>
<td align="left">从局部变量2中装载long类型值入栈</td>
</tr>
<tr>
<td align="center">0x21</td>
<td align="center">lload_3</td>
<td align="center"></td>
<td align="left">从局部变量3中装载long类型值入栈</td>
</tr>
<tr>
<td align="center">0x17</td>
<td align="center">(wide)fload</td>
<td align="center">indexbyte</td>
<td align="left">从局部变量indexbyte中装载float类型值入栈</td>
</tr>
<tr>
<td align="center">0x22</td>
<td align="center">fload_0</td>
<td align="center"></td>
<td align="left">从局部变量0中装载float类型值入栈</td>
</tr>
<tr>
<td align="center">0x23</td>
<td align="center">fload_1</td>
<td align="center"></td>
<td align="left">从局部变量1中装载float类型值入栈</td>
</tr>
<tr>
<td align="center">0x24</td>
<td align="center">fload_2</td>
<td align="center"></td>
<td align="left">从局部变量2中装载float类型值入栈</td>
</tr>
<tr>
<td align="center">0x25</td>
<td align="center">fload_3</td>
<td align="center"></td>
<td align="left">从局部变量3中装载float类型值入栈</td>
</tr>
<tr>
<td align="center">0x18</td>
<td align="center">(wide)dload</td>
<td align="center">indexbyte</td>
<td align="left">从局部变量indexbyte中装载double类型值入栈</td>
</tr>
<tr>
<td align="center">0x26</td>
<td align="center">dload_0</td>
<td align="center"></td>
<td align="left">从局部变量0中装载double类型值入栈</td>
</tr>
<tr>
<td align="center">0x27</td>
<td align="center">dload_1</td>
<td align="center"></td>
<td align="left">从局部变量1中装载double类型值入栈</td>
</tr>
<tr>
<td align="center">0x28</td>
<td align="center">dload_2</td>
<td align="center"></td>
<td align="left">从局部变量2中装载double类型值入栈</td>
</tr>
<tr>
<td align="center">0x29</td>
<td align="center">dload_3</td>
<td align="center"></td>
<td align="left">从局部变量3中装载double类型值入栈</td>
</tr>
<tr>
<td align="center">0x32</td>
<td align="center">aaload</td>
<td align="center"></td>
<td align="left">从引用类型数组中装载指定项的值</td>
</tr>
<tr>
<td align="center">0x2e</td>
<td align="center">iaload</td>
<td align="center"></td>
<td align="left">从int类型数组中装载指定项的值</td>
</tr>
<tr>
<td align="center">0x2f</td>
<td align="center">laload</td>
<td align="center"></td>
<td align="left">从long类型数组中装载指定项的值</td>
</tr>
<tr>
<td align="center">0x30</td>
<td align="center">faload</td>
<td align="center"></td>
<td align="left">从float类型数组中装载指定项的值</td>
</tr>
<tr>
<td align="center">0x31</td>
<td align="center">daload</td>
<td align="center"></td>
<td align="left">从double类型数组中装载指定项的值</td>
</tr>
<tr>
<td align="center">0x33</td>
<td align="center">baload</td>
<td align="center"></td>
<td align="left">从boolean类型数组或byte类型数组中装载指定项的值（先转为int类型的值，后压栈）</td>
</tr>
<tr>
<td align="center">0x34</td>
<td align="center">caload</td>
<td align="center"></td>
<td align="left">从char类型数组中装载指定项的值（先转为int类型的值，后压栈）</td>
</tr>
<tr>
<td align="center">0x35</td>
<td align="center">saload</td>
<td align="center"></td>
<td align="left">从short类型数组中装载指定项的值（先转为int类型的值，后压栈）</td>
</tr>
</tbody></table>
<blockquote>
<p>如果是静态方法，局部变量指令编号从0开始如：aload_0<br>如果是普通方法，局部变量指令编号从1开始如：aload_1<br>构造函数中为调用指令aload_0，代表this<br>double和long类型的局部变量会使用两个编号<br>局部变量表的容量以变量槽(Variable Slot)为最小单位。每个变量槽都可以存储32位长度的内存空间，例如boolean、byte、char、short、int、float、reference。<br>对于64位长度的数据类型（long，double），虚拟机会以高位对齐方式为其分配两个连续的Slot空间，也就是相当于把一次long和double数据类型读写分割成为两次32位读写。</p>
</blockquote>
<h2 id="将栈顶值保存到局部变量中指令"><a href="#将栈顶值保存到局部变量中指令" class="headerlink" title="将栈顶值保存到局部变量中指令"></a>将栈顶值保存到局部变量中指令</h2><table>
<thead>
<tr>
<th align="center">指令码</th>
<th align="center">操作码（助记符）</th>
<th align="center">操作数</th>
<th align="left">描述（栈指操作数栈）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0x3a</td>
<td align="center">(wide)astore</td>
<td align="center">indexbyte</td>
<td align="left">将栈顶引用类型值保存到局部变量indexbyte中</td>
</tr>
<tr>
<td align="center">0x4b</td>
<td align="center">astore_0</td>
<td align="center"></td>
<td align="left">将栈顶引用类型值保存到局部变量0中</td>
</tr>
<tr>
<td align="center">0x4c</td>
<td align="center">astore_1</td>
<td align="center"></td>
<td align="left">将栈顶引用类型值保存到局部变量1中</td>
</tr>
<tr>
<td align="center">0x4d</td>
<td align="center">astore_2</td>
<td align="center"></td>
<td align="left">将栈顶引用类型值保存到局部变量2中</td>
</tr>
<tr>
<td align="center">0x4e</td>
<td align="center">astore_3</td>
<td align="center"></td>
<td align="left">将栈顶引用类型值保存到局部变量3中</td>
</tr>
<tr>
<td align="center">0x36</td>
<td align="center">(wide)istore</td>
<td align="center">indexbyte</td>
<td align="left">将栈顶int类型值保存到局部变量indexbyte中</td>
</tr>
<tr>
<td align="center">0x3b</td>
<td align="center">istore_0</td>
<td align="center"></td>
<td align="left">将栈顶int类型值保存到局部变量0中</td>
</tr>
<tr>
<td align="center">0x3c</td>
<td align="center">istore_1</td>
<td align="center"></td>
<td align="left">将栈顶int类型值保存到局部变量1中</td>
</tr>
<tr>
<td align="center">0x3d</td>
<td align="center">istore_2</td>
<td align="center"></td>
<td align="left">将栈顶int类型值保存到局部变量2中</td>
</tr>
<tr>
<td align="center">0x3e</td>
<td align="center">istore_3</td>
<td align="center"></td>
<td align="left">将栈顶int类型值保存到局部变量3中</td>
</tr>
<tr>
<td align="center">0x37</td>
<td align="center">(wide)lstore</td>
<td align="center">indexbyte</td>
<td align="left">将栈顶long类型值保存到局部变量indexbyte中</td>
</tr>
<tr>
<td align="center">0x3f</td>
<td align="center">lstore_0</td>
<td align="center"></td>
<td align="left">将栈顶long类型值保存到局部变量0中</td>
</tr>
<tr>
<td align="center">0x40</td>
<td align="center">lstore_1</td>
<td align="center"></td>
<td align="left">将栈顶long类型值保存到局部变量1中</td>
</tr>
<tr>
<td align="center">0x41</td>
<td align="center">lstore_2</td>
<td align="center"></td>
<td align="left">将栈顶long类型值保存到局部变量2中</td>
</tr>
<tr>
<td align="center">0x42</td>
<td align="center">lstore_3</td>
<td align="center"></td>
<td align="left">将栈顶long类型值保存到局部变量3中</td>
</tr>
<tr>
<td align="center">0x38</td>
<td align="center">(wide)fstore</td>
<td align="center">indexbyte</td>
<td align="left">将栈顶float类型值保存到局部变量indexbyte中</td>
</tr>
<tr>
<td align="center">0x43</td>
<td align="center">fstore_0</td>
<td align="center"></td>
<td align="left">将栈顶float类型值保存到局部变量0中</td>
</tr>
<tr>
<td align="center">0x44</td>
<td align="center">fstore_1</td>
<td align="center"></td>
<td align="left">将栈顶float类型值保存到局部变量1中</td>
</tr>
<tr>
<td align="center">0x45</td>
<td align="center">fstore_2</td>
<td align="center"></td>
<td align="left">将栈顶float类型值保存到局部变量2中</td>
</tr>
<tr>
<td align="center">0x46</td>
<td align="center">fstore_3</td>
<td align="center"></td>
<td align="left">将栈顶float类型值保存到局部变量3中</td>
</tr>
<tr>
<td align="center">0x37</td>
<td align="center">(wide)dstore</td>
<td align="center">indexbyte</td>
<td align="left">将栈顶double类型值保存到局部变量indexbyte中</td>
</tr>
<tr>
<td align="center">0x3f</td>
<td align="center">dstore_0</td>
<td align="center"></td>
<td align="left">将栈顶double类型值保存到局部变量0中</td>
</tr>
<tr>
<td align="center">0x40</td>
<td align="center">dstore_1</td>
<td align="center"></td>
<td align="left">将栈顶double类型值保存到局部变量1中</td>
</tr>
<tr>
<td align="center">0x41</td>
<td align="center">dstore_2</td>
<td align="center"></td>
<td align="left">将栈顶double类型值保存到局部变量2中</td>
</tr>
<tr>
<td align="center">0x42</td>
<td align="center">dstore_3</td>
<td align="center"></td>
<td align="left">将栈顶double类型值保存到局部变量3中</td>
</tr>
<tr>
<td align="center">0x53</td>
<td align="center">aastore</td>
<td align="center"></td>
<td align="left">将栈顶引用类型值保存到指定引用类型数组的指定项</td>
</tr>
<tr>
<td align="center">0x4f</td>
<td align="center">iastore</td>
<td align="center"></td>
<td align="left">将栈顶int类型值保存到指定int类型数组的指定项</td>
</tr>
<tr>
<td align="center">0x50</td>
<td align="center">lastore</td>
<td align="center"></td>
<td align="left">将栈顶long类型值保存到指定long类型数组的指定项</td>
</tr>
<tr>
<td align="center">0x51</td>
<td align="center">fastore</td>
<td align="center"></td>
<td align="left">将栈顶float类型值保存到指定float类型数组的指定项</td>
</tr>
<tr>
<td align="center">0x52</td>
<td align="center">dastore</td>
<td align="center"></td>
<td align="left">将栈顶double类型值保存到指定double类型数组的指定项</td>
</tr>
<tr>
<td align="center">0x54</td>
<td align="center">bastore</td>
<td align="center"></td>
<td align="left">将栈顶boolean类型值或byte类型值保存到指定boolean类型数组或byte类型数组的指定项</td>
</tr>
<tr>
<td align="center">0x55</td>
<td align="center">castore</td>
<td align="center"></td>
<td align="left">将栈顶char类型值保存到指定char类型数组的指定项</td>
</tr>
<tr>
<td align="center">0x56</td>
<td align="center">sastore</td>
<td align="center"></td>
<td align="left">将栈顶short类型值保存到指定short类型数组的指定项</td>
</tr>
</tbody></table>
<h2 id="wide指令"><a href="#wide指令" class="headerlink" title="wide指令"></a>wide指令</h2><table>
<thead>
<tr>
<th align="center">指令码</th>
<th align="center">操作码（助记符）</th>
<th align="center">操作数</th>
<th align="left">描述（栈指操作数栈）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0xc4</td>
<td align="center">wide</td>
<td align="center"></td>
<td align="left">使用附加字节扩展局部变量索引（linc指令特殊）</td>
</tr>
</tbody></table>
<h2 id="通用（无类型）栈操作指令"><a href="#通用（无类型）栈操作指令" class="headerlink" title="通用（无类型）栈操作指令"></a>通用（无类型）栈操作指令</h2><table>
<thead>
<tr>
<th align="center">指令码</th>
<th align="center">操作码（助记符）</th>
<th align="center">操作数</th>
<th align="left">描述（栈指操作数栈）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0x00</td>
<td align="center">nop</td>
<td align="center"></td>
<td align="left">空操作</td>
</tr>
<tr>
<td align="center">0x57</td>
<td align="center">pop</td>
<td align="center"></td>
<td align="left">从栈顶弹出一个字长的数据</td>
</tr>
<tr>
<td align="center">0x58</td>
<td align="center">pop2</td>
<td align="center"></td>
<td align="left">从栈顶弹出两个字长的数据</td>
</tr>
<tr>
<td align="center">0x59</td>
<td align="center">dup</td>
<td align="center"></td>
<td align="left">复制栈顶一个字长的数据，将复制后的数据压栈</td>
</tr>
<tr>
<td align="center">0x5a</td>
<td align="center">dup_x1</td>
<td align="center"></td>
<td align="left">复制栈顶一个字长的数据，弹出栈顶两个字长的数据，将复制后的数据压栈，再将弹出的两个字长数据压栈</td>
</tr>
<tr>
<td align="center">0x5b</td>
<td align="center">dup_x2</td>
<td align="center"></td>
<td align="left">复制栈顶一个字长的数据，弹出栈顶三个字长的数据，将复制后的数据压栈，再将弹出的三个字长数据压栈</td>
</tr>
<tr>
<td align="center">0x5c</td>
<td align="center">dup2</td>
<td align="center"></td>
<td align="left">复制栈顶两个字长的数据，将复制后的数据压栈</td>
</tr>
<tr>
<td align="center">0x5d</td>
<td align="center">dup2_x1</td>
<td align="center"></td>
<td align="left">复制栈顶两个字长的数据，弹出栈顶三个字长的数据，将复制后的数据压栈，再将弹出的三个字长数据压栈</td>
</tr>
<tr>
<td align="center">0x5e</td>
<td align="center">dup2_x2</td>
<td align="center"></td>
<td align="left">复制栈顶两个字长的数据，弹出栈顶四个字长的数据，将复制后的数据压栈，再将弹出的四个字长数据压栈</td>
</tr>
<tr>
<td align="center">0x5f</td>
<td align="center">swap</td>
<td align="center"></td>
<td align="left">交换栈顶两个字长的数据的位置，Java指令中没有提供以两个字节长为单位的交换指令</td>
</tr>
</tbody></table>
<h2 id="类型转换指令"><a href="#类型转换指令" class="headerlink" title="类型转换指令"></a>类型转换指令</h2><table>
<thead>
<tr>
<th align="center">指令码</th>
<th align="center">操作码（助记符）</th>
<th align="center">操作数</th>
<th align="left">描述（栈指操作数栈）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0x86</td>
<td align="center">i2f</td>
<td align="center"></td>
<td align="left">将栈顶int类型值转换成float类型值</td>
</tr>
<tr>
<td align="center">0x85</td>
<td align="center">i2l</td>
<td align="center"></td>
<td align="left">将栈顶int类型值转换成long类型值</td>
</tr>
<tr>
<td align="center">0x87</td>
<td align="center">i2d</td>
<td align="center"></td>
<td align="left">将栈顶int类型值转换成double类型值</td>
</tr>
<tr>
<td align="center">0x8b</td>
<td align="center">f2i</td>
<td align="center"></td>
<td align="left">将栈顶float类型值转换成int类型值</td>
</tr>
<tr>
<td align="center">0x8c</td>
<td align="center">f2l</td>
<td align="center"></td>
<td align="left">将栈顶float类型值转换成long类型值</td>
</tr>
<tr>
<td align="center">0x8d</td>
<td align="center">f2d</td>
<td align="center"></td>
<td align="left">将栈顶float类型值转换成double类型值</td>
</tr>
<tr>
<td align="center">0x88</td>
<td align="center">l2i</td>
<td align="center"></td>
<td align="left">将栈顶long类型值转换成int类型值</td>
</tr>
<tr>
<td align="center">0x89</td>
<td align="center">l2f</td>
<td align="center"></td>
<td align="left">将栈顶long类型值转换成float类型值</td>
</tr>
<tr>
<td align="center">0x8a</td>
<td align="center">l2d</td>
<td align="center"></td>
<td align="left">将栈顶long类型值转换成double类型值</td>
</tr>
<tr>
<td align="center">0x8e</td>
<td align="center">d2i</td>
<td align="center"></td>
<td align="left">将栈顶double类型值转换成int类型值</td>
</tr>
<tr>
<td align="center">0x90</td>
<td align="center">d2f</td>
<td align="center"></td>
<td align="left">将栈顶double类型值转换成float类型值</td>
</tr>
<tr>
<td align="center">0x8f</td>
<td align="center">d2l</td>
<td align="center"></td>
<td align="left">将栈顶double类型值转换成long类型值</td>
</tr>
<tr>
<td align="center">0x91</td>
<td align="center">i2b</td>
<td align="center"></td>
<td align="left">将栈顶int类型值截断成byte类型，后带符合扩展成int类型值入栈</td>
</tr>
<tr>
<td align="center">0x92</td>
<td align="center">i2c</td>
<td align="center"></td>
<td align="left">将栈顶int类型值截断成char类型值，后带符号扩展成int类型值入栈</td>
</tr>
<tr>
<td align="center">0x93</td>
<td align="center">i2s</td>
<td align="center"></td>
<td align="left">将栈顶int类型值截断成short类型值，后带符号扩展成int类型值入栈</td>
</tr>
</tbody></table>
<h2 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h2><table>
<thead>
<tr>
<th align="center">指令码</th>
<th align="center">操作码（助记符）</th>
<th align="center">操作数</th>
<th align="left">描述（栈指操作数栈）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0x60</td>
<td align="center">iadd</td>
<td align="center"></td>
<td align="left">将栈顶两int类型整数相加，结果入栈</td>
</tr>
<tr>
<td align="center">0x64</td>
<td align="center">isub</td>
<td align="center"></td>
<td align="left">将栈顶两int类型整数相减，结果入栈</td>
</tr>
<tr>
<td align="center">0x68</td>
<td align="center">imul</td>
<td align="center"></td>
<td align="left">将栈顶两int类型整数相乘，结果入栈</td>
</tr>
<tr>
<td align="center">0x6c</td>
<td align="center">idiv</td>
<td align="center"></td>
<td align="left">将栈顶两int类型整数相除，结果入栈</td>
</tr>
<tr>
<td align="center">0x70</td>
<td align="center">irem</td>
<td align="center"></td>
<td align="left">将栈顶两int类型整数取模，结果入栈</td>
</tr>
<tr>
<td align="center">0x74</td>
<td align="center">ineg</td>
<td align="center"></td>
<td align="left">将栈顶两int类型值取负，结果入栈</td>
</tr>
<tr>
<td align="center">0x61</td>
<td align="center">ladd</td>
<td align="center"></td>
<td align="left">将栈顶两long类型整数相加，结果入栈</td>
</tr>
<tr>
<td align="center">0x65</td>
<td align="center">lsub</td>
<td align="center"></td>
<td align="left">将栈顶两long类型整数相减，结果入栈</td>
</tr>
<tr>
<td align="center">0x69</td>
<td align="center">lmul</td>
<td align="center"></td>
<td align="left">将栈顶两long类型整数相乘，结果入栈</td>
</tr>
<tr>
<td align="center">0x6d</td>
<td align="center">ldiv</td>
<td align="center"></td>
<td align="left">将栈顶两long类型整数相除，结果入栈</td>
</tr>
<tr>
<td align="center">0x71</td>
<td align="center">lrem</td>
<td align="center"></td>
<td align="left">将栈顶两long类型整数取模，结果入栈</td>
</tr>
<tr>
<td align="center">0x75</td>
<td align="center">lneg</td>
<td align="center"></td>
<td align="left">将栈顶long类型值取负，结果入栈</td>
</tr>
<tr>
<td align="center">0x84</td>
<td align="center">(wide)iinc</td>
<td align="center">indexbyte<br>constbyte</td>
<td align="left">将整数值constbyte加到indexbyte指定的int类型的局部变量中</td>
</tr>
</tbody></table>
<h2 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h2><table>
<thead>
<tr>
<th align="center">指令码</th>
<th align="center">操作码（助记符）</th>
<th align="center">操作数</th>
<th align="left">描述（栈指操作数栈）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0x62</td>
<td align="center">fadd</td>
<td align="center"></td>
<td align="left">将栈顶两float类型数相加，结果入栈</td>
</tr>
<tr>
<td align="center">0x66</td>
<td align="center">fsub</td>
<td align="center"></td>
<td align="left">将栈顶两float类型数相减，结果入栈</td>
</tr>
<tr>
<td align="center">0x6a</td>
<td align="center">fmul</td>
<td align="center"></td>
<td align="left">将栈顶两float类型数相乘，结果入栈</td>
</tr>
<tr>
<td align="center">0x6e</td>
<td align="center">fdiv</td>
<td align="center"></td>
<td align="left">将栈顶两float类型数相除，结果入栈</td>
</tr>
<tr>
<td align="center">0x72</td>
<td align="center">frem</td>
<td align="center"></td>
<td align="left">将栈顶两float类型数取模，结果入栈</td>
</tr>
<tr>
<td align="center">0x76</td>
<td align="center">fneg</td>
<td align="center"></td>
<td align="left">将栈顶float类型值取反，结果入栈</td>
</tr>
<tr>
<td align="center">0x63</td>
<td align="center">dadd</td>
<td align="center"></td>
<td align="left">将栈顶两double类型数相加，结果入栈</td>
</tr>
<tr>
<td align="center">0x67</td>
<td align="center">dsub</td>
<td align="center"></td>
<td align="left">将栈顶两double类型数相减，结果入栈</td>
</tr>
<tr>
<td align="center">0x6b</td>
<td align="center">dmul</td>
<td align="center"></td>
<td align="left">将栈顶两double类型数相乘，结果入栈</td>
</tr>
<tr>
<td align="center">0x6f</td>
<td align="center">ddiv</td>
<td align="center"></td>
<td align="left">将栈顶两double类型数相除，结果入栈</td>
</tr>
<tr>
<td align="center">0x73</td>
<td align="center">drem</td>
<td align="center"></td>
<td align="left">将栈顶两double类型数取模，结果入栈</td>
</tr>
<tr>
<td align="center">0x77</td>
<td align="center">dneg</td>
<td align="center"></td>
<td align="left">将栈顶double类型值取反，结果入栈</td>
</tr>
</tbody></table>
<h2 id="逻辑运算——位移运算"><a href="#逻辑运算——位移运算" class="headerlink" title="逻辑运算——位移运算"></a>逻辑运算——位移运算</h2><table>
<thead>
<tr>
<th align="center">指令码</th>
<th align="center">操作码（助记符）</th>
<th align="center">操作数</th>
<th align="left">描述（栈指操作数栈）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0x78</td>
<td align="center">ishl</td>
<td align="center"></td>
<td align="left">左移int类型值</td>
</tr>
<tr>
<td align="center">0x79</td>
<td align="center">lshl</td>
<td align="center"></td>
<td align="left">左移long类型值</td>
</tr>
<tr>
<td align="center">0x7a</td>
<td align="center">ishr</td>
<td align="center"></td>
<td align="left">算术右移int类型值</td>
</tr>
<tr>
<td align="center">0x7b</td>
<td align="center">lshr</td>
<td align="center"></td>
<td align="left">算术右移long类型值</td>
</tr>
<tr>
<td align="center">0x7c</td>
<td align="center">iushr</td>
<td align="center"></td>
<td align="left">逻辑右移int类型值</td>
</tr>
<tr>
<td align="center">0x7d</td>
<td align="center">lushr</td>
<td align="center"></td>
<td align="left">逻辑右移long类型值</td>
</tr>
</tbody></table>
<h2 id="逻辑运算——按位布尔运算"><a href="#逻辑运算——按位布尔运算" class="headerlink" title="逻辑运算——按位布尔运算"></a>逻辑运算——按位布尔运算</h2><table>
<thead>
<tr>
<th align="center">指令码</th>
<th align="center">操作码（助记符）</th>
<th align="center">操作数</th>
<th align="left">描述（栈指操作数栈）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0x73</td>
<td align="center">iand</td>
<td align="center"></td>
<td align="left">对int类型的按位与运算</td>
</tr>
<tr>
<td align="center">0x7f</td>
<td align="center">land</td>
<td align="center"></td>
<td align="left">对long类型的按位与运算</td>
</tr>
<tr>
<td align="center">0x80</td>
<td align="center">ior</td>
<td align="center"></td>
<td align="left">对int类型的按位或运算</td>
</tr>
<tr>
<td align="center">0x81</td>
<td align="center">lor</td>
<td align="center"></td>
<td align="left">对long类型的按位或运算</td>
</tr>
<tr>
<td align="center">0x82</td>
<td align="center">ixor</td>
<td align="center"></td>
<td align="left">对int类型的按位异或运算</td>
</tr>
<tr>
<td align="center">0x83</td>
<td align="center">lxor</td>
<td align="center"></td>
<td align="left">对long类型的按位异或运算</td>
</tr>
</tbody></table>
<h2 id="控制流指令——条件跳转指令"><a href="#控制流指令——条件跳转指令" class="headerlink" title="控制流指令——条件跳转指令"></a>控制流指令——条件跳转指令</h2><table>
<thead>
<tr>
<th align="center">指令码</th>
<th align="center">操作码（助记符）</th>
<th align="center">操作数</th>
<th align="left">描述（栈指操作数栈）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0x99</td>
<td align="center">ifeq</td>
<td align="center">branchbyte1<br>branchbyte2</td>
<td align="left">若栈顶int类型值为0则跳转</td>
</tr>
<tr>
<td align="center">0x9a</td>
<td align="center">ifne</td>
<td align="center">branchbyte1<br>branchbyte2</td>
<td align="left">若栈顶int类型值不为0则跳转</td>
</tr>
<tr>
<td align="center">0x9b</td>
<td align="center">iflt</td>
<td align="center">branchbyte1<br>branchbyte2</td>
<td align="left">若栈顶int类型值小于0则跳转</td>
</tr>
<tr>
<td align="center">0x9e</td>
<td align="center">ifle</td>
<td align="center">branchbyte1<br>branchbyte2</td>
<td align="left">若栈顶int类型值小于等于0则跳转</td>
</tr>
<tr>
<td align="center">0x9d</td>
<td align="center">ifgt</td>
<td align="center">branchbyte1<br>branchbyte2</td>
<td align="left">若栈顶int类型值大于0则跳转</td>
</tr>
<tr>
<td align="center">0x9c</td>
<td align="center">ifge</td>
<td align="center">branchbyte1<br>branchbyte2</td>
<td align="left">若栈顶int类型值大于等于0则跳转</td>
</tr>
<tr>
<td align="center">0x9f</td>
<td align="center">if_icmpeq</td>
<td align="center">branchbyte1<br>branchbyte2</td>
<td align="left">若栈顶两int类型值相等则跳转</td>
</tr>
<tr>
<td align="center">0xa0</td>
<td align="center">if_icmpne</td>
<td align="center">branchbyte1<br>branchbyte2</td>
<td align="left">若栈顶两int类型值不相等则跳转</td>
</tr>
<tr>
<td align="center">0xa1</td>
<td align="center">if_icmplt</td>
<td align="center">branchbyte1<br>branchbyte2</td>
<td align="left">若栈顶两int类型值前小于后则跳转</td>
</tr>
<tr>
<td align="center">0xa4</td>
<td align="center">if_icmple</td>
<td align="center">branchbyte1<br>branchbyte2</td>
<td align="left">若栈顶两int类型值前小于等于后则跳转</td>
</tr>
<tr>
<td align="center">0xa3</td>
<td align="center">if_icmpgt</td>
<td align="center">branchbyte1<br>branchbyte2</td>
<td align="left">若栈顶两int类型值前大于后则跳转</td>
</tr>
<tr>
<td align="center">0xa2</td>
<td align="center">if_icmpge</td>
<td align="center">branchbyte1<br>branchbyte2</td>
<td align="left">若栈顶两int类型值前大于等于后则跳转</td>
</tr>
<tr>
<td align="center">0xc6</td>
<td align="center">ifnull</td>
<td align="center">branchbyte1<br>branchbyte2</td>
<td align="left">若栈顶引用值为null则跳转</td>
</tr>
<tr>
<td align="center">0xc7</td>
<td align="center">ifnonnull</td>
<td align="center">branchbyte1<br>branchbyte2</td>
<td align="left">若栈顶引用值不为null则跳转</td>
</tr>
<tr>
<td align="center">0xa5</td>
<td align="center">if_acmpeq</td>
<td align="center">branchbyte1<br>branchbyte2</td>
<td align="left">若栈顶两引用类型值相等则跳转</td>
</tr>
<tr>
<td align="center">0xa6</td>
<td align="center">if_acmpne</td>
<td align="center">branchbyte1<br>branchbyte2</td>
<td align="left">若栈顶两引用类型值不相等则跳转</td>
</tr>
</tbody></table>
<h2 id="控制流指令——比较指令"><a href="#控制流指令——比较指令" class="headerlink" title="控制流指令——比较指令"></a>控制流指令——比较指令</h2><table>
<thead>
<tr>
<th align="center">指令码</th>
<th align="center">操作码（助记符）</th>
<th align="center">操作数</th>
<th align="left">描述（栈指操作数栈）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0x94</td>
<td align="center">lcmp</td>
<td align="center"></td>
<td align="left">比较栈顶两long类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈</td>
</tr>
<tr>
<td align="center">0x95</td>
<td align="center">fcmpl</td>
<td align="center"></td>
<td align="left">比较栈顶两float类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈；有NaN存在，-1入栈</td>
</tr>
<tr>
<td align="center">0x96</td>
<td align="center">fcmpg</td>
<td align="center"></td>
<td align="left">比较栈顶两float类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈；有NaN存在，-1入栈</td>
</tr>
<tr>
<td align="center">0x97</td>
<td align="center">dcmpl</td>
<td align="center"></td>
<td align="left">比较栈顶两double类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈；有NaN存在，-1入栈</td>
</tr>
<tr>
<td align="center">0x98</td>
<td align="center">dcmpg</td>
<td align="center"></td>
<td align="left">比较栈顶两float类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈；有NaN存在，-1入栈</td>
</tr>
</tbody></table>
<h2 id="控制流指令——无条件跳转指令"><a href="#控制流指令——无条件跳转指令" class="headerlink" title="控制流指令——无条件跳转指令"></a>控制流指令——无条件跳转指令</h2><table>
<thead>
<tr>
<th align="center">指令码</th>
<th align="center">操作码（助记符）</th>
<th align="center">操作数</th>
<th align="left">描述（栈指操作数栈）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0xa7</td>
<td align="center">goto</td>
<td align="center">branchbyte1<br>branchbyte2</td>
<td align="left">无条件跳转到指定位置</td>
</tr>
<tr>
<td align="center">0xc8</td>
<td align="center">goto_w</td>
<td align="center">branchbyte1<br>branchbyte2<br>branchbyte3<br>branchbyte4</td>
<td align="left">无条件跳转到执行位置（宽索引）</td>
</tr>
</tbody></table>
<h2 id="控制流指令——表跳转指令"><a href="#控制流指令——表跳转指令" class="headerlink" title="控制流指令——表跳转指令"></a>控制流指令——表跳转指令</h2><table>
<thead>
<tr>
<th align="center">指令码</th>
<th align="center">操作码（助记符）</th>
<th align="center">操作数</th>
<th align="left">描述（栈指操作数栈）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0xaa</td>
<td align="center">tablewitch</td>
<td align="center">&lt;0-3bytepad&gt;<br>defaultbyte1<br>defaultbyte2<br>defaultbyte3<br>defaultbyte4<br>lowbyte1<br>lowbyte2<br>lowbyte3<br>lowbyte4<br>highbyte1<br>highbyte2<br>highbyte3<br>highbyte4<br>jump offsets…</td>
<td align="left">通过索引访问跳转表，并跳转</td>
</tr>
<tr>
<td align="center">0xab</td>
<td align="center">lookupswitch</td>
<td align="center">&lt;0-3bytepad&gt;<br>defaultbyte1<br>defaultbyte2<br>defaultbyte3<br>defaultbyte4<br>npairs1<br>npairs2<br>npairs3<br>npairs4<br>match offsets</td>
<td align="left">通过键值访问跳转表，并跳转</td>
</tr>
</tbody></table>
<h2 id="控制流指令——异常和finally"><a href="#控制流指令——异常和finally" class="headerlink" title="控制流指令——异常和finally"></a>控制流指令——异常和finally</h2><table>
<thead>
<tr>
<th align="center">指令码</th>
<th align="center">操作码（助记符）</th>
<th align="center">操作数</th>
<th align="left">描述（栈指操作数栈）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0xbf</td>
<td align="center">athrow</td>
<td align="center"></td>
<td align="left">抛出异常</td>
</tr>
<tr>
<td align="center">0xa8</td>
<td align="center">jsr</td>
<td align="center">branchbyte1<br>branchbyte2</td>
<td align="left">跳转到子例程序</td>
</tr>
<tr>
<td align="center">0xc9</td>
<td align="center">jsr_w</td>
<td align="center">branchbyte1<br>branchbyte2<br>branchbyte3<br>branchbyte4</td>
<td align="left">跳转都子例程序（宽索引）</td>
</tr>
<tr>
<td align="center">oxa9</td>
<td align="center">(widde)ret</td>
<td align="center">indexbyte</td>
<td align="left">返回子例程序</td>
</tr>
</tbody></table>
<h2 id="对象操作指令"><a href="#对象操作指令" class="headerlink" title="对象操作指令"></a>对象操作指令</h2><table>
<thead>
<tr>
<th align="center">指令码</th>
<th align="center">操作码（助记符）</th>
<th align="center">操作数</th>
<th align="left">描述（栈指操作数栈）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0xbb</td>
<td align="center">new</td>
<td align="center">indexbyte1<br>indexbyte2</td>
<td align="left">创建新的实例对象</td>
</tr>
<tr>
<td align="center">0xc0</td>
<td align="center">checkcast</td>
<td align="center">indexbyte1<br>indexbyte</td>
<td align="left">类型强转</td>
</tr>
<tr>
<td align="center">0xc1</td>
<td align="center">instanceof</td>
<td align="center">indexbyte1<br>indexbyte2</td>
<td align="left">判断类型</td>
</tr>
<tr>
<td align="center">0xb4</td>
<td align="center">getfield</td>
<td align="center">indexbyte1<br>indexbyte2</td>
<td align="left">获取对象字段的值</td>
</tr>
<tr>
<td align="center">0xb5</td>
<td align="center">putfield</td>
<td align="center">indexbyte1<br>indexbyte2</td>
<td align="left">给对象字段赋值</td>
</tr>
<tr>
<td align="center">0xb2</td>
<td align="center">getstatic</td>
<td align="center">indexbyte1<br>indexbyte2</td>
<td align="left">获取静态字段的值</td>
</tr>
<tr>
<td align="center">0xb3</td>
<td align="center">putstatic</td>
<td align="center">indexbyte1<br>indexbyte2</td>
<td align="left">给静态字段赋值</td>
</tr>
</tbody></table>
<h2 id="数组操作指令"><a href="#数组操作指令" class="headerlink" title="数组操作指令"></a>数组操作指令</h2><table>
<thead>
<tr>
<th align="center">指令码</th>
<th align="center">操作码（助记符）</th>
<th align="center">操作数</th>
<th align="left">描述（栈指操作数栈）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0xbc</td>
<td align="center">newarray</td>
<td align="center">atype</td>
<td align="left">创建type类型的数组</td>
</tr>
<tr>
<td align="center">0xbd</td>
<td align="center">anewarray</td>
<td align="center">indexbyte1<br>indexbyte2</td>
<td align="left">创建引用类型的数组</td>
</tr>
<tr>
<td align="center">0xbe</td>
<td align="center">arraylength</td>
<td align="center"></td>
<td align="left">获取一维数组的长度</td>
</tr>
<tr>
<td align="center">0xc5</td>
<td align="center">multianewarray</td>
<td align="center">indexbyte1<br>indexbyte2<br>dimension</td>
<td align="left">创建dimension维度的数组</td>
</tr>
</tbody></table>
<h2 id="方法调用指令"><a href="#方法调用指令" class="headerlink" title="方法调用指令"></a>方法调用指令</h2><table>
<thead>
<tr>
<th align="center">指令码</th>
<th align="center">操作码（助记符）</th>
<th align="center">操作数</th>
<th align="left">描述（栈指操作数栈）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0xb7</td>
<td align="center">invokespecial</td>
<td align="center">indexbyte1<br>indexbyte2</td>
<td align="left">编译时方法绑定调用方法</td>
</tr>
<tr>
<td align="center">0xb6</td>
<td align="center">invokvirtual</td>
<td align="center">indexbyte1<br>indexbyte2</td>
<td align="left">运行时方法绑定调用方法</td>
</tr>
<tr>
<td align="center">0xb8</td>
<td align="center">invokestatic</td>
<td align="center">indexbyte1<br>indexbyte2</td>
<td align="left">调用静态方法</td>
</tr>
<tr>
<td align="center">0xb9</td>
<td align="center">invokeinterface</td>
<td align="center">indexbyte1<br>indexbyte2<br>count<br>0</td>
<td align="left">调用接口方法</td>
</tr>
</tbody></table>
<h2 id="方法返回指令"><a href="#方法返回指令" class="headerlink" title="方法返回指令"></a>方法返回指令</h2><table>
<thead>
<tr>
<th align="center">指令码</th>
<th align="center">操作码（助记符）</th>
<th align="center">操作数</th>
<th align="left">描述（栈指操作数栈）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0xac</td>
<td align="center">ireturn</td>
<td align="center"></td>
<td align="left">返回int类型值</td>
</tr>
<tr>
<td align="center">0xad</td>
<td align="center">lreturn</td>
<td align="center"></td>
<td align="left">返回long类型值</td>
</tr>
<tr>
<td align="center">0xae</td>
<td align="center">freturn</td>
<td align="center"></td>
<td align="left">返回float类型值</td>
</tr>
<tr>
<td align="center">0xaf</td>
<td align="center">dreturn</td>
<td align="center"></td>
<td align="left">返回double类型值</td>
</tr>
<tr>
<td align="center">0xb0</td>
<td align="center">areturn</td>
<td align="center"></td>
<td align="left">返回引用类型值</td>
</tr>
<tr>
<td align="center">0xb1</td>
<td align="center">return</td>
<td align="center"></td>
<td align="left">viod函数返回</td>
</tr>
</tbody></table>
<h2 id="线程同步指令"><a href="#线程同步指令" class="headerlink" title="线程同步指令"></a>线程同步指令</h2><table>
<thead>
<tr>
<th align="center">指令码</th>
<th align="center">操作码（助记符）</th>
<th align="center">操作数</th>
<th align="left">描述（栈指操作数栈）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0xc2</td>
<td align="center">monitorenter</td>
<td align="center"></td>
<td align="left">进入并获得对象监视器</td>
</tr>
<tr>
<td align="center">0xc3</td>
<td align="center">monitorexit</td>
<td align="center"></td>
<td align="left">释放并退出对象监视器</td>
</tr>
</tbody></table>
<p>摘录: <a href="https://www.cnblogs.com/longjee/p/8675771.html">https://www.cnblogs.com/longjee/p/8675771.html</a></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>黑马JVM课程——JAVA内存模型（四）</title>
    <url>/2022/09/02/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<blockquote>
<p>简单的说，JMM（java Memory model）定义了一套在多线程读写共享数据时（成员变量、数组）时，对数据的可见性、有序性、和原子性的规则和保障</p>
</blockquote>
<h1 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h1><p><strong>问题</strong>：</p>
<blockquote>
<p>两个线程对初始值为0的静态变量一个做自增，一个做自减，各做5000次，结果是0吗？</p>
</blockquote>
<p>伪代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">static</span>  <span class="keyword">int</span> i = <span class="number">0</span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  </span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5000</span>; j++) &#123;  </span><br><span class="line">                i++;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5000</span>; j++) &#123;  </span><br><span class="line">                i--;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">        t1.start();  </span><br><span class="line">        t2.start();  </span><br><span class="line">        t1.join();  </span><br><span class="line">        t2.join();  </span><br><span class="line">        System.out.println(i);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><blockquote>
<p>运行上面的代码，等到的结果可能是正数，可能是负数，也可能是0，为什么呢？<br>因为java中对静态变量的自增，自减并不是原子操作。</p>
</blockquote>
<ul>
<li><p>例如对<code>i++</code>而言（i为静态变量），实际会产生如下的JVM字节码指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getstatic     i //获取静态变量i的值</span><br><span class="line">iconst_1        //准备常量1</span><br><span class="line">iadd            //加法</span><br><span class="line">putstatic     i //将修改后的值存入静态变量i</span><br></pre></td></tr></table></figure></li>
<li><p>而对应的<code>i--</code>也是类似：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getstatic     i //获取静态变量i的值</span><br><span class="line">iconst_1        //准备常量1</span><br><span class="line">isub            //减法</span><br><span class="line">putstatic     i //将修改后的值存入静态变量i</span><br></pre></td></tr></table></figure></li>
<li><p>而java的内存模型如下，完成静态变量的自增，自减需要在主内存和线程内存中进行数据交换</p>
</li>
<li><p>当CPU执行两个线程的时候，并不一定就是同时运行两个线程，而是每次执行一个，交错运行</p>
</li>
<li><p>当一个线程读取数据，计算完毕，准备把数值覆盖回主内存时，也行另一个线程已经运行了多次，多次修改了主内存，然后再被覆盖，就会导致结果错误<br><img src="/2022/09/02/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/image-20220903101523820.png"></p>
</li>
<li><p>如果是单线程执行上面的8行代码是顺序执行的（不会交错）也就没有问题了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//假设i的初始值是0</span><br><span class="line">getstatic     i //线程1-获取静态变量i的值 线程内值 i=0</span><br><span class="line">iconst_1        //线程1-准备常量1</span><br><span class="line">iadd            //线程1-加法i=i+1 线程内i=1</span><br><span class="line">putstatic     i //线程1-将修改后的值存入静态变量i 静态变量 i=1</span><br><span class="line">getstatic     i //线程1-获取静态变量i的值 线程内i=1</span><br><span class="line">iconst_1        //线程1-准备常量1</span><br><span class="line">isub            //线程1-减法 i=i-1 线程内i=0</span><br><span class="line">putstatic     i //线程1-将修改后的值存入静态变量i 静态变量i=0</span><br></pre></td></tr></table></figure></li>
<li><p>但多线程下，这8行代码可能是交错运行</p>
</li>
<li><p>出现负的情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//假设i的初始值是0</span><br><span class="line">getstatic     i //线程1-获取静态变量i的值 线程内值 i=0</span><br><span class="line">getstatic     i //线程2-获取静态变量i的值 线程内值 i=0</span><br><span class="line">iconst_1        //线程1-准备常量1</span><br><span class="line">iadd            //线程1-加法i=i+1 线程内i=1</span><br><span class="line">putstatic     i //线程1-将修改后的值存入静态变量i 静态变量 i=1</span><br><span class="line">iconst_1        //线程2-准备常量1</span><br><span class="line">isub            //线程2-减法 i=i-1 线程内i=-1</span><br><span class="line">putstatic     i //线程2-将修改后的值存入静态变量i 静态变量i=-1</span><br></pre></td></tr></table></figure></li>
<li><p>出现正数的情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//假设i的初始值是0</span><br><span class="line">getstatic     i //线程1-获取静态变量i的值 线程内值 i=0</span><br><span class="line">getstatic     i //线程2-获取静态变量i的值 线程内值 i=0</span><br><span class="line">iconst_1        //线程1-准备常量1</span><br><span class="line">iadd            //线程1-加法i=i+1 线程内i=1</span><br><span class="line">iconst_1        //线程2-准备常量1</span><br><span class="line">isub            //线程2-减法 i=i-1 线程内i=-1</span><br><span class="line">putstatic     i //线程2-将修改后的值存入静态变量i 静态变量i=-1</span><br><span class="line">putstatic     i //线程1-将修改后的值存入静态变量i 静态变量 i=1</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p><strong>synchronized</strong>(同步关键字)<br>语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象)&#123;</span><br><span class="line">	要原子操作的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用 synchronized 解决并发问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">static</span>  <span class="keyword">int</span> i = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  </span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5000</span>; j++) &#123;  </span><br><span class="line">                <span class="keyword">synchronized</span> (lock)&#123;  </span><br><span class="line">                    i++;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5000</span>; j++) &#123;  </span><br><span class="line">                <span class="keyword">synchronized</span> (lock)&#123;  </span><br><span class="line">                    i--;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">        t1.start();  </span><br><span class="line">        t2.start();  </span><br><span class="line">        t1.join();  </span><br><span class="line">        t2.join();  </span><br><span class="line">        System.out.println(i);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h1><h2 id="退不出的循环"><a href="#退不出的循环" class="headerlink" title="退不出的循环"></a>退不出的循环</h2><blockquote>
<p>先来看一个现象，<code>main</code>线程对<code>run</code>变量的修改对于<code>t</code>线程不可见，导致了<code>t</code>线程无法停止<br>当我们循环一秒钟后，将 <code>run</code> 的值修改为<code>false</code>，理论上是应该能让循环停下来的，但实际却不行</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> run = <span class="keyword">true</span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  </span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;  </span><br><span class="line">            <span class="keyword">while</span> (run) &#123;  </span><br><span class="line">                <span class="comment">//。。。。  </span></span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">        t.start();  </span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);  </span><br><span class="line">        run = <span class="keyword">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么呢？分析一下：</p>
<ul>
<li><p>初始状态，t线程刚开始从主内存读取<code>run</code>的值到工作内存<br><img src="/2022/09/02/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/image-20220903104659759.png"></p>
</li>
<li><p>因为 t 线程要频繁从主内存总读取 <code>run的值</code>，JIT编译器会将 <code>run</code> 的值缓存到自己工作内存中的高速缓存中，减少对主内存中 <code>run</code> 的访问，提高效率<br><img src="/2022/09/02/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/image-20220903105053273.png"></p>
</li>
<li><p>一秒钟之后，<code>main</code> 线程修改了 <code>run</code> 的值，并同步到主内存，而 <code>t</code> 是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值<br><img src="/2022/09/02/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/image-20220903105231004.png"></p>
</li>
</ul>
<h2 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h2><p><strong>volatile</strong>（易变关键字）</p>
<blockquote>
<p>它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作内存中查找变量的值，必须到主内存中获取它的值，线程操作 <code>volatile</code> 变量都是直接操作主存</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> run = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>
<h2 id="可见性-1"><a href="#可见性-1" class="headerlink" title="可见性"></a>可见性</h2><blockquote>
<p>前面的例子体现的就是可见性，它保证的是在多个线程之间，一个线程对 volatile 变量的修改对另一个线程可见，不能保证原子性，仅用在一个写线程，多个读线程的情况：</p>
</blockquote>
<p>上例从字节码理解是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getstatic     run  // 线程 t 获取 run true</span><br><span class="line">getstatic     run  // 线程 t 获取 run true</span><br><span class="line">getstatic     run  // 线程 t 获取 run true</span><br><span class="line">getstatic     run  // 线程 t 获取 run true</span><br><span class="line">getstatic     run  // 线程 t 获取 run true</span><br><span class="line">putstatic     run  // 线程 main 获取 run false （仅此一次）</span><br><span class="line">getstatic     run  // 线程 t 获取 run false</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ul>
<li><code>synchronized</code> 语句块既可以保证代码块的原子性，也同时可以保证代码块内变量的可见性，但缺点是 <code>synchronized</code> 是属于重量级操作，性能更低</li>
</ul>
<h1 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h1><h2 id="诡异的结果"><a href="#诡异的结果" class="headerlink" title="诡异的结果"></a>诡异的结果</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">boolean</span> ready = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//线程1 执行此方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor1</span><span class="params">(Result r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(ready)&#123;</span><br><span class="line">		r.r1 = num + num;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		r.r1 = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线程2 执行此方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(Result r)</span></span>&#123;</span><br><span class="line">	num = <span class="number">2</span>;</span><br><span class="line">	ready = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Result 是一个对象，有一个熟悉 r1 用来保存结果，问，可能有几种结果？</p>
<ul>
<li>线程1先执行，这个时候 <code>ready = false</code>，所以进入 <code>else</code> 分支，结果1</li>
<li>线程2先执行 <code>num=2</code>，但没来得及执行<code>ready = true</code>，线程1执行，还是进入<code>else</code>分支，结果1</li>
<li>线程2线执行到<code>ready=true</code>，线程1执行，这次进入<code>if</code>分支，结果为4（因为<code>num=2</code>已经执行了）</li>
</ul>
<p><strong>但其实除了上面的情况，还会有另一种情况，最后结果是0</strong></p>
<ul>
<li>线程2先执行了<code>ready=true</code>，切换到线程1，进入<code>if</code>分支，但是此时<code>num=2</code>还没有执行，相加结果为0，再1切回线程2执行<code>num=2</code></li>
</ul>
<p>这种现象叫做<strong>指令重排</strong>，是JIT编译器在运行时的一些优化<br>这种现象需要通过大量测试才能复现，借助java并发压测工具 <code>jcstress</code><br><a href="http://hg.openjdk.java.net/code-tools/jcstress/file/tip/jcstress-samples/src/main/java/org/openjdk/jcstress/samples">code-tools/jcstress: 5fe2614f0b23 /jcstress-samples/src/main/java/org/openjdk/jcstress/samples/</a></p>
<p>添加如下依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jcstress<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jcstress-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.15<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jcstress<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jcstress-samples<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试代码如下：(I_Result是jcstress提供的)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JCStressTest</span>  </span><br><span class="line"><span class="comment">//检查感兴趣的结果,对结果进行分类  </span></span><br><span class="line"><span class="comment">//如果结果是1和4，分类到ACCEPTABLE中  </span></span><br><span class="line"><span class="meta">@Outcome(id = &#123;&quot;1&quot;,&quot;4&quot;&#125;,expect = Expect.ACCEPTABLE,desc = &quot;ok&quot;)</span>  </span><br><span class="line"><span class="comment">//如果结果是0，分类到ACCEPTABLE_INTERESTING中  </span></span><br><span class="line"><span class="meta">@Outcome(id = &quot;0&quot;,expect = Expect.ACCEPTABLE_INTERESTING,desc = &quot;!!!&quot;)</span>  </span><br><span class="line"><span class="meta">@State</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">boolean</span> ready = <span class="keyword">false</span>;  </span><br><span class="line">    <span class="meta">@Actor</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor1</span><span class="params">(I_Result r)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(ready)&#123;  </span><br><span class="line">            r.r1 = num + num;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            r.r1 = <span class="number">1</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">@Actor</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span></span>&#123;  </span><br><span class="line">        num = <span class="number">2</span>;  </span><br><span class="line">        ready = <span class="keyword">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过maven命令创建项目</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn archetype:generate -DinteractiveMode=false -DarchetypeGroupId=org.openjdk.jcstress -DarchetypeArtifactId=jcstress-java-test-archetype -DgroupId=org.sample -DartifactId=test -Dversion=1.0</span><br></pre></td></tr></table></figure>
<p>或者通过idea创建maven项目<br><img src="/2022/09/02/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/image-20220903115756796.png"></p>
<p>之后执行<code>mvn clean install</code>命令，之后可以找到打出的包<code>jcstress.jar</code>，之后执行<code>java -jar jcstress.jar</code>运行该jar包即可<br>以下是带JVM参数和不带参数时运行的结果，可以看到，0出现的几率虽然小，但并不是没有，<code>0.06%</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  JVM args: [-XX:-TieredCompilation]</span><br><span class="line">  Fork: #3</span><br><span class="line"></span><br><span class="line">  RESULT      SAMPLES     FREQ       EXPECT  DESCRIPTION</span><br><span class="line">       0      183,517    0.06%  Interesting  !!!</span><br><span class="line">       1  128,696,561   40.76%   Acceptable  ok</span><br><span class="line">       4  186,892,850   59.19%   Acceptable  ok</span><br><span class="line"></span><br><span class="line">RUN RESULTS:</span><br><span class="line">  Interesting tests: 1 matching test results.</span><br><span class="line"></span><br><span class="line">.......... [OK] org.example.Test</span><br><span class="line"></span><br><span class="line">  Results across all configurations:</span><br><span class="line"></span><br><span class="line">  RESULT      SAMPLES     FREQ       EXPECT  DESCRIPTION</span><br><span class="line">       0      726,071    0.06%  Interesting  !!!</span><br><span class="line">       1  371,787,438   33.09%   Acceptable  ok</span><br><span class="line">       4  750,953,755   66.84%   Acceptable  ok</span><br></pre></td></tr></table></figure>

<h2 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法"></a>解决方法</h2><p><code>volatile</code> 修饰变量，可以禁止指令重排<br>给 <code>ready</code> 变量加上 <code>volatile</code> 修饰，然后再次打包重新运行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> ready = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>
<p><code>Interesting tests: No matches.</code>已经没有感兴趣的结果了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RUN RESULTS:</span><br><span class="line">  Interesting tests: No matches.</span><br><span class="line"></span><br><span class="line">  Failed tests: No matches.</span><br><span class="line"></span><br><span class="line">  Error tests: No matches.</span><br><span class="line"></span><br><span class="line">  All remaining tests: <span class="number">1</span> matching test results. Use -v to print them.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="有序性理解"><a href="#有序性理解" class="headerlink" title="有序性理解"></a>有序性理解</h2><p>同一个线程内，JVM会在不影响正确性的前提下，可以调整语句的执行顺序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> j</span><br><span class="line"><span class="comment">//在某个线程内执行如下赋值操作</span></span><br><span class="line">i=...;<span class="comment">//比较耗时的操作</span></span><br><span class="line">j=...;</span><br></pre></td></tr></table></figure>
<p>可以看到，先执行<code>i</code>还是先执行<code>j</code>，对于最终的结果不会产生影响，所以，上面的代码真正执行时，既可以是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">i=...;<span class="comment">//比较耗时的操作</span></span><br><span class="line">j=...;</span><br></pre></td></tr></table></figure>
<p>也可以是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">j=...;</span><br><span class="line">i=...;<span class="comment">//比较耗时的操作</span></span><br></pre></td></tr></table></figure>
<p>这种特性称之为【指令重排】，多线程下【指令重排】会影响正确性<br>例如双层检查锁，看起来很完美，但是在多线程的情况下，new对象是会有问题的<br><code>INSTANCE = new Singletion()</code> 对应的字节码是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0: new           #2                  // class com/example/demo1/test16/Singleton</span><br><span class="line">3: dup</span><br><span class="line">4: invokespecial #3                  // Method com/example/demo1/test16/Singleton.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">7: putstatic     #4                  // Field INSTANCE:Lcom/example/demo1/test16/Singleton;</span><br></pre></td></tr></table></figure>
<p>0：给对象分配空间<br>3：把对象的空间引用放入操作数栈<br>4：调用构造方法<br>7：给静态变量赋值<br>可以看出，最后两步，也就是4和7，两步的顺序不是固定的，先执行哪一步都可以，JVM有时候就会进行优化，先赋值，再调用构造方法<br>如果两个线程t1和t2按如下时间顺序执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">时间1 t1 线程执行到 INSTANCE = new Singletion()</span><br><span class="line">时间2 t1 线程分配空间，为Singletion对象生成引用地址（0处）</span><br><span class="line">时间3 t1 线程将引用地址赋值给 INSTANCE ，这时 INSTANCE ！= null (7处)</span><br><span class="line">时间4 t2 线程尝试获取单例对象，发现  INSTANCE ！= null ，直接返回了  INSTANCE</span><br><span class="line">时间5 t1 线程执行 Singletion 的构造方法(4处)</span><br></pre></td></tr></table></figure>
<p>此时t1还未将构造方法执行完毕，如果在构造方法中要执行很多初始化操作，那么t2拿到的将是一个未初始化完毕的单例</p>
<p>对 <code>INSTANCE</code> 使用 <code>volatile</code> 修饰即可，可以禁用指令重排，但是要注意在 JDK5 以上版本的 <code>volatile</code> 才会真正有效</p>
<h2 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h2><p>happens-before 规定了哪些操作对其他线程的读操作可见，他是可见性与有序性的一套规则总结：</p>
<ul>
<li>线程解锁 lock 之前对变量的写，对于接下来对 lock 加锁的其他线程对该变量的读可见</li>
<li>线程对 volatile 变量的写，对接下来其他线程对该变量的读可见</li>
<li>线程start之前对变量的写，对该线程开始后对该变量的读可见</li>
<li>线程结束前对变量的写，对其他线程得知它结束后的读可见（比如其他线程调用t1.isAlive()或t1.join()等待它结束）</li>
<li>线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知t2被打断后对变量的读可见（通过t2.interupted或t2.isInerrupted）</li>
<li>对变量默认值（0，false，null）的写，对其他线程对该变量的读可见</li>
<li>具有传递性，如果x hb -&gt; y 并且 y hb -&gt; z 那么有 x hb-&gt; z</li>
</ul>
<h1 id="CAS与原子类"><a href="#CAS与原子类" class="headerlink" title="CAS与原子类"></a>CAS与原子类</h1><p>CAS即Compare and Swap，它体现的是一种乐观锁的思想，比如多个线程要对一个共享整型变量执行+1操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需要不同尝试</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">	<span class="keyword">int</span> 旧值 = 共享变量；<span class="comment">//比如拿到了当前值 0</span></span><br><span class="line">	<span class="keyword">int</span> 结果 = 旧值 + <span class="number">1</span>；<span class="comment">//在旧值 0 的基础上增加 1 ，正确结果是1</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		这个时候如果别的线程把共享变量更改成了 5，那么本线程的正确结果 1 就作废了</span></span><br><span class="line"><span class="comment">		这个时候 compareAndSwap 返回 false，重新尝试</span></span><br><span class="line"><span class="comment">		直到 compareAndSwap 返回true，表示我本线程修改的同时，别的线程没有干扰</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">if</span>(compareAndSwap(旧值,结果))&#123;</span><br><span class="line">		<span class="comment">//成功，退出循环</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取共享变量时，为了保证该变量的可见性，需要使用 volatile 修饰。结合CAS和volatile可以实现无锁并发，适用于竞争不激烈、多核CPU的场景下</p>
<ul>
<li>因为没有使用 synchronized ，所以线程不会陷入阻塞，这是效率提升的因素之一</li>
<li>但如果竞争激烈，可以想象到重试必然频繁发生，反而效率会受到影响</li>
</ul>
<h2 id="乐观锁悲观锁"><a href="#乐观锁悲观锁" class="headerlink" title="乐观锁悲观锁"></a>乐观锁悲观锁</h2><ul>
<li>CAS 是基于乐观锁思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没有关系，我吃亏点再重试</li>
<li>synchronized 是基于悲观锁思想：最悲观的估计，得防着其他线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会</li>
</ul>
<h2 id="原子操作类"><a href="#原子操作类" class="headerlink" title="原子操作类"></a>原子操作类</h2><p>juc(java.util.concurrent)中提供了原子操作类，可以提供线程安全的操作，例如：AtomicInteger、AtomicBoolean等，他们底层采用了CAS技术 + volatile来实现的</p>
<h1 id="synchronized优化"><a href="#synchronized优化" class="headerlink" title="synchronized优化"></a>synchronized优化</h1><p>Java HotSpot 虚拟机中，每个对象都有对象头（包括class指针和Mark Word）。Mark Word平时存储这个对象的哈希码、分代年龄、当加锁时，这些信息就根据情况被替换为标记位、线程锁记录指针、重量级锁指针、线程Id等内容</p>
<h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>如果一个对象虽然有多线程访问，但多线程访问的时间是错开的(也就是没有竞争)，那么可以使用轻量级锁来优化</p>
<p>假设有两个方法同步块，利用同一个对象加锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">		<span class="comment">// 同步块 A</span></span><br><span class="line">		method2();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">		<span class="comment">// 同步块 B</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个线程得栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的 Mark Word</p>
<table>
<thead>
<tr>
<th align="left">线程1</th>
<th align="left">对象Mark Word</th>
</tr>
</thead>
<tbody><tr>
<td align="left">访问同步块A，把Mark复制到线程1的锁记录</td>
<td align="left">01 （无锁）</td>
</tr>
<tr>
<td align="left">CAS修改Mark为线程1锁记录地址</td>
<td align="left">01（无锁）</td>
</tr>
<tr>
<td align="left">成功（加锁）</td>
<td align="left">00(轻量级锁) 线程1锁记录地址</td>
</tr>
<tr>
<td align="left">执行同步代码A</td>
<td align="left">00(轻量级锁) 线程1锁记录地址</td>
</tr>
<tr>
<td align="left">访问同步块B，把Mark复制到线程1的锁记录</td>
<td align="left">00(轻量级锁) 线程1锁记录地址</td>
</tr>
<tr>
<td align="left">CAS修改Mark为线程1锁记录地址</td>
<td align="left">00(轻量级锁) 线程1锁记录地址</td>
</tr>
<tr>
<td align="left">失败（发现是自己的锁）</td>
<td align="left">00(轻量级锁) 线程1锁记录地址</td>
</tr>
<tr>
<td align="left">锁重入</td>
<td align="left">00(轻量级锁) 线程1锁记录地址</td>
</tr>
<tr>
<td align="left">执行同步快B</td>
<td align="left">00(轻量级锁) 线程1锁记录地址</td>
</tr>
<tr>
<td align="left">同步块B执行完毕</td>
<td align="left">00(轻量级锁) 线程1锁记录地址</td>
</tr>
<tr>
<td align="left">同步块A执行完毕</td>
<td align="left">00(轻量级锁) 线程1锁记录地址</td>
</tr>
<tr>
<td align="left">成功（解锁）</td>
<td align="left">01（无锁）</td>
</tr>
</tbody></table>
<h2 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h2><p>如果在尝试加轻量级锁的过程中，CAS操作无法成功，这时一种情况就是有其他线程为此对象上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">		<span class="comment">//同步块</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">线程1</th>
<th align="left">对象Mark</th>
<th align="left">线程2</th>
</tr>
</thead>
<tbody><tr>
<td align="left">访问同步块，把Mark复制到线程1的锁记录</td>
<td align="left">01（无锁）</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left">CAS 修改Mark为线程1锁记录地址</td>
<td align="left">01 （无锁）</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left">成功（加锁）</td>
<td align="left">00（轻量锁）线程1锁记录地址</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left">执行同步快</td>
<td align="left">00（轻量锁）线程1锁记录地址</td>
<td align="left">访问同步块，把Mark复制到线程2</td>
</tr>
<tr>
<td align="left">执行同步快</td>
<td align="left">00（轻量锁）线程1锁记录地址</td>
<td align="left">CAS修改Mark为线程2锁记录地址</td>
</tr>
<tr>
<td align="left">执行同步快</td>
<td align="left">00（轻量锁）线程1锁记录地址</td>
<td align="left">失败（发现别人已经占用了锁）</td>
</tr>
<tr>
<td align="left">执行同步快</td>
<td align="left">00（轻量锁）线程1锁记录地址</td>
<td align="left">CAS修改Mark为重量级锁</td>
</tr>
<tr>
<td align="left">执行同步快</td>
<td align="left">10（重量锁）重量锁指针</td>
<td align="left">阻塞中</td>
</tr>
<tr>
<td align="left">执行完毕</td>
<td align="left">10（重量锁）重量锁指针</td>
<td align="left">阻塞中</td>
</tr>
<tr>
<td align="left">失败（解锁）</td>
<td align="left">10（重量锁）重量锁指针</td>
<td align="left">阻塞中</td>
</tr>
<tr>
<td align="left">释放重量锁，唤起阻塞线程竞争</td>
<td align="left">01（无锁）</td>
<td align="left">阻塞中</td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">10（重量锁）</td>
<td align="left">竞争重量锁</td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">10（重量锁）</td>
<td align="left">成功（加锁）</td>
</tr>
<tr>
<td align="left">…</td>
<td align="left">…</td>
<td align="left">…</td>
</tr>
</tbody></table>
<h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h2><p>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这个时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞</p>
<p>在java6之后，自旋锁是自适应的，比如对象刚刚一次自旋操作成功，那么认为这次自旋成功的可能性会高，就多自旋几次，反之，就少自旋甚至不自旋</p>
<ul>
<li>自旋会占用CPU时间，单核CPU自旋就是浪费，多核CPU自旋才能发挥优势</li>
<li>java7之后，不能控制是否开启自旋功能</li>
</ul>
<h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>轻量级锁在没有竞争时（就自己这个线程），每次重入任然需要执行CAS操作。<br>Java6中引入了偏向锁来做进一步优化：只有第一次使用CAS将线程ID设置到对象头的MarkWord头，之后发现这个县城Id是自己的表示没有竞争，不用重新CAS</p>
<ul>
<li>撤销偏向需要将持锁线程升级为轻量级锁，这个过程中所有线程需要暂停（STW）</li>
<li>访问对象的hashCode也会撤销偏向锁</li>
<li>如果对象芮然被多个线程访问，但没有竞争，这时偏向了线程T1的对象仍有机会重新偏向T2，重偏向会重置对象的Thread ID</li>
<li>撤销偏向和重偏向都是批量进行的，以类为单位</li>
<li>如果撤销偏向达到某个阈值，整个类的所有对象都会变为不可偏向的</li>
<li>可以使用 -XX:-UseBiasedLocking禁用偏向锁</li>
</ul>
<h2 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h2><h3 id="减少上锁时间"><a href="#减少上锁时间" class="headerlink" title="减少上锁时间"></a>减少上锁时间</h3><ul>
<li>同步代码块中尽量短</li>
</ul>
<h3 id="减少锁的粒度"><a href="#减少锁的粒度" class="headerlink" title="减少锁的粒度"></a>减少锁的粒度</h3><p>将一个锁拆分为多个锁提高并发度，例如：</p>
<ul>
<li>ConcurrentHashMap</li>
<li>LongAdder分为base和cells两部分。没有并发竞争的时候或者是cells数组正在初始化的时候，会使用CAS来累加值到base，有并发挣用，会初始化cells数组，数组有多少个cell，就允许有多个线程并行修改，最后将数组中每个cell累加，再加上base就是最终的值</li>
<li>LinkedBlokingQueue 入队和出队使用不同的锁，相对于 LinkedBlokingArray只有一个锁效率要高</li>
</ul>
<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><ul>
<li>多次循环进入同步代码块不如同步块内多次循环</li>
<li>另外JVM可能会做如下优化，把多次append的加锁操作粗化为一次（因为都是对同一个对象加锁，没必要重入多次）</li>
</ul>
<h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><ul>
<li>JVM 会进行代码的逃逸分析，例如某个加锁对象是方法内局部变量，不会被其他线程访问到，这个时候会被即时编译器忽略掉所有同步操作</li>
</ul>
<h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><ul>
<li>CopyOnWriteArrayList</li>
<li>CopyOnWriteSet</li>
</ul>
<h2 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h2><p><img src="/2022/09/02/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/image-20220903204931912.png"></p>
<h3 id="无锁—-gt-偏向锁"><a href="#无锁—-gt-偏向锁" class="headerlink" title="无锁—&gt;偏向锁"></a>无锁—&gt;偏向锁</h3><p>使用synchronized关键之锁住某个代码开的时候，当锁对象第一次被线程获得时候，进入偏向状态，标记为1 01，同时使用CAS操作将线程ID记录到Mark Word中，如果CAS操作成功，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何同步操作。</p>
<p>当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向后恢复到未锁定状态或者轻量级锁状态，如果从头到尾就只有一个线程在使用锁，偏向几乎没有额外开销，性能极高。</p>
<p>在偏向锁状态下如果调用了对象的hahsCode，但此时偏向锁的对象MarkWord中存储的是线程ID，如果调用HashCode会导致偏向锁被撤销，而轻量级锁会在锁记录中记录HashCode重量级锁会在Monitor中记录HashCode，所以无影响。</p>
<h3 id="偏向锁-—-gt-轻量级锁"><a href="#偏向锁-—-gt-轻量级锁" class="headerlink" title="偏向锁 —-&gt; 轻量级锁"></a>偏向锁 —-&gt; 轻量级锁</h3><p>一旦有第二个线程加入锁竞争，偏向锁转换为轻量级锁（自旋锁）。<br>锁竞争：如果多个线程轮流获取一个锁，但是每次获取的时候都很顺利，没有发生阻塞，那么就不存在锁竞争，只有当某线程获取锁的时候，发现锁已经被占用，需要等待其释放，则说明发生了锁竞争。</p>
<p>在轻量级锁状态山继续锁竞争，没有抢到锁的线程进行自旋操作，即在一个循环中不停判断是否可以获取锁。获取锁的操作就是通过CAS操作修改对象头里面的标志位，先比较当前锁标志位是否为释放锁状态，如果是，将其设置为锁定状态，比较并设置是原子性操作，这个是JVM层面保证的，当前线程就算持有了锁，然后线程将昂前锁的持有者信息更改为自己。</p>
<p>假如我们获取到锁的线程操作时间很长，比如会进行复杂的计算，数据量很大的网络传输等；那么其他等待锁的线程就会进入长时间的自旋操作，这个操作过程是非常耗费资源的，其实这时候相当于有一个线程在有效地工作，其他的线程什么都干不了，在白白地消耗CPU，这种情况叫做忙等。<br>所以如果多个线程使用独占锁，但是没有发生锁竞争，或者发生了很轻微的锁竞争，那么synchronized就是轻量级锁，允许短时间的忙等现象，这种折中的想法，短时间的忙等，换取线程在用户态和内核态之间切换的开销</p>
<p>每个线程的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的Mark Word，让锁记录中Object reference指向锁对象，并尝试使用CAS替换Object的Mark Word，将Mark Word的值存入锁记录</p>
<p>如果CAS替换成成功，对象头中存储了锁记录地址和状态 00 ，表示由该线程给对象加锁</p>
<p>如果CAS失败，有两种情况：</p>
<ul>
<li>如果是其他线程已经持有了该Object的轻量级锁，这时表明有竞争，会先进入自旋状态，最后进入重量级锁状态</li>
<li>如果是自己执行了synchronized锁重入，那么再添加一条锁记录作为重入的计数（值为null）</li>
</ul>
<p>当退出synchronized代码块（解锁时）如果有取值null的锁记录，表示由重入，这时重置锁记录，表示重入计数减一，相当于踢出一条null的锁记录</p>
<p>当退出synchronized代码块（解锁时）锁记录的值不为null，这时候cas将Mark Word的值恢复给对象头<br>成功，则解锁成功<br>失败，说明轻量级锁进行锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</p>
<h3 id="轻量级锁—-gt-重量级锁"><a href="#轻量级锁—-gt-重量级锁" class="headerlink" title="轻量级锁—-&gt;重量级锁"></a>轻量级锁—-&gt;重量级锁</h3><p>显然，忙等是会有限度的（JVM有一个计数器记录自旋的次数，默认运行循环10次，可以修改）。<br>如果锁竞争情况严重，达到某个最大自旋次数的线程，会将轻量级锁升级为重量级锁（依然是通过CAS修改锁标志位，但不修改持有锁的线程ID）。<br>当后续线程尝试获取锁时，发现被占用的锁是重量级锁，则直接将自己挂起（而不是上面说的忙等，即不会自旋），等待释放锁的线程去唤醒。<br>在JDK6之前，synchronized直接加重量级锁</p>
<p>JVM中，synchronized锁只能按照偏向锁、轻量级锁、重量级锁、的顺序逐渐升级（也有把这个称为锁膨胀的过程），不允许降级</p>
<ul>
<li>假设Thread-1进行轻量级加锁时，Thread-0已经对该对象加了轻量级锁</li>
<li>这时Thread-1加轻量级锁失败，进入所膨胀流程（这里我们就先忽略自旋）</li>
<li>即为Object对象申请Monitor锁，让Object指向重量级锁地址</li>
<li>然后自己进入Monitor的Entrylist BLOCKED</li>
<li>当Thread-0退出同步块解锁时，使用cas将MarkWord的值恢复给对象头，失败。这时会进入重量级锁解锁流程，即按照Monitor地址找到Monitor对象，设置Owner为null，唤醒Entrylist BLOCKED线程</li>
<li>每个java对象都可以关联一个Monitor对象，如果使用synchronized给对象上锁（重量级）之后，该对象头的Mark Word中就被设置指向Monitor对象的指针</li>
<li>刚开始Monitor中的Owner为null</li>
<li>当Thread-2执行synchronized（ob）就会将Monitor的所持有者Owner设置为Thread-2，Monitor只能有一个Owner</li>
<li>在Thread-2上锁的过程中，如果Thread-3、Thread-4、Thread-5也执行synchronized(obj)，就会进入Entrylist BLOCKED</li>
<li>Thread-2执行完同步代码块中的内容，然后唤醒Entrylist 中等待的线程来竞争锁，竞争的时候是非公平的</li>
</ul>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ul>
<li>synchronized只能随机唤醒一个线程，或者唤醒所有线程</li>
<li>偏向锁撤销时会导致STW，会暂停所有线程然后遍历线程，找到持有偏向锁的线程，如果偏向的线程还存活，并且还在执行同步代码块中的代码，则升级为轻量级锁，否则重偏向</li>
</ul>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>黑马JVM课程</tag>
      </tags>
  </entry>
  <entry>
    <title>黑马JVM课程——JMV内存结构（一）</title>
    <url>/2022/07/31/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94JMV%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="什么是-JVM"><a href="#什么是-JVM" class="headerlink" title="什么是 JVM"></a>什么是 JVM</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p>Java Virtual Machine —— Java 程序的运行环境（Java二进制字节码的运行环境）</p>
</blockquote>
<h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ul>
<li>一次编写，到处运行；</li>
<li>自动内存管理，垃圾回收功能；</li>
<li>数组下标越界检查；</li>
<li>多态。</li>
</ul>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p><img src="/2022/07/31/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94JMV%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/jvm-jre-jdk%E6%AF%94%E8%BE%83.png" alt="jvm-jre-jdk比较.png"></p>
<h2 id="常见的JVM"><a href="#常见的JVM" class="headerlink" title="常见的JVM"></a>常见的JVM</h2><p><img src="/2022/07/31/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94JMV%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/%E5%B8%B8%E8%A7%81%E7%9A%84JVM%E5%9B%BE%E7%A4%BA.png" alt="常见的JVM图示"></p>
<h1 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h1><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li>记住下一条jvm指令的执行地址<blockquote>
<p>java代码在编译之后，会编译成一条条指令，然后将指令交给解释器，解释器将指令解释成机器码然后交给CPU执行<br>当程序执行一条指令的时候，程序计数器就会记录下一条指令的位置<br>程序计数器是通过寄存器实现的，寄存器是CPU中运行最快的单元，因为从程序计数器获取执行位置的操作是非常频繁的</p>
</blockquote>
</li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li><p>线程私有</p>
<blockquote>
<p>Java实现多线程的原理是通过由CPU轮询各个线程来实现多线程的<br>当线程切换了之后，就需要程序计数器来记录当前线程下一次需要执行那一条指令，以便于cpu轮询回来的时候能够立即执行</p>
</blockquote>
</li>
<li><p>在Java虚拟机规范中唯一不会存在内存溢出</p>
</li>
</ul>
<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><ul>
<li>每个线程运行时所需要的内存，称为虚拟机栈</li>
<li>每个栈由多个栈帧组成，对应着每次方法调用时所占用的内存</li>
<li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个 </li>
</ul>
<blockquote>
<p>线程运行时需要的内存空间<br>每个栈由多个栈帧组成<br>栈帧-每个方法运行时需要的内存</p>
<blockquote>
<p>参数，局部变量，返回地址</p>
</blockquote>
<p>当线程执行一个方法的时候，就会先把代表方法的栈帧压入栈内，当方法执行完毕，弹出栈</p>
</blockquote>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="垃圾回收是否涉及栈内存？"><a href="#垃圾回收是否涉及栈内存？" class="headerlink" title="垃圾回收是否涉及栈内存？"></a>垃圾回收是否涉及栈内存？</h4><blockquote>
<p>不涉及<br>栈内存中就是一次次的方法调用，没当一个方法调用完毕，就立刻出栈释放了内存，不需要垃圾回收来处理</p>
</blockquote>
<h4 id="栈内存分配越大越好吗？"><a href="#栈内存分配越大越好吗？" class="headerlink" title="栈内存分配越大越好吗？"></a>栈内存分配越大越好吗？</h4><blockquote>
<p>可以通过jvm参数来指定  <code>-Xss size</code><br>默认栈内存为1024kb，Windows会通过虚拟机内存进行计算<br>因为机器物理内存是一定的，如果栈内存划分比较大，会导致能创建的线程数量变少</p>
</blockquote>
<h4 id="方法内的局部变量是否是线程安全？"><a href="#方法内的局部变量是否是线程安全？" class="headerlink" title="方法内的局部变量是否是线程安全？"></a>方法内的局部变量是否是线程安全？</h4><blockquote>
<p>如果方法内部变量没有逃离方法的作用范围，它是线程安全的<br>如果是局部变量引用了对象，并逃离了方法的最哦用范围，需要考虑线程安全问题（基本类型不会有线程安全问题）</p>
</blockquote>
<h3 id="栈内存溢出"><a href="#栈内存溢出" class="headerlink" title="栈内存溢出"></a>栈内存溢出</h3><h4 id="栈帧过多导致栈内存溢出（递归）"><a href="#栈帧过多导致栈内存溢出（递归）" class="headerlink" title="栈帧过多导致栈内存溢出（递归）"></a>栈帧过多导致栈内存溢出（递归）</h4><blockquote>
<p>如下图所示，使用递归调用，没有设置临界值，最终会导致栈内存溢出<br><code>java.lang.StackOverflowError</code><br>注意，并不一定就是 39689 次调用会溢出，根据机器配置不同，会略有差异</p>
</blockquote>
<p><img src="/2022/07/31/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94JMV%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/%E9%80%92%E5%BD%92%E6%A0%88%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E4%BB%A3%E7%A0%81%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="递归栈内存溢出代码示意图"></p>
<ul>
<li>栈帧过大导致栈内存溢出</li>
</ul>
<h3 id="线程与运行诊断"><a href="#线程与运行诊断" class="headerlink" title="线程与运行诊断"></a>线程与运行诊断</h3><h4 id="CPU占用过多"><a href="#CPU占用过多" class="headerlink" title="CPU占用过多"></a>CPU占用过多</h4><ul>
<li>首先通过<code>top</code>命令查看到占用CPU过高的进程</li>
<li><code>ps H -eo pid,tid,%cpu</code><ul>
<li>可以通过<code>ps</code>查看具体某个进程下得线程</li>
<li><code>-eo</code>可以指定感兴趣的内容，<code>pid</code>进程号，<code>tid</code>线程号，<code>%cpu</code>cpu占用情况</li>
</ul>
</li>
<li><code>ps H -eo pid,tid,%cpu | grep pid</code><ul>
<li>可以通过过滤<code>top</code>命令查到的进程号来查看</li>
</ul>
</li>
<li><code>jstack tid</code><ul>
<li>通过java提供的一个命令，可以查看到当前进程下运行的所有线程</li>
<li>然后将有问题的线程进行16进制编码，就是线程中的<code>nid</code></li>
<li>然后可以根据具体的堆栈信息找到有问题的代码行数，进行排查</li>
</ul>
</li>
</ul>
<h4 id="程序运行很长时间没有结果"><a href="#程序运行很长时间没有结果" class="headerlink" title="程序运行很长时间没有结果"></a>程序运行很长时间没有结果</h4><ul>
<li><code>jstack tid</code><ul>
<li>可以通过该命令查看所有线程的运行情况</li>
<li>如果有死锁问题会在堆栈信息的最后打印</li>
<li>不过如果是逻辑上的死锁，是不会直接打印的，需要自己梳理</li>
</ul>
</li>
</ul>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><ul>
<li>使用 <code>native</code> 标记的方法为本地方法</li>
<li>本地方法为C/C++编写</li>
<li>由于有些功能java代码并不能很好的实现，于是就在jvm中引入了大量的C/C++代码</li>
</ul>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><ul>
<li>使用new关键字创建的对象，都会使用堆内存</li>
</ul>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul>
<li>它是线程共享的，堆中对象都需要考虑线程安全问题</li>
<li>有垃圾回收机制</li>
</ul>
<h3 id="堆内存溢出"><a href="#堆内存溢出" class="headerlink" title="堆内存溢出"></a>堆内存溢出</h3><blockquote>
<p>如下图所示，不停的想list中添加字符串，最终会导致堆内存溢出<br><code>java.lang.OutOfMemoryError: Java heap space</code><br>添加字符串的个数，也就是<code>i</code>的值，跟对内存的大小有关<br><code>-Xms8m</code> 可以通过jvm参数调整堆内存的大小</p>
</blockquote>
<p><img src="/2022/07/31/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94JMV%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/%E5%A0%86%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p>
<h3 id="堆内存诊断"><a href="#堆内存诊断" class="headerlink" title="堆内存诊断"></a>堆内存诊断</h3><h4 id="jps-工具（命令行）"><a href="#jps-工具（命令行）" class="headerlink" title="jps 工具（命令行）"></a>jps 工具（命令行）</h4><ul>
<li>查看当前系统中有哪些java进程</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2912 </span><br><span class="line">19988 Jps</span><br><span class="line">21172</span><br><span class="line">10044 Launcher</span><br><span class="line">24332 Test1</span><br></pre></td></tr></table></figure>

<h4 id="jmap-工具（命令行）"><a href="#jmap-工具（命令行）" class="headerlink" title="jmap 工具（命令行）"></a>jmap 工具（命令行）</h4><ul>
<li>查看堆内存占用情况（只能看到某一个时刻）</li>
</ul>
<blockquote>
<p><code>jmap -heap 24332</code><br>使用如下伪代码，来查看jvm堆内存的变化<br>分别在创建对象前，创建对象后，执行垃圾回收后，观察日志的变化</p>
<p>主要可以观察<code>Eden Space</code>区域的内容变化，其中:</p>
<blockquote>
<p><code>capacity</code>表示总容量<br><code>used</code>表示已经占用了的<br><code>free</code>表示未占用的</p>
</blockquote>
<p>可以看到，示例1中，<code>used</code>的值，也就是被占用的空间，大概只有10M左右<br>当我们创建了一个10M的数组之后，被占用的空间已经到了20M<br>当执行了垃圾回收之后，如第三个示例，只剩下1M多点的占用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">&quot;1.....&quot;</span>);  </span><br><span class="line">    Thread.sleep(<span class="number">30000</span>);  </span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">10</span>];<span class="comment">//10mb  </span></span><br><span class="line">    System.out.println(<span class="string">&quot;2.....&quot;</span>);  </span><br><span class="line">    Thread.sleep(<span class="number">30000</span>);  </span><br><span class="line">    bytes = <span class="keyword">null</span>;  </span><br><span class="line">    System.gc();  </span><br><span class="line">    System.out.println(<span class="string">&quot;3....&quot;</span>);  </span><br><span class="line">    Thread.sleep(<span class="number">30000</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>未创建对象时<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Attaching to process ID 24332, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.152-b16</span><br><span class="line"></span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Parallel GC with 10 thread(s)</span><br><span class="line"></span><br><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio         = 0</span><br><span class="line">   MaxHeapFreeRatio         = 100</span><br><span class="line">   MaxHeapSize              = 4229955584 (4034.0MB)</span><br><span class="line">   NewSize                  = 88604672 (84.5MB)</span><br><span class="line">   MaxNewSize               = 1409810432 (1344.5MB)</span><br><span class="line">   OldSize                  = 177733632 (169.5MB)</span><br><span class="line">   NewRatio                 = 2</span><br><span class="line">   SurvivorRatio            = 8</span><br><span class="line">   MetaspaceSize            = 21807104 (20.796875MB)</span><br><span class="line">   CompressedClassSpaceSize = 1073741824 (1024.0MB)</span><br><span class="line">   MaxMetaspaceSize         = 17592186044415 MB</span><br><span class="line">   G1HeapRegionSize         = 0 (0.0MB)</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space:</span><br><span class="line">   capacity = 66584576 (63.5MB)</span><br><span class="line">   used     = 10711168 (10.2149658203125MB)</span><br><span class="line">   free     = 55873408 (53.2850341796875MB)</span><br><span class="line">   16.08656034694882% used</span><br><span class="line">From Space:</span><br><span class="line">   capacity = 11010048 (10.5MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 11010048 (10.5MB)</span><br><span class="line">   0.0% used</span><br><span class="line">To Space:</span><br><span class="line">   capacity = 11010048 (10.5MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 11010048 (10.5MB)</span><br><span class="line">   0.0% used</span><br><span class="line">PS Old Generation</span><br><span class="line">   capacity = 177733632 (169.5MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 177733632 (169.5MB)</span><br><span class="line">   0.0% used</span><br><span class="line"></span><br><span class="line">3178 interned Strings occupying 260512 bytes.</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<p>2.创建对象后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Attaching to process ID 24332, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.152-b16</span><br><span class="line"></span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Parallel GC with 10 thread(s)</span><br><span class="line"></span><br><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio         = 0</span><br><span class="line">   MaxHeapFreeRatio         = 100</span><br><span class="line">   MaxHeapSize              = 4229955584 (4034.0MB)</span><br><span class="line">   NewSize                  = 88604672 (84.5MB)</span><br><span class="line">   MaxNewSize               = 1409810432 (1344.5MB)</span><br><span class="line">   OldSize                  = 177733632 (169.5MB)</span><br><span class="line">   NewRatio                 = 2</span><br><span class="line">   SurvivorRatio            = 8</span><br><span class="line">   MetaspaceSize            = 21807104 (20.796875MB)</span><br><span class="line">   CompressedClassSpaceSize = 1073741824 (1024.0MB)</span><br><span class="line">   MaxMetaspaceSize         = 17592186044415 MB</span><br><span class="line">   G1HeapRegionSize         = 0 (0.0MB)</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space:</span><br><span class="line">   capacity = 66584576 (63.5MB)</span><br><span class="line">   used     = 21196944 (20.214981079101562MB)</span><br><span class="line">   free     = 45387632 (43.28501892089844MB)</span><br><span class="line">   31.834615872600885% used</span><br><span class="line">From Space:</span><br><span class="line">   capacity = 11010048 (10.5MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 11010048 (10.5MB)</span><br><span class="line">   0.0% used</span><br><span class="line">To Space:</span><br><span class="line">   capacity = 11010048 (10.5MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 11010048 (10.5MB)</span><br><span class="line">   0.0% used</span><br><span class="line">PS Old Generation</span><br><span class="line">   capacity = 177733632 (169.5MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 177733632 (169.5MB)</span><br><span class="line">   0.0% used</span><br><span class="line"></span><br><span class="line">3179 interned Strings occupying 260568 bytes.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.执行垃圾回收后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Attaching to process ID 24332, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.152-b16</span><br><span class="line"></span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Parallel GC with 10 thread(s)</span><br><span class="line"></span><br><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio         = 0</span><br><span class="line">   MaxHeapFreeRatio         = 100</span><br><span class="line">   MaxHeapSize              = 4229955584 (4034.0MB)</span><br><span class="line">   NewSize                  = 88604672 (84.5MB)</span><br><span class="line">   MaxNewSize               = 1409810432 (1344.5MB)</span><br><span class="line">   OldSize                  = 177733632 (169.5MB)</span><br><span class="line">   NewRatio                 = 2</span><br><span class="line">   SurvivorRatio            = 8</span><br><span class="line">   MetaspaceSize            = 21807104 (20.796875MB)</span><br><span class="line">   CompressedClassSpaceSize = 1073741824 (1024.0MB)</span><br><span class="line">   MaxMetaspaceSize         = 17592186044415 MB</span><br><span class="line">   G1HeapRegionSize         = 0 (0.0MB)</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space:</span><br><span class="line">   capacity = 66584576 (63.5MB)</span><br><span class="line">   used     = 1331712 (1.27001953125MB)</span><br><span class="line">   free     = 65252864 (62.22998046875MB)</span><br><span class="line">   2.0000307578740157% used</span><br><span class="line">From Space:</span><br><span class="line">   capacity = 11010048 (10.5MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 11010048 (10.5MB)</span><br><span class="line">   0.0% used</span><br><span class="line">To Space:</span><br><span class="line">   capacity = 11010048 (10.5MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 11010048 (10.5MB)</span><br><span class="line">   0.0% used</span><br><span class="line">PS Old Generation</span><br><span class="line">   capacity = 177733632 (169.5MB)</span><br><span class="line">   used     = 1919568 (1.8306427001953125MB)</span><br><span class="line">   free     = 175814064 (167.6693572998047MB)</span><br><span class="line">   1.0800251918556416% used</span><br><span class="line"></span><br><span class="line">3165 interned Strings occupying 259584 bytes.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="jconsole-工具（图形）"><a href="#jconsole-工具（图形）" class="headerlink" title="jconsole 工具（图形）"></a>jconsole 工具（图形）</h4><ul>
<li>图形界面的，多功能监测工具，可以连续监测</li>
</ul>
<blockquote>
<p>直接在命令行输入<code>jconsole</code>命令即可打开工具图形界面<br>在图形界面打开的时候会列出当前服务器上所有的java程序，可以选择链接其中的一个程序查看jvm运行情况</p>
<p>同样入上的代码，可以从界面中看出，对内存开始占用将近30M的内存<br>创建对象之后，升至40多兆<br>执行垃圾回收之后又极速下降<br>同时该图形界面还可以查看线程、类、CPU的具体情况</p>
</blockquote>
<p><img src="/2022/07/31/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94JMV%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/jsconsole%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="jsconsole图形界面示意图"></p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h4 id="垃圾回收之后，内存占用依旧很高"><a href="#垃圾回收之后，内存占用依旧很高" class="headerlink" title="垃圾回收之后，内存占用依旧很高"></a>垃圾回收之后，内存占用依旧很高</h4><p>1.可以先使用<code>jmap</code>指令查看具体占用堆内存的大小，或者直接使用<code>jconsole</code>指令查看<br>2.可以尝试直接使用<code>jconsole</code>面板手动执行GC<br>3.从图中可以看出，执行GC之后，虽然内存占用有所下降，但是下降的并不明显，依旧有二百多兆的占用，此时可以常使用使用<code>jvisualvm</code>工具<br>4.<code>jvisualvm</code>工具和<code>jconsole</code>类似，不过拥有更多的功能<br><img src="/2022/07/31/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94JMV%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/jconsole%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="jconsole问题排查示意图"></p>
<p>5.如下图，<code>jvisualvm</code>工具可以对当前堆内存进行dump<br><img src="/2022/07/31/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94JMV%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%9B%BE%E7%A4%BA1.png" alt="垃圾回收案例分析图示1"><br>6.对堆内存进行dump之后，可以对结果进行分析，从图中可以看出，其中最大的对象是ArrayList<br><img src="/2022/07/31/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94JMV%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%9B%BE%E7%A4%BA2.png" alt="垃圾回收案例分析图示2"><br>7.点击查看详情后可以发现，List中包含了许多的Status对象，一直没有被垃圾回收，导致内存占用过高，然后可以根据具体代码分析，可能是有一个Status类的集合一直没有被释放掉<br><img src="/2022/07/31/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94JMV%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%9B%BE%E7%A4%BA3.png" alt="垃圾回收案例分析图示3"></p>
<p>8.伪代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  </span><br><span class="line">        List&lt;Status&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;  </span><br><span class="line">            list.add(<span class="keyword">new</span> Status());  </span><br><span class="line">        &#125;  </span><br><span class="line">        Thread.sleep(<span class="number">100000000</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Status</span></span>&#123;  </span><br><span class="line">    <span class="keyword">byte</span>[] big = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><ul>
<li>线程共享</li>
<li>主要存储类信息，成员变量，方法数据，成员方法和构造方法，特殊方法</li>
<li>逻辑上方法区是堆得一个组成部分，不过并不是强制规定，各个JVM厂商可以有自己的实现</li>
<li>HotSpot虚拟机在jdk8之前，方法区（永久代）在堆里面</li>
<li>从jdk8开始，更改为元空间，方法区不在属于堆得一部分，使用服务器直接内存</li>
<li>不过方法区中的字符串表（stringTable）依旧存储在堆内</li>
</ul>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p><img src="/2022/07/31/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94JMV%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/%E6%96%B9%E6%B3%95%E5%8C%BA%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="方法区内存分布示意图"></p>
<blockquote>
<p>在jdk8之前，方法区依托永久代来实现，主要是为了能公用java堆得垃圾回收机制，不用再单独为方法区开发垃圾回收功能，不过并不是所有的虚拟机都是依托于永久代来实现的<br>在逻辑上属于堆的一部分，不过并不是堆，又名非堆</p>
</blockquote>
<h3 id="方法区内存溢出"><a href="#方法区内存溢出" class="headerlink" title="方法区内存溢出"></a>方法区内存溢出</h3><p>jdk1.7<br>设置jvm参数：<code>-XX:MaxPermSize=8m</code><br>因为此时方法区还是在永久代，需要设置永久代的大小，以到达OOM的目的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            Test test = <span class="keyword">new</span> Test();  </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++, j++) &#123;  </span><br><span class="line">                <span class="comment">//ClassWriter 作用是生成类的二进制字节码  </span></span><br><span class="line">                ClassWriter cw = <span class="keyword">new</span> ClassWriter(<span class="number">0</span>);  </span><br><span class="line">                <span class="comment">//参数：版本号，访问修饰符（public），类名，包名，父类，父接口  </span></span><br><span class="line">                cw.visit(Opcodes.V1_6, Opcodes.ACC_PUBLIC, <span class="string">&quot;Class&quot;</span> + i, <span class="keyword">null</span>, <span class="string">&quot;java/lang/Object&quot;</span>, <span class="keyword">null</span>);  </span><br><span class="line">                <span class="comment">//生成字节数组  </span></span><br><span class="line">                <span class="keyword">byte</span>[] bytes = cw.toByteArray();  </span><br><span class="line">                <span class="comment">//执行了类的加载  </span></span><br><span class="line">                test.defineClass(<span class="string">&quot;Class&quot;</span> + i, bytes, <span class="number">0</span>, bytes.length);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">            System.out.println(j);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终报错信息如下：<br><code>java.lang.OutOfMemoryError: PermGen space</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">25406</span><br><span class="line">Exception in thread &quot;Reference Handler&quot; Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: PermGen space</span><br><span class="line">	at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:140)</span><br><span class="line">java.lang.OutOfMemoryError: PermGen space</span><br><span class="line">	at java.lang.ClassLoader.defineClass(ClassLoader.java:800)</span><br><span class="line">	at java.lang.ClassLoader.defineClass(ClassLoader.java:643)</span><br><span class="line">	at com.ys.Test.main(Test.java:19)</span><br></pre></td></tr></table></figure>


<p>jdk1.8<br>在jdk1.8开始，将方法区从堆中剥离，以元空间来实现，基于服务器直接内存<br>为了达到OOM的目的，需要限制元空间的大小，如果不设置参数的话，元空间不受限制，理论上来说服务器有多少内存可以用多少，不过还是会受服务器位数的限制，比如32位服务器4G的限制<br><code>-XX:MaxMetaspaceSize=8m</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            Test test = <span class="keyword">new</span> Test();  </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++, j++) &#123;  </span><br><span class="line">                <span class="comment">//ClassWriter 作用是生成类的二进制字节码  </span></span><br><span class="line">                ClassWriter cw = <span class="keyword">new</span> ClassWriter(<span class="number">0</span>);  </span><br><span class="line">                <span class="comment">//参数：版本号，访问修饰符（public），类名，包名，父类，父接口  </span></span><br><span class="line">                cw.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, <span class="string">&quot;Class&quot;</span> + i, <span class="keyword">null</span>, <span class="string">&quot;java/lang/Object&quot;</span>, <span class="keyword">null</span>);  </span><br><span class="line">                <span class="comment">//生成字节数组  </span></span><br><span class="line">                <span class="keyword">byte</span>[] bytes = cw.toByteArray();  </span><br><span class="line">                <span class="comment">//执行了类的加载  </span></span><br><span class="line">                test.defineClass(<span class="string">&quot;Class&quot;</span> + i, bytes, <span class="number">0</span>, bytes.length);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">            System.out.println(j);  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.in.read();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码和上面的一模一样，但是最后抛出的异常却是完全不同：<br><code>java.lang.OutOfMemoryError: Metaspace</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5411</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Metaspace</span><br><span class="line">	at java.lang.ClassLoader.defineClass1(Native Method)</span><br><span class="line">	at java.lang.ClassLoader.defineClass(ClassLoader.java:763)</span><br><span class="line">	at java.lang.ClassLoader.defineClass(ClassLoader.java:642)</span><br><span class="line">	at com.example.demo.test5.Test.main(Test.java:25)</span><br></pre></td></tr></table></figure>

<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><ul>
<li>常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息</li>
<li>运行时常量池，常量池是 <code>*.class</code> 文件中的，当该类被加载，它的长量池信息就会放入运行时常量池，并把里面的符号地址变成真实地址</li>
</ul>
<p>例如，如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>javac Test.java</code> 命令进行编译，编译后生产 <code>Test.class</code> 字节码文件<br>使用 <code>javap -v Test.class</code> 命令进行反编译，就可以查看字节码文件内容<br>内容如下：</p>
<blockquote>
<p>具体内容解读如下：（从上到下）<br>文件信息<br>最后修改时间<br>文件md5值<br>访问修饰符，类型（类还是接口），包名，类名<br>版本（52指jdk1.8）<br>访问修饰符<br>常量池<br>构造函数（不写默认会生成无参构造）<br>main方法，以及main方法中代码编译出的指令</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Classfile /E:/project/java/demo2/src/main/java/com/example/demo/test15/Test.class</span><br><span class="line">  Last modified 2022-8-11; size 437 bytes</span><br><span class="line">  MD5 checksum 23e36db3fde35b83da8bb567f036f0d8</span><br><span class="line">  Compiled from &quot;Test.java&quot;</span><br><span class="line">public class com.example.demo.test15.Test</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #6.#15         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #16.#17        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #3 = String             #18            // hello world</span><br><span class="line">   #4 = Methodref          #19.#20        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #5 = Class              #21            // com/example/demo/test15/Test</span><br><span class="line">   #6 = Class              #22            // java/lang/Object</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               main</span><br><span class="line">  #12 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #13 = Utf8               SourceFile</span><br><span class="line">  #14 = Utf8               Test.java</span><br><span class="line">  #15 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #16 = Class              #23            // java/lang/System</span><br><span class="line">  #17 = NameAndType        #24:#25        // out:Ljava/io/PrintStream;</span><br><span class="line">  #18 = Utf8               hello world</span><br><span class="line">  #19 = Class              #26            // java/io/PrintStream</span><br><span class="line">  #20 = NameAndType        #27:#28        // println:(Ljava/lang/String;)V</span><br><span class="line">  #21 = Utf8               com/example/demo/test15/Test</span><br><span class="line">  #22 = Utf8               java/lang/Object</span><br><span class="line">  #23 = Utf8               java/lang/System</span><br><span class="line">  #24 = Utf8               out</span><br><span class="line">  #25 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #26 = Utf8               java/io/PrintStream</span><br><span class="line">  #27 = Utf8               println</span><br><span class="line">  #28 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  public com.example.demo.test15.Test();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 7: 0</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #3                  // String hello world</span><br><span class="line">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         8: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 9: 0</span><br><span class="line">        line 10: 8</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;Test.java&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对上面的代码进行一些简单的解读：<br>首先程序执行到main方法之后，还会执行 <code>getstatic</code> 指令，获取一个静态变量，具体从哪里获取，从后面的 <code>#2</code> 位置，该位置对应常量池表中的位置</p>
<blockquote>
<p><code>#2 = Fieldref</code> 表示引用的一个成员变量，具体引用的哪个成员变量，继续看后面的 <code>#16.#17</code><br><code>#16 = Class</code> 是一个类，表示要找哪个类下面的成员变量，对应的是 <code>#23</code><br><code>#23 = Utf8</code> 暂且理解是一个字符串，后面跟着的就是具体的类名 <code>java/lang/System</code><br><code>#17</code> 又引用了 <code>#24:#25</code><br><code>#24 = Utf8</code> 表示类里面具体哪个成员变量， <code>out</code> 成员变量名称<br><code>#25 = Utf8</code> 这个成员变量的类型， <code>Ljava/io/PrintStream;</code><br><code>ldc</code> 将常量池中的常量值入栈，后面跟着是具体的常量位置 <code>#3</code><br><code>#3 = String</code> 表示是一个String 类型，<code>#18</code><br><code>#18 = Utf8</code> 常量，具体常量的内容 <code>hello world</code><br><code>invokevirtual</code> 指令调用用实例方法，<code>#4</code><br><code>#4 = Methodref</code> 调用方法，<code>#19.#20</code><br><code>#19 = Class</code> 调用的方法属于那个类，<code>#26</code> 指向具体类路径的名称<br><code>#20 = NameAndType</code> ，<code>#27:#28</code>  指向具体的方法名称，以及方法的参数类型</p>
</blockquote>
</blockquote>
<h3 id="StringTable"><a href="#StringTable" class="headerlink" title="StringTable"></a>StringTable</h3><blockquote>
<p>我们定义一个变量：<code>String a = &quot;hello&quot;;</code>，编译之后，会被定义到class文件的常量池中；<br>当项目开始运行，类被加载到内存中，常量池中的内容也会被加载到<code>运行时常量池</code>中;<br>但此时“hello”字符串在运行时常量池中，只是一个符号；<br>java实行了懒加载机制，当代码运行到这一行的时候，会进行加载；<br>“hello”会从一个字符串符号，变成一个字符串对象，然后会去<code>StringTable</code>中查找是否有相同的字符串；<br>如果有，直接返回对应的地址，如果没有就会把“hello”放到StringTable中，然后再把地址赋值给变量<br><code>String a = new String(&quot;hello&quot;);</code>这种创建对象的方式，使用的对象并不是在StringTable中，而是会在堆中</p>
</blockquote>
<h4 id="StringTable特性"><a href="#StringTable特性" class="headerlink" title="StringTable特性"></a>StringTable特性</h4><ul>
<li>常量池中的字符串仅是符号，第一次用到时才变成对象</li>
<li>利用串池的机制，来避免重复创建字符串对象</li>
<li>字符串变量拼接的原理是StringBulider（1.8）</li>
<li>字符串常量拼接的原理是编译期优化（会直接将对应的常量拼接成新的常量）</li>
<li>可以使用<code>intern</code>方法，主动将串池中没有的字符串对象放入串池<ul>
<li>如果串池中已经包含相同的对象，会返回串池中的对象，如果串池中没有，会先放入串池，然后返回串池中的对象</li>
<li>在1.6的jdk中，因为StringTable是在方法区中的，所以往串池中放对象的时候是复制，所以返回的对象和原对象不同，从1.7开始，StringTable已经迁移到了堆中，所以再主动往串池中存放对象的时候，只是将对象做一下标记，并不会再复制对象，所以地址会和原对象相同</li>
</ul>
</li>
</ul>
<h4 id="StringTable位置"><a href="#StringTable位置" class="headerlink" title="StringTable位置"></a>StringTable位置</h4><blockquote>
<p>在jdk1.6中，StringTable是在方法区中，但是方法区垃圾回收很少，StringTable使用又非常频繁<br>所以在jdk1.7中把StringTable迁移到了堆中<br>在1.8中将整个方法区的实现更改成了元空间 </p>
</blockquote>
<h4 id="StringTable垃圾回收"><a href="#StringTable垃圾回收" class="headerlink" title="StringTable垃圾回收"></a>StringTable垃圾回收</h4><blockquote>
<p><code>-Xmx10m</code> 设置虚拟机堆内存最大值<br><code>-XX:+PrintStringTableStatistics</code> 打印字符串表的统计信息<br><code>-XX:+PrintGCDetails -verbose:gc</code></p>
</blockquote>
<blockquote>
<p>添加虚拟机参数后最终打印信息如下，<br>前三行表示垃圾回收的信息，垃圾回收的区域，回收前占用，回收后占用，回收耗费时间<br><code>Heap</code>下面的内容则是堆得一些信息<br><code>SymbolTable statistics:</code>运行时常量池所占用的空间的大小<br><code>StringTable statistics:</code> 字符串池占用空间大小，底层用hashTable实现，默认桶位<code>60013</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 2048K-&gt;490K(2560K)] 2048K-&gt;1060K(9728K), 0.0007148 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 2457K-&gt;503K(2560K)] 3027K-&gt;1588K(9728K), 0.0004959 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 2551K-&gt;504K(2560K)] 3636K-&gt;1785K(9728K), 0.0006075 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 2560K, used 637K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">  eden space 2048K, 6% used [0x00000000ffd00000,0x00000000ffd21710,0x00000000fff00000)</span><br><span class="line">  from space 512K, 98% used [0x00000000fff00000,0x00000000fff7e010,0x00000000fff80000)</span><br><span class="line">  to   space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)</span><br><span class="line"> ParOldGen       total 7168K, used 1281K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000)</span><br><span class="line">  object space 7168K, 17% used [0x00000000ff600000,0x00000000ff7406d0,0x00000000ffd00000)</span><br><span class="line"> Metaspace       used 3234K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 351K, capacity 388K, committed 512K, reserved 1048576K</span><br><span class="line">SymbolTable statistics:</span><br><span class="line">Number of buckets       :     20011 =    160088 bytes, avg   8.000</span><br><span class="line">Number of entries       :     13223 =    317352 bytes, avg  24.000</span><br><span class="line">Number of literals      :     13223 =    567200 bytes, avg  42.895</span><br><span class="line">Total footprint         :           =   1044640 bytes</span><br><span class="line">Average bucket size     :     0.661</span><br><span class="line">Variance of bucket size :     0.664</span><br><span class="line">Std. dev. of bucket size:     0.815</span><br><span class="line">Maximum bucket size     :         6</span><br><span class="line">StringTable statistics:</span><br><span class="line">Number of buckets       :     60013 =    480104 bytes, avg   8.000</span><br><span class="line">Number of entries       :      1740 =     41760 bytes, avg  24.000</span><br><span class="line">Number of literals      :      1740 =    156352 bytes, avg  89.857</span><br><span class="line">Total footprint         :           =    678216 bytes</span><br><span class="line">Average bucket size     :     0.029</span><br><span class="line">Variance of bucket size :     0.029</span><br><span class="line">Std. dev. of bucket size:     0.171</span><br><span class="line">Maximum bucket size     :         2</span><br></pre></td></tr></table></figure>

<h4 id="StringTable性能调优"><a href="#StringTable性能调优" class="headerlink" title="StringTable性能调优"></a>StringTable性能调优</h4><ul>
<li>调整 <code>-XX:StringTableSize=20000</code>：调整StringTable桶位的个数，如果项目中用到的常量比较多，可以适当调大</li>
<li>考虑将字符串对象是否如池<ul>
<li>如果需要在内存中加载大量的字符串，而这些字符串又有重复的可能性，可以考虑将字符串入池，字符串会自动做去重处理</li>
</ul>
</li>
</ul>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><ul>
<li>常见于NIO操作时，用于数据缓冲区</li>
<li>分配回收成本较高，但读写性能高</li>
<li>不受JVM内存回收管理</li>
</ul>
<blockquote>
<p>假设我们用java实现一个大文件的复制操作，java本身是不具备操作io的能力的，需要调用操作系统的相关功能<br>所以每次去读取文件，CPU就需要先由用户态切换到内核态，然后把磁盘中的文件加载到系统缓冲区中<br>然后再把CPU切换成用户态，并把数据复制到JVM内存中<br>将文件写入到本地的时候同样，从JVM内存复制到系统缓冲区，然后写入磁盘<br>如果jvm操作直接内存，则可以省略从系统缓存向jvm内存复制的过程，提高文件处理的性能</p>
</blockquote>
<h3 id="DirectByteBuffer"><a href="#DirectByteBuffer" class="headerlink" title="DirectByteBuffer"></a>DirectByteBuffer</h3><blockquote>
<p>DirectByteBuffer 是 NIO中的一个缓冲类，它所创建的内存区域就是直接内存<br>Java中想要操作直接内存需要通过<code>Unsafe</code>类来进行操控，<code>Unsafe</code>不会对普通程序员放开，需要通过反射获取<br><code>unsafe.setMemory()</code> 方法分配直接内存，long类型返回值是分配的内存地址<br><code>unsafe.freeMemory(address)</code> 回收直接内存，通过分配内存时分配的地址，进行回收内存</p>
</blockquote>
<blockquote>
<p>下面代码是 <code>DirectByteBuffer</code> 构造方法的源代码<br><code>base = unsafe.allocateMemory(size);</code> 可以看到是通过<code>Unsafe</code>来进行分配内存的<br>至于回收内存，则是在 <code>cleaner = Cleaner.create(this, new Deallocator(base, size, cap));</code> 这一行<br><code>Deallocator</code> 是一个任务对象，实现了<code>Runnable</code>接口，会在run方法中对直接内存进行回收<br>分配完直接内存后，会依托<code>Cleaner</code>创建一个任务，而任务的执行时间，则是需要看<code>Cleaner</code>对象<br><code>Cleaner</code>是一个虚引用对象，当和他关联的对象被回收了之后，就会调用他的<code>clean</code>方法，在<code>clean</code>方法中，会执行与之 绑定的任务</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DirectByteBuffer(<span class="keyword">int</span> cap) &#123;                   <span class="comment">// package-private  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">super</span>(-<span class="number">1</span>, <span class="number">0</span>, cap, cap);  </span><br><span class="line">    <span class="keyword">boolean</span> pa = VM.isDirectMemoryPageAligned();  </span><br><span class="line">    <span class="keyword">int</span> ps = Bits.pageSize();  </span><br><span class="line">    <span class="keyword">long</span> size = Math.max(<span class="number">1L</span>, (<span class="keyword">long</span>)cap + (pa ? ps : <span class="number">0</span>));  </span><br><span class="line">    Bits.reserveMemory(size, cap);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">long</span> base = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        base = unsafe.allocateMemory(size);  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;  </span><br><span class="line">        Bits.unreserveMemory(size, cap);  </span><br><span class="line">        <span class="keyword">throw</span> x;  </span><br><span class="line">    &#125;  </span><br><span class="line">    unsafe.setMemory(base, size, (<span class="keyword">byte</span>) <span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">if</span> (pa &amp;&amp; (base % ps != <span class="number">0</span>)) &#123;  </span><br><span class="line">        <span class="comment">// Round up to page boundary  </span></span><br><span class="line">        address = base + ps - (base &amp; (ps - <span class="number">1</span>));  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        address = base;  </span><br><span class="line">    &#125;  </span><br><span class="line">    cleaner = Cleaner.create(<span class="keyword">this</span>, <span class="keyword">new</span> Deallocator(base, size, cap));  </span><br><span class="line">    att = <span class="keyword">null</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>黑马JVM课程</tag>
      </tags>
  </entry>
  <entry>
    <title>黑马JVM课程——垃圾回收（二）</title>
    <url>/2022/08/13/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[<h1 id="如何判断对象可以回收"><a href="#如何判断对象可以回收" class="headerlink" title="如何判断对象可以回收"></a>如何判断对象可以回收</h1><h2 id="引用计数分析算法"><a href="#引用计数分析算法" class="headerlink" title="引用计数分析算法"></a>引用计数分析算法</h2><blockquote>
<p>在对象头中使用一个计数器，每当一个对象被引用的时候+1，断开引用的时候-1<br>这种方案可能会出现循环引用的情况<br>如下图，A对象引用B对象，B对象又引用A对象，此时他们两个是没有被其他对象引用的<br>应该被回收，但因为互相引用，就会导致无法回收</p>
</blockquote>
<img src="http://www.plantuml.com/plantuml/svg/Iyv9B2vMS7owVkUBZGkhQnKKk9B18av88a04LQ2WQmUJ0Gew8GIXyW00">

<h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><ul>
<li>Java 虚拟机中的垃圾回收器采用可达性分析算法来探索所有存活的对象</li>
<li>扫描堆中的对象，看是否能够沿着<code>GC ROOT</code>对象为起点的引用链找到该对象，找不到，表示可以回收</li>
<li>那些对象可以作为<code>GC ROOT</code>？</li>
</ul>
<blockquote>
<p>为了分析那些可以作为<code>GC ROOT</code>节点，我们可以使用一个工具，<code>MemoryAnalyzer</code>，它可以更加详细的查看堆信息<br>使用这个工具，需要配合<code>jmap</code>命令来进行，需要执行下面的命令<br><code>jmap -dump:format=b,live,file=1.bin 6364</code></p>
<blockquote>
<p><code>-dump:</code> 表示本次操作需要把堆信息dump下来<br><code>format=b</code> format表示转储文件的格式，b是二进制文件<br><code>live</code> 表示抓取快照的时候只关心存活的对象，在抓取快照之前，会进行一次垃圾回收<br><code>file=1.bin</code> 要保存文件的位置以及名称<br>最后的数字是当前运行服务的pid</p>
</blockquote>
<p>具体代码如下，分别在创建对象后，对象置空后进行一次抓取</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">        List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();  </span><br><span class="line">        list.add(<span class="string">&quot;a&quot;</span>);  </span><br><span class="line">        list.add(<span class="string">&quot;b&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="number">1</span>);  </span><br><span class="line">        System.in.read();  </span><br><span class="line">  </span><br><span class="line">        list = <span class="keyword">null</span>;  </span><br><span class="line">        System.out.println(<span class="number">2</span>);  </span><br><span class="line">        System.in.read();  </span><br><span class="line">        System.out.println(<span class="string">&quot;结束......&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下图可以看到，可以作为<code>GC ROOT</code> 节点的对象</p>
<ul>
<li><code>System Class</code> JVM启动需要的一些核心类，主要是支撑JVM运行</li>
<li><code>JNI Global</code></li>
<li><code>Thread</code> 活动线程正在使用的一些对象</li>
<li><code>Busy Monitor</code> 被作为锁的对象</li>
<li>其他（并不一定只有这些）<br><img src="/2022/08/13/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/GC-ROOT%E6%9F%A5%E7%9C%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="GC-ROOT查看示意图"></li>
</ul>
<h2 id="四种引用"><a href="#四种引用" class="headerlink" title="四种引用"></a>四种引用</h2><h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><blockquote>
<p>我们平时使用的大多数对象引用，都是强引用（使用new关键字创建的对象，当然强引用对象的创建方式并不只有这一种）<br>特点：如果所有的GC Root对象都没有与某个对象有强引用链接，那么这个对象就可以被垃圾回收了</p>
</blockquote>
<h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><blockquote>
<p>通过<code>SoftReference</code>引用对象，这个引用就是软引用<br>特点：如果一个对象只存在软引用，那么当进行GC之后，如果内存依旧不够使用，则在下次进行GC的时候回收软引用的对象<br>软引用自身也是一个对象（SoftReference类型的对象），也会占用内存，SoftReference回收可以使用引用队列<br>当软引用对象所引用的对象被垃圾回收后，软引用对象（SoftReference类型对象）就会被放到引用队列中，可以监听引用队列进行处理</p>
</blockquote>
<h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><blockquote>
<p>通过<code>WeakReference</code>引用对象，这种引用方式为弱引用<br>特点：在进行GC的时候，无论内存是否充足，都会回收弱引用对象，弱引用本身（WeakReference对象）也会占用内存，他的回收需要使用引用队列</p>
</blockquote>
<h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><blockquote>
<p>使用<code>PhantomReference</code>引用对象时，这种引用方式就是虚引用<br>虚引用需要结合引用队列<code>ReferenceQueue</code>来使用<br>比如在ByteBuffer中就使用虚引用来释放直接内存<br>当对象只剩下虚引用的时候，随时都有可能被垃圾回收</p>
</blockquote>
<h3 id="终结器引用"><a href="#终结器引用" class="headerlink" title="终结器引用"></a>终结器引用</h3><blockquote>
<p>使用 <code>FinalReference</code> 引用对象，这种引用方式为终结器引用<br>需要配合引用队列使用（终结器引用，用户一般不会使用，是jvm在回收对象的时候使用的）<br><code>finalize</code>方法的调用就使用到了终结器引用<br>当一个对象正在被回收时（还没有回收），虚拟机会创建该对象的终结器引用，并且进入引用队列，在引用队列上有一个优先级很低的线程，扫描到终结器引用，会根据引用找到对象，调用<code>finalize</code>方法实现资源清理，在下次GC时该对象会被回收。<br>由于使用<code>finalize</code>的对象在被回收时，需要两次，且调用<code>finalize</code>的线程优先级特别低，<code>finalize</code>方法可能迟迟无法调用，所以不推荐使用<code>finalize</code>方法</p>
</blockquote>
<h1 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h1><h2 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h2><ul>
<li>标记：遍历内存区域，对需要回收的对象打上标记</li>
<li>清除：再次遍历内存，对已经标记过的内存进行回收</li>
<li>缺点：<ul>
<li>遍历两次内存空间（一次标记，一次清除）</li>
<li>容易产生内存碎片，当需要一块比较大的内存时，无法找到一块满足需求的（此时或许总剩余空间还足够），因而不得不再次发出GC</li>
</ul>
</li>
</ul>
<h3 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h3><ul>
<li>标记：遍历内存区域，对需要回收的对象打上标记</li>
<li>整理：让存活的对象，向内存的一端移动，然后直接清理掉没有用的内存</li>
<li>缺点：<ul>
<li>在整理内存空间的时候，牵扯到对象引用地址的改变，速度比较慢</li>
</ul>
</li>
</ul>
<h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><blockquote>
<p>将内存划分为等大的两块，每次只使用其中的一块<br>当一块用完之后，触发GC，将该快内存中存活的对象复制到另外一块区域，然后一次性清理掉这块没有用的内存，下次GC再重新复制回来，如此往复</p>
</blockquote>
<ul>
<li>先做标记，然后复制对象</li>
<li>相对于标记清除算法，解决了内存碎片化的问题</li>
<li>效率更高（清理内存时，记住首尾地址，一次性抹掉）</li>
<li>缺点：<ul>
<li>内存利用率不高，每次只能使用一半内存</li>
</ul>
</li>
</ul>
<h1 id="分代垃圾回收"><a href="#分代垃圾回收" class="headerlink" title="分代垃圾回收"></a>分代垃圾回收</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>当前大多数虚拟机都采用分代收集算法，这个算法并没有新的内容，只是根据对象的存活时间长短，将内存分为了新生代和老年代，这样就可以针对不同的区域，采用相对应的算法，如：</p>
<ul>
<li>新生代，每次都有大量对象死亡，有老年代作为内存担保，采用复制算法</li>
<li>老年代，对象存活时间长，采用标记整理算法，或者标记清理算法都可以</li>
</ul>
</blockquote>
<blockquote>
<p>新生代采用复制算法并不会粗暴的将内存分为两等份使用<br>而是将内存分为一个<code>伊甸园</code>，两个<code>幸存区</code>，内存占比默认是<code>8:1:1</code>(可以使用jvm参数调整)<br>真正使用的时候，会使用<code>伊甸园</code>的全部区域，和一个<code>性存区</code>区域，当内存占满，需要执行GC的时候，会将存活对象复制到另一个<code>性存区</code>中，然后清除之前使用两块内存中的全部数据，然后再使用<code>伊甸园</code>和存有幸存对象的<code>性存区</code>，满了之后在进行此番操作，往复循环</p>
</blockquote>
<ul>
<li>对象首先会分配在伊甸园区</li>
<li>新生代空间不足时，触发 minor GC ，伊甸园和 from 存活的对象使用 copy 复制到 to 中，存活的对象年龄加1，并且交换 from 和 to</li>
<li>minor gc 会引发 stop the world，暂停其他用户线程，等垃圾回收结束后，用户线程才恢复运行</li>
<li>当对象寿命超过阀值，会晋升到老年代，最大寿命是15（年龄标记使用4bit存储，最大是15，并不一定就是15晋升，也有其他的原因会导致提前晋升）</li>
<li>当老年代空间不足，会先触发 minor gc，如果之后空间仍不足，那么触发 full gc，STW 的时间更长</li>
</ul>
<h2 id="相关JVM参数"><a href="#相关JVM参数" class="headerlink" title="相关JVM参数"></a>相关JVM参数</h2><table>
<thead>
<tr>
<th align="left">含义</th>
<th align="left">参数</th>
</tr>
</thead>
<tbody><tr>
<td align="left">堆初始大小</td>
<td align="left">-Xms</td>
</tr>
<tr>
<td align="left">堆最大大小</td>
<td align="left">-Xmx 或 -XX:MaxHeapSize=size</td>
</tr>
<tr>
<td align="left">新生代大小</td>
<td align="left">-Xmn 或 （-XX:NewSize=size + -XX:MaxNewSize=size）</td>
</tr>
<tr>
<td align="left">幸存区比例（动态）</td>
<td align="left">-XX:InitialSurvivorRatio=ratio 和 -XX:+UseAdaptiveSizePolicy</td>
</tr>
<tr>
<td align="left">幸存区比例</td>
<td align="left">-XX:SurvivorRatio=ratio</td>
</tr>
<tr>
<td align="left">晋升阀值</td>
<td align="left">-XX:MaxTenuringThreshold=threshold</td>
</tr>
<tr>
<td align="left">晋升详情</td>
<td align="left">-XX:+PrintTenuringDistribution</td>
</tr>
<tr>
<td align="left">GC详情</td>
<td align="left">-XX:PrintGCDetails -verbose:gc</td>
</tr>
<tr>
<td align="left">FullGC 前 MinorGC</td>
<td align="left">-XX:+ScavengeBeforeFullGC</td>
</tr>
</tbody></table>
<blockquote>
<p>如下内容，是使用参数打印的垃圾回收信息，以及程序结束时堆的信息<br><code>-Xms20m -Xmx20m -Xmn10m -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc</code><br>使用了上面这些jvm参数（堆内存初始20m，最大20m，新生代10m，使用Serial垃圾回收器，打印垃圾回收信息）<br>以<code>[GC</code>开头的两行，表示年轻代垃圾回收信息（老年代垃圾回收以<code>Full GC</code>开头），DefNew表示新生代，后面是回收前内存，回收后内存，总内存，使用时间；然后是整个堆回收前占用内存，回收后占用内存，总内存，回收占用时间，时间主要看最后<code>real</code>的时间，平均时间<br><code>Heap</code> 程序停止的时候的堆信息<br><code>def new generation</code> 新生代堆信息，总内存，已经占用的内存<br><code>eden</code> 伊甸园的内存大小，占用比例<br><code>from</code> 幸存区from的内存大小，使用占比<br><code>to</code> 幸存区to的内存大小，使用占比<br><code>tenured generation</code> 老年代的内存带下，总空间，使用空间<br>老年代的空间大小，使用占比<br><code>Metaspace</code> 的相关信息</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [DefNew: 6436K-&gt;1024K(9216K), 0.0027524 secs] 6436K-&gt;1543K(19456K), 0.0028086 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [DefNew: 8859K-&gt;512K(9216K), 0.0041159 secs] 9378K-&gt;9223K(19456K), 0.0041326 secs] [Times: user=0.00 sys=0.02, real=0.00 secs] </span><br><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 1106K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</span><br><span class="line">  eden space 8192K,   7% used [0x00000000fec00000, 0x00000000fec94930, 0x00000000ff400000)</span><br><span class="line">  from space 1024K,  50% used [0x00000000ff400000, 0x00000000ff480048, 0x00000000ff500000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)</span><br><span class="line"> tenured generation   total 10240K, used 8711K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">   the space 10240K,  85% used [0x00000000ff600000, 0x00000000ffe81c18, 0x00000000ffe81e00, 0x0000000100000000)</span><br><span class="line"> Metaspace       used 3328K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 359K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>


<h1 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h1><h2 id="常见的垃圾收集器"><a href="#常见的垃圾收集器" class="headerlink" title="常见的垃圾收集器"></a>常见的垃圾收集器</h2><table>
<thead>
<tr>
<th align="center">垃圾收集器</th>
<th align="center">开启参数</th>
<th align="center">运行</th>
<th align="center">目标</th>
<th align="center">算法</th>
<th align="center">区域</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Serial</td>
<td align="center">-XX:+UseSerialGC</td>
<td align="center">串行</td>
<td align="center">响应速度优先</td>
<td align="center">复制算法</td>
<td align="center">年轻代</td>
</tr>
<tr>
<td align="center">Serial Old</td>
<td align="center">-XX:+UseSerialOldGC</td>
<td align="center">串行</td>
<td align="center">响应速度优先</td>
<td align="center">标记-整理</td>
<td align="center">老年代</td>
</tr>
<tr>
<td align="center">ParNew</td>
<td align="center">-XX:+UseParNewGC</td>
<td align="center">并行</td>
<td align="center">响应速度优先</td>
<td align="center">复制算法</td>
<td align="center">年轻代</td>
</tr>
<tr>
<td align="center">Parallel Scavenge</td>
<td align="center">-XX:+UseParallelGC</td>
<td align="center">并行</td>
<td align="center">吞吐量优先</td>
<td align="center">复制算法</td>
<td align="center">年轻代</td>
</tr>
<tr>
<td align="center">Parallel Old</td>
<td align="center">-XX:+UseParallelOld</td>
<td align="center">并行</td>
<td align="center">吞吐量优先</td>
<td align="center">标记-整理</td>
<td align="center">老年代</td>
</tr>
<tr>
<td align="center">CMS</td>
<td align="center">-XX:UseConcMarkSweepGC</td>
<td align="center">并行</td>
<td align="center">响应速度优先</td>
<td align="center">标记-清理</td>
<td align="center">老年代</td>
</tr>
<tr>
<td align="center">G1</td>
<td align="center">-XX:UseG1GC</td>
<td align="center">并行</td>
<td align="center">响应速度优先</td>
<td align="center">标记整理+复制算法</td>
<td align="center">全</td>
</tr>
</tbody></table>
<h3 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h3><ul>
<li> 新生代单线程垃圾收集器</li>
<li>在收集垃圾的时候需要停止所有工作线程，直至垃圾收集完毕</li>
<li>client模式下新生代默认垃圾收集器</li>
</ul>
<h3 id="Serial-Old"><a href="#Serial-Old" class="headerlink" title="Serial Old"></a>Serial Old</h3><ul>
<li>单线程老年代垃圾收集器</li>
<li><code>Serial</code> 垃圾收集器的老年代版本</li>
<li><code>CMS</code> 收集器失效之后的备用选择</li>
</ul>
<h3 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h3><ul>
<li>实际上就是<code>Serial</code>收集器的多线程版本（除了多线程外，其他和<code>Serial</code>一模一样，甚至有部分参数都是通用的）</li>
<li>是除了<code>Serial</code>外唯一可以和<code>CMS</code>配合的新生代垃圾收集器（使用<code>CMS</code>作为老年代垃圾收集器，会默认启用该垃圾收集器作为年轻代的收集器）</li>
</ul>
<h3 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h3><ul>
<li>吞吐量优先的年轻代垃圾收集器</li>
</ul>
<h3 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h3><ul>
<li><code>Parallel Scavenge</code>  垃圾收集器的老年代版本（并发）</li>
<li>在 <code>Parallel Old</code> 出现之前，<code>Parallel Scavenge</code> 地位是非常尴尬的，因为能与之匹配的老年代垃圾收集器只有 <code>Serial Old</code>，一直到 <code>Parallel Old</code> 出现之后，才真正的实现了“吞吐量优先”</li>
</ul>
<h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><ul>
<li>响应速度优先的老年代垃圾收集器</li>
<li>整个垃圾收集过程包括以下四个阶段</li>
<li>其中<code>初始标记</code>和<code>重复标记</code>这两个过程任然需要SWT；<ul>
<li><strong>初始标记</strong>：<code>初始标记</code>仅仅就是标记以下<code>GC Root</code>直接关联的对象，这个过程很快</li>
<li><strong>并发标记</strong>：并发标记<code>就是从</code>GC Root`的直接关联对象开始遍历整个对象图的过程，整个过程耗时比较长，但是并不需要停顿用户线程，可以和垃圾收集线程并发运行</li>
<li><strong>重新标记</strong>：<code>重新标记</code>是为了修正在<code>并发标记</code>阶段因用户线程继续执行而导致标记发生变动的那一部分对象的标记记录，这个阶段的停顿时间要比<code>初始标记</code>时间长一点，但也比<code>并发标记</code>的时间要短的多</li>
<li><strong>并发清除</strong>：<code>并发清除</code>阶段主要是并发清除之前已经标记的已经判定为死亡的对象，因为这个阶段不需要移动对象，所以也可以和用户线程并发执行</li>
</ul>
</li>
<li><strong>浮动垃圾</strong>：在并发标记和并发清理阶段，用户线程还是在继续运行的，程序运行自然也就伴随着垃圾产生，但这部分垃圾是出现在标记过程结束之后的，垃圾收集器无法在当次垃圾回收中将他们处理掉，只好等待下一次垃圾收集时再清理</li>
<li>同样，因为在垃圾收集阶段用户线程还是在继续运行的，所以<code>CMS</code>并不能等垃圾把老年代填满之后再进行收集，需要预留一部分的空间给用户线程，默认是92%时进行垃圾回收，但也有并发失败的情况，一旦出现，就会启用<code>Serial Old</code>垃圾收集器进行回收（具体也可以根据实际情况通过参数设置）</li>
<li>由于<code>CSM</code>是基于标记清理算法的，所以会留下内存碎片，当内存碎片过多的情况 下，可能会导致大对象内存分配失败，所以<code>CMS</code>留有参数，可以指定在几次不进行空间整理的垃圾回收后会进行一次空间整理，默认是0，每次都会进行空间整理</li>
<li>JDK9开始被标记为不推荐使用</li>
</ul>
<h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><ul>
<li>用于整个JVM堆的垃圾收集器</li>
<li>不再遵循固定大小以及固定数量的区域划分，而是把连续的java堆划分成一个个独立的区域（<code>Region</code>）</li>
<li>每个 <code>Region</code> 根据需要来扮演新生代、性存区和老年代，根据不同区域扮演的角色不同，使用不用的垃圾收集策略</li>
<li>每个<code> Region</code> 的大小在<code>1m-32m</code>之间，不过需要是2的n次幂，可以通过JVM参数来指定</li>
<li>划分有单独的<code>Humongous</code>区域来存放大对象，如果一个对象的大小超过<code>Region</code>区域的一半，就会被放进<code>Humongous</code>区域，一般<code>Humongous</code>被当做老年代对待<ul>
<li>如果对象的大小超过了<code>Humongous</code>的大小，会被放到N个连续的<code>Humongous</code>区域中</li>
</ul>
</li>
<li>每次垃圾回收并不会再针对整个堆，而是还会针对回收“<code>价值</code>”最大的<code>Region</code></li>
<li><strong>记忆集</strong>：由于是分区域进行垃圾收集，所以每个<code>Region</code>中都有可能会有对象引用了别的<code>Region</code>的对象，也可能被别的<code>Region</code>引用，所以每个<code>Region</code>都会维护一个<code>记忆集</code>，记录着“<code>我指向谁</code>”以及“<code>谁指向我</code>”<ul>
<li>记忆集的数据结构是哈希表，key是别的<code>Region</code>的起始地址，value是卡表索引</li>
<li>卡表是记忆集的一种实现方式，其结构一般可以用byte数组，数组中的值是记录的对象地址</li>
</ul>
</li>
<li><code>G1</code>为每个<code>Region</code>设计了两个名为<code>TAMS</code>的指针，把<code>Region</code>中的一部分空间划分出来用来存放垃圾收集期间新对象的分配<ul>
<li><code>TAMS</code>范围内的对象，默认是存活的，不纳入回收范围</li>
</ul>
</li>
<li>如果内存回收的速度赶不上内存分配的速度，<code>G1</code>也会冻结用户线程，进行STW</li>
<li>G1收集器的运作过程大致可以分为四个步骤：<ul>
<li><strong>初始标记</strong>：仅仅是标记一下<code>GC Root</code>能够直接关联的对象，并且修改一下<code>TAMS</code>指针的值，可以让用户线程在并发阶段在可用的<code>Region</code>中分配对象，并且该阶段是跟<code>Minor GC</code>同步完成的，所以<code>G1</code>在这个阶段并没有额外的停顿</li>
<li><strong>并发标记</strong>：从<code>GC Root</code>开始对堆中对象进行可达性分析，递归扫描整个对象图谱，找到要回收的对象，这个阶段时间比较长，但是是和用户线程同步执行的。扫描完对象图谱之后，会重新处理原始快照记录下得在并发时有引用变动的对象</li>
<li><strong>最终标记</strong>：对用户线程做短暂的暂停，用于处理并发结算结束后遗留下来的少量原始快照记录</li>
<li><strong>筛选回收</strong>：对各个<code>Region</code>回收的成本和价值做一个排序，然后根据用户所希望的停顿时间来制定回收计划，可以回收任意多个<code>Region</code>，然后把决定回收的哪一分<code>Region</code>空间中的存活对象复制到空的<code>Region</code>中，再清理掉整个旧的Region空间，这个操作涉及到 对象的移动，需要暂停用户线程</li>
</ul>
</li>
</ul>
<h3 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h3><ul>
<li><code>ZGC</code>在内存布局上和<code>G1</code>一样，也是使用了<code>Region</code>的结构（官方称为<code>Page</code>或者<code>ZPage</code>）</li>
<li>不过在<code>Region</code>的大小上和<code>G1</code>有所不同，分为三种：<ul>
<li><strong>小型</strong>：固定<code>2兆</code>，存放大小小于<code>256kb</code>的对象</li>
<li><strong>中型</strong>：固定<code>32兆</code>，存放大小小于<code>4兆</code>的对象</li>
<li><strong>大型</strong>：大小不固定，但必须是2的倍数，存放大于<code>4兆</code>的对象，只能存放一个对象（所以最小内存为4M，并不一定就会大于中型）</li>
</ul>
</li>
<li><strong>染色指针</strong>：在有些情况下，并不一定真的要拿到对象进行处理，比如给对象进行<code>三色标记</code>，<code>Serial</code>等垃圾收集器都是直接标记在对象头上的，<code>G1</code>是使用一个独立的数据结构进行标记的（大概占堆内存1/64），而<code>ZGC</code>则是使用<code>染色指针</code>技术，直接标记在指向对象的指针上</li>
<li>同时也可以在指针上标记该对象是否移动，通过这种方式，可以使得回收垃圾时一旦对象复制移动完毕就可以清理掉当前内存，而不用等到所有的引用更改完毕</li>
<li><code>染色指针</code>就是一种将少量额外信息直接存储在指针上的技术</li>
<li><code>ZGC</code>运作过程可以分为四步：<ul>
<li><strong>并发标记</strong>：和<code>G1</code>一样，<code>并发标记</code>是遍历对象图做可达性分析的阶段，前后也要经历类似G1的<code>初始标记</code>、<code>最终标记</code>的短暂停顿，而这些停顿所做的事情也是类似的，不过与<code>G1</code>不同的是<code>ZGC</code>的标记是在指针上，而不是在对象上进行，会更新<code>染色指针</code>中的<code>Marked0</code>、<code>Marked1</code>的标志位</li>
<li><strong>并发预备重分配</strong>：这个阶段会根据特定的查询条件统计出本次收集过程需要清理那些<code>Region</code>，并将这些<code>Region</code>组成<code>重分配集</code>，<code>ZGC</code>扫描标记的时候，会扫描全堆，用更大的扫描分为省去了<code>G1</code>中<code>记忆集</code>的维护</li>
<li><strong>并发重分配</strong>：重分配是<code>ZGC</code>执行过程中的核心阶段，这个过程要把重分配集中的存活对象复制到新的<code>Region</code>中，并为<code>重分配集</code>中的每个<code>Region</code>维护一个<code>转发表</code>，记录从旧对象到新对象的关系，得力于<code>染色指针</code>的支持，<code>ZGC</code>仅从指针上的标记就可以得知一个对象处于<code>重分配集</code>中，如果用户并发访问的对象在<code>重分配集</code>中，本次访问就会被<code>内存屏</code>障捕获，然后根据<code>Region</code>上的转发表访问转发到新复制的对象上，并同时修正该更新引用的值，直接指向新对象，<code>ZGC</code>的这种行为，称为指针的“<code>自愈</code>”，这样做的好处是只有第一次访问旧对象会陷入转发，也就只慢一次。</li>
<li><strong>并发重映射</strong>：重映射所做的事情就是修正整个堆中指向<code>重分配集</code>中旧对象的所有引用，不过这个任务在<code>ZGC</code>中并不是一个迫切需要完成的任务，因为即使使用旧引用去访问对象，也可以<code>自愈</code>，重映射清理这些旧引用的目的并不是为了不变慢，还是为了回收掉转发表的空间，所以ZGC把并发重映射的阶段合并到了下一次并发标记的阶段，反正他们都是需要遍历所有对象，可以省去一次遍历开销</li>
</ul>
</li>
</ul>
<h3 id="三色标记"><a href="#三色标记" class="headerlink" title="三色标记"></a>三色标记</h3><ul>
<li>并发的可达性分析（和用户和线程并发进行可达性标记）</li>
<li>可以按照”是否访问过”这个条件标记成一下三种颜色：<ul>
<li>白色：表示对象尚未被垃圾收集器访问过，最开始对象都是白色，在分析结束后若还是白色，表示对象不可达</li>
<li>黑色：表示垃圾收集器已经访问过，且该对象的引用对象也都已经扫描过</li>
<li>灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少还有一个引用没有被扫描</li>
</ul>
</li>
<li>假如用户线程和收集器线程同时工作，一边标记引用，一边修改关系，此时会出现两中情况：<ul>
<li>已经被标记为存活的对象被切断了引用关系（转变为死亡），这种情况还可以容忍，只是会产生浮动垃圾</li>
<li>已经被标记为死亡的对象，又重新建立了联系（复活了），这种对象如果被收集掉的话会出现程序错误<ul>
<li>同时满足一下两种情况，才会出现这种问题：<ul>
<li>赋值器创建了一条或者多条黑色对象到该对象的引用</li>
<li>赋值器删除了全部灰色对象到该白色对象的引用</li>
</ul>
</li>
<li>解决方案<ul>
<li>增量更新：当黑色对象插入指向白色对象的引用的时候，就将整个引用记录下来，等并发扫描结束后，再将这些记录过的引用关系中的黑色对象为根重新扫描一次，可以理解为当黑色对象被插入一个白色对象后，转变为灰色对象重新扫描。（打破的是第一条规则，CMS使用的是此种方案）</li>
<li>原始快照：当灰色对象要删除指向的白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束后，在将灰色对象作为根重新扫描，可以理解为，无论引用关系是否删除，都会按照刚开始扫描时的对象图谱来进行搜索。（打破的是第二条规则，G1使用的此种方案）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="串行"><a href="#串行" class="headerlink" title="串行"></a>串行</h2><ul>
<li>单线程</li>
<li>堆内存比较小，适合个人电脑(CPU核数少)</li>
</ul>
<p><img src="/2022/08/13/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E4%B8%B2%E8%A1%8C%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="串行垃圾收集器示意图"></p>
<h2 id="吞吐量优先"><a href="#吞吐量优先" class="headerlink" title="吞吐量优先"></a>吞吐量优先</h2><ul>
<li>多线程</li>
<li>堆内存比较大，需要多核CPU</li>
<li>在单位时间内，STW的时间最短</li>
<li>（假设在一个小时内回收垃圾2次，一次0.2秒，一共0.4，一个小时内回收的总耗时是最短的）</li>
<li>垃圾回收时间占程序运行时间的比例越低，吞吐量越高</li>
</ul>
<p><img src="/2022/08/13/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Parallel-Scavenge%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="Parallel-Scavenge垃圾收集器运行示意图"></p>
<h2 id="响应时间优先"><a href="#响应时间优先" class="headerlink" title="响应时间优先"></a>响应时间优先</h2><ul>
<li>多线程</li>
<li>堆内存比较大，需要多核CPU</li>
<li>尽可能让单次STW的时间最短</li>
<li>（假设在一个小时内垃圾回收5次，一次0.1秒，一共0.5秒，每次回收的时间是最短）</li>
</ul>
<p><img src="/2022/08/13/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/CMS%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="CMS垃圾收集器示意图"></p>
<h2 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h2><ul>
<li><p>Serial GC</p>
<ul>
<li>新生代内存不足发生垃圾收集 —— minor GC</li>
<li>老年代内存不足发生垃圾收集 —— full gc</li>
</ul>
</li>
<li><p>Parallel GC</p>
<ul>
<li>新生代内存不足发生垃圾收集 —— minor GC</li>
<li>老年代内存不足发生垃圾收集—— full GC</li>
</ul>
</li>
<li><p>CMS </p>
<ul>
<li>新生代内存不足发生的垃圾收集 —— minor GC </li>
<li>老年代内存不足  —— 并发收集（如果并发收集的速度赶不上垃圾制造的速度，才会发生 Full Gc）</li>
</ul>
</li>
<li><p>G1</p>
<ul>
<li>新生代内存不足发生的垃圾收集 —— minor GC </li>
<li>老年代内存不足  —— 并发收集（如果并发收集的速度赶不上垃圾制造的速度，才会发生 Full Gc）</li>
</ul>
</li>
</ul>
<h2 id="G1内部做出的优化"><a href="#G1内部做出的优化" class="headerlink" title="G1内部做出的优化"></a>G1内部做出的优化</h2><h3 id="JDK-8u20-字符串去重"><a href="#JDK-8u20-字符串去重" class="headerlink" title="JDK 8u20 字符串去重"></a>JDK 8u20 字符串去重</h3><blockquote>
<p>字符串的底层是基于<code>char</code>数组的，以往的在创建一个新的<code>String</code>对象的时候（不是直接赋值常量），无论字符串是否是一样的，都会创建一个新的<code>char</code>数组，不过在<code>JDK 8u20</code>这个版本中做了优化<br>当新生代回收的时候会去检查字符串是否相同，相同就引用同一个<code>char</code>数组<br><code>G1</code>垃圾收集器的功能</p>
</blockquote>
<ul>
<li>-XX:+UseStringDeduplication 默认开启</li>
<li>将所有新分配的字符串放入到一个队列里</li>
<li>当新生代回收时，<code>G1</code>并发检查是否有字符串重复</li>
<li>如果他们的值一样，让他们引用同一个`char[]``</li>
<li>注意：与<code>String.intern()</code>不一样<ul>
<li><code>String.intern()</code>关注的是字符串对象</li>
<li>而字符串去重关注的是<code>char[]</code></li>
<li>在Jvm内部，使用了不同的字符串表</li>
</ul>
</li>
</ul>
<h3 id="JDK-8u40-并发标记类卸载"><a href="#JDK-8u40-并发标记类卸载" class="headerlink" title="JDK 8u40 并发标记类卸载"></a>JDK 8u40 并发标记类卸载</h3><ul>
<li>所有对象都经过并发标记后，就能知道哪些类不再被使用，当一个雷加载器的所有类都不再使用，则卸载它所加载的所有类</li>
<li>-XX:+ClassUnloadingWithConcurrentMark 默认开启</li>
</ul>
<h3 id="JDK-8u60-回收巨型对象"><a href="#JDK-8u60-回收巨型对象" class="headerlink" title="JDK 8u60 回收巨型对象"></a>JDK 8u60 回收巨型对象</h3><ul>
<li>一个对象大于Region的一半时，称之为巨型对象</li>
<li>G1不会对巨型对象进行拷贝</li>
<li>回收时被优先考虑</li>
<li>G1会跟踪老年代所有incoming引用，这样老年代incoming引用为0的巨型对象就可以在新生代垃圾回收时处理掉</li>
</ul>
<h3 id="JDK9-并发标记起始时间的调整"><a href="#JDK9-并发标记起始时间的调整" class="headerlink" title="JDK9 并发标记起始时间的调整"></a>JDK9 并发标记起始时间的调整</h3><ul>
<li>并发标记必须在堆空间占满前完成，否则退化为FullGc</li>
<li>JDK 9 之前需要使用 -XX:InitiatingHeapOccupancyPercent</li>
<li>JDk9可以动态调整<ul>
<li>-XX:InitiatingHeapOccupancyPercent 用来设置初始值</li>
<li>进行数据采样并动态调整</li>
<li>总会添加一个安全的空档空间</li>
</ul>
</li>
</ul>
<h1 id="垃圾回收调优"><a href="#垃圾回收调优" class="headerlink" title="垃圾回收调优"></a>垃圾回收调优</h1><p>预备知识</p>
<ul>
<li>掌握GC相关的JVM参数，会基本的空间调整</li>
<li>掌握相关工具</li>
<li>明白一点：调优跟应用、环境有关，没有放之四海皆准的法则</li>
<li>查看JVM参数（过滤了关于GC的参数）<ul>
<li>java -XX:+PrintFlagsFinal -version | findstr “GC”<h2 id="调优领域"><a href="#调优领域" class="headerlink" title="调优领域"></a>调优领域</h2></li>
</ul>
</li>
<li>内存</li>
<li>锁竞争</li>
<li>cpu占用</li>
<li>io</li>
</ul>
<h2 id="确定目标"><a href="#确定目标" class="headerlink" title="确定目标"></a>确定目标</h2><ul>
<li>明确自己的项目是要做什么（如果是为了科学计算，一般要求吞吐量高，互联网项目，要求低延迟）</li>
<li>【低延迟】还是【高吞吐量】，选择合适的回收器<ul>
<li>低延迟：CMS，G1，ZGC</li>
<li>高吞吐量：ParallelGC</li>
</ul>
</li>
</ul>
<h2 id="最快的GC是不发生GC"><a href="#最快的GC是不发生GC" class="headerlink" title="最快的GC是不发生GC"></a>最快的GC是不发生GC</h2><ul>
<li>查看<code>Full GC</code>前后的内存占用，考虑下面几个问题<ul>
<li>数据是不是太多了？<ul>
<li>比如查询数据库，全表查询然后再代码过滤</li>
</ul>
</li>
<li>数据表示是否太臃肿？<ul>
<li>对象图<ul>
<li>比如只需要表中的几个字段，但是却查询所有字段</li>
</ul>
</li>
<li>对象大小<ul>
<li>对象最少是16个字节，比如<code>intrger</code>24个字节，可以考虑是否使用基本类型<code>int</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>是否存在内存泄漏？</li>
</ul>
<h2 id="新生代调优"><a href="#新生代调优" class="headerlink" title="新生代调优"></a>新生代调优</h2><ul>
<li>新生代的特点：<ul>
<li>所有的 <code>new</code> 操作的内存分配非常廉价<ul>
<li>TLAB thread-local allocation buffer</li>
<li>每个线程会在伊甸园张中分配一块私有区域，每次创建对象都是在自己的私有区域分配，避免并发</li>
</ul>
</li>
<li>死亡对象的回收代价是零</li>
<li>大部分对象用过即死</li>
<li><code>Minor GC</code> 的时间远远低于<code>Full GC</code></li>
</ul>
</li>
</ul>
<h3 id="新生代越大越好吗？"><a href="#新生代越大越好吗？" class="headerlink" title="新生代越大越好吗？"></a>新生代越大越好吗？</h3><blockquote>
<p>新生代如果设置的非常小，会导致不停的做垃圾回收，那这个时候我们是不是把新生代设置的大一点就好了呢？</p>
</blockquote>
<p>显然新生代也不是越大越好</p>
<ul>
<li>首先堆得内存空间是一点的，如果新生代设置的比较大，那么老年代空间必然会被压缩，从而导致老年代大量触发GC，老年代的GC是要比新生代代价大的多</li>
<li>另外如果新生代设置的过大，就会导致有大量的对象在新生代中留存，虽然有着年龄１５的限制，但并不是所有的对象都留到１５才晋升老年代，如果新生代过大，就会导致这一部分原本应该提前晋升老年代的对象在新生代中留存下来（比如大对象）</li>
<li>新生代使用复制算法，如果存留的对象过多，也会导致复制时间过长，包括复制之后更新引用的时间也会增加，从而导致ＳＴＷ时间过长</li>
<li>不过在一定范围内，适当的增加新生代的大小，确实也可以实现一定量的优化</li>
<li>新生代比较合适的范围：【并发量×（请求－响应）】</li>
<li>性存区大到能保存【当前活跃对象+需要晋升对象】</li>
<li>晋升阀值配置得当，让长时间存活的对象尽快晋升（调整晋升阈值）</li>
</ul>
<h2 id="老年代调优"><a href="#老年代调优" class="headerlink" title="老年代调优"></a>老年代调优</h2><p>以CMS为例：</p>
<ul>
<li>CMS的老年代内存越大越好</li>
<li>先尝试不做调优，如果没有Full GC那么表示已经是最优，否则尝试调优新生代</li>
<li>观察发生 Full GC 时老年代内存占用，将老年代内存预设调大</li>
</ul>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="Full-GC和Minor-GC频繁"><a href="#Full-GC和Minor-GC频繁" class="headerlink" title="Full GC和Minor GC频繁"></a>Full GC和Minor GC频繁</h3><ul>
<li>老年代频繁GC，但又没有OOM表示老年代每次回收掉了一些</li>
<li>所以可以考虑是否是年轻代内存空间设置过小，导致大量短寿命对象晋升老年代</li>
<li>或者是年轻代晋升阈值设置过小</li>
</ul>
<h3 id="请求高峰期发生Full-GC，单次暂停时间特别长（CMS）"><a href="#请求高峰期发生Full-GC，单次暂停时间特别长（CMS）" class="headerlink" title="请求高峰期发生Full GC，单次暂停时间特别长（CMS）"></a>请求高峰期发生Full GC，单次暂停时间特别长（CMS）</h3><ul>
<li>因为CMS的垃圾回收是分几个阶段的，所以可以通过GC日志查看是哪个阶段导致的</li>
<li>一般来说只有重新标记和并发清理阶段，如果是重新标记阶段时间过长，可能是因为重新标记的时候会去遍历年轻代，可以通过JVM参数设置在每次老年代垃圾收集之前，进行一次Minor GC</li>
<li>也有可能是因为高峰期产生了大量的垃圾，导致CMS来不及回收，降级为了Serial Old垃圾收集器，可以考虑增大内存空间，或者减小回收时机的百分比</li>
</ul>
<h3 id="老年代内存充裕的情况下，发生Full-GC（CMS-jdk-1-7）"><a href="#老年代内存充裕的情况下，发生Full-GC（CMS-jdk-1-7）" class="headerlink" title="老年代内存充裕的情况下，发生Full GC（CMS jdk 1.7）"></a>老年代内存充裕的情况下，发生Full GC（CMS jdk 1.7）</h3><ul>
<li>jdk1.7永久代还在JVM堆中，考虑可能是因为永久代内存设置过小，导致永久代内存不足而触发GC</li>
</ul>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>黑马JVM课程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发核心知识体系精讲——Java内存模型(二)</title>
    <url>/2021/11/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2%E2%80%94%E2%80%94Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2>Java内存模型——底层原理</h2>

<h2 id="自顶向下（学习方法）"><a href="#自顶向下（学习方法）" class="headerlink" title="自顶向下（学习方法）"></a>自顶向下（学习方法）</h2><ul>
<li>先将试用场景，再讲用法，最后讲原理</li>
<li>直观的了解、具体而感性的认识、有助于加深理解、最后分析源码</li>
<li>兴趣：连这个原理有什么作用都不知道的话，我们肯定是没有兴趣的，而没有兴趣就意味着我们学不好</li>
</ul>
<h2 id="到底什么叫“底层原理”？本章研究的内容是什么？"><a href="#到底什么叫“底层原理”？本章研究的内容是什么？" class="headerlink" title="到底什么叫“底层原理”？本章研究的内容是什么？"></a>到底什么叫“底层原理”？本章研究的内容是什么？</h2><h3 id="从Java代码到CPU指令"><a href="#从Java代码到CPU指令" class="headerlink" title="从Java代码到CPU指令"></a>从Java代码到CPU指令</h3><ul>
<li>最开始，我们编写的Java代码，是*.java文件</li>
<li>在编译（javac命令）后，从刚刚的*.java文件会编译出一个新的java字节码文件（*.class）</li>
<li>JVM会执行刚才生成的字节码文件（*.class），并把字节码文件转化为机器指令</li>
<li>机器指令可以直接在CPU上执行，也就是最终的程序执行</li>
</ul>
<blockquote>
<p>JVM实现会带来不同的”翻译“，不同的CPU平台的机器指令又千差万别，无法保证并发实现的效果一致（如果只是做一份编译，直接进行运行，不同的机器，对相同的编译内容理解也是不一样的，最终会导致运行结果不一致）<br>中断开始向下转移：转化过程的规范、原则（进行约束，以保证相同的代码最终能拿到相同的结果）</p>
</blockquote>
<h2 id="三兄弟：JVM内存结构-VS-Java内存模型-VS-Java对象模式"><a href="#三兄弟：JVM内存结构-VS-Java内存模型-VS-Java对象模式" class="headerlink" title="三兄弟：JVM内存结构 VS Java内存模型 VS Java对象模式"></a>三兄弟：JVM内存结构 VS Java内存模型 VS Java对象模式</h2><ul>
<li>JVM内存结构：和Java虚拟机的运行时区域有关</li>
<li>Java内存模型：和Java的并发编程有关</li>
<li>Java对象模型：和Java对象在虚拟机中的表现形式有关</li>
</ul>
<h3 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h3><ul>
<li>堆：整个运行区域最大的一块，主要存储实例对象，包括数组，如果这些对象不再有引用会被垃圾回收</li>
<li>虚拟机栈：保存基本数据类型，以及对对象的引用</li>
<li>方法区：已经加载的静态变量类信息以及常量信息包括永久引用</li>
<li>本地方法栈：主要是Native方法</li>
<li>程序计数器：主要存储当前线程所执行的字节码的行号数  </li>
</ul>
<p><img src="/2021/11/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2%E2%80%94%E2%80%94Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="JVM内存结构图"></p>
<h3 id="Java对象模型"><a href="#Java对象模型" class="headerlink" title="Java对象模型"></a>Java对象模型</h3><ul>
<li>Java对象自身的存储模型</li>
<li>JVM会给整个类创建一个instanceKlass，保存再方法区，用来再JVM层表示该Java类</li>
<li>当我们再Java代码中，使用new创建一个对象的时候，JVM会创建一个instanceOopDesc对象，这个对象中包含了对象头以及实例数据  </li>
</ul>
<p><img src="/2021/11/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2%E2%80%94%E2%80%94Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/Java%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E5%9B%BE%E7%A4%BA.png" alt="Java对象模型图示"></p>
<h2 id="JMM是什么？"><a href="#JMM是什么？" class="headerlink" title="JMM是什么？"></a>JMM是什么？</h2><h3 id="为什么需要JMM"><a href="#为什么需要JMM" class="headerlink" title="为什么需要JMM"></a>为什么需要JMM</h3><ul>
<li>C语言不存在内存模型的概念</li>
<li>依赖处理器，不同处理器结果不一样</li>
<li>无法保证并发安全</li>
<li>需要一个标准，让多线程运行的结果可预期</li>
</ul>
<h3 id="JMM是规范"><a href="#JMM是规范" class="headerlink" title="JMM是规范"></a>JMM是规范</h3><ul>
<li>Java Memory Model</li>
<li>是一组规范，需要各个JVM的实现来遵守JMM规范，以便于开发者可以利用这些规范，更方便地开发多线程程序</li>
<li>如果没有这样的一个JMM内存模型来规范，那么很可能经过了不同JVM的不同规则的重排序之后，导致不同的虚拟机上运行的结果不一样，那是很大的问题</li>
<li>volatile、synchronized、Lock等的原理都是JMM</li>
<li>如果没有JMM，那就需要我们自己指定什么时候使用内存栅栏等，那是相当麻烦的，幸好有了JMM，让我们只需要用同步工具和关键字就可以开发并发程序</li>
</ul>
<h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><h3 id="重排序的代码案例、什么是重排序"><a href="#重排序的代码案例、什么是重排序" class="headerlink" title="重排序的代码案例、什么是重排序"></a>重排序的代码案例、什么是重排序</h3><ul>
<li>代码演示如下</li>
<li>4行赋值代码的执行顺序决定了最终x和y的结果，一共有3种情况：<ul>
<li>a=1;x=b(0);b=1;y=a(1)，最终结果是x=0，y=1</li>
<li>b=1;y=a(0);a=1;x=b(1)，最终结果是x=1，y=0</li>
<li>b=1;a=1;x=b(1);y=a(1)，最终结果是x=1，y=1<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutOfOrderExecution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread one = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                a = <span class="number">1</span>;</span><br><span class="line">                x = b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread tow = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                b = <span class="number">1</span>;</span><br><span class="line">                y = a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        one.start();</span><br><span class="line">        tow.start();</span><br><span class="line">        one.join();</span><br><span class="line">        tow.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;x = &quot;</span> + x + <span class="string">&quot;, y = &quot;</span> + y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>根据上面的代码可以看出，一般意义来说，是不可能出现x=0和y=0的情况的，但是这种结果却又出现了</li>
<li>只有执行顺序为  y=a;a=1;x=b;b=1;  的时候才会出现x=0，y=0</li>
</ul>
<p><img src="/2021/11/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2%E2%80%94%E2%80%94Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F%E7%8E%B0%E8%B1%A1%E7%BB%93%E6%9E%9C%E5%9B%BE.png" alt="指令重排序现象结果图"></p>
<ul>
<li><strong>什么是重排序</strong>：在线程1内部的两行代码的实际执行顺序和代码在Java文件中的顺序不一致，代码指令并不是严格按照代码语句顺序执行的，它们的顺序被改变了，这就是重排序，这里被颠倒的是y=a和b=1这两行语句</li>
</ul>
<h3 id="重排序的好处：提高处理速度"><a href="#重排序的好处：提高处理速度" class="headerlink" title="重排序的好处：提高处理速度"></a>重排序的好处：提高处理速度</h3><blockquote>
<p>如下图所示，左边三行代码，对应三段指令，当指令重拍之后，就会对应到右边的顺序，对a来说少了一次读和写操作  </p>
</blockquote>
<p><img src="/2021/11/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2%E2%80%94%E2%80%94Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F%E7%9A%84%E5%A5%BD%E5%A4%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="指令重排序的好处示意图"></p>
<h3 id="重排序的3种情况：编译器优化、CPU指令重拍、内存的”重排序“"><a href="#重排序的3种情况：编译器优化、CPU指令重拍、内存的”重排序“" class="headerlink" title="重排序的3种情况：编译器优化、CPU指令重拍、内存的”重排序“"></a>重排序的3种情况：编译器优化、CPU指令重拍、内存的”重排序“</h3><ul>
<li>编译器优化：包括JVM，JIT编译器等</li>
<li>CPU指令重排：就算编译器不发生重拍，CPU也可能对指令进行重排</li>
<li>内存的“重排序”：线程A的修改线程B看不到（表面看起来像重排，实质是并发问题），引出可见性的问题</li>
</ul>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><h3 id="案例：演示什么是可见性"><a href="#案例：演示什么是可见性" class="headerlink" title="案例：演示什么是可见性"></a>案例：演示什么是可见性</h3><ul>
<li>具体演示代码如下所示，开启两个线程，同时操作变量a和b</li>
<li>一共会出现如下四种结果：</li>
<li>a=3;b=2;(线程1刚修改了a，还未修改b，线程2进行打印)</li>
<li>a=1;b=2;(线程2先于线程1运行)</li>
<li>a=3;b=3;(线程1运行完毕，线程2打印运行)</li>
<li>a=1;b=3;(从代码上看，这种情况几乎是不可能的，但是却真实出现了，线程1的操作对线程2来说，并不是完全可见的，线程2无法或者只能看到部分线程1的操作)<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldVisibility</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FieldVisibility test = <span class="keyword">new</span> FieldVisibility();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                test.change();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                test.print();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;b = &quot;</span> + b + <span class="string">&quot; a = &quot;</span> + a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">3</span>;</span><br><span class="line">        b = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="为什么会有可见性问题"><a href="#为什么会有可见性问题" class="headerlink" title="为什么会有可见性问题"></a>为什么会有可见性问题</h3><ul>
<li>CPU有多级缓存，导致读的数据过期<ul>
<li>高速缓存的容量比主内存小，但是速度仅次于寄存器，所以再CPU和主内存之间多了cache层</li>
<li>线程间的对于共享变量的可见性问题不是直接由多个引起的，而是由多缓存引起的</li>
<li>如果多有核心都只用一个缓存，那么也就不存在内存可见性问题了</li>
<li>每个核心都会将自己需要的数据读到独占缓存中，数据修改后也是写入到缓存中，然后等待刷入到主存中，多以会导致有些核心读取的值是一个过期的值</li>
</ul>
</li>
</ul>
<h3 id="JMM的抽象：主内存和本地内存"><a href="#JMM的抽象：主内存和本地内存" class="headerlink" title="JMM的抽象：主内存和本地内存"></a>JMM的抽象：主内存和本地内存</h3><h4 id="什么是主内存和本地内存"><a href="#什么是主内存和本地内存" class="headerlink" title="什么是主内存和本地内存"></a>什么是主内存和本地内存</h4><ul>
<li>Java作为高级语言，屏蔽了这些底层细节，用JMM定义了一套读写内存数据的规范，虽然我们不再需要关心一级缓存和二级缓存的问题，但是，JMM抽象了主内存和本地内存的概念。</li>
<li>这里说的本地内存并不是真的一块给每个线程分配的内存，而是JMM的一个抽象，是对于寄存器、一级缓存、二级缓存等的抽象</li>
</ul>
<h4 id="主内存和本地内存的关系"><a href="#主内存和本地内存的关系" class="headerlink" title="主内存和本地内存的关系"></a>主内存和本地内存的关系</h4><ul>
<li>JMM有一些规定<ul>
<li>所有的变量都是存储再主内存中，同时每个线程也有自己独立的工作内存，工作内存中的变量内容是主内存中的拷贝</li>
<li>线程不能直接读写主内存中的变量，而是只能操作自己工作内存中的变量，然后同步到主内存中</li>
<li>主内存是多个线程共享的，但线程间不共享工作内存，如果线程间=需要通信，必须借助主内存中转来完成</li>
</ul>
</li>
<li>所有的共享变量存在于主内存中，每个线程有自己的本地内存，而且线程读写共享数据也是通过本地内存交换的，所以才导致了可见性问题</li>
</ul>
<h3 id="Happens-Before原则"><a href="#Happens-Before原则" class="headerlink" title="Happens-Before原则"></a>Happens-Before原则</h3><ul>
<li>单线程原则<ul>
<li>排在后面的语句一定能看到前面的语句的操作</li>
<li>不影响重排序，如果重排序了，那么排在后面的也是能看到前面的语句的操作的</li>
</ul>
</li>
<li>锁操作（synchronized和Lock）<ul>
<li>如果一个线程对某把锁进行了解锁，另一个线程对这把锁进行了加锁，那么后面的线程一定能看到前面线程解锁前的所有操作</li>
</ul>
</li>
<li>volatile变量<ul>
<li>如果变量被volatile变量修饰，只要写入了就一定能被其他线程获取到</li>
</ul>
</li>
<li>线程启动<ul>
<li>子线程在启动的时候，能看到之前主线程的所有操作</li>
</ul>
</li>
<li>线程join<ul>
<li>一旦针对某个线程进行了join，那么后面的语句一定能看到这个线程join之前的所有操作</li>
</ul>
</li>
<li>传递<ul>
<li>一份代码中有很多行，原则上第一行执行完第二行一定能看到第一行的操作，第三行也一定能看到第二行的操作，所以第三行也可以看到第一行的操作</li>
</ul>
</li>
<li>中断<ul>
<li>一个线程被其他线程中断(interrupt)时，那么检测中断(isInterrupted)或者抛出InterruptedException一定能看到</li>
</ul>
</li>
<li>构造方法<ul>
<li>finalize()方法一定能看到构造方法中的最后一行语句（不做重点）</li>
</ul>
</li>
<li>工具类的happens-Before原则<ul>
<li>线程安全的容器get一定能看到在此之前的put等存入动作</li>
<li>CountDownLath</li>
<li>Semaphore</li>
<li>Future</li>
<li>线程池</li>
<li>CyclicBarrier</li>
</ul>
</li>
</ul>
<blockquote>
<p>近朱者赤：给b加了volatile，不仅b被影响，也可以实现轻量级同步<br>b之前的写入操作（对应代码b = a）对读取b后面的代码（print b）都可见，所以在writerThread里面对a的赋值，一定会对readerThread里面的读取可见，所以这里面的a即使不加volatile，只要b读到3，就可以由happens-before原则保证读取到的都是3，而不可能读取到1<br>（因为a对b进行了赋值，所以该语句的上一句，也就是对a的赋值操作，也必须完成之后，并且可见a之后，才能对b进行赋值操作）</p>
</blockquote>
<h3 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h3><h4 id="volatile是什么？"><a href="#volatile是什么？" class="headerlink" title="volatile是什么？"></a>volatile是什么？</h4><ul>
<li>volatile是一种同步机制，比synchronized或者Lock相关类更轻量，因为使用volatile并不会发生上下文切换等开销很大的行为</li>
<li>如果一个变量被修饰成volatile，那么JVM就知道了这个变量可能会被并发修改</li>
<li>但是开销小，相应的能力也小，虽然说volatile是用来同步的保证线程安全的，但是volatile做不到synchronized那样的原子保护，volatile仅在很有限的场景下才能发挥作用</li>
</ul>
<h4 id="volatile的适用场景"><a href="#volatile的适用场景" class="headerlink" title="volatile的适用场景"></a>volatile的适用场景</h4><ul>
<li>不适用：a++</li>
<li>适用场景1：boolean flag，如果一个共享变量自始至终只被各个线程赋值，而没有其他操作，那么就可以用volatile来代替synchronized或者代替原子变量，因为赋值自身是有原子性的，而volatile又保证了可见性，所以就足以保证线程安全</li>
<li>适用场景2：作为刷新之前变量的触发器</li>
</ul>
<h4 id="volatile的两点作用"><a href="#volatile的两点作用" class="headerlink" title="volatile的两点作用"></a>volatile的两点作用</h4><ul>
<li>可见性：读一个volatile变量之前，需要先使相应的本地缓存失效，这样就必须到主内存读取最新值，写一个volatile属性会立即刷入到主内存</li>
<li>禁止指令重排序优化：解决单例双重锁乱序问题</li>
</ul>
<h4 id="volatile和synchronized的关系"><a href="#volatile和synchronized的关系" class="headerlink" title="volatile和synchronized的关系"></a>volatile和synchronized的关系</h4><ul>
<li>volatile在这方面可以看做是轻量版的synchronized：如果一个共享变量自始至终只被各个线程赋值，而没有其他的操作，那么就可以用volatile来代替synchronized或者代替原子变量，因为赋值操作自身是有原子性的，而volatile又保证了可见性，所以就足以保证线程安全</li>
</ul>
<h4 id="volatile小结"><a href="#volatile小结" class="headerlink" title="volatile小结"></a>volatile小结</h4><ul>
<li>volatile修饰符适用于一下场景：某个属性被多个线程共享，其中有一个线程修改了此属性，其他线程可以立即得到修改后的值，比如boolean flag，或者作为触发器，实现轻量级同步</li>
<li>volatile属性的读写操作都是无锁的，它不能替代synchronized因为它没有提供原子性和互斥性，因为无锁，不需要花费时间在获取锁和释放锁上，所以说它是低成本的</li>
<li>volatile只能作用于属性，我们用volatile修饰属性，这样compilers就不会对这个属性做指令重排序</li>
<li>volatile提供了可见性，任何一个线程对其的修改将立马对其他线程可见。volatile属性不会被线程缓存，始终从主内存中读取</li>
<li>volatile提供了happens-before保证，对volatile变量v的写入happens-before所有其他线程后续对v的读操作</li>
<li>volatile可以使得long和double的赋值是原子的，后面马上会讲long和double的原子性</li>
</ul>
<h3 id="能保证可见性的措施"><a href="#能保证可见性的措施" class="headerlink" title="能保证可见性的措施"></a>能保证可见性的措施</h3><ul>
<li>除了volatile可以保证可见性之外，synchronized、Lock、并发集合、Thread.join()和Thread.start()等都可以保证可见性</li>
<li>具体看happens-before原则的规定</li>
</ul>
<h3 id="升华：对synchronized可见性的正确理解"><a href="#升华：对synchronized可见性的正确理解" class="headerlink" title="升华：对synchronized可见性的正确理解"></a>升华：对synchronized可见性的正确理解</h3><ul>
<li>synchronized不仅保证了原子性，还保证了可见性</li>
<li>synchronized不仅让被保护的代码安全，还近朱者赤（synchronized加锁时可以看到所有加锁前的操作，所以另一个线程在加锁的时候，也可以看到这个线程加锁前的操作）</li>
</ul>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><h3 id="什么是原子性"><a href="#什么是原子性" class="headerlink" title="什么是原子性"></a>什么是原子性</h3><ul>
<li>一系列的操作，要么全部执行成功，要么全部不执行，不会出现执行一半的情况，整个操作是不可分割的（ATM即取钱）</li>
<li>i++不是原子性的（首先会先读取i的值，然后执行加1操作，然后写回去，这三步操作，两个线程完全是可能交替执行的）</li>
<li>用synchronized实现原子性</li>
</ul>
<h3 id="Java中的原子操作有那些？"><a href="#Java中的原子操作有那些？" class="headerlink" title="Java中的原子操作有那些？"></a>Java中的原子操作有那些？</h3><ul>
<li>除了long和double之外的基本类型（int,byte,boolean,short,char,float）的赋值操作</li>
<li>所有引用referebce的赋值操作，不管是32位机器还是64位的机器</li>
<li>java.concurrent.Atomic.* 包中所有类都是原子类</li>
</ul>
<h3 id="long和double的原子性"><a href="#long和double的原子性" class="headerlink" title="long和double的原子性"></a>long和double的原子性</h3><ul>
<li>问题描述：官方文档、对于64位值的写入，可以分为两个32位的操作进行写入，读取错误、使用volatile解决</li>
<li>结论：在32位的JVM上，long和double的操作不是原子性的，但是在64位的JVM上是原子性的</li>
<li>实际开发中：商用Java虚拟机中不会出现这种问题</li>
</ul>
<h3 id="原子操作-原子操作-！-原子操作"><a href="#原子操作-原子操作-！-原子操作" class="headerlink" title="原子操作 + 原子操作 ！= 原子操作"></a>原子操作 + 原子操作 ！= 原子操作</h3><ul>
<li>简单的把原子操作组合在一起，并不能保证整体依然具有原子性</li>
<li>比如去ATM取两次钱是独立的原子操作，但是期间可能把银行卡借给其他人，也就是被其他线程打断或修改。</li>
<li>全同步的HashMap也不完全安全（比如先从中取出一个值，进行判断然后修改，然后再put，这一系列操作并不是原子性的，所以可能会出现问题，类似i++）</li>
</ul>
<h2 id="常见面试问题"><a href="#常见面试问题" class="headerlink" title="常见面试问题"></a>常见面试问题</h2><ul>
<li><p>JMM应用实例：单例模式8中写法、单例和并发编程的关系</p>
<ul>
<li><p>单例模式的作用（为什么要使用单例模式）</p>
<blockquote>
<p>节省内存和计算（假如某一资源在获取后就不会经常变动，而获取的过程又很耗费cpu或内存，可以使用单例）<br>保证结果正确（有时候可能会做一些统计，为了速度，可以使用多线程进行统计，但是最终还是要有一个全局的单例计数器）<br>方便管理（比如一些工具类）</p>
</blockquote>
</li>
<li><p>单例模式适用场景</p>
<blockquote>
<p>无状态的工具类：比如日志工具类，不管是在哪里使用，我们需要的只是他帮我们记录日志信息，除此之外，并不需要在它的实例对象上存储任何状态，这时候我们就只需要一个实例对象即可<br>全局信息类：比如我们在一个类上记录网站的访问次数，我们不希望有的访问记录在对象A上，有的却在对象B上，这个时候我们就让这个类成为单例</p>
</blockquote>
</li>
</ul>
</li>
<li><p>讲一讲Java内存模型</p>
</li>
<li><p>volatile和synchronized的异同</p>
</li>
<li><p>什么是原子操作？Java中有那些原子操作？生产对象的过程是不是原子操作？</p>
</li>
<li><p>什么是内存可见性</p>
</li>
<li><p>64位的double和long写入的时候是原子的吗？</p>
</li>
</ul>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java并发核心知识体系精讲</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发核心知识体系精讲——死锁(三)</title>
    <url>/2021/11/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2%E2%80%94%E2%80%94%E6%AD%BB%E9%94%81/</url>
    <content><![CDATA[<h2>死锁——从生产到消除</h2>


<h2 id="死锁是什么？有什么危害？"><a href="#死锁是什么？有什么危害？" class="headerlink" title="死锁是什么？有什么危害？"></a>死锁是什么？有什么危害？</h2><h3 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h3><ul>
<li>发生在并发中</li>
<li>互不相让：当两个（或更多）线程（或进程）相互持有对方所需要的资源，又不主动释放，导致所有人都无法继续前进，导致程序陷入无尽阻塞，这就是死锁</li>
<li>多个线程造成死锁的情况<ul>
<li>如果多个线程之间的依赖关系是环形，存在环路的锁的依赖关系，那么也可能会发生死锁</li>
</ul>
</li>
</ul>
<h3 id="死锁的影响"><a href="#死锁的影响" class="headerlink" title="死锁的影响"></a>死锁的影响</h3><ul>
<li>死锁的影响不同系统中是不一样的，这取决于系统对死锁的处理能力<ul>
<li>数据库中：检测并放弃事务</li>
<li>JVM中：无法自动处理</li>
</ul>
</li>
</ul>
<h3 id="几率不高但危害大"><a href="#几率不高但危害大" class="headerlink" title="几率不高但危害大"></a>几率不高但危害大</h3><ul>
<li>不一定发生，但是遵守“墨菲定律”</li>
<li>一旦发生，多是高并发场景，影响用户多</li>
<li>整个系统崩溃、子系统崩溃、性能降低</li>
<li>压力测试无法找出所有潜在的死锁</li>
</ul>
<h2 id="发生死锁的例子"><a href="#发生死锁的例子" class="headerlink" title="发生死锁的例子"></a>发生死锁的例子</h2><h3 id="最简单的情况"><a href="#最简单的情况" class="headerlink" title="最简单的情况"></a>最简单的情况</h3><blockquote>
<p>代码如下所示<br>当类的对象flag=1时(T1)，先锁定o1，睡眠500毫秒，然后锁定o2<br>而T1在睡眠的时候，另一个flag=0的对象(T2)线程启动，先锁定o2，睡眠500毫秒，等待T1释放o1<br>T1睡眠结束后，需要锁定o2才能继续执行，而此时o2已经被T2锁定<br>T2睡眠结束后，需要锁定o1才能继续执行，而此时o1已经被T1锁定<br>T1、T2相互等待，都需要对方锁定的资源才能继续执行，从而死锁</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MustDeadLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> Object o2 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MustDeadLock r1 = <span class="keyword">new</span> MustDeadLock();</span><br><span class="line">        MustDeadLock r2 = <span class="keyword">new</span> MustDeadLock();</span><br><span class="line">        r1.flag = <span class="number">1</span>;</span><br><span class="line">        r2.flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">new</span> Thread(r1).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(r2).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o1)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (o2)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程1拿到了锁&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o2)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (o1)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程2拿到了锁&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实际生产中的例子：转账"><a href="#实际生产中的例子：转账" class="headerlink" title="实际生产中的例子：转账"></a>实际生产中的例子：转账</h3><ul>
<li>需要两把锁（A向B转钱，需要把A的账户锁定，也需要把B的账户锁定）</li>
<li>获取两把锁成功，且余额大于0，则扣除转出人，增加收款人的余额，是原子操作</li>
<li>顺序相反导致死锁（A向B转钱，B同时向A转钱）</li>
</ul>
<h2 id="死锁的4个必要条件"><a href="#死锁的4个必要条件" class="headerlink" title="死锁的4个必要条件"></a>死锁的4个必要条件</h2><ul>
<li>互斥条件（某一个资源只能同时被一个线程拥有）</li>
<li>请求与保持条件（请求另外一把锁，但是保持自身已有的锁）</li>
<li>不剥夺条件（不会剥夺其中的一个锁给另外一个）</li>
<li>循环等待条件（互相等待）</li>
</ul>
<h2 id="如何定位死锁？"><a href="#如何定位死锁？" class="headerlink" title="如何定位死锁？"></a>如何定位死锁？</h2><ul>
<li>jstack<ul>
<li>使用工具查看到运行的java项目的pid</li>
<li>执行jstack pid （查看线程信息）</li>
</ul>
</li>
<li>ThreadMXBean代码演示<ul>
<li>代码如下所示，在程序进入死锁后，运行如下代码，可以获取死锁的线程信息<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();</span><br><span class="line">long[] deadlockedThreads = threadMXBean.findDeadlockedThreads();</span><br><span class="line">if (deadlockedThreads != null &amp;&amp; deadlockedThreads.length &gt; 0)&#123;</span><br><span class="line">    for (int i = 0; i &lt; deadlockedThreads.length; i++) &#123;</span><br><span class="line">        ThreadInfo threadInfo = threadMXBean.getThreadInfo(deadlockedThreads[i]);</span><br><span class="line">        System.out.println(threadInfo.getThreadName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="修复死锁的策略"><a href="#修复死锁的策略" class="headerlink" title="修复死锁的策略"></a>修复死锁的策略</h2><h3 id="线上发生了死锁应该怎么办？"><a href="#线上发生了死锁应该怎么办？" class="headerlink" title="线上发生了死锁应该怎么办？"></a>线上发生了死锁应该怎么办？</h3><ul>
<li>线上问题都需要防范于未然，不造成损失的扑灭几乎已经是不可能</li>
<li>保存案发现场然后立刻重启服务器</li>
<li>暂时保证线上服务的安全，然后再利用刚才保存的信息，排查死锁，修改代码，重新发版</li>
</ul>
<h3 id="常见的修复策略"><a href="#常见的修复策略" class="headerlink" title="常见的修复策略"></a>常见的修复策略</h3><h4 id="避免测试"><a href="#避免测试" class="headerlink" title="避免测试"></a>避免测试</h4><ul>
<li>避免相反的获取锁的顺序</li>
<li>实际上不在乎获取锁的顺序<h5 id="转账换序方案"><a href="#转账换序方案" class="headerlink" title="转账换序方案"></a>转账换序方案</h5></li>
<li>将获取锁的顺序固定，不允许有的线程先拿到锁一，有的线程先拿到锁二</li>
<li>比如可以根据主键进行排序，无论是你给我转账还是我给你转账，那么获取多的时候都先获取主键值小的那把锁，再获取主键值大的<blockquote>
<p>代码如下所示<br>转账时，获取锁的顺序按照hashCode进行排序，如果hashCode相同，那么就同时尝试获取第三把锁</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferMoney1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Account a = <span class="keyword">new</span> Account(<span class="number">500</span>);</span><br><span class="line">    <span class="keyword">static</span> Account b = <span class="keyword">new</span> Account(<span class="number">500</span>);</span><br><span class="line">    <span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        TransferMoney1 r1 = <span class="keyword">new</span> TransferMoney1();</span><br><span class="line">        TransferMoney1 r2 = <span class="keyword">new</span> TransferMoney1();</span><br><span class="line">        r1.flag = <span class="number">1</span>;</span><br><span class="line">        r2.flag = <span class="number">0</span>;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(r1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(r2);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;a的余额：&quot;</span> + a.balance);</span><br><span class="line">        System.out.println(<span class="string">&quot;b的余额：&quot;</span> + b.balance);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">            transferMoney(a, b, <span class="number">200</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">            transferMoney(b, a, <span class="number">200</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">transferMoney</span><span class="params">(Account from, Account to, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Helper</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (from.balance - amount &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;余额不足，转账失败。&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                from.balance -= amount;</span><br><span class="line">                to.balance += amount;</span><br><span class="line">                System.out.println(<span class="string">&quot;成功转账&quot;</span> + amount + <span class="string">&quot;元&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> fromHash = System.identityHashCode(from);</span><br><span class="line">        <span class="keyword">int</span> toHash = System.identityHashCode(to);</span><br><span class="line">        <span class="keyword">if</span> (fromHash &lt; toHash) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (from) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (to) &#123;</span><br><span class="line">                    <span class="keyword">new</span> Helper().transfer();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (fromHash &gt; toHash)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (to) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (from) &#123;</span><br><span class="line">                    <span class="keyword">new</span> Helper().transfer();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (to) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (from) &#123;</span><br><span class="line">                        <span class="keyword">new</span> Helper().transfer();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> balance;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(<span class="keyword">int</span> balance)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.balance = balance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="哲学家就餐的换手方案"><a href="#哲学家就餐的换手方案" class="headerlink" title="哲学家就餐的换手方案"></a>哲学家就餐的换手方案</h5><p>问题描述：如下图，五个哲学家围着圆桌吃饭，但是只有五根筷子如下分布，每次开始吃饭，哲学家们就会先拿起左边的筷子，再拿起右边的筷子，然后吃饭，如果右边的筷子被人拿了就等着别人放下再获取</p>
<ul>
<li>假设每个人都拿起了左边的筷子，然后等待右边的，这样就会陷入无尽等待（死锁）</li>
</ul>
<p><img src="/2021/11/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2%E2%80%94%E2%80%94%E6%AD%BB%E9%94%81/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98%E5%9B%BE%E7%A4%BA.png" alt="哲学家就餐问题图示"></p>
<blockquote>
<p>死锁代码如下所示：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiningPhilosophers</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Philosophers</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        Object leftChopstick = <span class="keyword">new</span> Object();</span><br><span class="line">        Object rightChopstick = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Philosophers</span><span class="params">(Object leftChopstick, Object rightChopstick)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.leftChopstick = leftChopstick;</span><br><span class="line">            <span class="keyword">this</span>.rightChopstick = rightChopstick;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    doAction(<span class="string">&quot;Thinking&quot;</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (leftChopstick) &#123;</span><br><span class="line">                        doAction(<span class="string">&quot;拿起左边筷子&quot;</span>);</span><br><span class="line">                        <span class="keyword">synchronized</span> (rightChopstick) &#123;</span><br><span class="line">                            doAction(<span class="string">&quot;拿起右边筷子&quot;</span>);</span><br><span class="line">                            doAction(<span class="string">&quot;放下右边筷子&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        doAction(<span class="string">&quot;放下左边筷子&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">(String action)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;  &quot;</span> + action);</span><br><span class="line">            Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">10</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Philosophers[] philosophers = <span class="keyword">new</span> Philosophers[<span class="number">5</span>];</span><br><span class="line">        Object[] chopsticks = <span class="keyword">new</span> Object[philosophers.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chopsticks.length; i++) &#123;</span><br><span class="line">            chopsticks[i] = <span class="keyword">new</span> Object();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; philosophers.length; i++) &#123;</span><br><span class="line">            Object leftChopstick = chopsticks[i];</span><br><span class="line">            Object rightChopstick = chopsticks[(i + <span class="number">1</span>) % chopsticks.length];</span><br><span class="line">            philosophers[i] = <span class="keyword">new</span> Philosophers(leftChopstick, rightChopstick);</span><br><span class="line">            <span class="keyword">new</span> Thread(philosophers[i], <span class="string">&quot;哲学家&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot;号&quot;</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="多种解决方案"><a href="#多种解决方案" class="headerlink" title="多种解决方案"></a>多种解决方案</h6><ul>
<li>服务员检测（避免策略）<blockquote>
<p>每次拿筷子找服务员拿，由服务员去协调</p>
</blockquote>
</li>
<li>改变一个哲学家拿筷子的顺序（避免策略）<blockquote>
<p>其中一个哲学家先拿起右边的筷子，再拿左边的<br>代码更改如下</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (int i = 0; i &lt; philosophers.length; i++) &#123;</span><br><span class="line">    Object leftChopstick = chopsticks[i];</span><br><span class="line">    Object rightChopstick = chopsticks[(i + 1) % chopsticks.length];</span><br><span class="line">    if (i == philosophers.length-1)</span><br><span class="line">        philosophers[i] = new Philosophers(rightChopstick,leftChopstick);</span><br><span class="line">    else</span><br><span class="line">        philosophers[i] = new Philosophers(leftChopstick, rightChopstick);</span><br><span class="line">    new Thread(philosophers[i], &quot;哲学家&quot; + (i + 1) + &quot;号&quot;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>餐票（避免策略）<blockquote>
<p>想要吃饭需要先拿到餐票，餐票只有四张</p>
</blockquote>
</li>
<li>领导调节（检测与恢复策略）<blockquote>
<p>发现死锁之后，使其中一个哲学家放下筷子</p>
</blockquote>
</li>
</ul>
<h4 id="检测与恢复策略"><a href="#检测与恢复策略" class="headerlink" title="检测与恢复策略"></a>检测与恢复策略</h4><p>一段时间检测是否有死锁，如果有就剥夺某一个资源，来打开死锁</p>
<ul>
<li>检测算法：锁的调用链路图<ul>
<li>允许发生死锁</li>
<li>每次调用锁都记录</li>
<li>定期检测“锁的调用链路图”中是否存在环路</li>
</ul>
</li>
<li>恢复方法1：进程终止<ul>
<li>逐个终止线程，直到死锁消除</li>
<li>终止顺序<ul>
<li>优先级（是前台交互还是后台处理）</li>
<li>已占用资源、还需要的资源（还需要一点资源就可以完成）</li>
<li>已经运行时间</li>
</ul>
</li>
</ul>
</li>
<li>恢复方法2：资源抢占<ul>
<li>把已经分发出去的锁给收回来</li>
<li>让线程回退几步，这样就不用结束整个线程，成本比较低</li>
<li>缺点：可能同一个线程一直被抢占，那就会造成饥饿</li>
</ul>
</li>
</ul>
<h4 id="鸵鸟策略"><a href="#鸵鸟策略" class="headerlink" title="鸵鸟策略"></a>鸵鸟策略</h4><ul>
<li>鸵鸟这种动物在遇到危险的时间，通常就会把头埋在地上，这样一来它就看不到危险了。而鸵鸟策略的意思就是说，如果我们发生了死锁的概率极其低，那么我们就直接忽略它，直到死锁发生的时候，再人工修复</li>
</ul>
<h3 id="实际工程中如何避免死锁"><a href="#实际工程中如何避免死锁" class="headerlink" title="实际工程中如何避免死锁"></a>实际工程中如何避免死锁</h3><ul>
<li>设置超时时间<ul>
<li>Lock的tryLock(long timeout,TimeUnit unit)</li>
<li>synchronized不具备尝试锁的能力</li>
<li>造成超时的可能性很多：发生了死锁、线程陷入了死循环、线程执行很慢</li>
<li>超时时间到了就认为获取锁失败<br>具体代码演示如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TryLockDeadlock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Lock lock1 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">static</span> Lock lock2 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TryLockDeadlock r1 = <span class="keyword">new</span> TryLockDeadlock();</span><br><span class="line">        TryLockDeadlock r2 = <span class="keyword">new</span> TryLockDeadlock();</span><br><span class="line">        r1.flag = <span class="number">1</span>;</span><br><span class="line">        r2.flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">new</span> Thread(r1).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(r2).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (lock1.tryLock(<span class="number">800</span>, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                        Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">                        <span class="keyword">if</span> (lock2.tryLock(<span class="number">800</span>, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;线程1已经成功获取了两把锁&quot;</span>);</span><br><span class="line">                            lock2.unlock();</span><br><span class="line">                            lock1.unlock();</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;线程1获取锁2失败，已重试&quot;</span>);</span><br><span class="line">                            lock1.unlock();</span><br><span class="line">                            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程1获取第一把所失败，已重实&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (lock2.tryLock(<span class="number">3000</span>, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                        Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">                        <span class="keyword">if</span> (lock1.tryLock(<span class="number">3000</span>, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;线程2已经成功获取了两把锁&quot;</span>);</span><br><span class="line">                            lock1.unlock();</span><br><span class="line">                            lock2.unlock();</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;线程2获取锁1失败，已重试&quot;</span>);</span><br><span class="line">                            lock2.unlock();</span><br><span class="line">                            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程1获取第2把所失败，已重实&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>多使用并发类而不是自己设计锁<ul>
<li><code>ConcurrentHashMap</code>、<code>ConcurrentLinkedQueue</code>、<code>AtomicBoolean</code>等</li>
<li>实际应用中<code>java.util.concurrent.atomic</code>十分有用，简单方便且效率比使用Lock更高</li>
<li>多用并发集合少使用同步集合，并发集合比同步集合的可扩展性更好</li>
<li>并发场景需要用到map，首先想到使用<code>ConcurrentHashMap</code></li>
</ul>
</li>
<li>尽量降低锁的使用粒度：用不同的锁而不是一个锁</li>
<li>如果能使用同步代码块，就不使用同步方法：自己指定锁对象</li>
<li>给你的线程起一个有意义的名字：debug和排查时事半功倍，框架和JDK都遵守这个最佳实践</li>
<li>避免锁的嵌套：锁嵌套非常容易造成死锁</li>
<li>分配资源前先看能不能收回来：银行家算法</li>
<li>尽量不要几个功能使用同一把锁：专锁专用</li>
</ul>
<h2 id="其他活性故障"><a href="#其他活性故障" class="headerlink" title="其他活性故障"></a>其他活性故障</h2><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul>
<li>死锁是最常见的活跃性问题，不过除了刚才的死锁之外，还有一些类似的问题，会导致程序无法顺序执行，统称为活跃性问题</li>
</ul>
<h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><p>比如哲学家就餐问题：在完全相同的时刻进入餐厅，并同时拿起左手边的筷子，拿不到右手边的筷子，那么这些哲学家就会等待五分钟，<br>同时放下手中的筷子，然后再等待五分钟，又同时拿起这些筷子（相同的时间拿起，相同的时间放下，等待相同的时间那么同样无法完成就餐）</p>
<h4 id="什么是活锁"><a href="#什么是活锁" class="headerlink" title="什么是活锁"></a>什么是活锁</h4><ul>
<li>虽然线程并没有阻塞，也始终再运行（所以叫做“活”锁，线程是“活”的），但是程序却得不到进展，因为线程始终重复做同样的事</li>
<li>如果这里是死锁，那么就是这里两个人始终一动不动，直到对方先抬头，他们之间不再说话，只是等待</li>
<li>如果发生活锁，那么这里的情况就是双方都不停的对对方说”你先起来吧，你先起来吧”，双方都一直再说话，在运行</li>
<li>活锁和死锁的结果是一样的，就是谁都不能先抬头<blockquote>
<p>假设有一对夫妻，只有一套餐具<br>吃饭的时候会去检查对方是不是处于饥饿状态，如果对方处于饥饿状态，就会把餐具让给对方<br>程序将处于一直谦让的状态无法完成</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LiveLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Spoon</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Diner diner;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%s has eaten!&quot;</span>, diner.name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Spoon</span><span class="params">(Diner diner)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.diner = diner;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Diner <span class="title">getDiner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> diner;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDiner</span><span class="params">(Diner diner)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.diner = diner;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Diner</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> idHungry = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Diner</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eatWith</span><span class="params">(Spoon spoon, Diner spouse)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (idHungry) &#123;</span><br><span class="line">                <span class="keyword">if</span> (spoon.diner != <span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (spouse.idHungry) &#123;</span><br><span class="line">                    System.out.println(name + <span class="string">&quot;亲爱的&quot;</span> + spouse.name + <span class="string">&quot;你先吃吧&quot;</span>);</span><br><span class="line">                    spoon.setDiner(spouse);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                spoon.use();</span><br><span class="line">                idHungry = <span class="keyword">false</span>;</span><br><span class="line">                System.out.println(name + <span class="string">&quot; 我已经吃完了&quot;</span>);</span><br><span class="line">                spoon.setDiner(spouse);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Diner husband = <span class="keyword">new</span> Diner(<span class="string">&quot;牛郎&quot;</span>);</span><br><span class="line">        Diner wife = <span class="keyword">new</span> Diner(<span class="string">&quot;织女&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Spoon spoon = <span class="keyword">new</span> Spoon(husband);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                husband.eatWith(spoon, wife);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                wife.eatWith(spoon, husband);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="如何解决活锁问题"><a href="#如何解决活锁问题" class="headerlink" title="如何解决活锁问题"></a>如何解决活锁问题</h4></li>
<li>原因：重试机制不变，消息队列始终重试，吃饭始终谦让</li>
<li>以太网的指数避退算法</li>
<li>加入随机因素(在进行谦让的时候加入随机因素，比如随机数，某一种情况下不进行谦让)</li>
</ul>
<h4 id="工程中的活锁实例：消息队列"><a href="#工程中的活锁实例：消息队列" class="headerlink" title="工程中的活锁实例：消息队列"></a>工程中的活锁实例：消息队列</h4><ul>
<li>策略：消息如果处理失败，就放在队列开头重试</li>
<li>由于依赖服务出了问题，处理该消息一直失败（由于依赖服务出现异常，把失败的消息放在队列头部，一直进行重试，一直都不会成功）</li>
<li>没有阻塞，但是程序无法继续</li>
<li>解决：放到队列尾部、重试次数限制</li>
</ul>
<h3 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h3><ul>
<li>当线程需要某些资源（列如CPU），但是始终得不到</li>
<li>线程的优先级设置的过于低，或者有某线程持有锁同时又无限循环从而不释放锁，或者某些程序始终占用某些文件的写锁</li>
<li>饥饿可能会导致相应性差：比如，我们的浏览器有一个线程负责下载图片和文件、计算渲染等，在这种情况下，如果后台线程把CPU资源都占用，那么前台线程将无法得到很好的执行，这会导致用户的体验很差</li>
</ul>
<h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><ul>
<li><p>写一个必然死锁大的例子（上面已经写过了），生产中什么场景下会发生死锁？</p>
<blockquote>
<p>需要获取两把锁的时候，都有可能发生死锁</p>
</blockquote>
</li>
<li><p>发生死锁必须满足那些条件</p>
<blockquote>
<p>互斥条件<br>请求保持条件<br>不剥夺条件<br>循环等待条件</p>
</blockquote>
</li>
<li><p>如何定位死锁？</p>
<blockquote>
<p>jstack<br>ThreadMXBean</p>
</blockquote>
</li>
<li><p>有那些解决死锁问题的策略？</p>
<blockquote>
<p>避免策略<br>检查与恢复策略<br>鸵鸟策略</p>
</blockquote>
</li>
<li><p>讲一讲哲学家就餐问题</p>
<blockquote>
<p>上面已经有描述</p>
</blockquote>
</li>
<li><p>实际工程中如何避免死锁？</p>
<blockquote>
<p>设置超时时间<br>多使用并发类而不是自己设计锁<br>尽量降低锁的使用粒度：用不同的锁而不是一个锁<br>如果能使用同步代码块，就不适用同步方法：自己指定锁对象<br>给线程起一个有意义的名称<br>避免锁嵌套<br>分配资源前先看能不能收回来<br>尽量不要几个功能使用同一把锁：专锁专用</p>
</blockquote>
</li>
<li><p>什么是活跃性问题？活锁、饥饿和死锁有什么区别？</p>
</li>
</ul>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java并发核心知识体系精讲</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发成神之路-精通JUC并发工具十八般武艺——Lock锁(三)</title>
    <url>/2021/11/28/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94Lock%E9%94%81/</url>
    <content><![CDATA[<h1 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h1><h2 id="简介、地位、作用"><a href="#简介、地位、作用" class="headerlink" title="简介、地位、作用"></a>简介、地位、作用</h2><ul>
<li>锁是一种工具，用于控制对共享资源的访问</li>
<li>Lock和synchronized，这两个是最常见的锁，它们都可以达到线程安全的目的，但是在使用上和功能上又有较大的不同</li>
<li>Lock并不是用来代替synchronized的，而是当使用synchronized不合适或不满足要求的时候，来提供高级功能</li>
<li>Lock接口最常见的实现类就是ReentrantLock</li>
<li>通常情况下，Lock只允许一个线程来访问这个共享资源，不过有的时候，一些特殊的实现也可以运行并发访问，比如ReadWriteLock里面的ReadLock</li>
</ul>
<h2 id="为什么synchronized不够用？为什么需要Lock锁？"><a href="#为什么synchronized不够用？为什么需要Lock锁？" class="headerlink" title="为什么synchronized不够用？为什么需要Lock锁？"></a>为什么synchronized不够用？为什么需要Lock锁？</h2><ul>
<li>效率低：锁的释放情况少，试图获得锁时不能设定超时、不能中断一个正在试图获得锁的过程</li>
<li>不够灵活（读写锁更灵活）：加锁和释放的时机单一，每个锁仅有单一的条件（某个对象），可能是不够的</li>
<li>无法知道是否成功获取到锁</li>
</ul>
<h2 id="方法介绍"><a href="#方法介绍" class="headerlink" title="方法介绍"></a>方法介绍</h2><ul>
<li>在Lock中声明了四个方法来获取锁</li>
<li><code>lock()</code>、<code>tryLock()</code>、<code>tryLock(long time,TimeUnit unit)</code>和<code>lockInterruptibly()</code></li>
</ul>
<h3 id="四个方法的区别"><a href="#四个方法的区别" class="headerlink" title="四个方法的区别"></a>四个方法的区别</h3><h4 id="lock"><a href="#lock" class="headerlink" title="lock()"></a><code>lock()</code></h4><ul>
<li><code>lock()</code>就是最普通的获取锁，如果锁已经被其他线程获取，则进行等待</li>
<li>Lock不会想synchronized一样在异常时自动释放锁</li>
<li>因此最佳实践是，在finally中释放锁，以保证发生异常时锁一定被释放</li>
<li><code>lock()</code>方法不能被中断，这会带来很大隐患：一旦陷入死锁，<code>lock()</code>就会陷入永远等待</li>
</ul>
<h4 id="tryLock"><a href="#tryLock" class="headerlink" title="tryLock()"></a><code>tryLock()</code></h4><ul>
<li>tryLock()用来尝试获取锁，如果当前锁没有被其他线程占用，则获取成功，则返回true，否则返回false，代表获取锁失败</li>
<li>相比与<code>lock()</code>，这样的方法显然功能更强大了，我们可以根据是否能获取到锁来决定后续程序的行为</li>
<li>该方法会立即返回，即便在拿不到锁时不会一直在那等</li>
</ul>
<h4 id="tryLock-long-time-TimeUnit-unit"><a href="#tryLock-long-time-TimeUnit-unit" class="headerlink" title="tryLock(long time,TimeUnit unit)"></a><code>tryLock(long time,TimeUnit unit)</code></h4><ul>
<li>相比与tryLock()方法，增加了超时时间，和时间类型两个参数</li>
<li>尝试获取锁，并不会立即返回，而是会等待指定时间，如果超时了就会返回，或者拿到锁了也会返回</li>
</ul>
<h4 id="lockInterruptibly"><a href="#lockInterruptibly" class="headerlink" title="lockInterruptibly()"></a><code>lockInterruptibly()</code></h4><ul>
<li>相当于<code>TryLock(long time,TimeUnit unit)</code>把超时时间设置为无限，在等待锁的过程中线程可以被中断</li>
</ul>
<h4 id="unlock"><a href="#unlock" class="headerlink" title="unlock()"></a><code>unlock()</code></h4><ul>
<li>解锁</li>
</ul>
<h1 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h1><ul>
<li>这些分类，是从各种不同角度出发去看的</li>
<li>这些分类并不是互斥的，也就是多个类型可以并存：有可能一个锁，同时属于两种类型</li>
<li>比如ReentrantLock即是互斥锁，又是可重入锁</li>
</ul>
<p><img src="/2021/11/28/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94Lock%E9%94%81/Java%E4%B8%AD%E9%94%81%E5%88%86%E7%B1%BB%E5%9B%BE.png" alt="Java中锁分类图">+ </p>
<h1 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h1><h2 id="为什么还会诞生非互斥同步锁（乐观锁）——互斥同步锁（悲观锁）"><a href="#为什么还会诞生非互斥同步锁（乐观锁）——互斥同步锁（悲观锁）" class="headerlink" title="为什么还会诞生非互斥同步锁（乐观锁）——互斥同步锁（悲观锁）"></a>为什么还会诞生非互斥同步锁（乐观锁）——互斥同步锁（悲观锁）</h2><h3 id="互斥同步锁的劣势"><a href="#互斥同步锁的劣势" class="headerlink" title="互斥同步锁的劣势"></a>互斥同步锁的劣势</h3><ul>
<li>阻塞和唤醒带来的性能劣势（线程状态切换，上下文切换，检查是否有被阻塞线程等，都会带来性能损耗）</li>
<li>永久阻塞：如果持有锁的线程被永久阻塞，比如遇到了无限循环、死锁等活跃性问题，那么等待该线程释放锁的那几个悲催的线程，将永远也得不到执行</li>
<li>优先级反转（低优先级的线程先拿到了锁，高优先级的线程也只能等待它完成之后才能拿到锁）</li>
</ul>
<h2 id="什么是乐观锁和悲观锁"><a href="#什么是乐观锁和悲观锁" class="headerlink" title="什么是乐观锁和悲观锁"></a>什么是乐观锁和悲观锁</h2><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><ul>
<li>如果我不锁柱这个资源，别人就会来争抢，就会造成数据结果错误，所以悲观锁为了确保结果正确性，会在每次获取并修改数据时，把数据锁住，让别人无法访问该数据，这样就可以确保数据内容万无一失</li>
<li>Java中悲观锁的实现就是synchronized和Lock相关类</li>
</ul>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><ul>
<li>认为自己在操作的时候不会有其他线程来干扰，所以并不会锁住被操作对象</li>
<li>在更新的时候，去对比在我修改期间数据有没有被其他人改过：如果没被改变过，就说明真的是只有我自己在操作，那我就正常去执行修改数据</li>
<li>如果数据和我一开始拿到的不一样了，说明其他人在这段时间内修改过数据，那我就不能继续刚才的更新数据过程了，我会选择放弃修改、报错、重试等策略</li>
<li>乐观锁的实现一般都是利用CAS算法来实现的</li>
</ul>
<h2 id="典型例子"><a href="#典型例子" class="headerlink" title="典型例子"></a>典型例子</h2><ul>
<li>乐观锁的典型例子就是原子类、并发容器等</li>
<li>悲观锁的典型例子就是synchronized和Lock相关类</li>
<li>Git：Git就是乐观锁的典型例子，当我们往远程仓库push的时候，git会检查远程仓库的版本是不是领先于我们现在大的版本，如果远程仓库的版本号和本地的不一样，就表示有其他人修改了远程代码了，我们的这次提交就失败，如果远端和本地版本号一致，我们就可以顺利提交版本到远端仓库</li>
<li>数据库<ul>
<li>select for update就是悲观锁</li>
<li>用version控制数据就是乐观锁<ul>
<li>添加一个字段lock_version</li>
<li>先查询这个更新语句的version：select * from table</li>
<li>然后update set num = 2,version = version+1 where version = 1 and id = 5</li>
<li>如果version被更新等于2，不一样就会出现更新错误，这就是乐观锁的原理</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="开销对比"><a href="#开销对比" class="headerlink" title="开销对比"></a>开销对比</h2><ul>
<li>悲观锁的原始开销要高于乐观锁，但是特点是一劳永逸，临界区持锁时间就算越来越差，也不会对互斥锁的开销造成影响</li>
<li>相反，虽然乐观锁一开始的开销比悲观锁小，但是如果自旋时间很长或者不停重试，那么消耗的资源也会越来越多</li>
</ul>
<h2 id="两种锁的使用场景"><a href="#两种锁的使用场景" class="headerlink" title="两种锁的使用场景"></a>两种锁的使用场景</h2><ul>
<li>悲观锁：适合并发写入多的情况，适用于临界区持锁时间比较长的情况，悲观锁可以避免大量的无用自旋等消耗，典型情况：<ul>
<li>临界区有IO操作</li>
<li>临界区代码复杂或者循环量大</li>
<li>临界区竞争非常激烈</li>
</ul>
</li>
<li>乐观锁：适合并发写入少，大部分是读取的场景，不加锁能让读取性能大幅度提高</li>
</ul>
<h1 id="可重入锁和非可重入锁，以ReentrantLock为例（重点）"><a href="#可重入锁和非可重入锁，以ReentrantLock为例（重点）" class="headerlink" title="可重入锁和非可重入锁，以ReentrantLock为例（重点）"></a>可重入锁和非可重入锁，以<code>ReentrantLock</code>为例（重点）</h1><h2 id="可重入性质"><a href="#可重入性质" class="headerlink" title="可重入性质"></a>可重入性质</h2><h3 id="什么是可重入"><a href="#什么是可重入" class="headerlink" title="什么是可重入"></a>什么是可重入</h3><ul>
<li>当一个线程获取到一把锁之后，可以再次获取这把锁，甚至多次获得这把锁，递归获取</li>
<li>ReentrantLock和synchronized都是可重入锁</li>
<li>好处：可以避免死锁，比如需要多次获取当前锁的时候，不可能放弃再重新获取</li>
<li>代码示例如下，递归进行调用，每次不需要重新获取锁<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursionDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        accessResource();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">accessResource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;已经对资源进行了处理&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (lock.getHoldCount() &lt; <span class="number">5</span>)</span><br><span class="line">                accessResource();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
可重入锁和不可重入锁源码对比：<blockquote>
<p>如图所示，可重入锁，在线程再次获取锁的时候，会判断当前线程是否持有锁，如果有，就在标记上加1<br>解锁的时候同理，标记减一，最后判断是否等于0，等于0表示彻底解锁<br>不可重入锁则是直接判断锁的状态，已被持有直接返回</p>
</blockquote>
</li>
</ul>
<p><img src="/2021/11/28/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94Lock%E9%94%81/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E5%92%8C%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E6%BA%90%E7%A0%81%E5%AF%B9%E6%AF%94.png" alt="可重入锁和不可重入锁源码对比"></p>
<h2 id="ReentrantLock的其他方法介绍"><a href="#ReentrantLock的其他方法介绍" class="headerlink" title="ReentrantLock的其他方法介绍"></a>ReentrantLock的其他方法介绍</h2><ul>
<li><code>isHeldByCurrentThread</code>可以看出锁是否被当前线程持有</li>
<li>getQueueLength可以返回当前正在等待这把锁的队列有多长，一般这两个方法是开发和调试的时候使用，上线后不会使用</li>
</ul>
<h1 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h1><h2 id="什么是公平和非公平"><a href="#什么是公平和非公平" class="headerlink" title="什么是公平和非公平"></a>什么是公平和非公平</h2><ul>
<li>公平值得是按照线程请求的顺序，来分配锁</li>
<li>非公平指的是，不完全按照请求的顺序，在一定情况下可以插队（并不是完全打乱顺序）</li>
<li>注意：非公平也同样不提倡“插队”行为，这里的非公平，指的是“在合适的时机”插队，而不是盲目插队</li>
<li>合适的时机：在被唤醒的空档期，有一个完全清醒的线程来获取锁，可以直接拿到</li>
</ul>
<h2 id="为什么要有非公平"><a href="#为什么要有非公平" class="headerlink" title="为什么要有非公平"></a>为什么要有非公平</h2><ul>
<li>提高效率</li>
<li>避免唤醒带来的空档期</li>
</ul>
<h2 id="公平情况（以ReentrantLock为例）"><a href="#公平情况（以ReentrantLock为例）" class="headerlink" title="公平情况（以ReentrantLock为例）"></a>公平情况（以<code>ReentrantLock</code>为例）</h2><ul>
<li>如果创建ReentrantLock对象时，参数填写为true，那么这就是一个公平锁</li>
<li>假设有1234，四个线程去获取锁，1拿到了锁，234就在队列里面等待，2完就是3，然后4</li>
</ul>
<h2 id="不公平情况（以ReentrantLock为例）"><a href="#不公平情况（以ReentrantLock为例）" class="headerlink" title="不公平情况（以ReentrantLock为例）"></a>不公平情况（以<code>ReentrantLock</code>为例）</h2><ul>
<li>还是上面的例子，假如在1释放锁的时候，线程5恰好去执行<code>lock()</code></li>
<li>由于<code>ReentrantLock</code>发现此时并没有线程持有lock这把锁（线程2还没有来得及获取，因为唤醒和获取需要时间）</li>
<li>线程5可以插队，直接拿到这把锁，这也是<code>ReentrantLock</code>默认的公平策略，也就是“不公平”</li>
</ul>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><blockquote>
<p>如下面代码所示，当ReentrantLock参数为true，设置为公平锁的时候<br>线程1打印完毕第一次之后，想要再次获取到锁，就会排队到线程10的后面，需要1到10挨个打印完第一伦之后，才会打印第二轮<br>当ReentrantLock参数为false，设置为非公平锁的时候<br>线程1打印完之后，就会尝试第二次获取锁，而这个时候线程2唤醒还需要时间，就会出现，线程1连着两次打印，线程2连着打印的情况</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FairLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        PrintQueue printQueue = <span class="keyword">new</span> PrintQueue();</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Job(printQueue));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            threads[i].start();</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Job</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    PrintQueue printQueue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Job</span><span class="params">(PrintQueue printQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.printQueue = printQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;开始打印&quot;</span>);</span><br><span class="line">        printQueue.printJob(<span class="keyword">new</span> Object());</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;打印完毕&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintQueue</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock queueLock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">false</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printJob</span><span class="params">(Object document)</span></span>&#123;</span><br><span class="line">        queueLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> duration = <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>)+<span class="number">1</span>;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;正在打印，需要&quot;</span>+duration);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(duration*<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            queueLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        queueLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> duration = (<span class="keyword">long</span>) (Math.random() * <span class="number">10000</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;正在打印，需要&quot;</span>+duration/<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(duration);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            queueLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="特例"><a href="#特例" class="headerlink" title="特例"></a>特例</h2><ul>
<li>针对<code>tryLock()</code>方法，它不遵守设定的公平规则（无论公平还是非公平）</li>
<li>例如，当有线程在执行<code>tryLock()</code>的时候，一旦有线程释放了锁，那么这个正在tryLock的线程就能获取到锁，即使在它之前已经有其他线程等待在队列里面了</li>
</ul>
<h2 id="对比公平和非公平的有缺点"><a href="#对比公平和非公平的有缺点" class="headerlink" title="对比公平和非公平的有缺点"></a>对比公平和非公平的有缺点</h2><table>
<thead>
<tr>
<th align="left"></th>
<th align="left">优势</th>
<th align="left">劣势</th>
</tr>
</thead>
<tbody><tr>
<td align="left">公平</td>
<td align="left">各线程公平平等，每个线程在等待一段时间后，总有执行的机会</td>
<td align="left">更慢，吞吐量更小</td>
</tr>
<tr>
<td align="left">不公平</td>
<td align="left">更快，吞吐量更大</td>
<td align="left">有可能产生线程饥饿，也就是某些线程在长时间内，始终得不到执行</td>
</tr>
</tbody></table>
<h2 id="源码对比"><a href="#源码对比" class="headerlink" title="源码对比"></a>源码对比</h2><blockquote>
<p>公平锁和非公平锁的源码对比如下<br>可以看出，公平锁在线程获取锁的时候会先判断，队列中是否有任务，非公平锁则不会判断，直接就去获取锁</p>
</blockquote>
<p><img src="/2021/11/28/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94Lock%E9%94%81/%E5%85%AC%E5%B9%B3%E9%94%81%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E6%BA%90%E7%A0%81%E5%AF%B9%E6%AF%94.png" alt="公平锁非公平锁源码对比"></p>
<h1 id="共享锁和排它锁：以ReentrantReadWriteLock读写锁为例（重点）"><a href="#共享锁和排它锁：以ReentrantReadWriteLock读写锁为例（重点）" class="headerlink" title="共享锁和排它锁：以ReentrantReadWriteLock读写锁为例（重点）"></a>共享锁和排它锁：以<code>ReentrantReadWriteLock</code>读写锁为例（重点）</h1><h2 id="什么是共享锁和排他锁"><a href="#什么是共享锁和排他锁" class="headerlink" title="什么是共享锁和排他锁"></a>什么是共享锁和排他锁</h2><ul>
<li>排它锁：又叫独占锁、独享锁</li>
<li>共享锁：又称为读锁，获取共享锁之后，可以查看但无法修改和删除数据，其他线程此时也可以获取到共享锁，也可以查看但无法修改和删除数据</li>
<li>共享锁和排他锁的典型就是读写锁<code>ReentrantReadWriteLock</code>，其中读锁是共享锁，写锁是独享锁</li>
</ul>
<h2 id="读写锁的作用"><a href="#读写锁的作用" class="headerlink" title="读写锁的作用"></a>读写锁的作用</h2><ul>
<li>在没有读写锁之前，我们假设使用ReentrantLock，那么虽然我们保证了线程安全，但是也浪费了一定的资源：多个读操作同时进行，并没有线程安全问题</li>
<li>在读的地方使用读锁，在写的地方使用写锁，灵活控制，如果没有写锁的情况下，读是没有阻塞的，提高了程序的执行效率</li>
</ul>
<h2 id="读写锁的规则"><a href="#读写锁的规则" class="headerlink" title="读写锁的规则"></a>读写锁的规则</h2><ul>
<li>多个线程只申请读锁，都可以申请到</li>
<li>如果又一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁</li>
<li>如果又一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁</li>
<li>总结：要么是一个或者多个线程同时读锁，要么是一个线程拥有写锁，但是两者不会同时出现（要么多读，要么一写）</li>
<li>换一种理解思路：读写锁只是一把锁，可以通过两种方式锁定：<ul>
<li>读锁定和写锁定</li>
<li>读写锁可以同时被一个或多个线程锁定，也可以被单一线程写锁定</li>
<li>但是永远不能同时对这把锁进行读锁定和写锁定<blockquote>
<p>读写锁代码实现如下所示</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CinemaReadWrite</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantReadWriteLock reentrantReadWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantReadWriteLock.ReadLock readLock = reentrantReadWriteLock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantReadWriteLock.WriteLock writeLock = reentrantReadWriteLock.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;得到了读锁，正在读取&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;释放了读锁&quot;</span>);</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>&#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;得到了写锁，正在写入&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;释放了写锁&quot;</span>);</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;read(),<span class="string">&quot;Thread1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;read(),<span class="string">&quot;Thread2&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;write(),<span class="string">&quot;Thread3&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;write(),<span class="string">&quot;Thread4&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thread1得到了读锁，正在读取</span><br><span class="line">Thread2得到了读锁，正在读取</span><br><span class="line">Thread2释放了读锁</span><br><span class="line">Thread1释放了读锁</span><br><span class="line">Thread3得到了写锁，正在写入</span><br><span class="line">Thread3释放了写锁</span><br><span class="line">Thread4得到了写锁，正在写入</span><br><span class="line">Thread4释放了写锁</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="读写锁插队策略"><a href="#读写锁插队策略" class="headerlink" title="读写锁插队策略"></a>读写锁插队策略</h2><ul>
<li>公平锁：不允许插队</li>
<li>非公平锁：<ul>
<li>写锁可以随时插队</li>
<li>读锁仅在队列头节点不是想获取写锁的线程的时候可以插队</li>
<li>(如果读锁可以随意插队，那么可能会造成写锁饥饿，读取需要时间，假如刚好一个结束，另一个开始，这样会导致写锁一直得不到执行)<blockquote>
<p>根据<code>ReentrantReadWriteLock</code>中的源码可以看出来，公平锁读写锁每次都会判断队列，在决定是否去获取锁<br>非公平锁，写锁直接返回false，可以去进行插队，读锁会判断队列第一位是不是排它锁，也就是写锁</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p><img src="/2021/11/28/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94Lock%E9%94%81/ReentrantReadWriteLock%E5%85%AC%E5%B9%B3%E9%94%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0.png" alt="ReentrantReadWriteLock公平锁代码实现"><br><img src="/2021/11/28/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94Lock%E9%94%81/ReentrantReadWriteLock%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0.png" alt="ReentrantReadWriteLock非公平锁代码实现"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairBargeDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantReadWriteLock reentrantReadWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantReadWriteLock.ReadLock readLock = reentrantReadWriteLock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantReadWriteLock.WriteLock writeLock = reentrantReadWriteLock.writeLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        list.add(Thread.currentThread().getName() + <span class="string">&quot;开始尝试获取读锁&quot;</span>);</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            list.add(Thread.currentThread().getName() + <span class="string">&quot;得到了读锁，正在读取&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            list.add(Thread.currentThread().getName() + <span class="string">&quot;释放了读锁&quot;</span>);</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        list.add(Thread.currentThread().getName() + <span class="string">&quot;开始尝试获取写锁&quot;</span>);</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            list.add(Thread.currentThread().getName() + <span class="string">&quot;得到了写锁，正在写入&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">20</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            list.add(Thread.currentThread().getName() + <span class="string">&quot;释放了写锁&quot;</span>);</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; write(), <span class="string">&quot;Thread1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; read(), <span class="string">&quot;Thread2&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; read(), <span class="string">&quot;Thread3&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; read(), <span class="string">&quot;Thread4&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; read(), <span class="string">&quot;Thread5&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; write(), <span class="string">&quot;Thread6&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; read(), <span class="string">&quot;Thread7&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Thread[] threads = <span class="keyword">new</span> Thread[<span class="number">1000</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                    threads[i] = <span class="keyword">new</span> Thread(() -&gt; read(), <span class="string">&quot;子线程创建的Thread&quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                    threads[i].start();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        list.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>插队演示代码如上所示，先将锁设置为非公平锁<br>读锁插队：我们先将创建线程获取到一个写锁，写锁完毕之后，会唤醒后面的读锁，后面跟了多个读锁，按照顺序唤醒，需要时间去执行，而这个时候，插队线程会不停的发出插队请求<br>具体结果如下图<br>线程1释放读锁之后，线程2被唤醒，然后线程158开始插队并插队成功，之后线程3和4拿到了读锁，然后线程159插队成功，线程5拿到读锁之后，线程5后面的线程6拿的是写锁<br>队列第一位为写锁的时候读锁不允许插队，所以后面的插队读请求全部插队失败</p>
</blockquote>
<p><img src="/2021/11/28/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94Lock%E9%94%81/%E8%AF%BB%E9%94%81%E6%8F%92%E9%98%9F%E7%BB%93%E6%9E%9C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="读锁插队结果示意图"></p>
<blockquote>
<p>如下图所示，当之前的读锁任务执行完毕之后，并没有其他线程来抢锁，直接由线程7写锁抢锁成功，之后的所有尝试获取读锁的线程都进行等待</p>
</blockquote>
<p><img src="/2021/11/28/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94Lock%E9%94%81/%E5%86%99%E9%94%81%E6%8F%92%E9%98%9F%E7%BB%93%E6%9E%9C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="写锁插队结果示意图"></p>
<blockquote>
<p>如果是公平锁，结果如下两图所示，线程1执行完毕之后，线程2、3、4、5开始执行，期间又线程进行尝试，但都在获取锁的时候进行等待<br>当线程2、3、4、5执行完毕，线程6开始执行，线程6释放锁之后，线程7才开始和其他线程一起执行读锁</p>
</blockquote>
<p><img src="/2021/11/28/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94Lock%E9%94%81/%E5%85%AC%E5%B9%B3%E9%94%81%E6%8A%A2%E9%94%81%E7%BB%93%E6%9E%9C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="公平锁抢锁结果示意图"><br><img src="/2021/11/28/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94Lock%E9%94%81/%E5%85%AC%E5%B9%B3%E9%94%81%E6%8A%A2%E9%94%81%E7%BB%93%E6%9E%9C%E7%A4%BA%E6%84%8F%E5%9B%BE2.png" alt="公平锁抢锁结果示意图2"></p>
<h2 id="锁的升降级"><a href="#锁的升降级" class="headerlink" title="锁的升降级"></a>锁的升降级</h2><ul>
<li>支持降级，不支持升级</li>
<li>假设又两个线程同时持有读锁，其中一个想要进行升级，那么等另外一个线程执行完毕就可以进行升级，但是如果两个线程都想要升级，那么就会互相等待，陷入死锁（锁可以支持升级，只不过<code>ReentrantReadWriteLock</code>为了避免死锁不支持升级，可以自己实现锁支持升级，但是需要保证升级的时候只有一个线程进行升级，不然就容易陷入死锁）<blockquote>
<p>锁升降级代码如下所示<br>在获取到了写锁的情况下可以直接去拿读锁进行降级，可以成功<br>在拿到读锁的情况下，再去尝试获取写锁进行升级，会陷入阻塞中</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Upgrading</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantReadWriteLock reentrantReadWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantReadWriteLock.ReadLock readLock = reentrantReadWriteLock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantReadWriteLock.WriteLock writeLock = reentrantReadWriteLock.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readUpgrading</span><span class="params">()</span></span>&#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;得到了读锁，正在读取&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;升级会带来堵塞&quot;</span>);</span><br><span class="line">            writeLock.lock();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;成功获取到了写锁，升级成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;释放了读锁&quot;</span>);</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeUpgrading</span><span class="params">()</span></span>&#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;得到了写锁，正在写入&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            readLock.lock();</span><br><span class="line">            System.out.println(<span class="string">&quot;在不释放写锁的情况下直接获取读锁成功，锁降级成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.lock();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;释放了写锁&quot;</span>);</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; writeUpgrading(), <span class="string">&quot;Thread1&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        thread.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;readUpgrading(),<span class="string">&quot;Thread2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><code>ReentrantReadWriteLock</code>实现了<code>ReadWriteLock</code>接口，最主要的有来给两个方法：<code>readLock()</code>和<code>writeLock()</code>用来获取读锁和写锁</li>
<li>锁的申请和释放策略<ul>
<li>多个线程只申请读锁，都可以申请到</li>
<li>如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请的线程会一直等待释放读锁</li>
<li>如果有一个线程已经占用了写锁，则此时其他线程如果要申请读锁，则申请的线程会一直等待释放写锁</li>
<li>要么是一个或者多个线程同时持有读锁，要么是一个线程持有写锁，但是两者不会同时出现</li>
</ul>
</li>
<li>插队策略：为了防止饥饿，读锁不能插队</li>
<li>升降级策略：只能降级，不能升级</li>
<li>使用场景：相比于<code>ReentrantLock</code>适用于一般场合，<code>ReentrantReadWriteLock</code>适用于读多写少的情况，合理适用可以进一步提高并发效率</li>
</ul>
<h1 id="自旋锁和阻塞锁"><a href="#自旋锁和阻塞锁" class="headerlink" title="自旋锁和阻塞锁"></a>自旋锁和阻塞锁</h1><ul>
<li>阻塞或唤醒一个Java线程需要操作系统切换CPU的状态来完成，这种状态转换需要耗费处理器时间</li>
<li>如果同步代码块中的内容过于简单，状态切换消耗的时间有可能比用户代码执行的时间还要长</li>
<li>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失</li>
<li>如果物理机有多核处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快会释放锁</li>
<li>而为了让当前线程“稍微等一下”，我们需要让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销，这就是自旋锁</li>
<li>阻塞锁和自旋锁相反，阻塞锁如果遇到没拿到锁的情况，会直接把线程阻塞，直到被唤醒</li>
</ul>
<h2 id="自旋锁的缺点"><a href="#自旋锁的缺点" class="headerlink" title="自旋锁的缺点"></a>自旋锁的缺点</h2><ul>
<li>如果锁被占用的时间很长，那么自旋的线程只会浪费处理器资源</li>
<li>在自旋的过程中，一直消耗CPU，所以虽然自旋锁的起始开销低于悲观锁，但是随着自旋时间的增长，开销也是线性增长的</li>
</ul>
<h2 id="原理和源码分析"><a href="#原理和源码分析" class="headerlink" title="原理和源码分析"></a>原理和源码分析</h2><ul>
<li>在Java1.5版本及以上的并发框架<code>java.util.concurrent</code>的atomic包下的类基本都是自旋锁的实现</li>
<li><code>AtomicInteger</code>的实现：自旋锁的实现原理CAS，<code>AtomicInteger</code>中调用<code>unsafe</code>进行自增操作的源码中的<code>do-while</code>循环就是一个自旋操作，如果修改过程中遇到其他线程竞争导致没修改成功，就在while里死循环，直至修改成功<blockquote>
<p>如图所示</p>
</blockquote>
</li>
</ul>
<p><img src="/2021/11/28/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94Lock%E9%94%81/%E8%87%AA%E6%97%8B%E9%94%81%E6%BA%90%E7%A0%81%E5%9B%BE%E7%A4%BA.png" alt="自旋锁源码图示"></p>
<blockquote>
<p>自旋锁实现代码如下所示  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Thread&gt; sign = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        <span class="keyword">while</span> (!sign.compareAndSet(<span class="keyword">null</span>, thread)) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        sign.compareAndSet(thread, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpinLock spinLock = <span class="keyword">new</span> SpinLock();</span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始尝试获取自旋锁&quot;</span>);</span><br><span class="line">                spinLock.lock();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获得自旋锁&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">300</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    spinLock.unlock();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;释放了自旋锁&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(runnable).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(runnable).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自旋锁的适用场景"><a href="#自旋锁的适用场景" class="headerlink" title="自旋锁的适用场景"></a>自旋锁的适用场景</h2><ul>
<li>自旋锁一般用于多核服务器，在并发度不是特别高的情况下，比阻塞锁的效率高</li>
<li>另外，自旋锁适用于临界区比较短小的情况，否则如果临界区很大（线程一旦拿到锁，很久之后才会释放），那也是不合适的</li>
</ul>
<h1 id="可中断锁：顾名思义，就是可以相应中断的锁"><a href="#可中断锁：顾名思义，就是可以相应中断的锁" class="headerlink" title="可中断锁：顾名思义，就是可以相应中断的锁"></a>可中断锁：顾名思义，就是可以相应中断的锁</h1><ul>
<li>在Java中<code>synchronized</code>就是不可中断锁，而<code>Lock</code>是可中断锁，因为<code>tryLock(time)</code>和<code>lockInterruptibly</code>都能响应中断</li>
<li>如果某一线程A正在执行锁中的代码，另一个线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以中断它，这种就是可中断锁</li>
</ul>
<h1 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h1><h2 id="Java虚拟机对锁的优化"><a href="#Java虚拟机对锁的优化" class="headerlink" title="Java虚拟机对锁的优化"></a>Java虚拟机对锁的优化</h2><ul>
<li>自旋锁和自适应(在自旋的时候会自动判断自旋的时间，也许自旋几次之后就会转为阻塞，会根据上次获取锁的情况进行判断)</li>
<li>锁消除(jvm会判断对锁的使用，假设是在一个方法内部，根本不会出现并发情况，JVM会自动帮忙消除锁)</li>
<li>锁粗化(虚拟机检测到在很短的代码内对同一个多不停的加锁解锁，就会将锁的范围粗化，减少加锁解锁的次数)</li>
</ul>
<h2 id="我们在写代码时如何优化锁和提高并发性能"><a href="#我们在写代码时如何优化锁和提高并发性能" class="headerlink" title="我们在写代码时如何优化锁和提高并发性能"></a>我们在写代码时如何优化锁和提高并发性能</h2><ul>
<li>缩小同步代码块</li>
<li>尽量不要锁着方法</li>
<li>减少请求锁的次数</li>
<li>避免认为制造“热点”</li>
<li>锁中尽量不要再包含锁</li>
<li>选择合适的锁类型或合适的工具类</li>
</ul>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>精通JUC并发工具十八般武艺</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发成神之路-精通JUC并发工具十八般武艺——实现高性能缓存(十)</title>
    <url>/2021/12/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h1 id="从最简单版本缓存入手——HashMap"><a href="#从最简单版本缓存入手——HashMap" class="headerlink" title="从最简单版本缓存入手——HashMap"></a>从最简单版本缓存入手——HashMap</h1><p>代码如下所示，第一次查询缓存Map，找不到就会查询数据库或者通过一些逻辑计算获取值，然后将获取到的结果保存到map中，并且返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YsCache1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, Integer&gt; cache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">computer</span><span class="params">(String userId)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Integer result = cache.get(userId);</span><br><span class="line">        <span class="comment">//先检查HashMap里面有没有保存过之前的计算结果</span></span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果缓存中找不到，那么需要现在计算一下结果，并且保存到HashMap中</span></span><br><span class="line">            result = doCompute(userId);</span><br><span class="line">            cache.put(userId, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Integer <span class="title">doCompute</span><span class="params">(String userId)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        YsCache1 ysCache1 = <span class="keyword">new</span> YsCache1();</span><br><span class="line">        System.out.println(<span class="string">&quot;开始获取信息&quot;</span>);</span><br><span class="line">        Integer result = ysCache1.computer(<span class="string">&quot;13&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第一次获取信息=&quot;</span> + result);</span><br><span class="line">        result = ysCache1.computer(<span class="string">&quot;13&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第二次获取信息=&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>线程安全问题<br>上面的代码写法在并发情况下是不安的，比如两个线程同时去查，然后发现没有，同时去进行计算，同时HashMap也不是线程安全的，也有可能会引起一些HashMap自身线程安全的问题</p>
<h2 id="给HashMap加final关键字"><a href="#给HashMap加final关键字" class="headerlink" title="给HashMap加final关键字"></a>给HashMap加final关键字</h2><ul>
<li>属性被声明未final后，该变量则只能被赋值一次，且一旦被赋值，final的变量就不能在被改变</li>
<li>所以我们把它加上final关键字，增强安全性</li>
</ul>
<h1 id="并发安全要保证——用synchronized实现"><a href="#并发安全要保证——用synchronized实现" class="headerlink" title="并发安全要保证——用synchronized实现"></a>并发安全要保证——用synchronized实现</h1><p>解决办法就是可以在<code>computer()</code>获取数据的方法上面添加<code>synchronized</code>关键字，使用锁保证线程安全</p>
<h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h2><p>性能差(使用缓存本身就是为了提高性能的，加锁之后，只能但线程访问，会对性能造成影响)<br>代码复用能力差(缓存逻辑和计算结果的业务代码写在同一个类里面，复用性比较差)</p>
<h1 id="代码又重构空间——用装饰着模式"><a href="#代码又重构空间——用装饰着模式" class="headerlink" title="代码又重构空间——用装饰着模式"></a>代码又重构空间——用装饰着模式</h1><p>我们假设ExpensiveFunction类是耗时计算的实现类，实现了Computable接口，但是其本身不具备缓存功能，也不需要考虑缓存的事情<br>优化后的实现如下所示：<br>每次如果有不同的缓存需求，只需要使用不同的实现就可以了  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有一个计算函数computer，用来代表耗时计算，每个计算器都要实现这个接口，这样就可以实现无侵入的缓存功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Computable</span>&lt;<span class="title">A</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">V <span class="title">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 耗时计算的实现类，实现了computable接口，但是本身不具备缓存能力，不需要考虑缓存的事情</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExpensiveFunction</span> <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">String</span>,<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">compute</span><span class="params">(String arg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YsCache2</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, V&gt; cache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Computable&lt;A, V&gt; computable;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">YsCache2</span><span class="params">(Computable&lt;A, V&gt; computable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.computable = computable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进入缓存机制&quot;</span>);</span><br><span class="line">        V result = cache.get(arg);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            result = computable.compute(arg);</span><br><span class="line">            cache.put(arg, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        YsCache2&lt;String, Integer&gt; expensiveComputer = <span class="keyword">new</span> YsCache2&lt;&gt;(<span class="keyword">new</span> ExpensiveFunction());</span><br><span class="line">        System.out.println(<span class="string">&quot;开始获取信息&quot;</span>);</span><br><span class="line">        Integer result = expensiveComputer.compute(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第一次获取信息=&quot;</span> + result);</span><br><span class="line">        result = expensiveComputer.compute(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第二次获取信息=&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h2><p>性能差<br>当多个线程同时向计算的时候，需要慢慢等待，严重时，性能甚至比不用缓存更差<br>当一个缓存不存在，需要进行计算，需要几秒钟的时间，这个时候如果来了另一个请求，即便它的缓存已经存在，也需要等上一个的计算完毕之后才能获取到值，因为锁直接把它挡在了方法外面了</p>
<h1 id="性能待优化——引出锁性能优化经验：缩小锁的粒度"><a href="#性能待优化——引出锁性能优化经验：缩小锁的粒度" class="headerlink" title="性能待优化——引出锁性能优化经验：缩小锁的粒度"></a>性能待优化——引出锁性能优化经验：缩小锁的粒度</h1><p>如下代码所示，修改了锁的范围，这样不同的key就可以同时进行读写操作了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YsCache3</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, V&gt; cache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Computable&lt;A, V&gt; computable;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">YsCache3</span><span class="params">(Computable&lt;A, V&gt; computable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.computable = computable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进入缓存机制&quot;</span>);</span><br><span class="line">        V result = cache.get(arg);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            result = computable.compute(arg);</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">                cache.put(arg, result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        YsCache3&lt;String, Integer&gt; expensiveComputer = <span class="keyword">new</span> YsCache3&lt;&gt;(<span class="keyword">new</span> ExpensiveFunction());</span><br><span class="line">        System.out.println(<span class="string">&quot;开始获取信息&quot;</span>);</span><br><span class="line">        Integer result = expensiveComputer.compute(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第一次获取信息=&quot;</span> + result);</span><br><span class="line">        result = expensiveComputer.compute(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第二次获取信息=&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h2><p>看起来是解决问题了，但是同时读写，对HashMap也是不安全的</p>
<h1 id="用并发集合——ConcurrentHashMap"><a href="#用并发集合——ConcurrentHashMap" class="headerlink" title="用并发集合——ConcurrentHashMap"></a>用并发集合——ConcurrentHashMap</h1><p>如下代码所示，更改使用并发集合之后，就不会在存在同时读写的并发问题了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YsCache4</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, V&gt; cache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Computable&lt;A, V&gt; computable;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">YsCache4</span><span class="params">(Computable&lt;A, V&gt; computable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.computable = computable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进入缓存机制&quot;</span>);</span><br><span class="line">        V result = cache.get(arg);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            result = computable.compute(arg);</span><br><span class="line">            cache.put(arg, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        YsCache4&lt;String, Integer&gt; expensiveComputer = <span class="keyword">new</span> YsCache4&lt;&gt;(<span class="keyword">new</span> ExpensiveFunction());</span><br><span class="line">        System.out.println(<span class="string">&quot;开始获取信息&quot;</span>);</span><br><span class="line">        Integer result = expensiveComputer.compute(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第一次获取信息=&quot;</span> + result);</span><br><span class="line">        result = expensiveComputer.compute(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第二次获取信息=&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="问题-4"><a href="#问题-4" class="headerlink" title="问题"></a>问题</h2><p>在计算完成之前，另一个需要计算相同值的请求到来，会导致计算两遍，这和缓存想避免多次计算的初衷恰恰相反，是不可接受的</p>
<h1 id="避免重复计算——Future和Callable的妙用"><a href="#避免重复计算——Future和Callable的妙用" class="headerlink" title="避免重复计算——Future和Callable的妙用"></a>避免重复计算——Future和Callable的妙用</h1><p>修改后的代码如下所示，使用Future将最终的结果做一层封装，如果两个请求是前后脚进来，如果获取到值，直接调用get方法返回内容即可，如果获取到的值为空，那么，前一个请求就立刻封装一个FutureTask对象放进缓存，并调用它的run方法开始计算，这样第二次请求进来之后，就会拿到这个Future，最终返回的时候会去调用get方法，如果计算还没有完成，就会进行阻塞，计算完成之后就直接返回，不需要两次请求都进行计算</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YsCache5</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, Future&lt;V&gt;&gt; cache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Computable&lt;A, V&gt; computable;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">YsCache5</span><span class="params">(Computable&lt;A, V&gt; computable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.computable = computable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Future&lt;V&gt; f = cache.get(arg);</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Callable&lt;V&gt; callable = <span class="keyword">new</span> Callable&lt;V&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> computable.compute(arg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            FutureTask&lt;V&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(callable);</span><br><span class="line">            f = ft;</span><br><span class="line">            cache.put(arg, f);</span><br><span class="line">            ft.run();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        YsCache5&lt;String, Integer&gt; expensiveComputer = <span class="keyword">new</span> YsCache5&lt;&gt;(<span class="keyword">new</span> ExpensiveFunction());</span><br><span class="line">        System.out.println(<span class="string">&quot;开始获取信息&quot;</span>);</span><br><span class="line">        Integer result = expensiveComputer.compute(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第一次获取信息=&quot;</span> + result);</span><br><span class="line">        result = expensiveComputer.compute(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第二次获取信息=&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="问题-5"><a href="#问题-5" class="headerlink" title="问题"></a>问题</h2><p>如果两个请求，不是前后脚，而是同时进行，那么当两个请求同时调用map的get方法的时候，拿到的都是null，然后都会进入判断进行计算，依然会存在重复计算的情况</p>
<h1 id="依然存在重复计算的可能——用原子操作putIfAbsent"><a href="#依然存在重复计算的可能——用原子操作putIfAbsent" class="headerlink" title="依然存在重复计算的可能——用原子操作putIfAbsent"></a>依然存在重复计算的可能——用原子操作putIfAbsent</h1><p>代码修改为如下所示。当我们保存最后封装好的Future对象的时候，调用ConcurrentHashMap的putIfAbsent方法，这个方法由ConcurrentHashMap保证原子性，如果当前Key已经存在对应的值了，那么就不会再存放，并且返回之前的值，如果当前Key没有值，那么会将键值对存放进去，返回null，这样就可以保证，即便是两个线程同时请求，并且没有拿到对象，虽然会封装两个Future，但是最终只有一个进行计算</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YsCache6</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, Future&lt;V&gt;&gt; cache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Computable&lt;A, V&gt; computable;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">YsCache6</span><span class="params">(Computable&lt;A, V&gt; computable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.computable = computable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Future&lt;V&gt; f = cache.get(arg);</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Callable&lt;V&gt; callable = <span class="keyword">new</span> Callable&lt;V&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> computable.compute(arg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            FutureTask&lt;V&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(callable);</span><br><span class="line">            f = cache.putIfAbsent(arg, ft);</span><br><span class="line">            <span class="keyword">if</span> (f == <span class="keyword">null</span>)&#123;</span><br><span class="line">                f = ft;</span><br><span class="line">                ft.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        YsCache6&lt;String, Integer&gt; expensiveComputer = <span class="keyword">new</span> YsCache6&lt;&gt;(<span class="keyword">new</span> ExpensiveFunction());</span><br><span class="line">        System.out.println(<span class="string">&quot;开始获取信息&quot;</span>);</span><br><span class="line">        Integer result = expensiveComputer.compute(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第一次获取信息=&quot;</span> + result);</span><br><span class="line">        result = expensiveComputer.compute(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第二次获取信息=&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="问题-6"><a href="#问题-6" class="headerlink" title="问题"></a>问题</h2><p>计算并不一定都是成功的，有可能会因为一些外部原因导致失败，需要重试机制</p>
<h1 id="计算中抛出异常——ExecutionException"><a href="#计算中抛出异常——ExecutionException" class="headerlink" title="计算中抛出异常——ExecutionException"></a>计算中抛出异常——ExecutionException</h1><p>抓取异常，并在对应的异常中进行相应的处理，比如直接向上抛出异常，或者打印一些提示，或者做其他处理，如代码所示，在方法中添加while循环语句，在异常之后会进行重试，直到成功<br>但是会存在内存污染的问题，Future封装的对象一旦异常，那么每次调用get方法都会打印异常，而我们又是先把Future放到map中才进行的计算的，所以需要在异常中将原本的key对应的异常Future删除  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YsCache7</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, Future&lt;V&gt;&gt; cache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Computable&lt;A, V&gt; computable;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">YsCache7</span><span class="params">(Computable&lt;A, V&gt; computable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.computable = computable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            Future&lt;V&gt; f = cache.get(arg);</span><br><span class="line">            <span class="keyword">if</span> (f == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Callable&lt;V&gt; callable = <span class="keyword">new</span> Callable&lt;V&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> computable.compute(arg);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                FutureTask&lt;V&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(callable);</span><br><span class="line">                f = cache.putIfAbsent(arg, ft);</span><br><span class="line">                <span class="keyword">if</span> (f == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    f = ft;</span><br><span class="line">                    ft.run();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> f.get();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CancellationException e)&#123;</span><br><span class="line">                cache.remove(arg);</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                cache.remove(arg);</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;计算异常，请重试&quot;</span>);</span><br><span class="line">                cache.remove(arg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        YsCache7&lt;String, Integer&gt; expensiveComputer = <span class="keyword">new</span> YsCache7&lt;&gt;(<span class="keyword">new</span> MayFail());</span><br><span class="line">        System.out.println(<span class="string">&quot;开始获取信息&quot;</span>);</span><br><span class="line">        Integer result = expensiveComputer.compute(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第一次获取信息=&quot;</span> + result);</span><br><span class="line">        result = expensiveComputer.compute(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第二次获取信息=&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="问题-7"><a href="#问题-7" class="headerlink" title="问题"></a>问题</h2><p>缓存并不是数据库，没必要长时间存储，有些数据已经没用了，需要进行删除</p>
<h1 id="缓存过期功能"><a href="#缓存过期功能" class="headerlink" title="缓存过期功能"></a>缓存过期功能</h1><p>实现如下，使用线程池，创建一个可以在未来指定时间执行任务的线程池，等超时时间达到之后，就会去清除缓存（方法未做线程安全处理，可以和上面的方法合并使用）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YsCache8</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, Future&lt;V&gt;&gt; cache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Computable&lt;A, V&gt; computable;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">YsCache8</span><span class="params">(Computable&lt;A, V&gt; computable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.computable = computable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            Future&lt;V&gt; f = cache.get(arg);</span><br><span class="line">            <span class="keyword">if</span> (f == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Callable&lt;V&gt; callable = <span class="keyword">new</span> Callable&lt;V&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> computable.compute(arg);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                FutureTask&lt;V&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(callable);</span><br><span class="line">                f = cache.putIfAbsent(arg, ft);</span><br><span class="line">                <span class="keyword">if</span> (f == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    f = ft;</span><br><span class="line">                    ft.run();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> f.get();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CancellationException e)&#123;</span><br><span class="line">                cache.remove(arg);</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                cache.remove(arg);</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;计算异常，请重试&quot;</span>);</span><br><span class="line">                cache.remove(arg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ScheduledExecutorService EXECUTOR_SERVICE = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">compute</span><span class="params">(A arg,<span class="keyword">long</span> expire)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (expire &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            EXECUTOR_SERVICE.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    expire(arg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,expire,TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> computable.compute(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">expire</span><span class="params">(A key)</span> </span>&#123;</span><br><span class="line">        Future&lt;V&gt; f = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (f != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!f.isDone())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Future 任务被取消&quot;</span>);</span><br><span class="line">                f.cancel(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;过期时间到，缓存被清楚了&quot;</span>);</span><br><span class="line">            cache.remove(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        YsCache8&lt;String, Integer&gt; expensiveComputer = <span class="keyword">new</span> YsCache8&lt;&gt;(<span class="keyword">new</span> ExpensiveFunction());</span><br><span class="line">        System.out.println(<span class="string">&quot;开始获取信息&quot;</span>);</span><br><span class="line">        Integer result = expensiveComputer.compute(<span class="string">&quot;666&quot;</span>,<span class="number">6000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第一次获取信息=&quot;</span> + result);</span><br><span class="line">        result = expensiveComputer.compute(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第二次获取信息=&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="问题-8"><a href="#问题-8" class="headerlink" title="问题"></a>问题</h2><p>指定超时时间，如果同时有大量的请求访问，但又有大量的数据同时缓存过期，会导致雪崩效应</p>
<h1 id="缓存过期时间设置未随机"><a href="#缓存过期时间设置未随机" class="headerlink" title="缓存过期时间设置未随机"></a>缓存过期时间设置未随机</h1><p>使用随机数设置缓存过期时间，可以设置一个大概的范围，比如几分钟或者或者几小时，然后生成随机数去指定缓存过期时间，避免缓存会同一时间失效</p>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>精通JUC并发工具十八般武艺</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发成神之路-精通JUC并发工具十八般武艺——控制并发流程(七)</title>
    <url>/2021/12/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94%E6%8E%A7%E5%88%B6%E5%B9%B6%E5%8F%91%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="什么是控制并发流程"><a href="#什么是控制并发流程" class="headerlink" title="什么是控制并发流程"></a>什么是控制并发流程</h1><ul>
<li>控制并发流程的工具类，作用就是帮助我们程序员更容易的让线程之间合作</li>
<li>让线程之间相互配合，来满足业务逻辑</li>
<li>比如让线程A等待线程B执行完毕后再执行等合作策略</li>
</ul>
<h2 id="有那些控制并发流程的工具类"><a href="#有那些控制并发流程的工具类" class="headerlink" title="有那些控制并发流程的工具类"></a>有那些控制并发流程的工具类</h2><table>
<thead>
<tr>
<th align="center">类</th>
<th align="left">作用</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>Semaphore</code></td>
<td align="left">信号量，可以通过控制”许可证“的数量，来保证线程之间的配合</td>
<td align="left">线程只有在拿到”许可证“后才能继续运行，相比于其他同步器，更灵活</td>
</tr>
<tr>
<td align="center"><code>CyclicBarrier</code></td>
<td align="left">线程会等待，直到足够多线程达到了事先规定的数目，一旦达到触发条件，就可以进行下一步的动作。</td>
<td align="left">适用于线程之间相互等待处理结果就绪的场景</td>
</tr>
<tr>
<td align="center"><code>Phaser</code></td>
<td align="left">和CyclicBarrier类似，但是计数可变</td>
<td align="left">Java7加入的</td>
</tr>
<tr>
<td align="center"><code>CountDownLatch</code></td>
<td align="left">和CyclicBarrier类似，数量递减到0时，触发动作</td>
<td align="left">不可重复使用</td>
</tr>
<tr>
<td align="center"><code>Exchanger</code></td>
<td align="left">让两个线程在合适的适合交换对象</td>
<td align="left">适用场景：当两个线程工作在同一个类的不同示例上时，用于交换数据</td>
</tr>
<tr>
<td align="center"><code>Condition</code></td>
<td align="left">可以控制线程的”等待“和”唤醒“</td>
<td align="left">是Object.wait()的升级版</td>
</tr>
</tbody></table>
<h1 id="CountDownLatch倒计时门闩"><a href="#CountDownLatch倒计时门闩" class="headerlink" title="CountDownLatch倒计时门闩"></a>CountDownLatch倒计时门闩</h1><h2 id="CountDownLatch类的作用"><a href="#CountDownLatch类的作用" class="headerlink" title="CountDownLatch类的作用"></a>CountDownLatch类的作用</h2><ul>
<li>倒数门闩</li>
<li>流程：倒数结束之前，一直处于等待状态，直到倒计时结束了，此线程才继续工作</li>
<li>开始 -&gt; 进入等待 -&gt; 倒数结束 -&gt; 继续工作</li>
</ul>
<h2 id="CountDownLatch类的主要方法"><a href="#CountDownLatch类的主要方法" class="headerlink" title="CountDownLatch类的主要方法"></a>CountDownLatch类的主要方法</h2><ul>
<li><code>CountDownLatch(int count)</code>：仅有一个构造函数，参数count为需要倒数的数值</li>
<li><code>await()</code>：调用<code>await()</code>方法的线程会被挂起，它会等待直到count值为0才继续执行</li>
<li><code>countDown()</code>：将count值减1，直到为0时，等待的线程会被唤起</li>
</ul>
<h2 id="CountDownLatch类的主要用法"><a href="#CountDownLatch类的主要用法" class="headerlink" title="CountDownLatch类的主要用法"></a>CountDownLatch类的主要用法</h2><ul>
<li><p>用法一：一个线程等待多个线程都执行完毕，再继续自己的工作</p>
</li>
<li><p>代码如下所示：假设一个产品需要经过5道质检程序，全部检查之后通过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">5</span>);</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> no = i+<span class="number">1</span>;</span><br><span class="line">            Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep((<span class="keyword">long</span>) (Math.random()*<span class="number">10000</span>));</span><br><span class="line">                        System.out.println(<span class="string">&quot;No.&quot;</span>+no+<span class="string">&quot;完成了检查&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                        latch.countDown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            executorService.submit(runnable);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;等待5个人检查完毕~~~~&quot;</span>);</span><br><span class="line">        latch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;所有人都检查完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>用法二：多个线程等待某一个线程的信号，同时开始执行</p>
</li>
<li><p>代码如下所示：假设有5个人进行跑步比赛，裁判枪响之后，同时开始比赛</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> no = i+<span class="number">1</span>;</span><br><span class="line">            Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;NO.&quot;</span> + no + <span class="string">&quot;准备完毕，等待发令枪&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        latch.await();</span><br><span class="line">                        System.out.println(<span class="string">&quot;NO.&quot;</span> + no + <span class="string">&quot;开始跑步&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            executorService.submit(runnable);</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;发令抢响，比赛开始&quot;</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ul>
<li>扩展用法：多个线程等多个线程完成执行后，再同时执行</li>
<li><code>CountDownLatch</code>是不能够重用的，如果需要重新计数，可以考虑适用<code>CyclicBarrier</code>或创建新的<code>CountDownLatch</code></li>
</ul>
<h1 id="Semaphore信号量"><a href="#Semaphore信号量" class="headerlink" title="Semaphore信号量"></a>Semaphore信号量</h1><ul>
<li><code>Semaphore</code>可以用来限制或者管理数量有限的资源的适用情况</li>
<li>信号量的作用是维护一个”许可证“的计数，线程可以”获取“许可证，那信号量剩余的许可证就减一，线程也可以”释放“一个许可证，那么信号量剩余的许可证就加一，当信号量所拥有的许可证数量为0，那么下一个还想要获取许可证的线程，就需要等待，直到有另外的线程释放了许可证</li>
</ul>
<h2 id="信号量的使用流程"><a href="#信号量的使用流程" class="headerlink" title="信号量的使用流程"></a>信号量的使用流程</h2><ul>
<li>初始化<code>Semaphore</code>并指定许可证的数量</li>
<li>在需要被限制的代码前加<code>acquire()</code>或者<code>acquireUninterruptibly()</code>方法</li>
<li>在任务执行结束后，调用<code>release()</code>来释放许可证</li>
</ul>
<h2 id="信号量的主要方法介绍"><a href="#信号量的主要方法介绍" class="headerlink" title="信号量的主要方法介绍"></a>信号量的主要方法介绍</h2><ul>
<li><code>new Semaphore(int permits,boolean fair)</code>：这里可以设置是否使用公平策略，如果传入true，那么<code>Semaphore</code>会把之前等待的线程放到FIFO的队列里，以便于当有了新的许可证，可以分发给之前等待了最长时间的线程</li>
<li><code>acquire()</code>：获取许可证，可以响应中断</li>
<li><code>acquireUninterruptibly()</code>：获取许可证，不能响应中断</li>
<li><code>tryAcquire()</code>：看看现在有没有空闲的许可证，如果有的话就获取，如果没有的话也没有关系，我不必陷入阻塞，我可以去做别的事，过一会再来看许可证的空闲情况</li>
<li><code>tryAcquire(timeout)</code>：和<code>tryAcquire()</code>方法一样，但是多了一个超时时间，如果没有许可证，会等待一定的时间，然后再退出</li>
<li><code>release()</code>：归还许可证</li>
</ul>
<h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><p>使用方法如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>,<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">50</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            executorService.submit(<span class="keyword">new</span> Task());</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.isShutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;拿到了许可证&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;释放了许可证-----&quot;</span>);</span><br><span class="line">                semaphore.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="信号量特殊用法"><a href="#信号量特殊用法" class="headerlink" title="信号量特殊用法"></a>信号量特殊用法</h2><ul>
<li>一次性获取或释放多个许可证<ul>
<li>比如任务A会调用很多消耗资源的方法，而任务B调用的不是太消耗资源的方法，假设我们一共有5个许可证，那么我们就可以要求任务A获取5个许可证才能执行，而任务B只需要获取到一个许可证就能执行，这样就避免了两个任务同时运行的情况，我们可以根据自己的需求合理分配资源</li>
</ul>
</li>
</ul>
<h2 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h2><ul>
<li>获取和释放的许可证数量必须一致，否则比如每次获取到2个许可证，但是只释放1个，随着时间的推移，到最后许可证数量不够用，会导致城西卡死，（虽然信号量类并不对释放和获取的数量做规定，但是这是我们的编程规范，否则容易出错）</li>
<li>注意在初始化Semaphore的时候设置公平性，一般设置为true更合理（因为使用Semaphore的地方一般都是因为处理太慢，如果使用非公平策略，可能会导致饥饿的情况）</li>
<li>并不是必须由获取许可证的线程释放那个许可证，事实上，获取和释放许可证对线程并无要求，也许A获取了，然后B释放，只要逻辑合理即可</li>
<li>信号量的作用，除了控制临界 区最多同时有N个线程访问外，另一个作用是可以实现“条件等待”，例如线程1需要在线程2完成准备工作后才能开始工作，那么就线程1<code>acquire()</code>，而线程2完成任务后<code>release()</code>，这样的话就相当于轻量级<code>CountDownLatch</code></li>
</ul>
<h1 id="Condition接口（又称条件对象）"><a href="#Condition接口（又称条件对象）" class="headerlink" title="Condition接口（又称条件对象）"></a>Condition接口（又称条件对象）</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul>
<li>当线程1需要等待某个条件的时候，它就会去执行<code>condition.await()</code>方法，一旦执行了<code>await()</code>方法，线程就会进入阻塞状态</li>
<li>然后通常会有另外一个线程，假设是线程2，去执行对应的条件，直到这个条件达成的时候，线程2就会去执行<code>condition.signal()</code>方法，这是JVM就会从被阻塞的线程里找到那些等待该condition的线程，当线程1就会收到可执行的信号的时候，它的线程状态就会变成Runnable可执行状态</li>
</ul>
<h2 id="signalAll-和signal-方法的区别"><a href="#signalAll-和signal-方法的区别" class="headerlink" title="signalAll()和signal()方法的区别"></a><code>signalAll()</code>和<code>signal()</code>方法的区别</h2><ul>
<li>signalAll()会唤起所有正在等待的线程</li>
<li>但是signal()是公平的，只会唤起那个等待时间最长的线程</li>
</ul>
<h2 id="代码演示-1"><a href="#代码演示-1" class="headerlink" title="代码演示"></a>代码演示</h2><p>代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionDemo1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConditionDemo1 conditionDemo1 = <span class="keyword">new</span> ConditionDemo1();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    conditionDemo1.method2();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        conditionDemo1.method1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;条件不满足，开始等待&quot;</span>);</span><br><span class="line">            condition.await();</span><br><span class="line">            System.out.println(<span class="string">&quot;添加满足了，继续处理任务&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;准备工作完成，开始唤醒其他线程&quot;</span>);</span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>Condition</code>来实现生产者和消费者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionDemo2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> queueSize = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(queueSize);</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition notFull = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition notEmpty = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConditionDemo2 conditionDemo2 = <span class="keyword">new</span> ConditionDemo2();</span><br><span class="line">        Consumer consumer = conditionDemo2.<span class="function">new <span class="title">Consumer</span><span class="params">()</span></span>;</span><br><span class="line">        Producer producer = conditionDemo2.n<span class="function">ew <span class="title">Producer</span><span class="params">()</span></span>;</span><br><span class="line">        consumer.start();</span><br><span class="line">        producer.start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            consume();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (queue.size() == <span class="number">0</span>)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;队列为空，等待数据&quot;</span>);</span><br><span class="line">                        notEmpty.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                    queue.poll();</span><br><span class="line">                    notFull.signalAll();</span><br><span class="line">                    System.out.println(<span class="string">&quot;从队列里取走了一个数据，队列里剩余: &quot;</span>+queue.size());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            produce();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (queue.size() == queueSize)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;队列已满，等待空余&quot;</span>);</span><br><span class="line">                        notFull.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                    queue.offer(<span class="number">1</span>);</span><br><span class="line">                    notEmpty.signalAll();</span><br><span class="line">                    System.out.println(<span class="string">&quot;向队列插入一个元素，队列剩余空间: &quot;</span>+(queueSize-queue.size())+<span class="string">&quot;-----&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注意点-2"><a href="#注意点-2" class="headerlink" title="注意点"></a>注意点</h2><ul>
<li>实际上，如果说<code>Lock</code>用来代替<code>synchronized</code>，那么<code>Condition</code>就是用来代替相对应的<code>Object.wait/notify</code>的，所以在用法和性质上，几乎都一样</li>
<li><code>await</code>方法会自动释放持有的<code>Lock</code>锁，和<code>Object.wait</code>一样，不需要自己手动先释放锁</li>
<li>调用<code>await</code>的时候，必须持有锁，否则会抛出异常，和<code>Object.wait</code>一样</li>
</ul>
<h1 id="CyclicBarrier循环栅栏"><a href="#CyclicBarrier循环栅栏" class="headerlink" title="CyclicBarrier循环栅栏"></a><code>CyclicBarrier</code>循环栅栏</h1><ul>
<li><code>CyclicBarrier</code>循环栅栏和<code>CountDownLatch</code>很类似，都能阻塞一组线程</li>
<li>当有大量线程相互配合，分别计算不同任务，并且需要最后统一汇总的时候，我们可以使用<code>CyclicBarrier</code>，<code>CyclicBarrier</code>可以构造一个集结点，当某一个线程执行完毕，它就会到集结点等待，直到所有线程都到了集结点，那么该栅栏就被撤销，所有线程再统一出发，继续执行剩下的任务</li>
</ul>
<h2 id="代码演示-2"><a href="#代码演示-2" class="headerlink" title="代码演示"></a>代码演示</h2><p>代码如下所示，<code>CyclicBarrier</code>是可重用的，假设是同时执行了10个线程，也是可以，只不过会5个一起出发 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;所有都到了，大家一起出发吧&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task(i,cyclicBarrier)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(<span class="keyword">int</span> id, CyclicBarrier cyclicBarrier)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">            <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程&quot;</span>+id+<span class="string">&quot;现在前往集合地点&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep((<span class="keyword">long</span>) (Math.random()*<span class="number">10000</span>));</span><br><span class="line">                System.out.println(<span class="string">&quot;线程&quot;</span>+id+<span class="string">&quot;到了集合地点，开始等待其他人&quot;</span>);</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">                System.out.println(<span class="string">&quot;线程&quot;</span>+id+<span class="string">&quot;出发了&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CyclicBarrier和CountDownLatch的区别"><a href="#CyclicBarrier和CountDownLatch的区别" class="headerlink" title="CyclicBarrier和CountDownLatch的区别"></a><code>CyclicBarrier</code>和<code>CountDownLatch</code>的区别</h2><ul>
<li>作用不同：<code>CyclicBarrier</code>要等固定数量的线程都到达了栅栏位置才能继续执行，而<code>CountDownLatch</code>只需要等待数字到0，也就是说<code>CountDownLatch</code>用于事件，但是<code>CyclicBarrier</code>是用于线程（<code>CountDownLatch</code>同一个任务用一个线程执行多次，只要计算为0就可以，<code>CyclicBarrier</code>则必须要指定数量的线程才行）</li>
<li>可重用性不同：<code>CountDownLatch</code>在倒数到0并触发门闩打开后，就不能再次使用了，除非创建新的实例，而<code>CyclicBarrier</code>可以重复使用</li>
<li><code>CyclicBarrier</code>在所有线程都到达只会，可以再去运行一个Runnable方法</li>
</ul>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>精通JUC并发工具十八般武艺</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发成神之路-精通JUC并发工具十八般武艺——线程池(一)</title>
    <url>/2021/11/26/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h1 id="并发工具类——分类"><a href="#并发工具类——分类" class="headerlink" title="并发工具类——分类"></a>并发工具类——分类</h1><ul>
<li>为了并发安全：互斥同步、非互斥同步、无同步方案</li>
<li>管理线程、提高效率</li>
<li>线程协作</li>
</ul>
<p><img src="/2021/11/26/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E6%B1%A0/%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%9A%84%E5%88%86%E7%B1%BB.png" alt="并发工具的分类"></p>
<!--

- 并发工具类的分类
  - 为了线程安全（从底层原理来看）
    - 互斥同步
      - 使用各种互斥同步的锁
        - synchronized
        - ReentrantLock
        - ReadWriteLock
        - ...
      - 使用同步的工具类
        - Collections.synchronizedList(new ArrayList<>())等
        - Vector等
    - 非互斥同步
      - atomic包，原子类
        - Atomic*基本类型原子类
          - AtomicInteger：整型原子类
          - AtomicLong：长整型原子类
          - AtomicBoolean：布尔型原子类
        - Atomic*Array数组类型原子类(数组里面的元素，都可以保证原子性)
          - AtomicIntegerArray：整型数组原子类
          - AtomicLongArray：长整型数组原子类
          - AtomicReferenceArray：引用类型数组原子类
        - Atomic*Reference引用类型子类
          - AtomicReference：引用类型原子类
          - AtomicStampedReference：引用类型原子类的升级，带时间戳，可以解决ABA问题
          - AtomicMarkableReference
        - Atomic*FieldUpdater升级原子类
          - 用Atomic*FieldUpdater等升级自己的变量
          - AtomicIntegerFieldUpdater：原子更新整型字段的更新器
          - AtomicLongFieldUpdater：原子更新长整型字段的更新器
        - Adder加法器
          - LongAdder
          - DoubleAdder
        - Accumulator累加器
          - LongAccumulator
          - DoubleAccumulator
    - 结合互斥和非互斥同步
      - 线程安全的并发容器
        - ConcurrentHashMap
        - CopyOnWriteArrayList
        - 并发队列
          - 阻塞队列
            - ArrayBlockingQueue
            - LinkedBlockingQueue
            - PriorityBlockingQueue
            - SynchronousQueue
            - DelayedQueue
            - TransferQueue
            - ...
          - 非阻塞队列
            - ConcurrentLinkedQueue
        - ConcurrentSkipListMap和ConcurrentSkipListSet
    - 无同步方、不可变
      - final关键字
      - 线程封闭
        - ThreadLocal
        - 栈封闭
  - 为了线程安全（从使用者角度来看）
    - 避免共享变量
      - 线程封闭
        - ThreadLocal
        - 栈封闭
    - 共享变量，但是可以限制和处理
      - 互斥同步
        - 使用各种互斥同步的锁
          - synchronized
          - Lock接口相关的类
      - final关键字
    - 使用成熟工具类
      - 线程安全的并发容器
        - ConcurrentHashMap
        - CopyOnWriteArrayList
        - 并发队列
          - 阻塞队列
            - ArrayBlockingQueue
            - LinkedBlockingQueue
            - PriorityBlockingQueue
            - SynchronousQueue
            - DelayedQueue
            - TransferQueue
            - ...
          - 非阻塞队列
            - ConcurrentLinkedQueue
        - ConcurrentSkipListMap和ConcurrentSkipListSet
        - 使用同步的工具类
          - Collections.synchronizedList(new ArrayList<>())等
          - Vector等
      - atomic包，原子类
        - Atomic*基本类型原子类
          - AtomicInteger：整型原子类
          - AtomicLong：长整型原子类
          - AtomicBoolean：布尔型原子类
        - Atomic*Array数组类型原子类(数组里面的元素，都可以保证原子性)
          - AtomicIntegerArray：整型数组原子类
          - AtomicLongArray：长整型数组原子类
          - AtomicReferenceArray：引用类型数组原子类
        - Atomic*Reference引用类型子类
          - AtomicReference：引用类型原子类
          - AtomicStampedReference：引用类型原子类的升级，带时间戳，可以解决ABA问题
          - AtomicMarkableReference
        - Atomic*FieldUpdater升级原子类
          - 用Atomic*FieldUpdater等升级自己的变量
          - AtomicIntegerFieldUpdater：原子更新整型字段的更新器
          - AtomicLongFieldUpdater：原子更新长整型字段的更新器
        - Adder加法器
          - LongAdder
          - DoubleAdder
        - Accumulator累加器
          - LongAccumulator
          - DoubleAccumulator
  - 为了方便管理线程、提高效率
    - 线程池相关
      - Executor
      - Executors
      - ExecutorService
      - 常见线程池
        - FixedThreadPool
        - CachedThreadPool
        - ScheduledThreadPool
        - SingleThreadExecutor
        - ForkJoinPool
        - ...
    - 能获取子线程的运行结果
      - Callable
      - Future
      - FutureTask
      - ...
  - 为了线程之间配合，来满足业务逻辑
    - CountDownLath
    - CyclicBarrier
    - Semaphore
    - Condition
    - Exchanger
    - Phaser
    - ...


-->

<h1 id="线程池的自我介绍"><a href="#线程池的自我介绍" class="headerlink" title="线程池的自我介绍"></a>线程池的自我介绍</h1><h2 id="线程池的重要性"><a href="#线程池的重要性" class="headerlink" title="线程池的重要性"></a>线程池的重要性</h2><ul>
<li>如果不使用线程池，每个任务都需要新开一个线程处理<ul>
<li>一个线程还好，如果是几千的任务，每次都创建线程</li>
</ul>
</li>
<li>这样开销太大，我们希望有固定的数量的线程，来执行这几千个任务，这样就避免了反复创建并销毁线程所带来的开销问题</li>
</ul>
<h2 id="为什么要使用线程池"><a href="#为什么要使用线程池" class="headerlink" title="为什么要使用线程池"></a>为什么要使用线程池</h2><ul>
<li>问题一：反复创建线程开销大</li>
<li>问题二：过多的线程会占用太多内存</li>
<li>解决以上两个问题的思路<ul>
<li>用少量的线程——避免内存占用过多</li>
<li>让这部分线程都保持工作，且可以反复执行任务——避免生命周期的损耗</li>
</ul>
</li>
</ul>
<h2 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h2><ul>
<li>加快相应速度</li>
<li>合理利用CPU和内存</li>
<li>统一管理</li>
</ul>
<h2 id="线程池适合应用的场景"><a href="#线程池适合应用的场景" class="headerlink" title="线程池适合应用的场景"></a>线程池适合应用的场景</h2><ul>
<li>服务器接受到大量请求时，使用线程池技术是非常合适的，它可以大大减少线程的创建和销毁次数，提高服务器的工作效率</li>
<li>实际上，在开发中，如果需要创建5个以上的线程，那么就可以使用线程池来管理</li>
</ul>
<h1 id="创建和停止线程池"><a href="#创建和停止线程池" class="headerlink" title="创建和停止线程池"></a>创建和停止线程池</h1><h2 id="线程池构造函数的参数"><a href="#线程池构造函数的参数" class="headerlink" title="线程池构造函数的参数"></a>线程池构造函数的参数</h2><table>
<thead>
<tr>
<th align="center">参数名</th>
<th align="center">类型</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">corePoolSize</td>
<td align="center">int</td>
<td align="center">核心线程数，详解见下文</td>
</tr>
<tr>
<td align="center">maximumPoolSize</td>
<td align="center">int</td>
<td align="center">最大线程数，详解见下文</td>
</tr>
<tr>
<td align="center">keepAliveTime</td>
<td align="center">long</td>
<td align="center">保持存活时间</td>
</tr>
<tr>
<td align="center">unit</td>
<td align="center">TimeUnit</td>
<td align="center">保持存活时间的单位</td>
</tr>
<tr>
<td align="center">workQueue</td>
<td align="center">BlockingQueue</td>
<td align="center">任务存储队列</td>
</tr>
<tr>
<td align="center">threadFactory</td>
<td align="center">ThreadFactory</td>
<td align="center">当线程池需要新的线程的时候，会使用threadFactory来生成新的线程</td>
</tr>
<tr>
<td align="center">Handler</td>
<td align="center">RejectedExecutionHandler</td>
<td align="center">由于线程池也无法接受你所提交的任务的拒绝策略</td>
</tr>
</tbody></table>
<h3 id="参数中corePoolSize和macPoolSize"><a href="#参数中corePoolSize和macPoolSize" class="headerlink" title="参数中corePoolSize和macPoolSize"></a>参数中<code>corePoolSize</code>和<code>macPoolSize</code></h3><ul>
<li><code>corePoolSize</code>指的是核心线程数：线程池在完成初始化后，默认情况下，线程池中并没有任何线程，线程池会等待有任务到来时，再创建新线程去执行任务</li>
<li>线程池有可能会在核心线程数的基础上，额外增加一些线程，但是这些增加的线程数有一个上限，这就是最大量<code>maximumPoolSize</code></li>
</ul>
<h3 id="添加线程规则"><a href="#添加线程规则" class="headerlink" title="添加线程规则"></a>添加线程规则</h3><ul>
<li>如果线程数小于<code>corePoolSize</code>，即使其他工作线程处于空闲状态，也会创建一个新的线程来运行新任务</li>
<li>如果线程数等于（或大于）<code>corePoolSize</code>但少于<code>maximumPoolSize</code>，则将任务放入队列</li>
<li>如果队列已满，并且线程数小于<code>maximumPoolSize</code>，则创建一个新的线程来运任务</li>
<li>如果队列已满，并且线程数大于或等于<code>maximumPoolSize</code>，则拒绝该任务</li>
<li>是否需要增加线程的判断顺序是：<ul>
<li><code>corePoolSize</code></li>
<li><code>workQueue</code></li>
<li><code>maximumPoolSize</code></li>
</ul>
</li>
</ul>
<div id="flowchart-0" class="flow-chart"></div>

<h3 id="增减线程的特点"><a href="#增减线程的特点" class="headerlink" title="增减线程的特点"></a>增减线程的特点</h3><ul>
<li>通过设置<code>corePoolSize</code>和<code>maximumPoolSize</code>相同，就可以创建一个固定大小的线程池</li>
<li>线程池希望保持较少的线程数，并且只有在负载变得很大的时候才增加它</li>
<li>通过设置<code>maximumPoolSize</code>为很高的值，例如Integer.MAX_VALUE，可以允许线程池容纳任意数量的并发任务</li>
<li>是只有队列填满的时候才会创建对于<code>corePoolSize</code>的线程，所以如果你使用的是无界队列（例如<code>LinkedBockingQueue</code>），那么线程数就不会超过<code>corePoolSize</code></li>
</ul>
<h3 id="keepAliveTime"><a href="#keepAliveTime" class="headerlink" title="keepAliveTime"></a><code>keepAliveTime</code></h3><ul>
<li>如果线程池当前的线程数对于<code>corePoolSize</code>，那么如果多余的线程空闲时间超过<code>keepAliveTime</code>，它们就会被终止</li>
</ul>
<h3 id="ThreadFactory用来创建线程"><a href="#ThreadFactory用来创建线程" class="headerlink" title="ThreadFactory用来创建线程"></a><code>ThreadFactory</code>用来创建线程</h3><ul>
<li>新的线程是由<code>ThreadFactory</code>创建的，默认使用<code>Executors.defaultThreadFactory()</code>，创建出来的线程都在同一个线程组，拥有同样的NORM_PRIORITY优先级并且都不是守护线程，如果自己指定ThreadFactory，那么就可以改变线程名、线程组、优先级、是否是守护线程等。</li>
<li>通常情况下我们使用默认的<code>ThreadFactory</code>就可以了</li>
</ul>
<h3 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h3><ul>
<li>有3中最常见的队列类型：<ul>
<li>直接交接：<code>SynchronousQueue</code>(没有队列，里面不存任务，直接交给线程执行)</li>
<li>无界队列：<code>LinkedBlockingQueue</code>(队列没有界限，永远不会被塞满，但是可能会内存溢出)</li>
<li>有界队列：<code>ArrayBlockingQueue</code>(可以设置队列大小)</li>
</ul>
</li>
</ul>
<h2 id="线程池应该手动创建还是自动创建"><a href="#线程池应该手动创建还是自动创建" class="headerlink" title="线程池应该手动创建还是自动创建"></a>线程池应该手动创建还是自动创建</h2><ul>
<li>手动创建更好，因为这样可以让我们更加明确线程池的运行规则，避免资源耗尽的风险</li>
<li>让我们来看看自动创建线程池（也就是直接调用JDK封装好的构造函数）可能带来那些问题</li>
</ul>
<h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a><code>newFixedThreadPool</code></h3><ul>
<li>创建一个定长的线程池</li>
<li>由于传进去的LinkedBlockQueue是没有容量上限的，所以当请求数越来越多，并且无法及时处理完毕的时候，也就是请求堆积的时候，会容易造成占用大量的内存，可能会导致OOM。<blockquote>
<p>OOM的代码如下，任务数调到最大，每个线程都直接休眠，任务一直无法完成，就会全部堆积在队列中，最终导致队列OOM</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FixedThreadPoolOOM</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i++) &#123;</span><br><span class="line">            executorService.execute(<span class="keyword">new</span> SubThread());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a><code>newSingleThreadExecutor</code></h3></li>
<li>创建一个单线程的线程池</li>
<li>可以看出，这里和刚才的<code>newFixedThreadPool</code>的原理基本是一样的，只不过是把线程数直接设置成了1，所以这也会导致同样的问题，也就是当请求堆积的时候，可能会占用大量内存</li>
</ul>
<h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a><code>newCachedThreadPool</code></h3><ul>
<li>可以缓存的线程池</li>
<li>这里的弊端在于第二个参数<code>maximumPoolSize</code>被设置为了<code>Integer.MAX_VALUE</code>，这可能会创建数量非常多的线程，甚至导致OOM</li>
</ul>
<h3 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a><code>newScheduledThreadPool</code></h3><ul>
<li>支持定时及周期性任务执行的线程池</li>
<li>可以在指定时间后执行任务，也可以在指定时间后每隔多久执行一次任务</li>
</ul>
<h3 id="workStealingPool是JDK8加入的"><a href="#workStealingPool是JDK8加入的" class="headerlink" title="workStealingPool是JDK8加入的"></a>workStealingPool是JDK8加入的</h3><ul>
<li>子任务：适合有子任务的场景（比如遍历二叉树，一个任务会创建多个子任务）</li>
<li>窃取：当其他的线程执行完任务之后，如果某一个线程的子任务还没有执行完毕，其他线程就会帮他执行，任务执行是没有顺序的</li>
</ul>
<h3 id="正确的创建线程池的方法"><a href="#正确的创建线程池的方法" class="headerlink" title="正确的创建线程池的方法"></a>正确的创建线程池的方法</h3><ul>
<li>根据不同的业务场景，自己设置线程池参数，比如我们的内存有多大，我们想给线程取什么名字等待</li>
</ul>
<h2 id="线程池里的线程数量设定为多少比较合适"><a href="#线程池里的线程数量设定为多少比较合适" class="headerlink" title="线程池里的线程数量设定为多少比较合适"></a>线程池里的线程数量设定为多少比较合适</h2><ul>
<li>CPU密集性（加密、计算hash等）：最佳线程数为CPU核心数的1-2倍左右。</li>
<li>耗时IO型（读写数据库、文件、网络读写等）：最佳线程数一般会大于CPU核心数很多倍，以JVM线程监控显示繁忙情况为依据，保证线程空闲可以衔接上</li>
<li>参考Brain Goetz推荐的计算方法：<ul>
<li>线程数 = CPU核心数 * （1 + 平均等待时间 / 平均工作时间）</li>
</ul>
</li>
</ul>
<h1 id="停止线程池的正确方法"><a href="#停止线程池的正确方法" class="headerlink" title="停止线程池的正确方法"></a>停止线程池的正确方法</h1><ul>
<li><code>shutdown()</code><ul>
<li>并不会立即停止线程池，而是通知线程池进行停止</li>
<li>线程池会将正在等待的以及正在执行的任务执行完毕之后再停止</li>
<li>但是再执行该方法之后，就无法再向线程池提交任务</li>
</ul>
</li>
<li><code>isShutdown()</code><ul>
<li>判断线程池是否已经执行过了<code>shutdown</code></li>
<li>并不是返回true就是线程池已经结束，而是开始准备结束</li>
</ul>
</li>
<li><code>isTerminated()</code><ul>
<li>判断线程池是否真的结束</li>
</ul>
</li>
<li><code>awaitTermination(long timeout, TimeUnit unit)</code><ul>
<li>会阻塞线程，阻塞时间根据参数指定</li>
<li>然后返回一个布尔类型的结果</li>
<li>结果是判断线程池是否关闭</li>
<li>阻塞一定的时间，然后判断线程池是否已经关闭</li>
</ul>
</li>
<li><code>shutdownNow</code><ul>
<li>立即关闭线程池</li>
<li>会多所有正在执行任务发出中断指令</li>
<li>有一个List的返回值，返回的是所有正在等待中的任务的集合</li>
</ul>
</li>
</ul>
<h1 id="任务太多，怎么拒绝？"><a href="#任务太多，怎么拒绝？" class="headerlink" title="任务太多，怎么拒绝？"></a>任务太多，怎么拒绝？</h1><h2 id="决绝时机"><a href="#决绝时机" class="headerlink" title="决绝时机"></a>决绝时机</h2><ul>
<li>当线程池关闭时，提交新任务会被拒绝</li>
<li>当线程池对最大线程和工作队列容量使用有限制边界并且已经饱和的时候会拒绝任务</li>
</ul>
<h2 id="4中决绝策略"><a href="#4中决绝策略" class="headerlink" title="4中决绝策略"></a>4中决绝策略</h2><ul>
<li>AbortPolicy<ul>
<li>直接抛出异常</li>
</ul>
</li>
<li>DiscardPolicy<ul>
<li>直接丢弃任务，并且不会通知</li>
</ul>
</li>
<li>DiscardOldestPolicy<ul>
<li>丢弃最老的任务，将新的放进队列</li>
</ul>
</li>
<li>CallerRunPolicy<ul>
<li>让提交任务的线程去执行任务（同步执行）</li>
</ul>
</li>
</ul>
<h1 id="钩子方法，给线程池加点料"><a href="#钩子方法，给线程池加点料" class="headerlink" title="钩子方法，给线程池加点料"></a>钩子方法，给线程池加点料</h1><blockquote>
<p>具体实现如以下代码所示，代码的功能是实现一个可以暂停的线程池，等待一定时间后还能被唤醒<br>继承<code>ThreadPoolExecutor</code>类，并重写<code>beforeExecute</code>方法，这个方法会在线程执行每一个任务之前执行<br>通过标记位，实现对线程的暂停和恢复</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PauseableThreadPool</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isPaused;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition unpaused = lock.newCondition();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        PauseableThreadPool pauseableThreadPool = <span class="keyword">new</span> PauseableThreadPool(<span class="number">10</span>,<span class="number">20</span>,<span class="number">10L</span>,TimeUnit.SECONDS,<span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;());</span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我被执行了&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            pauseableThreadPool.execute(runnable);</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">        pauseableThreadPool.pause();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程池被暂停了&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">        pauseableThreadPool.resume();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程池被恢复了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.beforeExecute(t, r);</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isPaused) &#123;</span><br><span class="line">                unpaused.await();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            isPaused = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resume</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            isPaused = <span class="keyword">false</span>;</span><br><span class="line">            unpaused.signalAll();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PauseableThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="实现原理，源码分析"><a href="#实现原理，源码分析" class="headerlink" title="实现原理，源码分析"></a>实现原理，源码分析</h1><h2 id="线程池组成部分"><a href="#线程池组成部分" class="headerlink" title="线程池组成部分"></a>线程池组成部分</h2><ul>
<li>线程池管理器</li>
<li>工作线程</li>
<li>任务队列</li>
<li>任务接口（Task）</li>
</ul>
<h2 id="Executor家族"><a href="#Executor家族" class="headerlink" title="Executor家族"></a>Executor家族</h2><ul>
<li>线程池、<code>ThreadPoolExecutor</code>、<code>ExecutorService</code>、<code>Executor</code>、<code>Executors</code>等这么多和线程池相关的类，大家都是什么关系呢？<img src="http://www.plantuml.com/plantuml/svg/oymhIIrAIqnELN2jI4qkBSalggxboiGG34ujAii4ybChIbBpKegH5ISc5PSK9IQNA2Jd91ONApX2kUWwCtCBSb9pK_DAYj4D1Pe1qHgIKPIQc1AGdvy3Km6t3uUfrRK0"></li>
<li><code>Executor</code><blockquote>
<p>线程池的最顶级接口，只提供了执行线程的方法</p>
</blockquote>
</li>
<li><code>ExecutorService</code><blockquote>
<p>对<code>Executor</code>接口的继承，同时添加了一些其他的方法，比如停止线程池的方法等</p>
</blockquote>
</li>
<li><code>ThreadPoolExecutor</code><blockquote>
<p>线程池的最终实现类</p>
</blockquote>
</li>
<li><code>Executors</code><blockquote>
<p>一个工具类，提供了一些创建线程池的方法</p>
</blockquote>
</li>
</ul>
<h2 id="线程池实现线程复用的原理"><a href="#线程池实现线程复用的原理" class="headerlink" title="线程池实现线程复用的原理"></a>线程池实现线程复用的原理</h2><ul>
<li>相同线程执行不同任务<blockquote>
<p>下面代码是从<code>ThreadPoolExecutor</code>类中摘取的启动任务的方法<br>从代码中可以看出来，主要是通过while循环，判断当前任务不为空，或者能取到下一个任务<br>而任务的类型就是<code>Runnable</code>类型的，之后就直接执行它的<code>run()</code>方法运行任务</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final void runWorker(Worker w) &#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = null;</span><br><span class="line">    w.unlock(); // allow interrupts</span><br><span class="line">    boolean completedAbruptly = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        while (task != null || (task = getTask()) != null) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            // If pool is stopping, ensure thread is interrupted;</span><br><span class="line">            // if not, ensure thread is not interrupted.  This</span><br><span class="line">            // requires a recheck in second case to deal with</span><br><span class="line">            // shutdownNow race while clearing interrupt</span><br><span class="line">            if ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            try &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; catch (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; throw x;</span><br><span class="line">                &#125; catch (Error x) &#123;</span><br><span class="line">                    thrown = x; throw x;</span><br><span class="line">                &#125; catch (Throwable x) &#123;</span><br><span class="line">                    thrown = x; throw new Error(x);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                task = null;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = false;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h2><ul>
<li>RUNNING：接受新任务并且处理排队任务</li>
<li>SHUTDOWN：不接受新的任务，但是处理排队中的任务</li>
<li>STOP：不接受新的任务，也不处理排队中的任务，并且中断正在进行中的任务</li>
<li>TIDYING，中文是整洁，理解了中文就容易理解这个状态了：所有任务都已经终止，<code>workerCount</code>为0时，线程会转换到<code>TIDYING</code>状态，并将运行<code>terminate()</code>钩子方法</li>
<li>TERMINATED：<code>terminate()</code>运行完成</li>
</ul>
<h1 id="使用线程池的注意点"><a href="#使用线程池的注意点" class="headerlink" title="使用线程池的注意点"></a>使用线程池的注意点</h1><ul>
<li>避免任务堆积</li>
<li>避免线程数过度增加</li>
<li>排查线程泄漏（线程一直无法回收）</li>
</ul>
<script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: 开始
o1=>operation: 提交任务
c1=>condition: 核心线程池是否已满？
c2=>condition: 队列是否已满？
c3=>condition: 线程池是否已满？
o2=>operation: 按照策略处理无法执行的任务
o3=>operation: 创建核心线程执行任务
o4=>operation: 任务添加到队列
o5=>operation: 创建非核心线程执行任务
st->o1
o1->c1
c1(yes)->c2
c1(no)->o3
c2(yes)->c3
c2(no)->o4
c3(yes)->o2
c3(no)->o5
e=>end: 结束
o2->e
o3->e
o4->e
o5->e</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script>]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>精通JUC并发工具十八般武艺</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaIO流</title>
    <url>/2021/12/18/java%E5%9F%BA%E7%A1%80/JavaIO%E6%B5%81/</url>
    <content><![CDATA[<h1 id="IO流概述"><a href="#IO流概述" class="headerlink" title="IO流概述"></a>IO流概述</h1><blockquote>
<p>在Java程序中，对于数据的输入/输出操作以“流（stream）”方式进行；Java提供了各种各样的“流”类，用以获取不同类的数据；程序中通过标准的方法输出或输入数据。Java的流类型一般位于<code>java.io</code>包中<br>数据源data source，提供原始数据的原始媒介。常见的：数据库、文件、其他程序、网络连接、IO设备（既可以做数据的源头，也可以做数据的目的地）<br>流是一个抽象、动态的概念，是一连串连续动态的数据集合。<br>数据元就像水箱，流就像水管中留着的水流，程序就是我们最终的用户。流是一个抽象、动态的概念，是一连串连续动态的数据集合。</p>
</blockquote>
<h2 id="IO流分类"><a href="#IO流分类" class="headerlink" title="IO流分类"></a>IO流分类</h2><ul>
<li><p>按流的方向分类：</p>
<ul>
<li>输入流：数据流向是数据源到程序（以<code>InputStream</code>、<code>Reader</code>结尾的流）</li>
<li>输出流：数据流向是程序到目的地（以<code>OutPutStream</code>、<code>Writer</code>结尾的流）<br>输入输出流的划分是相对于程序而言的，并不是相对数据源</li>
</ul>
</li>
<li><p>按处理的数据单元分类：</p>
<ul>
<li>字节流：以字节为单位获取数据，命名上以<code>Stream</code>结尾的流一般是字节流，顶级类 <code>InputStream</code>、<code>OutPutStream</code></li>
<li>字符流：以字符为单位获取数据，命名上以<code>Reader</code>、<code>Writer</code>结尾的一般是字符流，顶级类<code>Reader</code>、<code>Writer</code></li>
</ul>
</li>
<li><p>按处理对象不同分类：</p>
<ul>
<li>节点流：可以直接从数据源或目的地读写数据，如<code>FileInputStream</code>、<code>FileReader</code>等</li>
<li>处理流：不直接连接到数据源或目的地，是“处理流的流”，通过对其他流的处理提高程序的性能，如BufferedInputStream、BufferedReader等。处理流也叫包装流<br>节点流处于IO操作的第一线，所有操作必须通过它们进行，处理流可以对节点流进行包装，提高性能或提高程序的灵活性</li>
</ul>
</li>
</ul>
<h2 id="IO流体系结构"><a href="#IO流体系结构" class="headerlink" title="IO流体系结构"></a>IO流体系结构</h2><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><ul>
<li><code>InputStream</code>和<code>OutPUtStream</code>是Java语言中最基本的两个字节输入输出类，其他所有字节输出输入流类都继承这两个基类</li>
<li>这两个类都是抽象类，不能创建它们的实例，只能使用它们的子类</li>
<li><code>FilterInputStream</code>和<code>FilterOutPutStream</code>是所有包装流的父类</li>
</ul>
<img src="http://www.plantuml.com/plantuml/svg/bP1H2i9034J_FSLUnIA285he2RBRgQwsIyqcq2AzUq4_AhZ5zJTvaymCsIXCJenhAKPp2BrA9GpgdjFcFIjzZ_fZOJ08Gfs6zxv5BbkCWYqpZNyS5t0kNU6X2EwN7RC8X7su5Deq-K_EzWOdkVIEX5BiLx2bevURTF_hggCFE6bdqpdMTQN6goLtprJD">

<img src="http://www.plantuml.com/plantuml/svg/IqmgBYbAJ2vHICv9B2vMy2yjAIWj2IufIatChQxbWWYwPUQa8aief5QKfEQbu5PTabf4lFg0p8BK5EALErMMf3eM5ILM4g_5FoahDRc4e7e5k0QNn994hCen_OPmLsbQMceH3f_WqHTGb9b7Z780">

<h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><ul>
<li><code>Reader</code>和<code>Writer</code>，Java语言中最基本的两个字符输入输出类</li>
<li>其他所有字符输入输出流都继承自这两个基类</li>
<li>这两个类都是抽象类，不能创建它们的实例，只能使用它们的子类<br>字符流只适合读写文本之类的，不适合音频文件</li>
</ul>
<img src="http://www.plantuml.com/plantuml/svg/VOzH2eCm44J_UufSfHKA1Id5dc2JZ3LKWsmsK17lhY1OQsW-TtcxyuPq42OZohGKWgf05ZnEftMynBe6mwvhXO_0suGg6k8pCmrvxERxA4zXK9S7hwuLS9vvkFwFbjgO9SlvL_vFwJpkiTD9tc_rlHiEPDBhAnb3eycy3mVxVkCq0m00">

<img src="http://www.plantuml.com/plantuml/svg/IqmgBYbAJ2vHICv9B2vM22_AB4ajggxbWd2TIjFIKejIKo322gaL9QbvAHYgd3CIYnoBYX8hyIlpBoqfA2q9BYbAJSp5hz8jCmV8nQyc8BC0XxiKu6g0TcNcfHEqAnLD1QP3gsi1">

<h1 id="File类的使用"><a href="#File类的使用" class="headerlink" title="File类的使用"></a><code>File</code>类的使用</h1><ul>
<li><code>File</code>类用来代表文件和文件夹</li>
<li>主要作用有两个：<ul>
<li>获取文件或者文件加的属性</li>
<li>实现对文件、文件夹的创建和删除</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">file.isFile()</td>
<td align="center">是否是文件</td>
</tr>
<tr>
<td align="center">file.isDirectory()</td>
<td align="center">是否是目录</td>
</tr>
<tr>
<td align="center">file.exists()</td>
<td align="center">是否存在</td>
</tr>
<tr>
<td align="center">file.length()</td>
<td align="center">文件大小（字节）</td>
</tr>
<tr>
<td align="center">file.lastModified()</td>
<td align="center">最后修改时间（毫秒值）</td>
</tr>
<tr>
<td align="center">file.canRead()</td>
<td align="center">是否可读</td>
</tr>
<tr>
<td align="center">file.canWrite()</td>
<td align="center">是否可写</td>
</tr>
<tr>
<td align="center">file.canExecute()</td>
<td align="center">是否可执行</td>
</tr>
<tr>
<td align="center">file.getPath()</td>
<td align="center">获取文件全路径</td>
</tr>
<tr>
<td align="center">file.getParent()</td>
<td align="center">获取文件父级目录</td>
</tr>
<tr>
<td align="center">file.getParentFile()</td>
<td align="center">获取父级文件</td>
</tr>
<tr>
<td align="center">file.getAbsolutePath()</td>
<td align="center">返回全路径</td>
</tr>
<tr>
<td align="center">file.mkdir()</td>
<td align="center">创建一级目录</td>
</tr>
<tr>
<td align="center">file.mkdirs()</td>
<td align="center">创建多级目录</td>
</tr>
<tr>
<td align="center">file.createNewFile()</td>
<td align="center">创建新文件</td>
</tr>
<tr>
<td align="center">file.getName()</td>
<td align="center">获取文件名称</td>
</tr>
<tr>
<td align="center">file.list()</td>
<td align="center">获取文件夹内文件的名称集合</td>
</tr>
<tr>
<td align="center">file.listFiles()</td>
<td align="center">获取文件夹内文件的集合</td>
</tr>
<tr>
<td align="center">file.delete()</td>
<td align="center">删除文件</td>
</tr>
</tbody></table>
<h1 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h1><h2 id="文件字节流FileInputStream和FileOutPutStream"><a href="#文件字节流FileInputStream和FileOutPutStream" class="headerlink" title="文件字节流FileInputStream和FileOutPutStream"></a>文件字节流<code>FileInputStream</code>和<code>FileOutPutStream</code></h2><ul>
<li><code>FileInputStream</code>和<code>FileOutPutStream</code>是字节流，数据源和目的地是文件</li>
<li>实现复制文件的功能<ul>
<li>复制文件需要分别创建一个输入流和输出流完成文件读写</li>
<li>需要创建一个中转站，借助循环和中转站完成复制</li>
<li>流使用完毕一定要关闭，这和垃圾回收没有关系<br>代码如下<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCopyFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;E:\\壁纸.zip&quot;</span>);</span><br><span class="line">             FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;E:\\壁纸2.zip&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> ((len = fis.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                fos.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="文件字符流FileReader和FileWriter"><a href="#文件字符流FileReader和FileWriter" class="headerlink" title="文件字符流FileReader和FileWriter"></a>文件字符流<code>FileReader</code>和<code>FileWriter</code></h2><ul>
<li><code>FileReader</code>和<code>FileWriter</code>是字符流，数据源和目的地是文件</li>
<li>实现复制文件的功能，代码如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCopyFile1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> ( Reader rd = <span class="keyword">new</span> FileReader(<span class="string">&quot;E:\\readme.txt&quot;</span>);</span><br><span class="line">              Writer wt = <span class="keyword">new</span> FileWriter(<span class="string">&quot;E:\\readme2.txt&quot;</span>);)&#123;</span><br><span class="line">            <span class="keyword">char</span>[] chars= <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> ((len = rd.read(chars)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                wt.write(chars,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其实只有字节流，没有字符流。字符流的底层还是字节流，进行了封装转换可以更简单的来处理非英文字符<br>字节流可以完成所有类型文件的复制（文本、音频、视频、图片、chm），字符流只能完成文本的复制（txt），doc不是文本文件，字符流一般只用来操作普通的文本文件</p>
</blockquote>
</li>
</ul>
<h1 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h1><h2 id="缓冲字节流BufferedInputStream和BufferedOutPutStream"><a href="#缓冲字节流BufferedInputStream和BufferedOutPutStream" class="headerlink" title="缓冲字节流BufferedInputStream和BufferedOutPutStream"></a>缓冲字节流<code>BufferedInputStream</code>和<code>BufferedOutPutStream</code></h2><ul>
<li>原理是在内存中创建一个缓冲区，默认大小是<code>8192</code>字节，输入流每次去缓冲区中获取，如果缓存区为空，会去磁盘一次读取8192字节，然后再根据自定义的中转站大小向输出流中转</li>
<li>输出流也是默认创建一个8192的缓存区，等缓冲区满了或者最后关毕流的时候会一次性写入磁盘，减少于磁盘的交互，提升性能  </li>
<li>代码如下所示  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCopyFile2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;E:\\照片.zip&quot;</span>));</span><br><span class="line">             BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;E:\\照片2.zip&quot;</span>)))&#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> ((len = bis.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                bos.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="缓冲字符流BufferedReader和BufferedWriter"><a href="#缓冲字符流BufferedReader和BufferedWriter" class="headerlink" title="缓冲字符流BufferedReader和BufferedWriter"></a>缓冲字符流<code>BufferedReader</code>和<code>BufferedWriter</code></h2><ul>
<li>实现一次读取一行</li>
<li>需要注意换行符问题<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCopyFile3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;E:\\readme.txt&quot;</span>));</span><br><span class="line">             BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;E:\\readme2.txt&quot;</span>)))&#123;</span><br><span class="line">             String str;</span><br><span class="line">             <span class="keyword">while</span> ((str = br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                 bw.write(str);</span><br><span class="line">                 bw.newLine();</span><br><span class="line">             &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="数据流和对象流"><a href="#数据流和对象流" class="headerlink" title="数据流和对象流"></a>数据流和对象流</h1><blockquote>
<p>之前使用文件流、缓冲流读取文件只能按照字节、数组方式读取，最方便的也是按行读取，能否很方便的实现各种基本类型和引用类型数据的读写，并保留其本身的类型。<br>数据流<code>DataInputStream</code>和<code>DataOutPutStream</code>和对象流<code>ObjectInputStream</code>和<code>ObjectOutPutStream</code>可以解决这个问题，最大的优势就是提供了方便操作各种数据类型的方法，直接调用，简单方便</p>
</blockquote>
<p>注意：</p>
<ul>
<li>只有字节流，没有字符流</li>
<li>都是处理流，不是节点流</li>
<li>数据流只能操作基本类型和字符串，对象流还可以操作对象</li>
<li>写入的是二进制数据，无法直接通过记事本等查看</li>
<li>写入的数据需要使用对应的输入输出流来读取</li>
</ul>
<h2 id="数据流DataInputStream和DataOutPutStream"><a href="#数据流DataInputStream和DataOutPutStream" class="headerlink" title="数据流DataInputStream和DataOutPutStream"></a>数据流<code>DataInputStream</code>和<code>DataOutPutStream</code></h2><ul>
<li><code>DataInputStream</code>和<code>DataOutPutStream</code>只能读取基本数据类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        writer();</span></span><br><span class="line">        reader();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;E:\\readme.txt&quot;</span>)));)&#123;</span><br><span class="line">            dos.writeInt(<span class="number">10</span>);</span><br><span class="line">            dos.writeBoolean(<span class="keyword">true</span>);</span><br><span class="line">            dos.writeUTF(<span class="string">&quot;今天的天气还是不错的&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (DataInputStream dis = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;E:\\readme.txt&quot;</span>)));)&#123;</span><br><span class="line">            System.out.println(dis.readInt());</span><br><span class="line">            System.out.println(dis.readBoolean());</span><br><span class="line">            System.out.println(dis.readUTF());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对象流ObjectInputStream和ObjectOutPutStream"><a href="#对象流ObjectInputStream和ObjectOutPutStream" class="headerlink" title="对象流ObjectInputStream和ObjectOutPutStream"></a>对象流<code>ObjectInputStream</code>和<code>ObjectOutPutStream</code></h2><ul>
<li>可以读写基本数据类型和引用数据类型</li>
<li>包含<code>DataInputStream</code>和<code>DataOutPutStream</code>的所有功能</li>
<li>想要写入的对象类必须实现<code>Serializable</code>序列化接口<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        writer();</span></span><br><span class="line">        reader();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;E:\\readme.txt&quot;</span>)));)&#123;</span><br><span class="line">            oos.writeInt(<span class="number">10</span>);</span><br><span class="line">            oos.writeBoolean(<span class="keyword">true</span>);</span><br><span class="line">            oos.writeUTF(<span class="string">&quot;今天的天气还是不错的&quot;</span>);</span><br><span class="line">            oos.writeObject(<span class="keyword">new</span> Date());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;E:\\readme.txt&quot;</span>)));)&#123;</span><br><span class="line">            System.out.println(ois.readInt());</span><br><span class="line">            System.out.println(ois.readBoolean());</span><br><span class="line">            System.out.println(ois.readUTF());</span><br><span class="line">            System.out.println(((Date)ois.readObject()).toLocaleString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h2><h3 id="什么是序列化和反序列化"><a href="#什么是序列化和反序列化" class="headerlink" title="什么是序列化和反序列化"></a>什么是序列化和反序列化</h3><ul>
<li>序列化：<code>Serialization</code>，将对象的状态信息转换为可以存储或者传输的形式的过程<ul>
<li>对象（内存）—&gt; 字节数组  字节序列（外存、网络）</li>
</ul>
</li>
<li>反序列化：<code>DeSerialization</code> 将字节数组转换成对象<ul>
<li>字节数组 字节序列（外存、网络）—–&gt; 对象（内存）</li>
</ul>
</li>
</ul>
<h3 id="什么时候需要序列化和反序列化"><a href="#什么时候需要序列化和反序列化" class="headerlink" title="什么时候需要序列化和反序列化"></a>什么时候需要序列化和反序列化</h3><ul>
<li>存储或传输 比如存储到外存（硬盘）中，传输到网络</li>
</ul>
<h3 id="如何实现序列化和反序列化"><a href="#如何实现序列化和反序列化" class="headerlink" title="如何实现序列化和反序列化"></a>如何实现序列化和反序列化</h3><ul>
<li>相应的类要实现<code>Serializable</code>接口</li>
<li>静态变量是不参与序列化的</li>
<li>用 transient 关键字修饰的字段也不参与序列化</li>
</ul>
<h1 id="其他流"><a href="#其他流" class="headerlink" title="其他流"></a>其他流</h1><h2 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h2><ul>
<li><code>PrintStream</code>和<code>PrintWriter</code></li>
<li>只有输入流，没有输出流</li>
<li><code>System.out</code>、<code>System.err</code>是<code>PrintStream</code>的实例变量</li>
<li>代码如下所示: <code>System.out.println()</code>就是使用<code>PrintStream</code>做的打印<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintStreamTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (PrintStream ps = <span class="keyword">new</span> PrintStream(<span class="string">&quot;E:\\readme.txt&quot;</span>))&#123;</span><br><span class="line">            ps.println(<span class="number">12</span>);</span><br><span class="line">            ps.println(<span class="number">2.3</span>);</span><br><span class="line">            ps.println(<span class="keyword">true</span>);</span><br><span class="line">            ps.println(<span class="string">&quot;今天天气不错啊&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><ul>
<li>InputStreamReader和OutputStreamWriter</li>
<li>实现字节流到字符流的转换，是适配器设计模式的应用</li>
<li>只能从字节流转成字符流，可以带来处理字符的便利，没有字符流转换成字节流的转换流，因为没有这种需求</li>
<li>将字节流转换成字符流，实现从键盘输入保存到文件  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCopyFile4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">             PrintStream bw = <span class="keyword">new</span> PrintStream(<span class="string">&quot;E:\\readme2.txt&quot;</span>))&#123;</span><br><span class="line">             String str;</span><br><span class="line">             <span class="keyword">while</span> (!<span class="string">&quot;bye&quot;</span>.equals(str = br.readLine()))&#123;</span><br><span class="line">                 bw.println(str);</span><br><span class="line">             &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="字节数组流"><a href="#字节数组流" class="headerlink" title="字节数组流"></a>字节数组流</h2><ul>
<li><code>ByteArrayInputStream</code>和<code>ByteArrayOutPutStream</code></li>
<li>是节点流，数据源是字节数组，可以实现各种基本和引用数据类型与字节数组之间的相互转换</li>
</ul>
<p>Java IO流的设计使用了装饰模式，动态组装流 ，可以减少子类的数量，是继承的一种替代方案</p>
<h1 id="XML，可扩展标记语言"><a href="#XML，可扩展标记语言" class="headerlink" title="XML，可扩展标记语言"></a>XML，可扩展标记语言</h1><ul>
<li><p>XML，Extensible Markup Language(可扩展标记语言)，由SGML语言发展而来，允许用户自定义标签，可以将标签和内容有效分离。它主键演变成为一种跨平台的数据交互格式（一种在不同平台、不同系统之间的数据交换格式），一种轻量级的持久化方案（保存简单数据，无需使用数据库）</p>
</li>
<li><p>XML只是纯文本，只是一种独立于软件、硬件的数据存储和传输攻击，它可以对外提供一些信息，但由于C、Java这些编程语言不同，XML无法提供任何“动态行为”。</p>
</li>
<li><p>和HTML提供预定义标签不同，开发者可以自定义任务标签，因此具有很强的扩张性，不同于HTML侧重于数据的展示，XML更加关注数据的存储和传输，不同于HTML可以使用浏览器来解析并显示，XML需要自行编写软件或程序，才能传递、接收、显示这个文档</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">students</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">student</span> <span class="attr">id</span> = <span class="string">&quot;001&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>23<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">score</span>&gt;</span>98<span class="tag">&lt;/<span class="name">score</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">student</span> <span class="attr">id</span>=<span class="string">&quot;002&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>24<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">score</span>&gt;</span>96<span class="tag">&lt;/<span class="name">score</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">students</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="一个XML文件分为如下几个部分"><a href="#一个XML文件分为如下几个部分" class="headerlink" title="一个XML文件分为如下几个部分"></a>一个XML文件分为如下几个部分</h2></li>
<li><p>文档声明</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>元素</p>
<blockquote>
<p><code>&lt;name&gt;</code>称为开始标签，<code>&lt;/name&gt;</code>称为结束标签，”李四“表示标签的内容。<br>开始标签、内容、结束标签组合成元素。元素是XML文档的主要部分，元素内容可以是普通文本，也可以是子元素，比如<code>student</code>元素的内部就是有多个子标签<br>一个XML文档有且仅有一个根元素，比如<code>students</code></p>
</blockquote>
</li>
<li><p>属性</p>
<blockquote>
<p>元素<code>&lt;student id=&quot;001&quot;&gt;</code>中的id就是属性名，001是属性值，属性值要使用双引号括起来，属性加载一个元素的开始开始标签上，用来对元素进行描述<br>一个元素可以有多个属性，空格隔开<br>属性没有先后顺序，同一个XML元素不允许有同名属性</p>
</blockquote>
</li>
<li><p>注释</p>
<blockquote>
<p><code>&lt;!-- 学生信息 --&gt;</code><br>对XML内容进行解释说明的文字</p>
</blockquote>
</li>
<li><p>CDATA标记、字符实体</p>
<blockquote>
<p>有时元素文本中会有一些特殊字符，比如<code>&lt;、&gt;、&quot;、&amp;</code>等，这些字符在XML文档结构本身中已经用到了，此时主要通过两种办法，实现正确解释这些特殊字符<br>方法1，个别的特殊字符，可以使用字符实体替换</p>
</blockquote>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">字符实体</th>
<th align="center">特殊字符</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>&amp;lt;</code></td>
<td align="center"><code>&lt;</code></td>
<td align="center">小于</td>
</tr>
<tr>
<td align="center"><code>&amp;gt;</code></td>
<td align="center"><code>&gt;</code></td>
<td align="center">大于</td>
</tr>
<tr>
<td align="center"><code>&amp;amp;</code></td>
<td align="center"><code>&amp;</code></td>
<td align="center">和号</td>
</tr>
<tr>
<td align="center"><code>&amp;apos;</code></td>
<td align="center"><code>&#39;</code></td>
<td align="center">单引号</td>
</tr>
<tr>
<td align="center"><code>&amp;aqot;</code></td>
<td align="center"><code>&quot;</code></td>
<td align="center">双引号</td>
</tr>
</tbody></table>
<blockquote>
<p>严格地讲，在XML中仅有字符<code>&lt;</code>和<code>&amp;</code>是非法的，单引号、双引号和大于号是合法的，但是把它们替换成实体引用是个好习惯<br>方法2，大量特殊字符可以使用CDATA标记来处理<br>CDATA标记中的所有字符都会被当作普通字符来处理，而不是XML标签<br>CDATA标记语法<br><code>&lt;!CDATA[[要显示的字符]]&gt;</code></p>
</blockquote>
<h2 id="格式良好的XML文档，遵循XML文档的基本规则"><a href="#格式良好的XML文档，遵循XML文档的基本规则" class="headerlink" title="格式良好的XML文档，遵循XML文档的基本规则"></a>格式良好的XML文档，遵循XML文档的基本规则</h2><ul>
<li>元素正确嵌套</li>
<li>XML文件的第一行必须是xml声明</li>
<li>XML文件只能有一个根节点</li>
<li>英文字符的大小写是有差异的</li>
<li>开始的控制标记与结束的控制标记缺一不可</li>
<li>属性值的设置必须被双引号包围起来</li>
</ul>
<h2 id="有效的XML文档"><a href="#有效的XML文档" class="headerlink" title="有效的XML文档"></a>有效的XML文档</h2><ul>
<li>首先必须是格式良好的（语法约束）</li>
<li>使用DTD和XSD（XML Scheme）定义语义约束</li>
</ul>
<h2 id="内部DTD"><a href="#内部DTD" class="headerlink" title="内部DTD"></a>内部DTD</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">students</span>[</span></span><br><span class="line"><span class="meta">        <span class="meta">&lt;!ELEMENT <span class="meta-keyword">students</span> (<span class="meta-keyword">student</span>+)&gt;</span></span></span><br><span class="line"><span class="meta">        <span class="meta">&lt;!ELEMENT <span class="meta-keyword">student</span> (<span class="meta-keyword">name</span>,<span class="meta-keyword">age</span>,<span class="meta-keyword">score</span>)&gt;</span></span></span><br><span class="line"><span class="meta">        <span class="meta">&lt;!ATTLIST <span class="meta-keyword">student</span> <span class="meta-keyword">id</span> <span class="meta-keyword">CDATA</span> <span class="meta-keyword">#REQUIRED</span>&gt;</span></span></span><br><span class="line"><span class="meta">        <span class="meta">&lt;!ELEMENT <span class="meta-keyword">name</span> (<span class="meta-keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">        <span class="meta">&lt;!ELEMENT <span class="meta-keyword">age</span> (<span class="meta-keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">        <span class="meta">&lt;!ELEMENT <span class="meta-keyword">score</span> (<span class="meta-keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">        ]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">students</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">student</span> <span class="attr">id</span>=<span class="string">&quot;001&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>23<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">score</span>&gt;</span>98<span class="tag">&lt;/<span class="name">score</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">student</span> <span class="attr">id</span>=<span class="string">&quot;002&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>24<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">score</span>&gt;</span>96<span class="tag">&lt;/<span class="name">score</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">students</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="外部DTD"><a href="#外部DTD" class="headerlink" title="外部DTD"></a>外部DTD</h2><p>新建一个dtd文件，将内容复制进去<br>student.dtd</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ELEMENT students (student+)&gt;</span><br><span class="line">&lt;!ELEMENT student (name|age|score)+&gt;</span><br><span class="line">&lt;!ATTLIST student id CDATA #REQUIRED&gt;</span><br><span class="line">&lt;!ELEMENT name (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT age (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT score (#PCDATA)&gt;</span><br></pre></td></tr></table></figure>
<p>在xml中引用<br><code>&lt;!DOCTYPE 根元素 SYSTEM &quot;外部DTD文件路径&quot;&gt;</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">students</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;student.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">students</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">student</span> <span class="attr">id</span>=<span class="string">&quot;001&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>23<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">score</span>&gt;</span>98<span class="tag">&lt;/<span class="name">score</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">student</span> <span class="attr">id</span>=<span class="string">&quot;002&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>24<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">score</span>&gt;</span>96<span class="tag">&lt;/<span class="name">score</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">students</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="公用DTD"><a href="#公用DTD" class="headerlink" title="公用DTD"></a>公用DTD</h2><ul>
<li>其实也算一种外部DTD，是有某个权威机构定制的，供特定行业或者公众使用</li>
<li>公用DTD用过PUBLIC关键字引入，而不是SYSTEM</li>
<li>另外还要再增加一个标识名</li>
<li><code>&lt;!DOCTYPE 跟元素 PUBLIC &quot;DTD标识名&quot; &quot;公用DTD的URI&quot;&gt;</code></li>
</ul>
<h1 id="DOM解析XML"><a href="#DOM解析XML" class="headerlink" title="DOM解析XML"></a>DOM解析XML</h1><h2 id="XML解析的四种方式"><a href="#XML解析的四种方式" class="headerlink" title="XML解析的四种方式"></a>XML解析的四种方式</h2><ul>
<li>DOM和SAX是XML解析的两种规范，目前主流的XML解析器都会为DOM和SAX提供实现</li>
<li>使用这两种技术解析XML比较繁琐，代码冗长，可读性也不高</li>
<li>所以Java领域中又出现了两个开源XML解析器：DOM4J和JDOM</li>
<li>其中DOM4J是面向接口编程</li>
<li>而JDOM是面向实现编程</li>
<li>DOM4J比JDOM更灵活，性能表现也比较优异</li>
<li>DOM<ul>
<li>基于XML树结构</li>
<li>比较耗资源</li>
<li>适用于多次访问XML</li>
</ul>
</li>
<li>SAX<ul>
<li>基于事件</li>
<li>耗资源小</li>
<li>适用于数据量比较大的XML</li>
</ul>
</li>
<li>JDOM<ul>
<li>比DOM更快</li>
<li>JDOM仅使用具体类而不使用接口</li>
</ul>
</li>
<li>DOM4J<ul>
<li>非常优秀的Java XML API </li>
<li>性能优异</li>
<li>功能强大</li>
<li>开放源码</li>
</ul>
</li>
</ul>
<h2 id="DOM：Document-Object-Model-文档对象模型"><a href="#DOM：Document-Object-Model-文档对象模型" class="headerlink" title="DOM：Document Object Model 文档对象模型"></a>DOM：Document Object Model 文档对象模型</h2><p>使用该技术解析XML文档时，会根据要操作的文档，构建一颗驻留内存中的树，然后就可以使用DOM接口来操作这棵树。<br>由于树是驻留再内存中，所以非常方便各种操作。<br>但是也因为这棵树包含了XML文档的所有内容，是比较耗费资源的，该方式适合小文档的解析、适合多次访问的文档的解析</p>
<h2 id="SAX：Simple-API-for-XML"><a href="#SAX：Simple-API-for-XML" class="headerlink" title="SAX：Simple API for XML"></a>SAX：Simple API for XML</h2><p>是基于事件的解析，它是为了解决DOM解析的资源耗费而出现的。<br>SAX在解析一份XML文档时，会以次发出文档开始、元素开始、元素结束、文档结束等事件。<br>该方式不需要是事先调入整个文档，优势是占用资源少，内存耗费小，一般在解析数据量比较大的文档时采用该方式。</p>
<h2 id="DOM4J：DOM-for-JAVA"><a href="#DOM4J：DOM-for-JAVA" class="headerlink" title="DOM4J：DOM for JAVA"></a>DOM4J：DOM for JAVA</h2><p>开源XML解析工具，完全支持DOM、SAX机制，具有性能优异、功能强大和操作简单等特点。越来越多的Java软件都在使用DOM4J处理XML</p>
<h2 id="JDOM：Java-DOM"><a href="#JDOM：Java-DOM" class="headerlink" title="JDOM：Java DOM"></a>JDOM：Java DOM</h2><p>JDOM的目的是成为Java特定义文档模型。<br>行至半路，一部分人产生了新的想法，而这些想法又无法在JDOM中实现，干脆就从该项目中分离出来，单独取开发另外一套专属的XML API，这就是DOM4J。<br>因此，两者具有相同的设计目的，用法也非常相似。<br>从组中解决来看，JDOM的主要API以类为主，DOM4J的API以接口为主。</p>
<h2 id="使用DOM解析XML"><a href="#使用DOM解析XML" class="headerlink" title="使用DOM解析XML"></a>使用DOM解析XML</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDOM</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParserConfigurationException, IOException, SAXException </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建DOM解析器工厂</span></span><br><span class="line">        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span><br><span class="line">        <span class="comment">//2.由DOM解析器工厂创建DOM解析器</span></span><br><span class="line">        DocumentBuilder db = dbf.newDocumentBuilder();</span><br><span class="line">        <span class="comment">//3.由DOM解析器解析文档，生成DOM树</span></span><br><span class="line">        Document doc = db.parse(<span class="string">&quot;E:\\project\\java\\leetcode\\src\\main\\java\\com\\ys\\io\\xml\\student.xml&quot;</span>);</span><br><span class="line">        NodeList nodeList = doc.getElementsByTagName(<span class="string">&quot;students&quot;</span>);</span><br><span class="line">        Element root = (Element)nodeList.item(<span class="number">0</span>);</span><br><span class="line">        NodeList students = root.getElementsByTagName(<span class="string">&quot;student&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; students.getLength(); i++) &#123;</span><br><span class="line">            Element item = (Element)students.item(i);</span><br><span class="line">            String id = item.getAttribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">            System.out.println(id);</span><br><span class="line">            NodeList childNodes = item.getChildNodes();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; childNodes.getLength(); j++) &#123;</span><br><span class="line">                Node node = childNodes.item(j);</span><br><span class="line">                <span class="keyword">if</span> (node.getNodeType() == Node.ELEMENT_NODE)&#123;</span><br><span class="line">                    Element element = (Element)node;</span><br><span class="line">                    System.out.println(element.getNodeName()+<span class="string">&quot;---&gt;&quot;</span>+element.getTextContent());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缺点：  </p>
<ul>
<li>前面三个步骤，每次都要书写一遍，能否封装好</li>
<li><code>getChildNodes()</code>不仅包括<code>Element</code>，也包括空白形成的<code>Text</code>，遍历时需要进行筛选</li>
<li><code>getChildNodes()</code>也包括注释，也包括外部<code>DTD</code>引用，大部分情况下并不是用户需要的</li>
</ul>
<h2 id="使用DOM4J解析XML"><a href="#使用DOM4J解析XML" class="headerlink" title="使用DOM4J解析XML"></a>使用DOM4J解析XML</h2><table>
<thead>
<tr>
<th align="center">Attribute</th>
<th align="center">定义了XML的属性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Node</td>
<td align="center">DOM4J树中所有节点的根接口</td>
</tr>
<tr>
<td align="center">Branch</td>
<td align="center">指包含子节点的节点，如元素（Element）和文档（Docuemnts）</td>
</tr>
<tr>
<td align="center">Document</td>
<td align="center">代表XML文档</td>
</tr>
<tr>
<td align="center">Element</td>
<td align="center">代表XML元素</td>
</tr>
<tr>
<td align="center">CharacterData</td>
<td align="center">所有文本元素的父接口，如CDATA、Comment、Text</td>
</tr>
<tr>
<td align="center">CDATA</td>
<td align="center">代表XML CDATA区域</td>
</tr>
<tr>
<td align="center">Comment</td>
<td align="center">代表XML注释内容</td>
</tr>
<tr>
<td align="center">DocumentType</td>
<td align="center">代表XML DOCTYPE声明</td>
</tr>
<tr>
<td align="center">processingInstruction</td>
<td align="center">代表XML处理指令</td>
</tr>
<tr>
<td align="center">Attribute</td>
<td align="center">代表XML元素的属性</td>
</tr>
</tbody></table>
<p>添加DOM4J的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>dom4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dom4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="DOM4J解析XML代码如下"><a href="#DOM4J解析XML代码如下" class="headerlink" title="DOM4J解析XML代码如下"></a>DOM4J解析XML代码如下</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDom4j1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> DocumentException </span>&#123;</span><br><span class="line">        <span class="comment">//1.根据XML文档创建DOM4J树</span></span><br><span class="line">        SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;E:\\project\\java\\leetcode\\src\\main\\java\\com\\ys\\io\\xml\\student.xml&quot;</span>);</span><br><span class="line">        Document document = reader.read(file);</span><br><span class="line">        <span class="comment">//2.获取DOM4j树的跟节点students</span></span><br><span class="line">        Element rootElement = document.getRootElement();</span><br><span class="line">        <span class="comment">//3.获取students的子节点student</span></span><br><span class="line">        <span class="comment">//List&lt;Element&gt; elements = rootElement.elements();</span></span><br><span class="line">        Iterator&lt;Element&gt; it = rootElement.elementIterator();</span><br><span class="line">        <span class="comment">//4.对student的属性和子节点进行解析</span></span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            Element next = it.next();</span><br><span class="line"><span class="comment">//            Attribute id = next.attribute(&quot;id&quot;);</span></span><br><span class="line"><span class="comment">//            System.out.println(id.getName()+&quot;--&gt;&quot;+id.getValue());</span></span><br><span class="line">            Iterator&lt;Attribute&gt; it2 = next.attributeIterator();</span><br><span class="line">            <span class="keyword">while</span> (it2.hasNext()) &#123;</span><br><span class="line">                Attribute attribute = it2.next();</span><br><span class="line">                System.out.println(attribute.getName() + <span class="string">&quot;--&gt;&quot;</span> + attribute.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;Element&gt; elements = next.elements();</span><br><span class="line">            <span class="keyword">for</span> (Element element : elements) &#123;</span><br><span class="line">                System.out.println(element.getName()+<span class="string">&quot;---&gt;&quot;</span>+element.getStringValue());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DOM4J创建XML代码如下"><a href="#DOM4J创建XML代码如下" class="headerlink" title="DOM4J创建XML代码如下"></a>DOM4J创建XML代码如下</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDom4j2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建一个DocumentFactory对象</span></span><br><span class="line">        <span class="comment">//DocumentFactory factory = new DocumentFactory();</span></span><br><span class="line">        <span class="comment">//2.使用DocumentFactory创建Document</span></span><br><span class="line">        <span class="comment">//Document document = factory.createDocument();</span></span><br><span class="line">        Document document = DocumentHelper.createDocument();</span><br><span class="line">        document.addComment(<span class="string">&quot;学生信息&quot;</span>);</span><br><span class="line">        <span class="comment">//3.给Document指定一个跟节点students</span></span><br><span class="line">        Element rootElement = document.addElement(<span class="string">&quot;students&quot;</span>);</span><br><span class="line">        <span class="comment">//4.给students添加一个子节点student</span></span><br><span class="line">        Element element = rootElement.addElement(<span class="string">&quot;student&quot;</span>);</span><br><span class="line">        <span class="comment">//5.给student节点添加一个属性节点：id</span></span><br><span class="line">        element.addAttribute(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;001&quot;</span>);</span><br><span class="line">        <span class="comment">//6.给student节点添加子节点：name age  score</span></span><br><span class="line">        Element name = element.addElement(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        name.addText(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        Element age = element.addElement(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        age.addText(<span class="string">&quot;25&quot;</span>);</span><br><span class="line">        Element score = element.addElement(<span class="string">&quot;score&quot;</span>);</span><br><span class="line">        score.addText(<span class="string">&quot;98.5&quot;</span>);</span><br><span class="line">        <span class="comment">//7.将上面的DOM4J树写入文件</span></span><br><span class="line">        <span class="comment">//默认写入的xml内容是不换行的，没有格式，可以创建一个格式</span></span><br><span class="line">        OutputFormat format = OutputFormat.createPrettyPrint();</span><br><span class="line">        Writer writer = <span class="keyword">new</span> FileWriter(<span class="string">&quot;E:\\project\\java\\leetcode\\src\\main\\java\\com\\ys\\io\\xml\\student1.xml&quot;</span>);</span><br><span class="line">        XMLWriter xmlWriter = <span class="keyword">new</span> XMLWriter(writer,format);</span><br><span class="line">        xmlWriter.write(document);</span><br><span class="line">        xmlWriter.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DOM4J修改XML代码如下"><a href="#DOM4J修改XML代码如下" class="headerlink" title="DOM4J修改XML代码如下"></a>DOM4J修改XML代码如下</h3><p>在XML末尾添加子节点，默认就是在末尾添加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDom4j3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> DocumentException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.根据XML文档创建DOM4J树</span></span><br><span class="line">        SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;E:\\project\\java\\leetcode\\src\\main\\java\\com\\ys\\io\\xml\\student1.xml&quot;</span>);</span><br><span class="line">        Document document = reader.read(file);</span><br><span class="line">        <span class="comment">//2.获取根节点</span></span><br><span class="line">        Element rootElement = document.getRootElement();</span><br><span class="line">        <span class="comment">//3.给students添加一个子节点student</span></span><br><span class="line">        Element element = rootElement.addElement(<span class="string">&quot;student&quot;</span>);</span><br><span class="line">        <span class="comment">//4.给student节点添加一个属性节点：id</span></span><br><span class="line">        element.addAttribute(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;002&quot;</span>);</span><br><span class="line">        <span class="comment">//5.给student节点添加子节点：name age  score</span></span><br><span class="line">        Element name = element.addElement(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        name.addText(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        Element age = element.addElement(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        age.addText(<span class="string">&quot;56&quot;</span>);</span><br><span class="line">        Element score = element.addElement(<span class="string">&quot;score&quot;</span>);</span><br><span class="line">        score.addText(<span class="string">&quot;99.5&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7.将上面的DOM4J树写入文件</span></span><br><span class="line">        <span class="comment">//默认写入的xml内容是不换行的，没有格式，可以创建一个格式</span></span><br><span class="line">        OutputFormat format = OutputFormat.createPrettyPrint();</span><br><span class="line">        Writer writer = <span class="keyword">new</span> FileWriter(<span class="string">&quot;E:\\project\\java\\leetcode\\src\\main\\java\\com\\ys\\io\\xml\\student1.xml&quot;</span>);</span><br><span class="line">        XMLWriter xmlWriter = <span class="keyword">new</span> XMLWriter(writer,format);</span><br><span class="line">        xmlWriter.write(document);</span><br><span class="line">        xmlWriter.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在XML中间插入节点  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDom4j4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> DocumentException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.根据XML文档创建DOM4J树</span></span><br><span class="line">        SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;E:\\project\\java\\leetcode\\src\\main\\java\\com\\ys\\io\\xml\\student1.xml&quot;</span>);</span><br><span class="line">        Document document = reader.read(file);</span><br><span class="line">        <span class="comment">//2.获取根节点</span></span><br><span class="line">        Element rootElement = document.getRootElement();</span><br><span class="line">        <span class="comment">//获取根节点的所有子节点</span></span><br><span class="line">        List elements = rootElement.elements();</span><br><span class="line">        <span class="comment">//3.新建一个子节点</span></span><br><span class="line">        Element element = DocumentHelper.createElement(<span class="string">&quot;student&quot;</span>);</span><br><span class="line">        <span class="comment">//4.给student节点添加一个属性节点：id</span></span><br><span class="line">        element.addAttribute(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;003&quot;</span>);</span><br><span class="line">        <span class="comment">//5.给student节点添加子节点：name age  score</span></span><br><span class="line">        Element name = element.addElement(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        name.addText(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        Element age = element.addElement(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        age.addText(<span class="string">&quot;78&quot;</span>);</span><br><span class="line">        Element score = element.addElement(<span class="string">&quot;score&quot;</span>);</span><br><span class="line">        score.addText(<span class="string">&quot;55.5&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将新新建的子节点写入到节点树中</span></span><br><span class="line">        elements.add(<span class="number">1</span>,element);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7.将上面的DOM4J树写入文件</span></span><br><span class="line">        <span class="comment">//默认写入的xml内容是不换行的，没有格式，可以创建一个格式</span></span><br><span class="line">        OutputFormat format = OutputFormat.createPrettyPrint();</span><br><span class="line">        Writer writer = <span class="keyword">new</span> FileWriter(<span class="string">&quot;E:\\project\\java\\leetcode\\src\\main\\java\\com\\ys\\io\\xml\\student1.xml&quot;</span>);</span><br><span class="line">        XMLWriter xmlWriter = <span class="keyword">new</span> XMLWriter(writer,format);</span><br><span class="line">        xmlWriter.write(document);</span><br><span class="line">        xmlWriter.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据条件删除某一个元素   </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDom4j5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> DocumentException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">//1.根据XML文档创建DOM4J树</span></span><br><span class="line">    SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">&quot;E:\\project\\java\\leetcode\\src\\main\\java\\com\\ys\\io\\xml\\student1.xml&quot;</span>);</span><br><span class="line">    Document document = reader.read(file);</span><br><span class="line">    <span class="comment">//2.获取根节点</span></span><br><span class="line">    Element rootElement = document.getRootElement();</span><br><span class="line">    <span class="comment">//获取根节点的所有子节点</span></span><br><span class="line">    List&lt;Element&gt; elements = rootElement.elements();</span><br><span class="line">    <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; elements.size(); i++) &#123;</span><br><span class="line">      String id = elements.get(i).attribute(<span class="string">&quot;id&quot;</span>).getValue();</span><br><span class="line">      <span class="keyword">if</span> (<span class="string">&quot;003&quot;</span>.equals(id)) &#123;</span><br><span class="line">        index = i;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (index == -<span class="number">1</span>) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;没有找到需要删除的元素&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      elements.remove(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//7.将上面的DOM4J树写入文件</span></span><br><span class="line">    <span class="comment">//默认写入的xml内容是不换行的，没有格式，可以创建一个格式</span></span><br><span class="line">    OutputFormat format = OutputFormat.createPrettyPrint();</span><br><span class="line">    Writer writer = <span class="keyword">new</span> FileWriter(<span class="string">&quot;E:\\project\\java\\leetcode\\src\\main\\java\\com\\ys\\io\\xml\\student1.xml&quot;</span>);</span><br><span class="line">    XMLWriter xmlWriter = <span class="keyword">new</span> XMLWriter(writer, format);</span><br><span class="line">    xmlWriter.write(document);</span><br><span class="line">    xmlWriter.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据条件修改某一个元素  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDom4j6</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> DocumentException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.根据XML文档创建DOM4J树</span></span><br><span class="line">        SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;E:\\project\\java\\leetcode\\src\\main\\java\\com\\ys\\io\\xml\\student1.xml&quot;</span>);</span><br><span class="line">        Document document = reader.read(file);</span><br><span class="line">        <span class="comment">//2.获取根节点</span></span><br><span class="line">        Element rootElement = document.getRootElement();</span><br><span class="line">        <span class="comment">//获取根节点的所有子节点</span></span><br><span class="line">        List&lt;Element&gt; elements = rootElement.elements();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; elements.size(); i++) &#123;</span><br><span class="line">            Element element = elements.get(i);</span><br><span class="line">            String id = element.attribute(<span class="string">&quot;id&quot;</span>).getValue();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;001&quot;</span>.equals(id))&#123;</span><br><span class="line">                element.attribute(<span class="string">&quot;id&quot;</span>).setValue(<span class="string">&quot;003&quot;</span>);</span><br><span class="line">                Element name = element.element(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                name.setText(<span class="string">&quot;天奇&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//7.将上面的DOM4J树写入文件</span></span><br><span class="line">        <span class="comment">//默认写入的xml内容是不换行的，没有格式，可以创建一个格式</span></span><br><span class="line">        OutputFormat format = OutputFormat.createPrettyPrint();</span><br><span class="line">        Writer writer = <span class="keyword">new</span> FileWriter(<span class="string">&quot;E:\\project\\java\\leetcode\\src\\main\\java\\com\\ys\\io\\xml\\student1.xml&quot;</span>);</span><br><span class="line">        XMLWriter xmlWriter = <span class="keyword">new</span> XMLWriter(writer,format);</span><br><span class="line">        xmlWriter.write(document);</span><br><span class="line">        xmlWriter.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven项目依赖管理</title>
    <url>/2021/06/12/maven/Maven%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>Maven:</strong> 一个用于自动化构建项目和管理项目依赖的工具<br><strong>自动化构建项目：</strong> 按照企业中主流的项目模板，创建完善的项目结构<br><strong>管理项目依赖：</strong> 配置式添加管理，自动下载和导入</p>
<h2 id="Maven环境配置"><a href="#Maven环境配置" class="headerlink" title="Maven环境配置"></a>Maven环境配置</h2><h3 id="Maven下载"><a href="#Maven下载" class="headerlink" title="Maven下载"></a>Maven下载</h3><p>Maven官网地址：<a href="http://maven.apache.org/">http://maven.apache.org</a></p>
<p><img src="/2021/06/12/maven/Maven%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/Maven%E5%AE%98%E7%BD%91%E5%9B%BE%E7%A4%BA.png" alt="Maven官网图示"><br>点击<code>Download</code>跳转Maven下载界面</p>
<p><img src="/2021/06/12/maven/Maven%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/Maven%E4%B8%8B%E8%BD%BD%E5%9B%BE%E7%A4%BA.png" alt="Maven下载图示"></p>
<h3 id="Maven环境变量配置"><a href="#Maven环境变量配置" class="headerlink" title="Maven环境变量配置"></a>Maven环境变量配置</h3><p>下载最新版zip即可，将下载后的zip包解压到本地任意文件夹下<br>然后打开maven解压后生成的文件夹，进入到bin目录下，复制路径地址</p>
<p><img src="/2021/06/12/maven/Maven%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/Maven%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E5%9B%BE%E7%A4%BA.png" alt="Maven环境变量配置图示"><br>如图所示，复制路径之后，右键我的电脑，点击属性 -&gt; 高级系统设置 -&gt; 环境变量 -&gt; Path -&gt; 新建<br>将复制的Maven路径黏贴到对应位置，点击确定关闭所有对话框</p>
<p>win+R快捷键，输入<code>cmd</code>打开Windows10命令行，输入：<code>mvn -version</code><br>注：一定要在保存环境变量后新打开的命令窗口输入，否则不生效；<br><img src="/2021/06/12/maven/Maven%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/Maven%E7%89%88%E6%9C%AC%E6%9F%A5%E7%9C%8B%E5%9B%BE%E7%A4%BA.png" alt="Maven版本查看图示"></p>
<h3 id="Maven本地仓库配置"><a href="#Maven本地仓库配置" class="headerlink" title="Maven本地仓库配置"></a>Maven本地仓库配置</h3><p>Maven下载jar包默认是下载到C盘用户目录下的.m2文件夹下的，会大量占用C盘空间<br>打开Maven文件夹下的<code>conf</code>文件夹，找到<code>settings.xml</code>文件，将其打开，在settings标签内增加<code>localRepository</code>标签，指定jar包下载位置（本地仓库位置）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- localRepository</span></span><br><span class="line"><span class="comment">   | The path to the local repository maven will use to store artifacts.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   | Default: $&#123;user.home&#125;/.m2/repository</span></span><br><span class="line"><span class="comment">  &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>D:\repository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Maven配置远程阿里云仓库"><a href="#Maven配置远程阿里云仓库" class="headerlink" title="Maven配置远程阿里云仓库"></a>Maven配置远程阿里云仓库</h3><p>Maven默认远程仓库是在国外的，由于网络原因，有时会导致下载jar包特别慢或者下载失败或者下载残缺，从而引起一些奇奇怪怪的问题，可以通过配置更改远程仓库位置，指向国内阿里云仓库<br>在Maven文件夹下的<code>conf</code>文件下的<code>settings.xml</code>文件中<code>mirrors</code>标签中做如下配置即可</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Maven依赖添加"><a href="#Maven依赖添加" class="headerlink" title="Maven依赖添加"></a>Maven依赖添加</h3><p>使用工具创建Maven项目后，会在目录下有一个pom.xml文件，只需要在文件中的<code>dependencies</code>标签中增加对应的依赖引入，maven即可完成对应的关联<br>Maven依赖查询网址：<a href="https://mvnrepository.com/">https://mvnrepository.com</a></p>
<h2 id="Maven基础知识讲解"><a href="#Maven基础知识讲解" class="headerlink" title="Maven基础知识讲解"></a>Maven基础知识讲解</h2><h3 id="Maven仓库"><a href="#Maven仓库" class="headerlink" title="Maven仓库"></a>Maven仓库</h3><ol>
<li>远程仓库/中央仓库<blockquote>
<p>maven默认远程仓库是在国外（<a href="http://repo1.maven.org/maven2/%EF%BC%89%EF%BC%8C%E7%94%B1%E4%BA%8E%E4%BC%97%E6%89%80%E5%91%A8%E7%9F%A5%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%8C%E4%B8%80%E8%88%AC%E9%83%BD%E4%BC%9A%E5%B0%86%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E9%85%8D%E7%BD%AE%E4%B8%BA%E5%9B%BD%E5%86%85%E6%BA%90%EF%BC%8C%E5%85%B7%E4%BD%93%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F%E5%A6%82%E4%B8%8A%E6%89%80%E7%A4%BA%E3%80%82">http://repo1.maven.org/maven2/），由于众所周知的原因，一般都会将远程仓库配置为国内源，具体配置方式如上所示。</a></p>
</blockquote>
</li>
<li>本地仓库<blockquote>
<p>maven默认的本地仓库配置为：${user.home}/.m2/repository；Windows电脑默认就是在C盘用户目录中<code>.m2</code>文件夹下，如果C盘空间不是特别大的话，可以添加如下配置将本地仓库修改到其他盘：</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>D:\repository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>私有服务器<blockquote>
<p>maven一般使用<code>nexus</code>用来做私服，具体搭建方式自行百度；搭建好后将私服作为远程仓库配置即可连接。</p>
</blockquote>
</li>
</ol>
<h3 id="Maven常用命令"><a href="#Maven常用命令" class="headerlink" title="Maven常用命令"></a>Maven常用命令</h3><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">mvn archetype:create -DarchetypeArtifactId=maven-archetype-quickstart -DgroupId=com.ryanote -Dartifact=common</td>
<td align="center">maven新建项目命令，指定相关设置信息</td>
</tr>
<tr>
<td align="center">mvn archetype:generate</td>
<td align="center">maven创建项目命令，之后根据提示设置相关项目信息</td>
</tr>
<tr>
<td align="center">mvn compile</td>
<td align="center">编译源代码</td>
</tr>
<tr>
<td align="center">mvn test-compile</td>
<td align="center">编译测试代码</td>
</tr>
<tr>
<td align="center">mvn test</td>
<td align="center">运行测试</td>
</tr>
<tr>
<td align="center">mvn site</td>
<td align="center">生产site</td>
</tr>
<tr>
<td align="center">mvn package</td>
<td align="center">打包</td>
</tr>
<tr>
<td align="center">mvn install</td>
<td align="center">将jar/war包安装到本地仓库</td>
</tr>
<tr>
<td align="center">mvn install -DMaven.test,skip=true</td>
<td align="center">执行mvn install命令，跳过测试</td>
</tr>
<tr>
<td align="center">mvn install:install-file</td>
<td align="center">安装jar包文件到本地仓库</td>
</tr>
<tr>
<td align="center">mvn clean</td>
<td align="center">清除生产的项目</td>
</tr>
<tr>
<td align="center">mvn eclipse:eclipse</td>
<td align="center">生产eclipse项目</td>
</tr>
<tr>
<td align="center">mvn idea:idea</td>
<td align="center">生产idea项目</td>
</tr>
<tr>
<td align="center">mvn deploy</td>
<td align="center">上传私服</td>
</tr>
<tr>
<td align="center">mvn deploy:deploy-file</td>
<td align="center">上传jar文件到私服</td>
</tr>
<tr>
<td align="center">mvn versions:set -DnewVersion=xx.xx</td>
<td align="center">maven更改版本号</td>
</tr>
<tr>
<td align="center">mvn versions:commit</td>
<td align="center">maven提交版本号更改</td>
</tr>
<tr>
<td align="center">mvn versions:revert</td>
<td align="center">maven回滚版本号更改</td>
</tr>
</tbody></table>
<h3 id="Maven生命周期"><a href="#Maven生命周期" class="headerlink" title="Maven生命周期"></a>Maven生命周期</h3><blockquote>
<p>maven拥有三套独立的生命周期，他们分别是clean、default和site。<br>clean生命周期的目的是清理项目；<br>default生命周期的目的是构建项目；<br>site生周期的目的是建立项目站点。  </p>
</blockquote>
<h4 id="clean生命周期"><a href="#clean生命周期" class="headerlink" title="clean生命周期"></a>clean生命周期</h4><p>clean生周期的目的是清理项目，它包括以下三个阶段。  </p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">pre-clean</td>
<td align="center">执行清理前需要完成的工作</td>
</tr>
<tr>
<td align="center">clean</td>
<td align="center">清理上一次构建过程中生产的文件，如编译后的class文件</td>
</tr>
<tr>
<td align="center">post-clean</td>
<td align="center">执行清理后需要完成的工作</td>
</tr>
</tbody></table>
<p>执行maven命令<code>mvn clean</code>其实就是运行clean阶段，需要注意的是<code>maven在一个生命周期运行某个阶段的时候，他之前的所有阶段都会被运行</code>，<br>也就是说执行<code>mvn clean</code>就是执行<code>mvn pre-clean clean</code>，如果执行<code>mvn post-clean</code>那么<code>pre-clean</code>和<code>clean</code>也会被运行。</p>
<h4 id="default生命周期"><a href="#default生命周期" class="headerlink" title="default生命周期"></a>default生命周期</h4><p>default生命周期定义了构建项目时所需要执行步骤，它是所有生命周期中最核心部分，包含的阶段如下：</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">validate</td>
<td align="center">验证项目结构是否正常，必要的配置文件是否存在</td>
</tr>
<tr>
<td align="center">initialize</td>
<td align="center">做构建前的初始化操作，比如初始化参数、创建必要目录等</td>
</tr>
<tr>
<td align="center">generate-sources</td>
<td align="center">产生在编译过程中需要的员代码</td>
</tr>
<tr>
<td align="center">process-sources</td>
<td align="center">处理源代码，比如过滤值</td>
</tr>
<tr>
<td align="center">generate-resources</td>
<td align="center">生产主代码中的资源在classpath中的包</td>
</tr>
<tr>
<td align="center">process-resources</td>
<td align="center">将资源文件复制到classpath的对应包中</td>
</tr>
<tr>
<td align="center">compile</td>
<td align="center">编译项目中的源代码</td>
</tr>
<tr>
<td align="center">process-classes</td>
<td align="center">生产编译过程中生成的文件</td>
</tr>
<tr>
<td align="center">generate-test-sources</td>
<td align="center">生产编译过程中测试相关的代码</td>
</tr>
<tr>
<td align="center">process-test-sources</td>
<td align="center">处理测试代码</td>
</tr>
<tr>
<td align="center">generate-test-resources</td>
<td align="center">生产测试中资源在classpath中的包</td>
</tr>
<tr>
<td align="center">process-test-resources</td>
<td align="center">将测试资源复制到classpath中</td>
</tr>
<tr>
<td align="center">test-compile</td>
<td align="center">编译测试代码</td>
</tr>
<tr>
<td align="center">process-test-classes</td>
<td align="center">生产编译测试代码过程的文件</td>
</tr>
<tr>
<td align="center">test</td>
<td align="center">运行测试案例</td>
</tr>
<tr>
<td align="center">prepare-package</td>
<td align="center">处理打包前需要初始化的准备工作</td>
</tr>
<tr>
<td align="center">package</td>
<td align="center">将编译后的class和资源打包成压缩包，如jar</td>
</tr>
<tr>
<td align="center">pre-integration-test</td>
<td align="center">做好集成测试前的准备工作，比如集成环境的参数设置</td>
</tr>
<tr>
<td align="center">integration-test</td>
<td align="center">集成测试</td>
</tr>
<tr>
<td align="center">post-integration-test</td>
<td align="center">完成集成测试后的收尾工作，比如清理集成环境的值</td>
</tr>
<tr>
<td align="center">verify</td>
<td align="center">检测测试后的包是否完好</td>
</tr>
<tr>
<td align="center">install</td>
<td align="center">将打包的组件以构件的形式，安装到本地依赖仓库中，以便共享给本地的其他项目</td>
</tr>
<tr>
<td align="center">deploy</td>
<td align="center">运行集成的发布环境，将测试后的最终包以构件的方式发布到远程仓库中，方便所有程序员共享</td>
</tr>
</tbody></table>
<p>最常用的阶段一般为：validate、compile、test、package、verify、install、site、deploy。</p>
<p>详细介绍可以查看：<a href="http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html">http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html</a></p>
<h3 id="Maven-POM-标签大全详解"><a href="#Maven-POM-标签大全详解" class="headerlink" title="Maven POM 标签大全详解"></a>Maven POM 标签大全详解</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0http://maven.apache.org/maven-v4_0_0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--父项目的坐标。如果项目中没有规定某个元素的值，那么父项目中的对应值即为项目的默认值。 坐标包括group ID，artifact ID和 </span></span><br><span class="line"><span class="comment">        version。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--被继承的父项目的构件标识符 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--被继承的父项目的全球唯一标识符 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--被继承的父项目的版本 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 父项目的pom.xml文件的相对路径。相对路径允许你选择一个不同的路径。默认值是../pom.xml。Maven首先在构建当前项目的地方寻找父项 </span></span><br><span class="line"><span class="comment">            目的pom，其次在文件系统的这个位置（relativePath位置），然后在本地仓库，最后在远程仓库寻找父项目的pom。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--声明项目描述符遵循哪一个POM模型版本。模型本身的版本很少改变，虽然如此，但它仍然是必不可少的，这是为了当Maven引入了新的特性或者其他模型变更的时候，确保稳定性。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目的全球唯一标识符，通常使用全限定的包名区分该项目和其他项目。并且构建时生成的路径也是由此生成， 如com.mycompany.app生成的相对路径为：/com/mycompany/app --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>asia.banseon<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 构件的标识符，它和group ID一起唯一标识一个构件。换句话说，你不能有两个不同的项目拥有同样的artifact ID和groupID；在某个 </span></span><br><span class="line"><span class="comment">        特定的group ID下，artifact ID也必须是唯一的。构件是项目产生的或使用的一个东西，Maven为项目产生的构件包括：JARs，源 码，二进制发布和WARs等。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>banseon-maven2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目产生的构件类型，例如jar、war、ear、pom。插件可以创建他们自己的构件类型，所以前面列的不是全部构件类型 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目当前版本，格式为:主版本.次版本.增量版本-限定版本号 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目的名称, Maven产生的文档用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>banseon-maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目主页的URL, Maven产生的文档用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.baidu.com/banseon<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 项目的详细描述, Maven 产生的文档用。 当这个元素能够用HTML格式描述时（例如，CDATA中的文本会被解析器忽略，就可以包含HTML标 </span></span><br><span class="line"><span class="comment">        签）， 不鼓励使用纯文本描述。如果你需要修改产生的web站点的索引页面，你应该修改你自己的索引页文件，而不是调整这里的文档。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>A maven project to study maven.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--描述了这个项目构建环境中的前提条件。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">prerequisites</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--构建该项目或使用该插件所需要的Maven的最低版本 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">prerequisites</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目的问题管理系统(Bugzilla, Jira, Scarab,或任何你喜欢的问题管理系统)的名称和URL，本例为 jira --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">issueManagement</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--问题管理系统（例如jira）的名字， --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">system</span>&gt;</span>jira<span class="tag">&lt;/<span class="name">system</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--该项目使用的问题管理系统的URL --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://jira.baidu.com/banseon<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">issueManagement</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目持续集成信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ciManagement</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--持续集成系统的名字，例如continuum --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">system</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--该项目使用的持续集成系统的URL（如果持续集成系统有web接口的话）。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--构建完成时，需要通知的开发者/用户的配置项。包括被通知者信息和通知条件（错误，失败，成功，警告） --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">notifiers</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--配置一种方式，当构建中断时，以该方式通知用户/开发者 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">notifier</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--传送通知的途径 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--发生错误时是否通知 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sendOnError</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--构建失败时是否通知 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sendOnFailure</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--构建成功时是否通知 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sendOnSuccess</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--发生警告时是否通知 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sendOnWarning</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--不赞成使用。通知发送到哪里 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">address</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--扩展配置项 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">notifier</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">notifiers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ciManagement</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目创建年份，4位数字。当产生版权信息时需要使用这个值。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">inceptionYear</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目相关邮件列表信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mailingLists</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--该元素描述了项目相关的所有邮件列表。自动产生的网站引用这些信息。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mailingList</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--邮件的名称 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--发送邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">post</span>&gt;</span>banseon@126.com<span class="tag">&lt;/<span class="name">post</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">subscribe</span>&gt;</span>banseon@126.com<span class="tag">&lt;/<span class="name">subscribe</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--取消订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">unsubscribe</span>&gt;</span>banseon@126.com<span class="tag">&lt;/<span class="name">unsubscribe</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--你可以浏览邮件信息的URL --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">archive</span>&gt;</span>http:/hi.baidu.com/banseon/demo/dev/<span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mailingList</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mailingLists</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目开发者列表 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">developers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--某个项目开发者的信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">developer</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--SCM里项目开发者的唯一标识符 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>HELLO WORLD<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目开发者的全名 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>banseon<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目开发者的email --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">email</span>&gt;</span>banseon@126.com<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目开发者的主页的URL --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目开发者在项目中扮演的角色，角色元素描述了各种角色 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">roles</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">role</span>&gt;</span>Project Manager<span class="tag">&lt;/<span class="name">role</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">role</span>&gt;</span>Architect<span class="tag">&lt;/<span class="name">role</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">roles</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目开发者所属组织 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">organization</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">organization</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目开发者所属组织的URL --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">organizationUrl</span>&gt;</span>http://hi.baidu.com/banseon<span class="tag">&lt;/<span class="name">organizationUrl</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目开发者属性，如即时消息如何处理等 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dept</span>&gt;</span>No<span class="tag">&lt;/<span class="name">dept</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目开发者所在时区， -11到12范围内的整数。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">timezone</span>&gt;</span>-5<span class="tag">&lt;/<span class="name">timezone</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">developer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">developers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目的其他贡献者列表 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contributors</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--项目的其他贡献者。参见developers/developer元素 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">contributor</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">email</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">organization</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">organizationUrl</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">roles</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">timezone</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">properties</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">contributor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">contributors</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--该元素描述了项目所有License列表。 应该只列出该项目的license列表，不要列出依赖项目的 license列表。如果列出多个license，用户可以选择它们中的一个而不是接受所有license。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">licenses</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--描述了项目的license，用于生成项目的web站点的license页面，其他一些报表和validation也会用到该元素。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">license</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--license用于法律上的名称 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Apache 2<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--官方的license正文页面的URL --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.baidu.com/banseon/LICENSE-2.0.txt<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目分发的主要方式： repo，可以从Maven库下载 manual， 用户必须手动下载和安装依赖 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">distribution</span>&gt;</span>repo<span class="tag">&lt;/<span class="name">distribution</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--关于license的补充信息 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">comments</span>&gt;</span>A business-friendly OSS license<span class="tag">&lt;/<span class="name">comments</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">license</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">licenses</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--SCM(Source Control Management)标签允许你配置你的代码库，供Maven web站点和其它插件使用。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scm</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--SCM的URL,该URL描述了版本库和如何连接到版本库。欲知详情，请看SCMs提供的URL格式和列表。该连接只读。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">connection</span>&gt;</span></span><br><span class="line">            scm:svn:http://svn.baidu.com/banseon/maven/banseon/banseon-maven2-trunk(dao-trunk)</span><br><span class="line">        <span class="tag">&lt;/<span class="name">connection</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--给开发者使用的，类似connection元素。即该连接不仅仅只读 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">developerConnection</span>&gt;</span></span><br><span class="line">            scm:svn:http://svn.baidu.com/banseon/maven/banseon/dao-trunk</span><br><span class="line">        <span class="tag">&lt;/<span class="name">developerConnection</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--当前代码的标签，在开发阶段默认为HEAD --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tag</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指向项目的可浏览SCM库（例如ViewVC或者Fisheye）的URL。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://svn.baidu.com/banseon<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">scm</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--描述项目所属组织的各种属性。Maven产生的文档用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">organization</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--组织的全名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--组织主页的URL --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.baidu.com/banseon<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">organization</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--构建项目需要的信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--该元素设置了项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sourceDirectory</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--该元素设置了项目脚本源码目录，该目录和源码目录不同：绝大多数情况下，该目录下的内容 会被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scriptSourceDirectory</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--该元素设置了项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">testSourceDirectory</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--被编译过的应用程序class文件存放的目录。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">outputDirectory</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--被编译过的测试class文件存放的目录。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">testOutputDirectory</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--使用来自该项目的一系列构建扩展 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">extensions</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--描述使用到的构建扩展。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">extension</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--构建扩展的groupId --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--构建扩展的artifactId --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--构建扩展的版本 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">extension</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--当项目没有规定目标（Maven2 叫做阶段）时的默认值 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">defaultGoal</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--这个元素描述了项目相关的所有资源路径列表，例如和项目相关的属性文件，这些资源被包含在最终的打包文件里。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--这个元素描述了项目相关或测试相关的所有资源路径 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 描述了资源的目标路径。该路径相对target/classes目录（例如$&#123;project.build.outputDirectory&#125;）。举个例 </span></span><br><span class="line"><span class="comment">                    子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven /messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">targetPath</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素里列出。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--描述存放资源的目录，该路径相对POM路径 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--包含的模式列表，例如**/*.xml. --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--排除的模式列表，例如**/*.xml --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">excludes</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--这个元素描述了单元测试相关的所有资源路径，例如和单元测试相关的属性文件。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">testResources</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--这个元素描述了测试相关的所有资源路径，参见build/resources/resource元素的说明 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">testResource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">targetPath</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">excludes</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">testResource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">testResources</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--构建产生的所有文件存放的目录 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--产生的构件的文件名，默认值是$&#123;artifactId&#125;-$&#123;version&#125;。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--当filtering开关打开时，使用到的过滤器属性文件列表 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filters</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--子项目可以引用的默认插件信息。该插件配置项直到被引用时才会被解析或绑定到生命周期。给定插件的任何本地配置都会覆盖这里的配置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--使用的插件列表 。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--plugin元素包含描述插件所需要的信息。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--插件在仓库里的group ID --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--插件在仓库里的artifact ID --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--被使用的插件的版本（或版本范围） --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该元素才被设置成enabled。 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">extensions</span> /&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--execution元素包含了插件执行需要的信息 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">phase</span> /&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--配置的执行目标 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--配置是否被传播到子POM --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--作为DOM对象的配置 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--项目引入插件所需要的额外依赖 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                            ......</span><br><span class="line">                        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--任何配置是否被传播到子项目 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--作为DOM对象的配置 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--使用的插件列表 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">extensions</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                        ......</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--在列的项目构建profile，如果被激活，会修改构建处理 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--根据环境参数或命令行参数激活某个构建处理 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--构建配置的唯一标识符。即用于命令行激活，也用于在继承时合并具有相同标识符的profile。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--自动触发profile的条件逻辑。Activation是profile的开启钥匙。profile的力量来自于它 能够在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。activation元素并不是激活profile的唯一方式。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--profile默认是否激活的标志 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">activeByDefault</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本不是以1.4开头的JDK。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">jdk</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">os</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--激活profile的操作系统的名字 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Windows XP<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--激活profile的操作系统所属家族(如 &#x27;windows&#x27;) --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">family</span>&gt;</span>Windows<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--激活profile的操作系统体系结构 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">arch</span>&gt;</span>x86<span class="tag">&lt;/<span class="name">arch</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--激活profile的操作系统版本 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.2600<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">os</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--如果Maven检测到某一个属性（其值可以在POM中通过$&#123;名称&#125;引用），其拥有对应的名称和值，Profile就会被激活。如果值 字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--激活profile的属性的名称 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">name</span>&gt;</span>mavenVersion<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--激活profile的属性的值 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">value</span>&gt;</span>2.0.3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活 profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">file</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--如果指定的文件存在，则激活profile。 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">exists</span>&gt;</span>/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">exists</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--如果指定的文件不存在，则激活profile。 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">missing</span>&gt;</span>/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">missing</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--构建项目所需要的信息。参见build元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">defaultGoal</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">targetPath</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">filtering</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">directory</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">includes</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">excludes</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">testResources</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">testResource</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">targetPath</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">filtering</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">directory</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">includes</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">excludes</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">testResource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">testResources</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">finalName</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filters</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">extensions</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">phase</span> /&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                                <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                                    ......</span><br><span class="line">                                <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">extensions</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">phase</span> /&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                                ......</span><br><span class="line">                            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">modules</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--发现依赖和扩展的远程仓库列表。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--参见repositories/repository元素 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">name</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">url</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">layout</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--发现插件的远程仓库列表，这些插件用于构建和报表 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">name</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">url</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">layout</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                    ......</span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--不赞成使用. 现在Maven忽略该元素. --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">reports</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--该元素包括使用报表插件产生报表的规范。当用户执行&quot;mvn site&quot;，这些报表就会运行。 在页面导航栏能看到所有报表的链接。参见reporting元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">reporting</span>&gt;</span></span><br><span class="line">                ......</span><br><span class="line">            <span class="tag">&lt;/<span class="name">reporting</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--参见dependencyManagement元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                        ......</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--参见distributionManagement元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">                ......</span><br><span class="line">            <span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--参见properties元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">properties</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--发现依赖和扩展的远程仓库列表。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--包含需要连接到远程仓库的信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--如何处理远程仓库里发布版本的下载 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--当Maven验证构件校验文件失败时该怎么做：ignore（忽略），fail（失败），或者warn（警告）。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的 </span></span><br><span class="line"><span class="comment">                策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>banseon-repository-proxy<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--远程仓库名称 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>banseon-repository-proxy<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--远程仓库URL，按protocol://hostname/path形式 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.1.169:9999/repository/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然 </span></span><br><span class="line"><span class="comment">                而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--发现插件的远程仓库列表，这些插件用于构建和报表 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">            ......</span><br><span class="line">        <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--依赖的group ID --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--依赖的artifact ID --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-artifact<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--依赖的版本号。 在Maven 2里, 也可以配置成版本号的范围。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展名或分类器。类型经常和使用的打包方式对应， </span></span><br><span class="line"><span class="comment">                尽管这也有例外。一些类型的例子：jar，war，ejb-client和test-jar。如果设置extensions为 true，就可以在 plugin里定义新的类型。所以前面的类型的例子不完整。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 依赖的分类器。分类器可以区分属于同一个POM，但不同构建方式的构件。分类器名被附加到文件名的版本号后面。例如，如果你想要构建两个单独的构件成 </span></span><br><span class="line"><span class="comment">                JAR，一个使用Java 1.4编译器，另一个使用Java 6编译器，你就可以使用分类器来生成两个单独的JAR构件。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">classifier</span>&gt;</span><span class="tag">&lt;/<span class="name">classifier</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。 - compile ：默认范围，用于编译 - provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath </span></span><br><span class="line"><span class="comment">                - runtime: 在执行时需要使用 - test: 用于test任务时使用 - system: 需要外在提供相应的元素。通过systemPath来取得 </span></span><br><span class="line"><span class="comment">                - systemPath: 仅用于范围为system。提供相应的路径 - optional: 当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--仅供system范围使用。注意，不鼓励使用这个元素，并且在新的版本中该元素可能被覆盖掉。该元素为依赖规定了文件系统上的路径。需要绝对路径而不是相对路径。推荐使用属性匹配绝对路径，例如$&#123;java.home&#125;。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span><span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--当计算传递依赖时， 从依赖构件列表里，列出被排除的依赖构件集。即告诉maven你只依赖指定的项目，不依赖项目的依赖。此元素主要用于解决版本冲突问题 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--可选依赖，如果你在项目B中把C依赖声明为可选，你就需要在依赖于B的项目（例如项目A）中显式的引用对C的依赖。可选依赖阻断依赖的传递性。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--不赞成使用. 现在Maven忽略该元素. --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">reports</span>&gt;</span><span class="tag">&lt;/<span class="name">reports</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--该元素描述使用报表插件产生报表的规范。当用户执行&quot;mvn site&quot;，这些报表就会运行。 在页面导航栏能看到所有报表的链接。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">reporting</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--true，则，网站不包括默认的报表。这包括&quot;项目信息&quot;菜单中的报表。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">excludeDefaults</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--所有产生的报表存放到哪里。默认值是$&#123;project.build.directory&#125;/site。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">outputDirectory</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--使用的报表插件和他们的配置。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--plugin元素包含描述报表插件需要的信息 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--报表插件在仓库里的group ID --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--报表插件在仓库里的artifact ID --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--被使用的报表插件的版本（或版本范围） --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--任何配置是否被传播到子项目 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--报表插件的配置 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--一组报表的多重规范，每个规范可能有不同的配置。一个规范（报表集）对应一个执行目标 。例如，有1，2，3，4，5，6，7，8，9个报表。1，2，5构成A报表集，对应一个执行目标。2，5，8构成B报表集，对应另一个执行目标 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">reportSets</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--表示报表的一个集合，以及产生该集合的配置 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">reportSet</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--报表集合的唯一标识符，POM继承时用到 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--产生报表集合时，被使用的报表的配置 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--配置是否被继承到子POMs --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--这个集合里使用到哪些报表 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">reports</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">reportSet</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">reportSets</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">reporting</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 继承自该项目的所有子项目的默认依赖信息。这部分的依赖信息不会被立即解析,而是当子项目声明一个依赖（必须描述group ID和 artifact </span></span><br><span class="line"><span class="comment">        ID信息），如果group ID和artifact ID以外的一些信息没有描述，则通过group ID和artifact ID 匹配到这里的依赖，并使用这里的依赖信息。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                ......</span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目分发信息，在执行mvn deploy后表示要发布的位置。有了这些信息就可以把网站部署到远程服务器或者把构件部署到远程仓库。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--部署项目产生的构件到远程仓库需要的信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--是分配给快照一个唯一的版本号（由时间戳和构建流水号）？还是每次都使用相同的版本号？参见repositories/repository元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">uniqueVersion</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>banseon-maven2<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>banseon maven2<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>file://$&#123;basedir&#125;/target/deploy<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">layout</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--构件的快照部署到哪里？如果没有配置该元素，默认部署到repository元素配置的仓库，参见distributionManagement/repository元素 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">uniqueVersion</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>banseon-maven2<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Banseon-maven2 Snapshot Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>scp://svn.baidu.com/banseon:/usr/local/maven-snapshot<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">layout</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--部署项目的网站需要的信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">site</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--部署位置的唯一标识符，用来匹配站点和settings.xml文件里的配置 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>banseon-site<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--部署位置的名称 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>business api website<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--部署位置的URL，按protocol://hostname/path形式 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span></span><br><span class="line">                scp://svn.baidu.com/banseon:/var/www/localhost/banseon-web</span><br><span class="line">            <span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">site</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--项目下载页面的URL。如果没有该元素，用户应该参考主页。使用该元素的原因是：帮助定位那些不在仓库里的构件（由于license限制）。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">downloadUrl</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--如果构件有了新的group ID和artifact ID（构件移到了新的位置），这里列出构件的重定位信息。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relocation</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--构件新的group ID --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--构件新的artifact ID --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--构件新的版本号 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--显示给用户的，关于移动的额外信息，例如原因。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">message</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">relocation</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 给出该构件在远程仓库的状态。不得在本地项目中设置该元素，因为这是工具自动更新的。有效的值有：none（默认），converted（仓库管理员从 </span></span><br><span class="line"><span class="comment">            Maven 1 POM转换过来），partner（直接从伙伴Maven 2仓库同步过来），deployed（从Maven 2实例部 署），verified（被核实时正确的和最终的）。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">status</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--以值替代名称，Properties可以在整个POM中使用，也可以作为触发条件（见settings.xml配置文件里activation元素的说明）。格式是&lt;name&gt;value&lt;/name&gt;。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Java网络编程教程|Netty深入浅出全套教程——Netty入门（二）</title>
    <url>/2022/01/31/netty/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B%E2%80%94%E2%80%94Netty%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="Netty是什么？"><a href="#Netty是什么？" class="headerlink" title="Netty是什么？"></a>Netty是什么？</h2><p>Netty是一个异步的、基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端  </p>
<h2 id="Netty的作者"><a href="#Netty的作者" class="headerlink" title="Netty的作者"></a>Netty的作者</h2><p><img src="/2022/01/31/netty/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B%E2%80%94%E2%80%94Netty%E5%85%A5%E9%97%A8/Netty%E7%9A%84%E4%BD%9C%E8%80%85%E5%9B%BE.png" alt="Netty的作者图"><br>他还是另一个著名网络应用框架Mina的重要贡献者  </p>
<h2 id="Netty的地位"><a href="#Netty的地位" class="headerlink" title="Netty的地位"></a>Netty的地位</h2><p>Netty在java网络应用框架中的地位就好比Spring框架在JavaEE开发中的地位<br>以下的框架都使用了Netty，因为它们由网络通信需求</p>
<ul>
<li>Cassandra - nosql数据库</li>
<li>Spark - 大数据分布式计算框架</li>
<li>Hadoop - 大数据分布式存储框架</li>
<li>RocketMQ - ali 开源的消息队列</li>
<li>ElasticSearch - 搜索引擎</li>
<li>gREC - rpc框架</li>
<li>Dubbo - rpc框架</li>
<li>Spring 5.x - flux api完全抛弃了tomcat，使用netty作为服务端</li>
<li>Zookeeper - 分布式协调框架</li>
</ul>
<h2 id="Netty的优势"><a href="#Netty的优势" class="headerlink" title="Netty的优势"></a>Netty的优势</h2><ul>
<li>Netty vs NIO，工作量大，bug多<ul>
<li>需要自己构建协议</li>
<li>解决TCP传输问题，如黏包、半包</li>
<li>epoll空轮询导致CPU 100%</li>
<li>对API进行增强，使之更易用，如<code>FastThreadLocal</code> =&gt; <code>ThreadLocal</code>，<code>ByteBuf</code> =&gt; <code>ByteBuffer</code></li>
</ul>
</li>
<li>Netty vs 其他网络应用框架<ul>
<li>Mina由apache维护，将来3.x版本可能会由较大重构，破坏API向下兼容性，Netty的开发迭代更迅速，API更简介、文档更优秀</li>
<li>久经考验，16年，Netty版本<ul>
<li>2.x 2004</li>
<li>3.x 2008</li>
<li>4.x 2013</li>
<li>5.x 已废弃（没有明显性能提升，维护成本高）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>开发一个简单的服务端和客户端</p>
<ul>
<li>客户端向服务端发送 hello、world</li>
<li>服务端仅接收，不反回</li>
</ul>
<p>加入依赖  </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.72.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.启动器，负责组装 netty 组件，启动服务</span></span><br><span class="line">        <span class="keyword">new</span> ServerBootstrap()</span><br><span class="line">                <span class="comment">//2. BossEventLoop、WorkerEventLoop(selector,thread),group 组</span></span><br><span class="line">                <span class="comment">//类似于多线程版NIO中的分组，不同的组负责不同的任务类型，里面包含selector和线程thread</span></span><br><span class="line">                <span class="comment">//创建NioEventLoopGroup，可以简单的理解为线程池+selector</span></span><br><span class="line">                .group(<span class="keyword">new</span> NioEventLoopGroup())</span><br><span class="line">                <span class="comment">//3.选择 服务器 ServerSocketChannel 实现</span></span><br><span class="line">                <span class="comment">//选择 Socket 实现类，其中NioServerSocketChannel 表示基于NIO的服务器端实现，其他的实现还有</span></span><br><span class="line">                <span class="comment">//EpollServerSocketChannel KQueueServerSocketChannel OioServerSocketChannel</span></span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                <span class="comment">//4.boss 负责处理连接 worker(child) 负责处理读写，决定了worker(child)能执行那些操作(handler)</span></span><br><span class="line">                <span class="comment">//为啥方法叫 childHandler ，是接下来添加的处理器都是给 SocketChannel 用的，而不是给 ServerSocketChannel</span></span><br><span class="line">                <span class="comment">//ChannelInitializer 处理器（仅执行一次），他的作用是待客户端 SocketChannel 建立连接后，执行 initChannel 方法以便添加更多的处理器</span></span><br><span class="line">                .childHandler(</span><br><span class="line">                        <span class="comment">//5.channel 代表和客户端进行数据读写的通道</span></span><br><span class="line">                        <span class="comment">//Initializer 初始化，负责添加别的 handler</span></span><br><span class="line">                        <span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="comment">//6.添加具体的 handler</span></span><br><span class="line">                        <span class="comment">//将ByteBuf转换成字符串</span></span><br><span class="line">                        <span class="comment">//SocketChannel的处理器，解码 ByteBuf =&gt; String</span></span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> StringDecoder());</span><br><span class="line">                        <span class="comment">//自定义 handler</span></span><br><span class="line">                        <span class="comment">//SocketChannel的业务处理器，使用上一个处理器的处理结果</span></span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                <span class="comment">//打印上一步转换的字符串</span></span><br><span class="line">                                System.out.println(msg);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">//7.绑定监听端口</span></span><br><span class="line">                <span class="comment">//ServerSocketChannel 绑定监听端口</span></span><br><span class="line">                .bind(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//启动类</span></span><br><span class="line">        <span class="keyword">new</span> Bootstrap()</span><br><span class="line">               <span class="comment">//2.添加 EventLoop</span></span><br><span class="line">                <span class="comment">// 创建 NioEventLoopGroup 同server</span></span><br><span class="line">                .group(<span class="keyword">new</span> NioEventLoopGroup())</span><br><span class="line">                <span class="comment">//3. 选择客户端channel</span></span><br><span class="line">                <span class="comment">//选择客户端Socket实现类，NioSocketChannel 表示基于NIO的客户端实现其他实现还有</span></span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                <span class="comment">//4.添加处理器</span></span><br><span class="line">                <span class="comment">//添加 SocketChannel 的处理器，ChannelInitializer 处理器（仅执行一次）</span></span><br><span class="line">                <span class="comment">//它的作用是待客户端 SocketChannel 建立连接后，执行 initChannel 方法以便添加更多的处理器</span></span><br><span class="line">                .handler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span> <span class="comment">//在连接建立后被调用</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="comment">//消息会经过通道handler处理，这里是将String =&gt; ByteBuf发出</span></span><br><span class="line">                        <span class="comment">//数据经过网络传输，到达服务器端，服务器端的handler处理器先后被触发，走完一个流程</span></span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">//5.连接服务器</span></span><br><span class="line">                <span class="comment">//指定要连接的服务器和端口</span></span><br><span class="line">                .connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8080</span>))</span><br><span class="line">                <span class="comment">//Netty中很多方法都是异步的，如connect，这时需要使用sync方法等待connect建立连接完毕</span></span><br><span class="line">                .sync()</span><br><span class="line">                <span class="comment">//获取 channel 对象，它即为通道抽象，可以进行数读写操作</span></span><br><span class="line">                .channel()</span><br><span class="line">                <span class="comment">//6.向服务端发送数据</span></span><br><span class="line">                <span class="comment">//写入消息并清空缓冲区</span></span><br><span class="line">                .writeAndFlush(<span class="string">&quot;hello, world&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>💡 提示</strong><br>一开始需要树立正确的观念  </p>
<ul>
<li>把<code>channel</code>理解为数据的通道</li>
<li>把msg理解为流动的数据，最开始输入是<code>ByteBuf</code>，但经过<code>pipeline</code>的加工，会变成其他类型对象，最后输出又变成<code>ByteBuf</code></li>
<li>把<code>handler</code>理解为数据的处理工序<ul>
<li>工序由多道，合在一起就是<code>pipeline</code>，<code>pipeline</code>负责发布事件（读、读取完成…）传播给每个<code>handler</code>，<code>handler</code>对自己感兴趣的事件进行处理（重写了相应事件处理方法）</li>
<li><code>handler</code>分<code>Inbound</code>和<code>Outbound</code>两类</li>
</ul>
</li>
<li>把<code>eventLoop</code>理解为处理数据的工人<ul>
<li>工人可以管理多个<code>channel</code>的io操作，并且一旦工人负责了某个<code>channel</code>，就要负责到底（绑定）</li>
<li>工人既可以执行io操作，也可以进行任务处理，每位工人有任务队列，队列里可以堆放多个<code>channel</code>的待处理任务，任务分为普通任务、定时任务</li>
<li>工人按照<code>pipeline</code>顺序，以次按照<code>handler</code>的规划（代码）处理数据，可以为每道工序指定不同的工人  </li>
</ul>
</li>
</ul>
<h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><h2 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a><code>EventLoop</code></h2><p>事件循环对象<br><code>EventLoop</code>本质是一个单线程执行器(同时维护了一个<code>selector</code>)，里面有<code>run</code>方法处理<code>Channel</code>上源源不断的 io 事件<br>它的继承关系比较复杂  </p>
<ul>
<li>一条线是继承自<code>j.u.c.ScheduledExecutorService</code> 因此包含了线程池中所有的方法</li>
<li>另一条线是继承自netty自己的<code>OrderedEventExecutor</code><ul>
<li>提供了 <code>boolean inEventLoop(Thread thread)</code>方法判断一个线程是否是属于此<code>EventLoop</code></li>
<li>提供了<code>parent</code>方法来看看自己属于哪个<code>EventLoop</code></li>
</ul>
</li>
</ul>
<p><img src="/2022/01/31/netty/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B%E2%80%94%E2%80%94Netty%E5%85%A5%E9%97%A8/EventLoop%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E5%9B%BE%E7%A4%BA.png" alt="EventLoop继承关系图示"></p>
<p><strong><code>EventLoopGroup</code></strong><br>事件循环组<br><code>EventLoopGroup</code>是一组<code>EventLoop</code>，<code>Channel</code>一般会调用<code>EventLoopGroup</code>的<code>register</code>方法来绑定其中一个<code>EventLoop</code>，后续整个<code>Channel</code>上的io事件都由此<code>EventLoop</code>来处理（保证了io事件处理时的线程安全）</p>
<ul>
<li>继承自netty自己的<code>EventExecutorGroup</code><ul>
<li>实现了<code>Iterable</code>接口提供遍历<code>EventLoop</code>的能力</li>
<li>另有<code>next</code>方法获取集合中下一个<code>EventLoop</code></li>
</ul>
</li>
</ul>
<p>以一个简单的实现为例：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 内部创建了两个 EventLoop, 每个 EventLoop 维护一个线程</span><br><span class="line">DefaultEventLoopGroup group = new DefaultEventLoopGroup(2);</span><br><span class="line">System.out.println(group.next());</span><br><span class="line">System.out.println(group.next());</span><br><span class="line">System.out.println(group.next());</span><br></pre></td></tr></table></figure>
<p>输出： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">io.netty.channel.DefaultEventLoop@60f82f98</span><br><span class="line">io.netty.channel.DefaultEventLoop@35f983a6</span><br><span class="line">io.netty.channel.DefaultEventLoop@60f82f98</span><br></pre></td></tr></table></figure>
<p>也可以使用for循环调用： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DefaultEventLoopGroup group = new DefaultEventLoopGroup(2);</span><br><span class="line">for (EventExecutor eventLoop : group) &#123;</span><br><span class="line">    System.out.println(eventLoop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结论：<br>调用<code>group.next()</code>获取事件循环对象，可以循环获取，比如现在多次调用获取对象，第一次和第三次获取的是一样的，第二次和第四次是一样的，以次类推，实现了一个轮询的效果</p>
<p><strong>执行普通任务和定时任务</strong><br><code>EventLoopGroup</code>继承了线程池中的所有方法，所以本身就相当于一个线程池，执行普通任务直接使用<code>submit</code>方法或者<code>execute</code>方法提交任务即可，定时任务调用<code>scheduleAtFixedRate</code>方法执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEventLoop</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建事件循环组</span></span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">2</span>);<span class="comment">//io事件，普通任务，定时任务</span></span><br><span class="line">                             <span class="comment">//new DefaultEventLoopGroup();//普通任务，定时任务</span></span><br><span class="line">        <span class="comment">//2.获取下一个事件循环对象</span></span><br><span class="line">        <span class="comment">//调用group.next()获取事件循环对象，可以循环获取，比如现在多次调用获取对象，第一次和第三次获取的是一样的，第二次和第四次是一样的，以次类推，实现了一个轮询的效果</span></span><br><span class="line">        System.out.println(group.next());</span><br><span class="line">        System.out.println(group.next());</span><br><span class="line">        System.out.println(group.next());</span><br><span class="line">        System.out.println(group.next());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.执行普通任务</span></span><br><span class="line">        group.next().submit(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                log.debug(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.指定定时任务</span></span><br><span class="line">        group.next().scheduleAtFixedRate(()-&gt;&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">        &#125;,<span class="number">0</span>,<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        log.debug(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>💡 优雅地关闭</strong><br>优雅地关闭，需要调用<code>group</code>的<code>group.shutdownGracefully()</code>方法。该方法会首先切换<code>EventLoopGroup</code>到关闭状态从而拒绝新的任务加入，然后在任务队列中的任务都处理完成后，停止线程的运行，从而确保整体应用是在正常有序的状态下退出的  </p>
<p><strong><code>NioEventLoop</code> 处理IO事件</strong>  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventLoopServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> ServerBootstrap()</span><br><span class="line">            <span class="comment">//boss 和 worker</span></span><br><span class="line">            <span class="comment">//第一个参数是boss，只负责 ServerSocketChannel 上的 accept 事件</span></span><br><span class="line">            <span class="comment">//第二个参数是worker 负责 SocketChannel 上的读写事件</span></span><br><span class="line">            .group(<span class="keyword">new</span> NioEventLoopGroup(), <span class="keyword">new</span> NioEventLoopGroup(<span class="number">2</span>))</span><br><span class="line">            .channel(NioServerSocketChannel.class)</span><br><span class="line">            .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">                  <span class="meta">@Override</span></span><br><span class="line">                  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">                    log.debug(buf.toString(Charset.defaultCharset()));</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;).bind(<span class="number">8080</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端启动多次，使用dubug模式多次调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventLoopClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Channel channel = <span class="keyword">new</span> Bootstrap()</span><br><span class="line">                .group(<span class="keyword">new</span> NioEventLoopGroup())</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>))</span><br><span class="line">                .sync()</span><br><span class="line">                .channel();</span><br><span class="line">        System.out.println(channel);</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11:37:14 [DEBUG] [nioEventLoopGroup-3-1] c.y.n.c.EventLoopServer - 1</span><br><span class="line">11:37:31 [DEBUG] [nioEventLoopGroup-3-2] c.y.n.c.EventLoopServer - 2</span><br><span class="line">11:37:46 [DEBUG] [nioEventLoopGroup-3-1] c.y.n.c.EventLoopServer - 3</span><br><span class="line">11:37:49 [DEBUG] [nioEventLoopGroup-3-1] c.y.n.c.EventLoopServer - 3</span><br><span class="line">11:37:57 [DEBUG] [nioEventLoopGroup-3-2] c.y.n.c.EventLoopServer - 2</span><br><span class="line">11:37:57 [DEBUG] [nioEventLoopGroup-3-2] c.y.n.c.EventLoopServer - 2</span><br><span class="line">11:38:01 [DEBUG] [nioEventLoopGroup-3-1] c.y.n.c.EventLoopServer - 1</span><br><span class="line">11:38:01 [DEBUG] [nioEventLoopGroup-3-1] c.y.n.c.EventLoopServer - 1</span><br></pre></td></tr></table></figure>
<p>可以看到，是两个人工人轮流处理<code>channel</code>的事件，并且每个<code>channel</code>是和线程进行绑定的，多次调用也是使用同一个线程进行处理<br><img src="/2022/01/31/netty/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B%E2%80%94%E2%80%94Netty%E5%85%A5%E9%97%A8/NioEventLoop%E5%A4%84%E7%90%86%E4%BA%8B%E4%BB%B6%E5%9B%BE%E7%A4%BA.png" alt="NioEventLoop处理事件图示"></p>
<p><strong>在增加两个非nio的工人</strong>  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventLoopServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//细分2：创建一个独立的EventLoopGroup</span></span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> DefaultEventLoopGroup();</span><br><span class="line">        <span class="keyword">new</span> ServerBootstrap()</span><br><span class="line">                <span class="comment">//boss 和 worker</span></span><br><span class="line">                <span class="comment">//第一个参数是boss，只负责 ServerSocketChannel 上的 accept 事件</span></span><br><span class="line">                <span class="comment">//第二个参数是worker 负责 SocketChannel 上的读写事件</span></span><br><span class="line">                .group(<span class="keyword">new</span> NioEventLoopGroup(),<span class="keyword">new</span> NioEventLoopGroup(<span class="number">2</span>))</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        ch.pipeline().addLast(<span class="string">&quot;handler1&quot;</span>,<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                ByteBuf buf = (ByteBuf)msg;</span><br><span class="line">                                log.debug(buf.toString(Charset.defaultCharset()));</span><br><span class="line">                                ctx.fireChannelRead(msg);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;).addLast(group,<span class="string">&quot;handler2&quot;</span>,<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                ByteBuf buf = (ByteBuf)msg;</span><br><span class="line">                                log.debug(buf.toString(Charset.defaultCharset()));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).bind(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端代码不变，启动多次，多次调用，结果如下：    </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11:42:57 [DEBUG] [nioEventLoopGroup-4-1] c.y.n.c.EventLoopServer - 1</span><br><span class="line">11:42:57 [DEBUG] [defaultEventLoopGroup-2-1] c.y.n.c.EventLoopServer - 1</span><br><span class="line">11:43:10 [DEBUG] [nioEventLoopGroup-4-2] c.y.n.c.EventLoopServer - 2</span><br><span class="line">11:43:10 [DEBUG] [defaultEventLoopGroup-2-2] c.y.n.c.EventLoopServer - 2</span><br><span class="line">11:43:23 [DEBUG] [nioEventLoopGroup-4-1] c.y.n.c.EventLoopServer - 3</span><br><span class="line">11:43:23 [DEBUG] [defaultEventLoopGroup-2-3] c.y.n.c.EventLoopServer - 3</span><br><span class="line">11:43:24 [DEBUG] [nioEventLoopGroup-4-1] c.y.n.c.EventLoopServer - 3</span><br><span class="line">11:43:24 [DEBUG] [defaultEventLoopGroup-2-3] c.y.n.c.EventLoopServer - 3</span><br><span class="line">11:43:24 [DEBUG] [nioEventLoopGroup-4-1] c.y.n.c.EventLoopServer - 3</span><br><span class="line">11:43:24 [DEBUG] [defaultEventLoopGroup-2-3] c.y.n.c.EventLoopServer - 3</span><br><span class="line">11:43:27 [DEBUG] [nioEventLoopGroup-4-2] c.y.n.c.EventLoopServer - 2</span><br><span class="line">11:43:27 [DEBUG] [defaultEventLoopGroup-2-2] c.y.n.c.EventLoopServer - 2</span><br><span class="line">11:43:27 [DEBUG] [nioEventLoopGroup-4-2] c.y.n.c.EventLoopServer - 2</span><br><span class="line">11:43:27 [DEBUG] [defaultEventLoopGroup-2-2] c.y.n.c.EventLoopServer - 2</span><br><span class="line">11:43:29 [DEBUG] [nioEventLoopGroup-4-1] c.y.n.c.EventLoopServer - 1</span><br><span class="line">11:43:29 [DEBUG] [defaultEventLoopGroup-2-1] c.y.n.c.EventLoopServer - 1</span><br><span class="line">11:43:30 [DEBUG] [nioEventLoopGroup-4-1] c.y.n.c.EventLoopServer - 1</span><br><span class="line">11:43:30 [DEBUG] [defaultEventLoopGroup-2-1] c.y.n.c.EventLoopServer - 1</span><br></pre></td></tr></table></figure>
<p>从结果可以看出，nio的工人和非nio的工人都绑定了<code>channel</code>，会按照绑定的顺序以次执行，客户端的每次调用同样绑定了<code>EventLoop</code>也就是线程<br>不同<code>handler</code>之间任务的传递通过 <code>ctx.fireChannelRead(msg)</code> 方法实现，上一个<code>handler</code>需要调用下一个<code>handler</code>的时候执行该方法，不然无法实现调用<br><img src="/2022/01/31/netty/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B%E2%80%94%E2%80%94Netty%E5%85%A5%E9%97%A8/EventLoop%E7%BB%91%E5%AE%9A%E7%BA%BF%E7%A8%8B%E5%9B%BE%E7%A4%BA2.png" alt="EventLoop绑定线程图示2"></p>
<p><strong>💡 <code>handler</code>执行中如何换人</strong><br>上一个<code>handler</code>如何将任务传递给下一个<code>handler</code>执行，关键代码如下：<br><code>io.netty.channel.AbstractChannelHandlerContext#invokeChannelRead()</code>  </p>
<ul>
<li>如果两个<code>handler</code>绑定的是同一个线程，那么就直接调用  </li>
<li>否则，把要调用的代码封装为一个任务对象，由下一个<code>handler</code>的线程来调用  </li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void invokeChannelRead(final AbstractChannelHandlerContext next, Object msg) &#123;</span><br><span class="line">    final Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, &quot;msg&quot;), next);</span><br><span class="line">    // 下一个 handler 的事件循环是否与当前的事件循环是同一个线程</span><br><span class="line">    //获取下一个handler事件循环对象（EventLoop）</span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    </span><br><span class="line">    // 是，直接调用，如果下一个事件循环对象也就是EventLoop是当前对象（线程），直接在当前线程中执行方法</span><br><span class="line">    if (executor.inEventLoop()) &#123;</span><br><span class="line">        next.invokeChannelRead(m);</span><br><span class="line">    &#125; </span><br><span class="line">    // 不是，将要执行的代码作为任务提交给下一个事件循环处理（换人）</span><br><span class="line">    //如果不是，需要将任务提交到另外的线程中</span><br><span class="line">    else &#123;</span><br><span class="line">        executor.execute(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                next.invokeChannelRead(m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a><code>Channel</code></h2><p><code>channel</code>的主要作用  </p>
<ul>
<li><code>close()</code>可以用来关闭<code>channel</code></li>
<li><code>closeFuture()</code>用来处理<code>channel</code>的关闭（调用<code>close()</code>方法之后的善后处理）<ul>
<li><code>sync()</code>方法作用是同步等待<code>channel</code>关闭</li>
<li>而<code>addListener</code>方法是异步等待<code>channel</code>关闭</li>
</ul>
</li>
<li><code>pipeline()</code>方法添加处理器  </li>
<li><code>write()</code>方法将数据写入（会将数据写入<code>channel</code>的缓冲区，并不会立刻发出，除非调用了<code>flush</code>方法或者缓冲区数据达到一定容量）</li>
<li><code>writeAndFlush()</code>方法将数据写入并刷出</li>
</ul>
<h3 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h3><blockquote>
<p>代码如下所示，当调用了<code>connect</code>方法建立连接，会返回一个<code>ChannelFuture</code>对象<br>可以通过<code>ChannelFuture</code>对象获取<code>channel</code>对象发送数据<br>但如果调用了<code>connect</code>方法后，立即获取<code>Channel</code>对象，此时的<code>Channel</code>对象是不完整的<br>因为<code>connect</code>方法建立连接并不是在当前线程去创建连接的，而是会异步处理，也就是发送给<code>BoosEventLoopGroup</code>处理<br>可以通过调用<code>ChannelFuture</code>的<code>sync()</code>方法等待连接建立完毕，此方法会将线程陷入阻塞，直到连接建立完毕<br>或者使用<code>ChannelFuture</code>的<code>addListener()</code>方法，封装一个任务对象通过该方法传入，会等待连接建立完毕之后执行任务  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ChannelFuture channelFuture = <span class="keyword">new</span> Bootstrap()</span><br><span class="line">                .group(<span class="keyword">new</span> NioEventLoopGroup())</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>));</span><br><span class="line"><span class="comment">//        channelFuture.sync();</span></span><br><span class="line"><span class="comment">//        channelFuture.channel();</span></span><br><span class="line">        channelFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            Channel channel = channelFuture.channel();</span><br><span class="line">            System.out.println(channel);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CloseFuture"><a href="#CloseFuture" class="headerlink" title="CloseFuture"></a><code>CloseFuture</code></h3><blockquote>
<p>服务端代码不变，客户端代码如下所示<br>关闭<code>channel</code>的时候直接调用<code>close</code>方法，并不会立即关闭，因为这个方法是一个异步方法<br>可以先通过<code>Channel</code>的 <code>channel.closeFuture()</code> 方法获取 <code>CloseFuture</code> 对象<br>然后可以再通过<code>CloseFuture</code>对象的<code>sync()</code>方法进行同步关闭，或者通过 <code>addListener</code> 方法进行异步关闭<br><code>sync()</code>方法会阻塞当前的调用线程，直到channel关闭结束后<br><code>addListener()</code>方法则可以将需要<code>Channel</code>关闭后处理的逻辑封装成任务对象，等完全关闭之后会进行回调执行任务  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloseFutureClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        ChannelFuture channelFuture = <span class="keyword">new</span> Bootstrap()</span><br><span class="line">                .group(group)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> LoggingHandler(LogLevel.DEBUG));</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">        Channel channel = channelFuture.sync().channel();</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, channel);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                String line = scanner.nextLine();</span><br><span class="line">                <span class="keyword">if</span> (line.equals(<span class="string">&quot;q&quot;</span>))&#123;</span><br><span class="line">                    channel.close();<span class="comment">//close 异步操作</span></span><br><span class="line">                    <span class="comment">//log.debug(&quot;处理关闭之后的操作&quot;);//不能在这里善后</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                channel.writeAndFlush(line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="comment">//获取 CloseFuture对象 1.同步处理关闭，2.异步处理关闭</span></span><br><span class="line">        ChannelFuture closeFuture = channel.closeFuture();</span><br><span class="line">        <span class="comment">/*log.debug(&quot;waiting close ...&quot;);</span></span><br><span class="line"><span class="comment">        closeFuture.sync();</span></span><br><span class="line"><span class="comment">        log.debug(&quot;处理关闭之后的操作&quot;);*/</span></span><br><span class="line"></span><br><span class="line">        closeFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                log.debug(<span class="string">&quot;处理关闭之后的操作&quot;</span>);</span><br><span class="line">                group.shutdownGracefully();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>💡异步提升的是什么</strong>  </p>
<ul>
<li>异步提升的不是效率而是吞吐量</li>
<li>单线程没法异步提升效率，必须配合多线程、多核cpu才能发挥异步的优势</li>
<li>异步并没有缩短响应事件，反而有所增加</li>
<li>合理进行任务拆分，也算利用异步的关键  </li>
</ul>
<h3 id="Future-amp-Promise"><a href="#Future-amp-Promise" class="headerlink" title="Future &amp; Promise"></a><code>Future</code> &amp; <code>Promise</code></h3><p>在异步处理的时候，经常会用到这个两个接口</p>
<p>首先要说明netty中的<code>Future</code>与jdk中的<code>Future</code>同名，但是是两个不同的接口，netty的<code>Future</code>继承自jdk的<code>Future</code>，而<code>Promise</code>又对netty的<code>Future</code>进行了扩展  </p>
<ul>
<li><code>jdk Future</code>只能同步等待任务结束（或成功、或失败）才能得到结果</li>
<li><code>netty Future</code>可以同步等待任务接口得到结果，也可以异步方式得到结果，但都是要等到任务结束</li>
<li><code>netty Promise</code>不仅有<code>netty Future</code>的功能，而且脱离了任务独立存在，只作为来给你个线程间传递结果的容器</li>
</ul>
<table>
<thead>
<tr>
<th align="center">功能/名称</th>
<th align="center">jdk Future</th>
<th align="center">netty Future</th>
<th align="center">Promise</th>
</tr>
</thead>
<tbody><tr>
<td align="center">cancel</td>
<td align="center">取消任务</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">isCanceled</td>
<td align="center">任务是否取消</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">isDone</td>
<td align="center">任务是否完成，不能区分成功失败</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">get</td>
<td align="center">获取任务结果，阻塞等待</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">getNow</td>
<td align="center">-</td>
<td align="center">获取任务结果，非阻塞，还未产生结果时返回null</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">await</td>
<td align="center">-</td>
<td align="center">等待任务结束，如果任务失败，不会抛异常，而是通过isSuccess判断</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">sync</td>
<td align="center">-</td>
<td align="center">等待任务结束，如果任务失败，抛出异常</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">isSuccess</td>
<td align="center">-</td>
<td align="center">判断任务是否成功</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">cause</td>
<td align="center">-</td>
<td align="center">获取失败信息，非阻塞，如果没有失败，返回null</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">addLinstenter</td>
<td align="center">-</td>
<td align="center">添加回调，异步接收结果</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">setSuccess</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">设置成功结果</td>
</tr>
<tr>
<td align="center">setFailure</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">设置失败结果</td>
</tr>
</tbody></table>
<p><strong>jdk Future</strong>   </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHJdkFuture</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//1.先创建一个线程池</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//2.提交任务</span></span><br><span class="line">        Future&lt;Integer&gt; future = service.submit(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                log.debug(<span class="string">&quot;执行计算&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//3.主线程通过Future来获取结果</span></span><br><span class="line">        log.debug(<span class="string">&quot;等待结果&quot;</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;结果是 &#123;&#125;&quot;</span>,future.get());</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>netty Future</strong>  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestNettyFuture</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoop eventLoop = group.next();</span><br><span class="line">        Future&lt;Integer&gt; future = eventLoop.submit(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                log.debug(<span class="string">&quot;执行计算&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">//        log.debug(&quot;等待结果&quot;);</span></span><br><span class="line"><span class="comment">//        log.debug(&quot;结果是 &#123;&#125;&quot;,future.get());</span></span><br><span class="line"><span class="comment">//        group.shutdownGracefully();</span></span><br><span class="line">        future.addListener(<span class="keyword">new</span> GenericFutureListener&lt;Future&lt;? <span class="keyword">super</span> Integer&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;? <span class="keyword">super</span> Integer&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                log.debug(<span class="string">&quot;结果是 &#123;&#125;&quot;</span>,future.getNow());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Netty Promise</strong>  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestNettyPromise</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//1.准备 EventLoop 对象</span></span><br><span class="line">        NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoop eventLoop = group.next();</span><br><span class="line">        <span class="comment">//2.可以主动创建Promise</span></span><br><span class="line">        DefaultPromise&lt;Integer&gt; promise = <span class="keyword">new</span> DefaultPromise&lt;&gt;(eventLoop);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.任意一个线程执行计算，计算完毕后向 promise 填充结果</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;开始计算....&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            promise.setSuccess(<span class="number">80</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.接收结果的线程</span></span><br><span class="line">        log.debug(<span class="string">&quot;等待结果....&quot;</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;结果是：&#123;&#125;&quot;</span>,promise.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Handler-amp-Pipeline"><a href="#Handler-amp-Pipeline" class="headerlink" title="Handler &amp; Pipeline"></a><code>Handler</code> &amp; <code>Pipeline</code></h3><p><code>ChannelHandler</code> 用来处理<code>Channel</code> 上的各种事件，分为入站、出站两种，所有<code>ChannelHandler</code>被连成一串，就是<code>Pipeline</code></p>
<ul>
<li>入站处理器通常是<code>ChannelInboundHandlerAdapter</code> 的子类，主要用来读取客户端数据，写回结果  </li>
<li>出站处理器通常是<code>ChannelOutboundHandlerAdapter</code>的子类，主要对写回结果进行加工</li>
</ul>
<p>服务端代码： </p>
<blockquote>
<p>如下代码所示，一共设置了6个处理器，其中1、2、3号处理器是入站处理器，4、5、6号处理器是出站处理器<br>当客户端发送一条消息，会触发1、2、3号处理器，当服务端要向客户端写出一条数据，会触发4、5、6号处理器<br>从结果可以看出，入站处理器是按照addLast的顺序进行调用的（1-&gt;2-&gt;3），而出站处理器是从尾部向前调用的（6-&gt;5-&gt;4）<br>可以从代码中看到，为了模拟写出，是在第三个入站处理器中调用了 <code>ch.writeAndFlush()</code> 方法进行写出的<br>调用<code>channel</code>的写出方法，是从<code>pipeline</code>的尾部开始找出站处理器的<br>如果调用入站处理器的参数，也就 <code>ctx(ChannelHandlerContext)</code> 的写出方法，则会从当前处理器的位置向前寻找出站处理器   </p>
</blockquote>
<p>可以看到，<code>ChannelInboundHandlerAdapter</code>是按照<code>addLast</code>的顺序执行的，而<code>ChannelOutboundHandlerAdapter</code>是按照<code>addLast</code>的逆序执行的。<br><code>ChannelPipeline</code>的实现是一个<code>ChannelHandlerContext</code>(包装了<code>ChannelHHandler</code>)组成的双向链表<br><img src="/2022/01/31/netty/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B%E2%80%94%E2%80%94Netty%E5%85%A5%E9%97%A8/Pipeline%E7%BB%93%E6%9E%84%E5%9B%BE%E7%A4%BA.png" alt="Pipeline结构图示"></p>
<ul>
<li>入站处理器中，<code>ctx.fireChannelRead(msg)</code>是调用下一个入站处理器<ul>
<li>如果注释掉，就不会执行下一个入站处理器  </li>
</ul>
</li>
<li><code>ctx.channel().write(msg)</code>会从尾部开始出发后续出站处理器的执行<ul>
<li>如果注释掉，不会打印后面的出站处理器方法</li>
</ul>
</li>
<li>类似的，出站处理器中，<code>ctx.write(msg, promise)</code>的调用，也会触发上一个出站处理器<ul>
<li>如果注释掉，则不会调用后续的出站处理器</li>
</ul>
</li>
<li><code>ctx.channel().write(msg)</code> vs <code>ctx.write(msg)</code><ul>
<li>都是触发出站处理器的执行</li>
<li><code>ctx.channel().write(msg)/(ch.write(msg))</code>从尾部开始查找出站处理器</li>
<li><code>ctx.write(msg)</code>是从当前节点向上找上一个出站处理器</li>
<li>3 处的 <code>ctx.channel().write(msg)</code> 如果改为 <code>ctx.write(msg)</code> 仅会打印 1 2 3，因为节点3 之前没有其它出站处理器了</li>
<li>6 处的 <code>ctx.write(msg, promise)</code> 如果改为 <code>ctx.channel().write(msg)</code> 会打印 1 2 3 6 6 6… 因为 <code>ctx.channel().write()</code> 是从尾部开始查找，结果又是节点6 自己<br><img src="/2022/01/31/netty/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B%E2%80%94%E2%80%94Netty%E5%85%A5%E9%97%A8/%E6%9C%8D%E5%8A%A1%E7%AB%AFpipeline%E8%A7%A6%E5%8F%91%E7%9A%84%E5%8E%9F%E5%A7%8B%E6%B5%81%E7%A8%8B.png" alt="服务端pipeline触发的原始流程"></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPipeline</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ServerBootstrap()</span><br><span class="line">                .group(<span class="keyword">new</span> NioEventLoopGroup())</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="comment">//1.通过 channel 拿到 pipeline</span></span><br><span class="line">                        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                        <span class="comment">//2.添加处理器 head -&gt; h1 -&gt; h2 -&gt; h3 -&gt; tail</span></span><br><span class="line">                        <span class="comment">//netty 会自动添加两个处理器，分别放在最前面和最后面，其他添加的都是在这两个中间 head    tail</span></span><br><span class="line">                        pipeline.addLast(<span class="string">&quot;h1&quot;</span>,<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                                <span class="keyword">super</span>.channelRead(ctx, msg);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                        pipeline.addLast(<span class="string">&quot;h2&quot;</span>,<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">                                <span class="keyword">super</span>.channelRead(ctx, msg);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                        pipeline.addLast(<span class="string">&quot;h3&quot;</span>,<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                log.debug(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">                                <span class="keyword">super</span>.channelRead(ctx, msg);</span><br><span class="line">                                ch.writeAndFlush(ctx.alloc().buffer().writeBytes(<span class="string">&quot;server...&quot;</span>.getBytes()));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                        pipeline.addLast(<span class="string">&quot;h4&quot;</span>,<span class="keyword">new</span> ChannelOutboundHandlerAdapter()&#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                log.debug(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">                                <span class="keyword">super</span>.write(ctx, msg, promise);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                        pipeline.addLast(<span class="string">&quot;h5&quot;</span>,<span class="keyword">new</span> ChannelOutboundHandlerAdapter()&#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                log.debug(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">                                <span class="keyword">super</span>.write(ctx, msg, promise);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                        pipeline.addLast(<span class="string">&quot;h6&quot;</span>,<span class="keyword">new</span> ChannelOutboundHandlerAdapter()&#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                log.debug(<span class="string">&quot;6&quot;</span>);</span><br><span class="line">                                <span class="keyword">super</span>.write(ctx, msg, promise);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).bind(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">16:48:27 [DEBUG] [nioEventLoopGroup-2-2] c.y.n.c.TestPipeline - 1</span><br><span class="line">16:48:27 [DEBUG] [nioEventLoopGroup-2-2] c.y.n.c.TestPipeline - 2</span><br><span class="line">16:48:27 [DEBUG] [nioEventLoopGroup-2-2] c.y.n.c.TestPipeline - 3</span><br><span class="line">16:48:27 [DEBUG] [nioEventLoopGroup-2-2] c.y.n.c.TestPipeline - 6</span><br><span class="line">16:48:27 [DEBUG] [nioEventLoopGroup-2-2] c.y.n.c.TestPipeline - 5</span><br><span class="line">16:48:27 [DEBUG] [nioEventLoopGroup-2-2] c.y.n.c.TestPipeline - 4</span><br></pre></td></tr></table></figure>

<h2 id="ByteBuf"><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a><code>ByteBuf</code></h2><p>是对字节数据的封装  </p>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ByteBuf buf = ByteBufAllocator.DEFAULT.buffer();</span><br></pre></td></tr></table></figure>
<p>创建了一个默认的<code>ByteBuf</code>，容量为netty默认256，也可以通过参数设置初始容量  </p>
<p>可以通过下面的方法比较方便的查看<code>ByteBuf</code>中的数据  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static void log(ByteBuf buffer) &#123;</span><br><span class="line">    int length = buffer.readableBytes();</span><br><span class="line">    int rows = length / 16 + (length % 15 == 0 ? 0 : 1) + 4;</span><br><span class="line">    StringBuilder buf = new StringBuilder(rows * 80 * 2)</span><br><span class="line">        .append(&quot;read index:&quot;).append(buffer.readerIndex())</span><br><span class="line">        .append(&quot; write index:&quot;).append(buffer.writerIndex())</span><br><span class="line">        .append(&quot; capacity:&quot;).append(buffer.capacity())</span><br><span class="line">        .append(NEWLINE);</span><br><span class="line">    appendPrettyHexDump(buf, buffer);</span><br><span class="line">    System.out.println(buf.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="直接内存-VS-堆内存"><a href="#直接内存-VS-堆内存" class="headerlink" title="直接内存 VS 堆内存"></a>直接内存 VS 堆内存</h3><p><font color="red">Netty默认是使用直接内存</font><br>可以使用下面的代码来创建池化基于堆得 ByteBuf</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ByteBuf buf = ByteBufAllocator.DEFAULT.heapBuffer();</span><br></pre></td></tr></table></figure>
<p>也可以使用下面的代码来创建池化基于直接内存的 <code>ByteBuf</code>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ByteBuf buf = ByteBufAllocator.DEFAULT.directBuffer();</span><br></pre></td></tr></table></figure>
<ul>
<li>直接内存创建和销毁的代价昂贵，但读写性能高(少一次内存复制)，适合配合池化功能一起用  </li>
<li>直接内存对GC压力小，因为这部分内存不受JVM垃圾回收的管理，但也要注意及时主动释放  </li>
</ul>
<h3 id="池化-VS-非池化"><a href="#池化-VS-非池化" class="headerlink" title="池化 VS 非池化"></a>池化 VS 非池化</h3><p>池化的最大意义在于可以重用<code>ByteBuf</code>，优点有  </p>
<ul>
<li>没有池化，则每次都得创建新的<code>ByteBuf</code>实例，这个操作对直接内存代价昂贵，就算是堆内存，也会增加GC压力</li>
<li>有了池化，则可以重用池中<code>ByteBuf</code>实例，并且采用了与jemalloc类似的内存分配算法提升分配效率</li>
<li>高并发时，池化功能更节约内存，减少内存溢出的可能  </li>
</ul>
<p>池化功能是否开启，可以通过下面的系统环境变量来设置  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Dio.netty.allocator.type=&#123;unpooled|pooled&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>4.1以后，非Android平台默认启用池化实现，Android平台启用非池化实现</li>
<li>4.1之前，池化功能还不成熟，默认是非池化实现  </li>
</ul>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p><code>ByteBuf</code>由四部分组成</p>
<ul>
<li>可扩容字节：在<code>ByteBuf</code>当前容量和最大容量之间的区域，都是可扩容字节，最大容量默认是<code>Integer.MaxValue</code>,可自定义设置</li>
<li>可写字节：初始时，整个<code>ByteBuf</code>都是可写部分，随着数据的写入，可写部分慢慢变少，最后触发扩容  </li>
<li>可读字节：数据写入后，已经写入的部分，都是可读部分</li>
<li>废弃字节：数据读取之后的，是废弃部分</li>
</ul>
<p><img src="/2022/01/31/netty/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B%E2%80%94%E2%80%94Netty%E5%85%A5%E9%97%A8/ByteBuf%E7%BB%84%E6%88%90%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="ByteBuf组成结构图"></p>
<h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><p>方法列表，省略一些不重要的方法  </p>
<table>
<thead>
<tr>
<th align="center">方法签名</th>
<th align="center">含义</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">writeBoolean(boolean value)</td>
<td align="center">写入一个boolean值</td>
<td align="center">用一个字节01&#124;00代表true&#124;false</td>
</tr>
<tr>
<td align="center">writeByte(int value)</td>
<td align="center">写入byte值</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">writeShort(int value)</td>
<td align="center">写入short值</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">writeInt(int value)</td>
<td align="center">写入int值</td>
<td align="center">Big Endian，即0x250,写入后00 00 02 05</td>
</tr>
<tr>
<td align="center">writeIntLE(int value)</td>
<td align="center">写入int值</td>
<td align="center">Little Endian，即0x250，写入后50 02 00 00</td>
</tr>
<tr>
<td align="center">writeLong(long value)</td>
<td align="center">写入 long 值</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">writeChar(int value)</td>
<td align="center">写入 char 值</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">writeFloat(float value)</td>
<td align="center">写入 float 值</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">writeDouble(double value)</td>
<td align="center">写入 double 值</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">writeBytes(ByteBuf src)</td>
<td align="center">写入 netty 的 ByteBuf</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">writeBytes(byte[] src)</td>
<td align="center">写入 byte[]</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">writeBytes(ByteBuffer src)</td>
<td align="center">写入 nio 的 ByteBuffer</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">int writeCharSequence(CharSequence sequence, Charset charset)</td>
<td align="center">写入字符串</td>
<td align="center">需要指定字符集</td>
</tr>
</tbody></table>
<p><font color="red">注意：</font>  </p>
<blockquote>
<p>这些方法为指明返回值的，其返回值都是<code>ByteBuf</code>，意味着可以链式调用<br>网络传输，默认习惯用 <code>Big Endian</code></p>
</blockquote>
<p>创建一个<code>ByteBuf</code><br>先写入4个字节  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">buf.writeBytes(new byte[]&#123;1,2,3,4&#125;);</span><br></pre></td></tr></table></figure>
<p>结果是：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read index:0 write index:4 capacity:10</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04                                     |....            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>
<p>再写入一个int整数，也是4个字节 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">buf.writeInt(5);</span><br></pre></td></tr></table></figure>
<p>结果：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read index:0 write index:8 capacity:10</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04 00 00 00 05                         |........        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>
<p>还有一类方法是set开头的一系列方法，也可以写入数据，但不会改变指针位置  </p>
<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>再写入一个int整数时，容量不够了（初始容量是10），这时会引发扩容 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">buf.writeInt(6);</span><br></pre></td></tr></table></figure>
<p><strong>扩容规则是</strong>：  </p>
<ul>
<li>如果写入后数据大小未超过512，则选择下一个16的整数倍，例如写入后大小为12，则扩容后<code>capacity</code>是16</li>
<li>如果写入后数据大小超过512，则选择下一个2^n(2的n次方)，例如写入后大小为513，则扩容后<code>capacity</code>是2^10=1024(2^9=512已经不够了)</li>
<li>扩容不能超过 <code>max capacity</code>，否则会报错</li>
</ul>
<p>结果是： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read index:0 write index:12 capacity:16</span><br><span class="line">+-------------------------------------------------+</span><br><span class="line">|  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04 00 00 00 05 00 00 00 06             |............    |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>

<h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><p>例如读了4次，每次一个字节  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.println(buffer.readByte());</span><br><span class="line">System.out.println(buffer.readByte());</span><br><span class="line">System.out.println(buffer.readByte());</span><br><span class="line">System.out.println(buffer.readByte());</span><br></pre></td></tr></table></figure>
<p>读过的内容，就属于废弃部分了，再读就只能读那些尚未读取的部分</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">read index:4 write index:12 capacity:16</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 00 00 00 05 00 00 00 06                         |........        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>
<p>如果需要重复读取int整数5<br>可以再<code>read</code>前先做个标记<code>mark</code>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">buffer.markReaderIndex();</span><br><span class="line">System.out.println(buffer.readInt());</span><br></pre></td></tr></table></figure>
<p>结果  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">read index:8 write index:12 capacity:16</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 00 00 00 06                                     |....            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>
<p>这时如果想要重复读取的话，重置标记位置<code>rest</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">buffer.resetReaderIndex();</span><br></pre></td></tr></table></figure>
<p>这时：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read index:4 write index:12 capacity:16</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 00 00 00 05 00 00 00 06                         |........        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>
<p>还有种办法是采用<code>get</code>开头的一系列方法，这些方法不会改变<code>read index</code>  </p>
<h3 id="retain-amp-release"><a href="#retain-amp-release" class="headerlink" title="retain &amp; release"></a><code>retain</code> &amp; <code>release</code></h3><p>由于Netty中有堆外内存的<code>ByteBuf</code>实现，堆外内存最好是手动来释放，而不是等GC垃圾回收  </p>
<ul>
<li><code>UnpooledHeapByteBuf</code> 使用的是 JVM 内存，只需等 GC 回收内存即可</li>
<li><code>UnpooledDirectByteBuf</code> 使用的就是直接内存了，需要特殊的方法来回收内存</li>
<li><code>PooledByteBuf</code> 和它的子类使用了池化机制，需要更复杂的规则来回收内存</li>
</ul>
<p>回收内存的源码实现，请关注下面方法的不同实现（不同实现释放方式不同）  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected abstract void deallocate()</span><br></pre></td></tr></table></figure>
<p>Netty这里采用了引用计数法来控制回收内存，每个<code>ByteBuf</code>都实现了<code>ReferenceCounted</code> 接口  </p>
<ul>
<li>每个<code>ByteBuf</code>对象的初始计数为1</li>
<li>调用<code>release</code>方法计数减1，如果计数为0，<code>ByteBuf</code>内存被回收  </li>
<li>调用<code>retain</code>方法计数加1，表示调用者没用完之前，其他<code>handler</code>即使调用了<code>release</code>也不会造成回收</li>
<li>当计数为0时，底层内存会被回收，这时即使<code>ByteBuf</code>对象还在，其各个方法均无法正常使用  </li>
</ul>
<p>因为<code>pipeline</code>的存在，一般需要将<code>ByteBuf</code>传递给下一个<code>ChannelHandler</code>，如果在每个处理器中释放，就失去了传递性（当然，如果在这个<code>ChannelHandler</code>内这个<code>ByteBuf</code>已经完成了它的使命，那么便无须再传递）  </p>
<p>基本规则是：<strong>谁是最后使用者，谁负责release</strong>，详细分析  </p>
<ul>
<li>起点，对于NIO实现，在 <code>io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read</code> 方法中首次创建<code>ByteBuf</code>放入<code>pipeline</code>（line 163 pipeline.fireChannelRead(byteBuf)）</li>
<li>入站<code>ByteBuf</code>处理原则<ul>
<li>对原始<code>ByteBuf</code>不做处理，调用<code>ctx.fireChannelRead(msg)</code>向后传递，这时无须<code>release</code></li>
<li>将原始<code>ByteBuf</code>转换为其他类型的Java对象，这时<code>ByteBuf</code>就没用了，必须<code>release</code></li>
<li>如果不调用<code>ctx.fireChannelRead(msg)</code>向后传递，那么也必须<code>release</code></li>
<li>注意各种异常，如果<code>ByteBuf</code>没有成功传递到下一个<code>ChannelHandler</code>，必须<code>release</code></li>
<li>假设消息一直向后传，那么<code>TailContext</code>会负责释放未处理消息（原始的<code>ByteBuf</code>）</li>
</ul>
</li>
<li>出站<code>ByteBuf</code>处理原则<ul>
<li>有时候不清楚<code>ByteBuf</code>被引用了多少次，但又必须彻底释放，可以循环调用<code>release</code>直到返回true</li>
</ul>
</li>
</ul>
<p><code>TailContext</code>释放未处理消息逻辑  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// io.netty.channel.DefaultChannelPipeline#onUnhandledInboundMessage(java.lang.Object)</span><br><span class="line">protected void onUnhandledInboundMessage(Object msg) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        logger.debug(</span><br><span class="line">            &quot;Discarded inbound message &#123;&#125; that reached at the tail of the pipeline. &quot; +</span><br><span class="line">            &quot;Please check your pipeline configuration.&quot;, msg);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        ReferenceCountUtil.release(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体代码  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// io.netty.util.ReferenceCountUtil#release(java.lang.Object)</span><br><span class="line">public static boolean release(Object msg) &#123;</span><br><span class="line">    if (msg instanceof ReferenceCounted) &#123;</span><br><span class="line">        return ((ReferenceCounted) msg).release();</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a><code>slice</code></h3><p>【零拷贝】的体现之一，对原始<code>ByteBuf</code>进行切片成多个<code>ByteBuf</code>，切片后的<code>ByteBuf</code>并没有发生内存复制，还是使用原始<code>ByteBuf</code>的内存，切片后的<code>ByteBuf</code>维护独立的<code>read</code>、<code>write</code>指针<br><img src="/2022/01/31/netty/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B%E2%80%94%E2%80%94Netty%E5%85%A5%E9%97%A8/slice%E5%9B%BE%E7%A4%BA.png" alt="slice图示"></p>
<p>调用<code>slice</code>进行切片，无参<code>slice</code>是从原始<code>ByteBuf</code>的<code>read index</code>到<code>write index</code>之间的内容进行切片，切片后的<code>max capacity</code> 被固定为这个区间的大小，因此不能追加<code>write</code>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ByteBuf slice = origin.slice();</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(slice));</span><br><span class="line">// slice.writeByte(5); 如果执行，会报 IndexOutOfBoundsException 异常</span><br></pre></td></tr></table></figure>
<p>带参数的<code>slice</code>方法，则是根据参数指定的下标和长度进行切分<br>因为切分后的<code>ByteBuf</code>和原<code>ByteBuf</code>使用的是同一块内存，所以切分后的<code>ByteBuf</code>如果内容更改，原<code>ByteBuf</code>内容也会更改，如果原<code>ByteBuf</code>指定<code>release</code>方法回收内存，切分的也会被回收内存  </p>
<h3 id="duplicate"><a href="#duplicate" class="headerlink" title="duplicate"></a><code>duplicate</code></h3><p>【零拷贝】的体现之一，就好比截取了原始<code>ByteBuf</code>所有内容，并且没有<code>max capacity</code>的限制，也是与原始<code>ByteBuf</code>使用同一块底层内存，只是读写指针是独立的<br><img src="/2022/01/31/netty/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B%E2%80%94%E2%80%94Netty%E5%85%A5%E9%97%A8/duplicate%E5%9B%BE%E7%A4%BA.png" alt="duplicate图示"></p>
<h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a><code>copy</code></h3><p>会将底层内存数据进行深拷贝，因此无论读写，都与原始<code>ByteBuf</code>无关  </p>
<h3 id="CompositeByteBuf"><a href="#CompositeByteBuf" class="headerlink" title="CompositeByteBuf"></a><code>CompositeByteBuf</code></h3><p>【零拷贝】的体现之一，可以将多个<code>ByteBuf</code>合并成一个逻辑上的<code>ByteBuf</code>，避免拷贝<br>有两个<code>ByteBuf</code>如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ByteBuf buf1 = ByteBufAllocator.DEFAULT.buffer(5);</span><br><span class="line">buf1.writeBytes(new byte[]&#123;1, 2, 3, 4, 5&#125;);</span><br><span class="line">ByteBuf buf2 = ByteBufAllocator.DEFAULT.buffer(5);</span><br><span class="line">buf2.writeBytes(new byte[]&#123;6, 7, 8, 9, 10&#125;);</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04 05                                  |.....           |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 06 07 08 09 0a                                  |.....           |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>
<p>合并成一个<code>ByteBuf</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CompositeByteBuf buf3 = ByteBufAllocator.DEFAULT.compositeBuffer();</span><br><span class="line">// true 表示增加新的 ByteBuf 自动递增 write index, 否则 write index 会始终为 0</span><br><span class="line">buf3.addComponents(true, buf1, buf2);</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>
<p><code>CompositeByteBuf</code> 是一个组合<code>ByteBuf</code>，它内部维护了一个<code>Component</code>数组，每个<code>Component</code>管理一个<code>ByteBuf</code>，记录了这个<code>ByteBuf</code>相对于整体偏移量等信息，代表着整体中某一段数据  </p>
<ul>
<li>优点：对外是一个虚拟视图，组合这些<code>ByteBuf</code>不会产生内存复制</li>
<li>缺点，复杂了很多，多次操作会带来性能的损耗</li>
</ul>
<h3 id="Unpooled"><a href="#Unpooled" class="headerlink" title="Unpooled"></a><code>Unpooled</code></h3><p><code>Unpooled</code>是一个工具类，类如其名，提供了非池化的<code>ByteBuf</code>创建、组合、复制等操作  </p>
<p>这里仅介绍其跟【零拷贝】相关的<code>wrappedBuffer</code> 方法，可以用来包装<code>ByteBuf</code>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ByteBuf buf1 = ByteBufAllocator.DEFAULT.buffer(5);</span><br><span class="line">buf1.writeBytes(new byte[]&#123;1, 2, 3, 4, 5&#125;);</span><br><span class="line">ByteBuf buf2 = ByteBufAllocator.DEFAULT.buffer(5);</span><br><span class="line">buf2.writeBytes(new byte[]&#123;6, 7, 8, 9, 10&#125;);</span><br><span class="line"></span><br><span class="line">// 当包装 ByteBuf 个数超过一个时, 底层使用了 CompositeByteBuf</span><br><span class="line">ByteBuf buf3 = Unpooled.wrappedBuffer(buf1, buf2);</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>
<p>也可以用来包装普通字节数组，底层也不会有拷贝操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ByteBuf buf4 = Unpooled.wrappedBuffer(new byte[]&#123;1, 2, 3&#125;, new byte[]&#123;4, 5, 6&#125;);</span><br><span class="line">System.out.println(buf4.getClass());</span><br></pre></td></tr></table></figure>
<p>输出： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class io.netty.buffer.CompositeByteBuf</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04 05 06                               |......          |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>
<h3 id="💡ByteBuf优势"><a href="#💡ByteBuf优势" class="headerlink" title="💡ByteBuf优势"></a>💡<code>ByteBuf</code>优势</h3><ul>
<li>池化-可以重用池中<code>ByteBuf</code>实例，更节约内存，减少内存溢出的可能  </li>
<li>读写指针分离，不需要想<code>ByteBuf</code>一样切换读写模式</li>
<li>可以自动扩容</li>
<li>支持链式调用，使用更流畅</li>
<li>很多地方体现零拷贝，例如 <code>slice</code>、<code>duplicate</code>、<code>CompositeByteBuf</code></li>
</ul>
<h1 id="双向通信"><a href="#双向通信" class="headerlink" title="双向通信"></a>双向通信</h1><p>实现一个 echo server</p>
<p>服务端：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new ServerBootstrap()</span><br><span class="line">    .group(new NioEventLoopGroup())</span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected void initChannel(NioSocketChannel ch) &#123;</span><br><span class="line">            ch.pipeline().addLast(new ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;</span><br><span class="line">                    ByteBuf buffer = (ByteBuf) msg;</span><br><span class="line">                    System.out.println(buffer.toString(Charset.defaultCharset()));</span><br><span class="line"></span><br><span class="line">                    // 建议使用 ctx.alloc() 创建 ByteBuf</span><br><span class="line">                    ByteBuf response = ctx.alloc().buffer();</span><br><span class="line">                    response.writeBytes(buffer);</span><br><span class="line">                    ctx.writeAndFlush(response);</span><br><span class="line"></span><br><span class="line">                    // 思考：需要释放 buffer 吗</span><br><span class="line">                    // 思考：需要释放 response 吗</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).bind(8080);</span><br></pre></td></tr></table></figure>
<p>客户端：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NioEventLoopGroup group = new NioEventLoopGroup();</span><br><span class="line">Channel channel = new Bootstrap()</span><br><span class="line">    .group(group)</span><br><span class="line">    .channel(NioSocketChannel.class)</span><br><span class="line">    .handler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected void initChannel(NioSocketChannel ch) throws Exception &#123;</span><br><span class="line">            ch.pipeline().addLast(new StringEncoder());</span><br><span class="line">            ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;</span><br><span class="line">                    ByteBuf buffer = (ByteBuf) msg;</span><br><span class="line">                    System.out.println(buffer.toString(Charset.defaultCharset()));</span><br><span class="line"></span><br><span class="line">                    // 思考：需要释放 buffer 吗</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).connect(&quot;127.0.0.1&quot;, 8080).sync().channel();</span><br><span class="line"></span><br><span class="line">channel.closeFuture().addListener(future -&gt; &#123;</span><br><span class="line">    group.shutdownGracefully();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">new Thread(() -&gt; &#123;</span><br><span class="line">    Scanner scanner = new Scanner(System.in);</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        String line = scanner.nextLine();</span><br><span class="line">        if (&quot;q&quot;.equals(line)) &#123;</span><br><span class="line">            channel.close();</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        channel.writeAndFlush(line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<h2 id="💡读和写的误解"><a href="#💡读和写的误解" class="headerlink" title="💡读和写的误解"></a>💡读和写的误解</h2><p>我最初在认识上有这样的误区，认为只有在 netty，nio 这样的多路复用 IO 模型时，读写才不会相互阻塞，才可以实现高效的双向通信，但实际上，Java Socket 是全双工的：在任意时刻，线路上存在A 到 B 和 B 到 A 的双向信号传输。即使是阻塞 IO，读和写是可以同时进行的，只要分别采用读线程和写线程即可，读不会阻塞写、写也不会阻塞读</p>
]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>Java网络编程教程-Netty深入浅出全套教程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java网络编程教程|Netty深入浅出全套教程——NIO基础（一）</title>
    <url>/2022/01/22/netty/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B%E2%80%94%E2%80%94NIO%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p><strong>non-blocking io 非阻塞IO</strong></p>
<h1 id="三大组件"><a href="#三大组件" class="headerlink" title="三大组件"></a>三大组件</h1><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a><code>Channel</code></h2><p><code>channel</code>优点类似于<code>stream</code>，它就是读写数据的<strong>双向通道</strong>，可以从<code>channel</code>将数据读写到<code>buffer</code>，也可以将<code>buffer</code>的数据读写到<code>channel</code>，而之前的<code>stream</code>要么是输入，要么是输出，<code>channel</code>比<code>stream</code>更为底层    </p>
<img src="http://www.plantuml.com/plantuml/svg/AqfDBadCIyz9LKZEICpBIytXAeAB99McfQKMSK4b57Jje08G2iY7wG40">

<p><strong>常用的<code>channel</code>有：</strong>  </p>
<ul>
<li>FileChannel</li>
<li>DatagramChannel</li>
<li>SocketChannel</li>
<li>ServerSocketChannel</li>
</ul>
<h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a><code>Buffer</code></h2><p><code>buffer</code>用来缓冲数据<br><strong>常见大的<code>buffer</code>有：</strong>  </p>
<ul>
<li>ByteBuffer<ul>
<li>MappedByteBuffer</li>
<li>DirectByteBuffer</li>
<li>HeapByteBuffer</li>
</ul>
</li>
<li>ShortBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>FloatBuffer</li>
<li>DoubleBuffer</li>
<li>CharBuffer</li>
</ul>
<h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a><code>Selector</code></h2><p>选择器，<code>selector</code>单从字面以上不好理解，需要结合服务器的设计宴会来理解它的用途</p>
<p><strong>服务器设置演化过程</strong></p>
<h3 id="多线程版设计"><a href="#多线程版设计" class="headerlink" title="多线程版设计"></a>多线程版设计</h3><img src="http://www.plantuml.com/plantuml/svg/AqfDBadCIyz9LNYwPDRpNVkVh-X-tjcXKCrL19SeoIXAJKmnn10nmX0nHX8fpa_EJYqnn10nmX0nveBQeA2hQmVN1xK3ISm8AcQC96RCLGi0">

<h4 id="多线程版缺点"><a href="#多线程版缺点" class="headerlink" title="多线程版缺点"></a>多线程版缺点</h4><p>服务端每来一个请求创建一个线程去处理，每个线程的创建都是需要成本的，会占用一定的内存，如果同时有大量的请求进来，就会创建大量的线程，占用大量内存，CPU因为核数有限，所以同时能够处理的线程是有限的，线程过多就会导致CPU不停的切换线程进行执行，每次切换都需要把原有线程的数据保存，然后加载新线程的数据  </p>
<ul>
<li>内存占用高</li>
<li>线程上下文切换成本高</li>
<li>只适合连接数少的场景</li>
</ul>
<h3 id="线程池版设计"><a href="#线程池版设计" class="headerlink" title="线程池版设计"></a>线程池版设计</h3><img src="http://www.plantuml.com/plantuml/svg/AqfDBadCIyz9LNY-Q__p5TtFDYvutjcXKCrL19SeoIXAJKmnn10nGX8fpa_EJYqnn131L6EC8MB21RL1GLVN3cuIJ4nFpmvk5jHU97N6S364EXEkMW00">

<h4 id="线程池版缺点"><a href="#线程池版缺点" class="headerlink" title="线程池版缺点"></a>线程池版缺点</h4><p>同一个线程在同一事件仅能处理一个请求，如果这个请求需要处理的内容比较耗时，就会影响到其他的请求的处理，同时如果有一些下载操作或者其他的需要长连接的操作，也会导致一个请求长时间独占一个线程，因为线程池中的线程是有一定数量的，如果有大量这种请求，就会导致剩余的请求无线程进行处理  </p>
<ul>
<li>阻塞模式下，线程同一时间仅能处理一个socket连接</li>
<li>仅适合短链接场景</li>
</ul>
<h3 id="selector版设计"><a href="#selector版设计" class="headerlink" title="selector版设计"></a>selector版设计</h3><p><code>selector</code>的作用就是配合一个线程来管理多个<code>channel</code>，获取这些<code>channel</code>上发生的事件，这些<code>channel</code>工作在非阻塞模式下，不会让线程吊死在一个<code>channel</code>上面。适合连接数特别多，但流量低的场景（low traffic）</p>
<img src="http://www.plantuml.com/plantuml/svg/AqfDBadCIyz9LIXEpG6oyukUTtOeL7CLmSLBCefI4rEG160AaOIICnBpyd9I3J65Z325ZBaWHYhewjeX38CnmA9myx296c4LDUQg1G00">

<p>调用<code>selector</code>的<code>select()</code>会阻塞直到<code>channel</code>发生了读写就绪事件，这些事件发生，<code>select</code>方法就会返回这些事件交给<code>thread</code>来处理  </p>
<p><code>selector</code>可以监控多个<code>channel</code>，当某一个<code>channel</code>上面发生了事件，就会通知<code>selector</code>，<code>selector</code>就会调用线程去处理，但是如果一个channel发送了大量的数据，就会导致线程长时间处理当前的事件，导致其他的事件等待  </p>
<h1 id="ByteBuffer"><a href="#ByteBuffer" class="headerlink" title="ByteBuffer"></a><code>ByteBuffer</code></h1><h2 id="ByteBuffer正确的使用姿势"><a href="#ByteBuffer正确的使用姿势" class="headerlink" title="ByteBuffer正确的使用姿势"></a><code>ByteBuffer</code>正确的使用姿势</h2><ul>
<li>向<code>Buffer</code>写入数据，列如调用<code>channel.read(buffer)</code></li>
<li>调用<code>flip()</code>切换至<strong>读模式</strong></li>
<li>从<code>buffer</code>读取数据，列如调用<code>buffer.get()</code></li>
<li>调用<code>clear()</code>或<code>compact()</code>切换至<strong>写模式</strong></li>
<li>重复上面步骤</li>
</ul>
<h2 id="ByteBuffer结构"><a href="#ByteBuffer结构" class="headerlink" title="ByteBuffer结构"></a><code>ByteBuffer</code>结构</h2><h3 id="ByteBuffer有以下重要属性"><a href="#ByteBuffer有以下重要属性" class="headerlink" title="ByteBuffer有以下重要属性"></a><code>ByteBuffer</code>有以下重要属性</h3><ul>
<li><code>capacity</code>   容量，<code>buffer</code>里面能装多少数据</li>
<li><code>position</code>   读写指针</li>
<li><code>limit</code>      读写的限制，应该读多少字节，应该写多少字节</li>
</ul>
<p><strong>写入数据过程：</strong><br>一开始，假设指定<code>buffer</code>的容量是10，那么<code>capacity</code>就是10，因为最开始<code>buffer</code>是空的，所以最开始的时候，<code>position</code>指针就在最开始的位置，至于能写的数目，最开始是跟整个容量相同的，所以此时<code>limit</code>等于<code>capacity</code><br><img src="/2022/01/22/netty/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B%E2%80%94%E2%80%94NIO%E5%9F%BA%E7%A1%80/Buffer%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE%E8%BF%87%E7%A8%8B%E4%B8%80.png" alt="Buffer写入数据过程一"><br>写模式下，<code>position</code>是写入位置，<code>limit</code>等于容量，下图标识写入了4个字节后的状态<br>每写入一个字节，<code>position</code>都会向后移动以一位<br><img src="/2022/01/22/netty/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B%E2%80%94%E2%80%94NIO%E5%9F%BA%E7%A1%80/Buffer%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE%E8%BF%87%E7%A8%8B%E4%BA%8C.png" alt="Buffer写入数据过程二"><br><code>flip</code>动作发生后（切换到读模式之后），<code>position</code>切换为读取位置，<code>limit</code>切换为读取限制<br>假设如下图，<code>buffer</code>中写入了4个字节，调用<code>flip</code>方法切换到读模式之后，会将<code>position</code>指针的位置切换到0，因为读取数据需要从第一位开始读，<code>limit</code>会被指向4，因为当前只有四个元素，后面的空位读取也没有意义<br><img src="/2022/01/22/netty/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B%E2%80%94%E2%80%94NIO%E5%9F%BA%E7%A1%80/Buffer%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE%E8%BF%87%E7%A8%8B%E4%B8%89.png" alt="Buffer写入数据过程三"><br>读取4个字节后，状态<br>假设是调用<code>get</code>方法，每次读取一个字节，调用一次<code>position</code>指针会从0指向1，再次调用会从1指向2，一直到和limit相同之后代表已经读完当前<code>buffer</code>中的数据<br><img src="/2022/01/22/netty/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B%E2%80%94%E2%80%94NIO%E5%9F%BA%E7%A1%80/Buffer%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE%E8%BF%87%E7%A8%8B%E5%9B%9B.png" alt="Buffer写入数据过程四"><br><code>clear</code>动作发生后，状态<br>相当于是将整个<code>buffer</code>重置，position回到起始位置，<code>limit</code>也和<code>capacity</code>相同，表示当前<code>buffer</code>是空的，全部空间都可以写入<br><img src="/2022/01/22/netty/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B%E2%80%94%E2%80%94NIO%E5%9F%BA%E7%A1%80/Buffer%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE%E8%BF%87%E7%A8%8B%E4%BA%94.png" alt="Buffer写入数据过程五"><br><code>compact</code>方法，是把未读完的部分向前压缩，然后切换到写模式<br>假设由于一些原因，可能当前<code>buffer</code>中的数据还没有读完，就需要再次写入，假设有四个字节的数据，当前只读了两个，调用<code>compact</code>方法后，会将前面两个已经读取过的数据清除，后面未读取的数据前移，同时<code>position</code>指针则指向第三个位置，表示只能从这个位置开始写入，<code>limit</code>同样和<code>capacity</code>相同，表示可以写到这个位置<br><img src="/2022/01/22/netty/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B%E2%80%94%E2%80%94NIO%E5%9F%BA%E7%A1%80/Buffer%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE%E8%BF%87%E7%A8%8B%E5%85%AD.png" alt="Buffer写入数据过程六"></p>
<h3 id="方法演示"><a href="#方法演示" class="headerlink" title="方法演示"></a>方法演示</h3><p>用到了下面的工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.util.internal.MathUtil;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.internal.StringUtil;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.internal.MathUtil.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBufferUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span>[] BYTE2CHAR = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span>[] HEXDUMP_TABLE = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">256</span> * <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] HEXPADDING = <span class="keyword">new</span> String[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] HEXDUMP_ROWPREFIXES = <span class="keyword">new</span> String[<span class="number">65536</span> &gt;&gt;&gt; <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] BYTE2HEX = <span class="keyword">new</span> String[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] BYTEPADDING = <span class="keyword">new</span> String[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] DIGITS = <span class="string">&quot;0123456789abcdef&quot;</span>.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">            HEXDUMP_TABLE[i &lt;&lt; <span class="number">1</span>] = DIGITS[i &gt;&gt;&gt; <span class="number">4</span> &amp; <span class="number">0x0F</span>];</span><br><span class="line">            HEXDUMP_TABLE[(i &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>] = DIGITS[i &amp; <span class="number">0x0F</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the lookup table for hex dump paddings</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; HEXPADDING.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> padding = HEXPADDING.length - i;</span><br><span class="line">            StringBuilder buf = <span class="keyword">new</span> StringBuilder(padding * <span class="number">3</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; padding; j++) &#123;</span><br><span class="line">                buf.append(<span class="string">&quot;   &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            HEXPADDING[i] = buf.toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the lookup table for the start-offset header in each row (up to 64KiB).</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; HEXDUMP_ROWPREFIXES.length; i++) &#123;</span><br><span class="line">            StringBuilder buf = <span class="keyword">new</span> StringBuilder(<span class="number">12</span>);</span><br><span class="line">            buf.append(StringUtil.NEWLINE);</span><br><span class="line">            buf.append(Long.toHexString(i &lt;&lt; <span class="number">4</span> &amp; <span class="number">0xFFFFFFFFL</span> | <span class="number">0x100000000L</span>));</span><br><span class="line">            buf.setCharAt(buf.length() - <span class="number">9</span>, <span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">            buf.append(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">            HEXDUMP_ROWPREFIXES[i] = buf.toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the lookup table for byte-to-hex-dump conversion</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BYTE2HEX.length; i++) &#123;</span><br><span class="line">            BYTE2HEX[i] = <span class="string">&#x27; &#x27;</span> + StringUtil.byteToHexStringPadded(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the lookup table for byte dump paddings</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BYTEPADDING.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> padding = BYTEPADDING.length - i;</span><br><span class="line">            StringBuilder buf = <span class="keyword">new</span> StringBuilder(padding);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; padding; j++) &#123;</span><br><span class="line">                buf.append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            BYTEPADDING[i] = buf.toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the lookup table for byte-to-char conversion</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BYTE2CHAR.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= <span class="number">0x1f</span> || i &gt;= <span class="number">0x7f</span>) &#123;</span><br><span class="line">                BYTE2CHAR[i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                BYTE2CHAR[i] = (<span class="keyword">char</span>) i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印所有内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> buffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">debugAll</span><span class="params">(ByteBuffer buffer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> oldlimit = buffer.limit();</span><br><span class="line">        buffer.limit(buffer.capacity());</span><br><span class="line">        StringBuilder origin = <span class="keyword">new</span> StringBuilder(<span class="number">256</span>);</span><br><span class="line">        appendPrettyHexDump(origin, buffer, <span class="number">0</span>, buffer.capacity());</span><br><span class="line">        System.out.println(<span class="string">&quot;+--------+-------------------- all ------------------------+----------------+&quot;</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;position: [%d], limit: [%d]\n&quot;</span>, buffer.position(), oldlimit);</span><br><span class="line">        System.out.println(origin);</span><br><span class="line">        buffer.limit(oldlimit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印可读取内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> buffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">debugRead</span><span class="params">(ByteBuffer buffer)</span> </span>&#123;</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="number">256</span>);</span><br><span class="line">        appendPrettyHexDump(builder, buffer, buffer.position(), buffer.limit() - buffer.position());</span><br><span class="line">        System.out.println(<span class="string">&quot;+--------+-------------------- read -----------------------+----------------+&quot;</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;position: [%d], limit: [%d]\n&quot;</span>, buffer.position(), buffer.limit());</span><br><span class="line">        System.out.println(builder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">appendPrettyHexDump</span><span class="params">(StringBuilder dump, ByteBuffer buf, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (MathUtil.isOutOfBounds(offset, length, buf.capacity())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(</span><br><span class="line">                    <span class="string">&quot;expected: &quot;</span> + <span class="string">&quot;0 &lt;= offset(&quot;</span> + offset + <span class="string">&quot;) &lt;= offset + length(&quot;</span> + length</span><br><span class="line">                            + <span class="string">&quot;) &lt;= &quot;</span> + <span class="string">&quot;buf.capacity(&quot;</span> + buf.capacity() + <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dump.append(</span><br><span class="line">                <span class="string">&quot;         +-------------------------------------------------+&quot;</span> +</span><br><span class="line">                        StringUtil.NEWLINE + <span class="string">&quot;         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |&quot;</span> +</span><br><span class="line">                        StringUtil.NEWLINE + <span class="string">&quot;+--------+-------------------------------------------------+----------------+&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> startIndex = offset;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> fullRows = length &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> remainder = length &amp; <span class="number">0xF</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dump the rows which have 16 bytes.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; fullRows; row++) &#123;</span><br><span class="line">            <span class="keyword">int</span> rowStartIndex = (row &lt;&lt; <span class="number">4</span>) + startIndex;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Per-row prefix.</span></span><br><span class="line">            appendHexDumpRowPrefix(dump, row, rowStartIndex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Hex dump</span></span><br><span class="line">            <span class="keyword">int</span> rowEndIndex = rowStartIndex + <span class="number">16</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = rowStartIndex; j &lt; rowEndIndex; j++) &#123;</span><br><span class="line">                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);</span><br><span class="line">            &#125;</span><br><span class="line">            dump.append(<span class="string">&quot; |&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ASCII dump</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = rowStartIndex; j &lt; rowEndIndex; j++) &#123;</span><br><span class="line">                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);</span><br><span class="line">            &#125;</span><br><span class="line">            dump.append(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dump the last row which has less than 16 bytes.</span></span><br><span class="line">        <span class="keyword">if</span> (remainder != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> rowStartIndex = (fullRows &lt;&lt; <span class="number">4</span>) + startIndex;</span><br><span class="line">            appendHexDumpRowPrefix(dump, fullRows, rowStartIndex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Hex dump</span></span><br><span class="line">            <span class="keyword">int</span> rowEndIndex = rowStartIndex + remainder;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = rowStartIndex; j &lt; rowEndIndex; j++) &#123;</span><br><span class="line">                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);</span><br><span class="line">            &#125;</span><br><span class="line">            dump.append(HEXPADDING[remainder]);</span><br><span class="line">            dump.append(<span class="string">&quot; |&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Ascii dump</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = rowStartIndex; j &lt; rowEndIndex; j++) &#123;</span><br><span class="line">                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);</span><br><span class="line">            &#125;</span><br><span class="line">            dump.append(BYTEPADDING[remainder]);</span><br><span class="line">            dump.append(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dump.append(StringUtil.NEWLINE +</span><br><span class="line">                <span class="string">&quot;+--------+-------------------------------------------------+----------------+&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">appendHexDumpRowPrefix</span><span class="params">(StringBuilder dump, <span class="keyword">int</span> row, <span class="keyword">int</span> rowStartIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row &lt; HEXDUMP_ROWPREFIXES.length) &#123;</span><br><span class="line">            dump.append(HEXDUMP_ROWPREFIXES[row]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dump.append(StringUtil.NEWLINE);</span><br><span class="line">            dump.append(Long.toHexString(rowStartIndex &amp; <span class="number">0xFFFFFFFFL</span> | <span class="number">0x100000000L</span>));</span><br><span class="line">            dump.setCharAt(dump.length() - <span class="number">9</span>, <span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">            dump.append(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">short</span> <span class="title">getUnsignedByte</span><span class="params">(ByteBuffer buffer, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">short</span>) (buffer.get(index) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体测试代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestByteBufferReadWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">        buffer.put((<span class="keyword">byte</span>) <span class="number">0x61</span>);<span class="comment">//&#x27;a&#x27;</span></span><br><span class="line">        ByteBufferUtil.debugAll(buffer);</span><br><span class="line">        buffer.put(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">0x62</span>,<span class="number">0x63</span>,<span class="number">0x64</span>&#125;);<span class="comment">//b   c   d</span></span><br><span class="line">        ByteBufferUtil.debugAll(buffer);</span><br><span class="line">        <span class="comment">//不切换到读模式，直接读取数据，因为当前指针position指向的是下一个要写入的下标，buffer原本是空的，所以读取出来的是0</span></span><br><span class="line"><span class="comment">//        System.out.println(buffer.get());//0</span></span><br><span class="line">        buffer.flip();<span class="comment">//切换到读模式</span></span><br><span class="line">        System.out.println(buffer.get());</span><br><span class="line">        ByteBufferUtil.debugAll(buffer);</span><br><span class="line">        buffer.compact();</span><br><span class="line">        ByteBufferUtil.debugAll(buffer);</span><br><span class="line">        buffer.put(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">0x65</span>,<span class="number">0x6f</span>&#125;);</span><br><span class="line">        ByteBufferUtil.debugAll(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：（添加了一些描述）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//写入了0x61 也就是字符a，position指针指向1，表示下一个数据从1开始插入</span><br><span class="line">+--------+-------------------- all ------------------------+----------------+</span><br><span class="line">position: [1], limit: [10]</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 61 00 00 00 00 00 00 00 00 00                   |a.........      |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">//批量插入三个字符：0x62,0x63,0x64（b c d），加上上面的写入的一个字符，一共是四个字符，</span><br><span class="line">//所以position指向下标为4的位置，也就是第5个字符位，表示下一个数据从第5个开始</span><br><span class="line">+--------+-------------------- all ------------------------+----------------+</span><br><span class="line">position: [4], limit: [10]</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 61 62 63 64 00 00 00 00 00 00                   |abcd......      |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">//切换为读模式之后，调用get()方法打印一个字符，是第一个插入的字符a，直接打印为10进制97，</span><br><span class="line">//如果不切换读模式直接读取，那么读到的是上面position指向的下标为4的数据，也就是0</span><br><span class="line">97</span><br><span class="line">//此时下标为0，也就是第一个数据已经打印，position指向下标为1的位置（切换为读模式之后，position指向0位，读取一位后指向1位），</span><br><span class="line">//limit为限制位，当前只有四个数据，所以limit为4，也就是指向下标为4的第5位，表示最多只能读取到这一位</span><br><span class="line">+--------+-------------------- all ------------------------+----------------+</span><br><span class="line">position: [1], limit: [4]</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 61 62 63 64 00 00 00 00 00 00                   |abcd......      |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">//调用compact()方法切换到写模式，该方法会保留未读取的数据，之前一共写入了4个数据，读出了一个，还剩3个未读，</span><br><span class="line">//会将后面的三个数据前移，同时position也会指向3，现在第4位，也就是下标为3的数据位不是空是之前遗留的脏数据，</span><br><span class="line">//下次写入数据的时候会从下标3开始写入，会将该数据覆盖</span><br><span class="line">+--------+-------------------- all ------------------------+----------------+</span><br><span class="line">position: [3], limit: [10]</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 62 63 64 64 00 00 00 00 00 00                   |bcdd......      |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">//写入两个字符之后，已经将第4位遗留的脏数据覆盖，同时position也已经指向到了5</span><br><span class="line">+--------+-------------------- all ------------------------+----------------+</span><br><span class="line">position: [5], limit: [10]</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 62 63 64 65 6f 00 00 00 00 00                   |bcdeo.....      |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>

<h2 id="ByteBuffer常见的方法"><a href="#ByteBuffer常见的方法" class="headerlink" title="ByteBuffer常见的方法"></a><code>ByteBuffer</code>常见的方法</h2><h3 id="分配空间"><a href="#分配空间" class="headerlink" title="分配空间"></a>分配空间</h3><p>可以使用<code>allocate</code>方法为<code>ByteBuffer</code>分配空间，其他的<code>Buffer</code>也有类似的方法<br><code>buffer</code>分配空间后不能动态调整空间大小，空间大固定  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocate(10);</span><br></pre></td></tr></table></figure>
<p><code>allocate()</code>和<code>allocateDirect()</code>方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>类型</th>
<th>内存</th>
<th>效率</th>
<th>GC</th>
<th>分配</th>
</tr>
</thead>
<tbody><tr>
<td>allocate()</td>
<td>class java.nio.HeapByteBuffer</td>
<td>java堆内存</td>
<td>读写效率较低</td>
<td>受GC影响</td>
<td></td>
</tr>
<tr>
<td>allocateDirect()</td>
<td>class java.nio.DirectByteBuffer</td>
<td>直接内存</td>
<td>读写效率高（少一次拷贝）</td>
<td>不受GC影响（因为不受GC控制，所以如果不能及时回收会占用大量服务器内存）</td>
<td>分配的效率低（选哟调用服务器函数分配）</td>
</tr>
</tbody></table>
<h3 id="向buffer写入数据"><a href="#向buffer写入数据" class="headerlink" title="向buffer写入数据"></a>向<code>buffer</code>写入数据</h3><p>有两种方法：  </p>
<ul>
<li>调用<code>channel</code>的<code>read</code>方法</li>
<li>调用<code>buffer</code>的<code>put</code>方法<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int readBytes = channel.read(buf);</span><br></pre></td></tr></table></figure>
和  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">buf.read((byte)127);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="从buffer中读取数据"><a href="#从buffer中读取数据" class="headerlink" title="从buffer中读取数据"></a>从<code>buffer</code>中读取数据</h3><p>同样有两种放法：  </p>
<ul>
<li>调用<code>channel</code>的<code>write</code>方法</li>
<li>嗲用<code>buffer</code>自己的<code>get</code>方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int writeBytes = channel.write(buf);</span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">byte b = buf.get();</span><br></pre></td></tr></table></figure>
<p><code>get</code>方法会然让<code>position</code>指针向后走，如果想要重复读取数据</p>
<ul>
<li>可以调用<code>rewind</code>方法将<code>position</code>重置为0</li>
<li>或者调用<code>get(int i)</code>方法获取索引i的内容，它不会移动指针  </li>
</ul>
<h3 id="mark-和-reset"><a href="#mark-和-reset" class="headerlink" title="mark 和 reset"></a><code>mark</code> 和 <code>reset</code></h3><p><code>mark</code>是在读取时，做一个标记，即使<code>position</code>改变，只要调用<code>reset</code>就能回到<code>mark</code>的位置</p>
<p><font color="red"><strong>注意：</strong></font><br><code>rewind</code>和<code>flip</code>都会清除<code>mark</code>位置  </p>
<h3 id="方法演示-1"><a href="#方法演示-1" class="headerlink" title="方法演示"></a>方法演示</h3><p><strong><code>rewind</code></strong>  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBufferRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">        buffer.put(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>&#125;);</span><br><span class="line">        buffer.flip();<span class="comment">//切换读模式</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//从头开始读</span></span><br><span class="line">        <span class="comment">//将buffer中的数据读到一个4位的数组中，此时position会移动到下标为4的位置</span></span><br><span class="line">        buffer.get(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>]);</span><br><span class="line">        ByteBufferUtil.debugAll(buffer);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">+--------+-------------------- all ------------------------+----------------+</span></span><br><span class="line"><span class="comment">position: [4], limit: [4]</span></span><br><span class="line"><span class="comment">         +-------------------------------------------------+</span></span><br><span class="line"><span class="comment">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span></span><br><span class="line"><span class="comment">+--------+-------------------------------------------------+----------------+</span></span><br><span class="line"><span class="comment">|00000000| 00 00 00 00 00 00 00 00 00 00                   |..........      |</span></span><br><span class="line"><span class="comment">+--------+-------------------------------------------------+----------------+</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//rewind从头开始读，将position重置为0</span></span><br><span class="line">        buffer.rewind();</span><br><span class="line">        <span class="comment">//存进去了4个字节，上面读出了4个字节，这里调用了rewind方法重置，所以读出的应该是第一个字节 a</span></span><br><span class="line">        System.out.println((<span class="keyword">char</span>) buffer.get());<span class="comment">// a</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>mark &amp; reset</code></strong>  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBufferRead</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">        buffer.put(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>&#125;);</span><br><span class="line">        buffer.flip();<span class="comment">//切换读模式</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//mark &amp; reset</span></span><br><span class="line">        <span class="comment">//mark 做一个标记，记录 position 位置，reset 是将 position 重置到 mark 记录的位置</span></span><br><span class="line">        System.out.println((<span class="keyword">char</span>)buffer.get());<span class="comment">//读取第一个字节，position指向1的位置   a</span></span><br><span class="line">        System.out.println((<span class="keyword">char</span>)buffer.get());<span class="comment">//读取第二个自己，position指向2的位置   b</span></span><br><span class="line">        buffer.mark();<span class="comment">//使用mark方法记录当前的位置，也就是索引为2的位置</span></span><br><span class="line">        System.out.println((<span class="keyword">char</span>)buffer.get());<span class="comment">//读取第3个字节，position指向3的位置    c</span></span><br><span class="line">        System.out.println((<span class="keyword">char</span>)buffer.get());<span class="comment">//读取第4个字节，position指向4的位置    d</span></span><br><span class="line">        buffer.reset();<span class="comment">//使用reset方法将position重置到之前mark记录的位置，也就是下标2，后面继续读取</span></span><br><span class="line">        System.out.println((<span class="keyword">char</span>)buffer.get());<span class="comment">//重新读取第3个字节                    c</span></span><br><span class="line">        System.out.println((<span class="keyword">char</span>)buffer.get());<span class="comment">//重新读取第4个字节                    d</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>get(i)</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBufferRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">        buffer.put(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>&#125;);</span><br><span class="line">        buffer.flip();<span class="comment">//切换读模式</span></span><br><span class="line">        System.out.println((<span class="keyword">char</span>) buffer.get(<span class="number">3</span>));<span class="comment">//直接通过下标获取最后一个字节，d</span></span><br><span class="line">        ByteBufferUtil.debugAll(buffer);</span><br><span class="line">        <span class="comment">//position位置依然是0，并没有因为get方法而改变</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">+--------+-------------------- all ------------------------+----------------+</span></span><br><span class="line"><span class="comment">position: [0], limit: [4]</span></span><br><span class="line"><span class="comment">         +-------------------------------------------------+</span></span><br><span class="line"><span class="comment">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span></span><br><span class="line"><span class="comment">+--------+-------------------------------------------------+----------------+</span></span><br><span class="line"><span class="comment">|00000000| 61 62 63 64 00 00 00 00 00 00                   |abcd......      |</span></span><br><span class="line"><span class="comment">+--------+-------------------------------------------------+----------------+</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串和ByteBuffer之间互相转换"><a href="#字符串和ByteBuffer之间互相转换" class="headerlink" title="字符串和ByteBuffer之间互相转换"></a>字符串和<code>ByteBuffer</code>之间互相转换</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestByteBufferString</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.字符串转为ByteBuffer</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">        buffer.put(<span class="string">&quot;hello&quot;</span>.getBytes());</span><br><span class="line">        ByteBufferUtil.debugAll(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.Charset</span></span><br><span class="line">        <span class="comment">//调用该方法生成的buffer是已经切换到读模式之后的，position指向0</span></span><br><span class="line">        ByteBuffer buffer1 = StandardCharsets.UTF_8.encode(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        ByteBufferUtil.debugAll(buffer1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.wrap</span></span><br><span class="line">        <span class="comment">//调用该方法生成的buffer是已经切换到读模式之后的，position指向0</span></span><br><span class="line">        ByteBuffer buffer2 = ByteBuffer.wrap(<span class="string">&quot;hello&quot;</span>.getBytes());</span><br><span class="line">        ByteBufferUtil.debugAll(buffer2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//buffer转字符串，第一个因为是直接写入的，所以需要切换到读模式之后才能转字符串，不然转出来的是空</span></span><br><span class="line">        <span class="comment">//后面两个因为已经是读模式了，可以直接转字符串</span></span><br><span class="line">        String str = StandardCharsets.UTF_8.decode(buffer2).toString();</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Buffer的线程安全"><a href="#Buffer的线程安全" class="headerlink" title="Buffer的线程安全"></a>Buffer的线程安全</h3><p><font color="red">buffer是非线程安全的</font></p>
<h2 id="Scattering-Reads"><a href="#Scattering-Reads" class="headerlink" title="Scattering Reads"></a>Scattering Reads</h2><p>分散读取，有一个文本<code>test.txt</code><br>如下数据，可以选择一次把数据读取到一个<code>buffer</code>中，然后再进行分割，不过因为每段的长度是已经知道的，所以可以直接读取到三个<code>buffer</code>中  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">onetwothree</span><br></pre></td></tr></table></figure>
<p>使用如下方式读取，可以将数据填充至多个buffer  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestScatteringReads</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (FileChannel channel = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;netty-demo/test.txt&quot;</span>,<span class="string">&quot;r&quot;</span>).getChannel())&#123;</span><br><span class="line">            ByteBuffer b1 = ByteBuffer.allocate(<span class="number">3</span>);</span><br><span class="line">            ByteBuffer b2 = ByteBuffer.allocate(<span class="number">3</span>);</span><br><span class="line">            ByteBuffer b3 = ByteBuffer.allocate(<span class="number">4</span>);</span><br><span class="line">            channel.read(<span class="keyword">new</span> ByteBuffer[]&#123;b1,b2,b3&#125;);</span><br><span class="line">            b1.flip();</span><br><span class="line">            b2.flip();</span><br><span class="line">            b3.flip();</span><br><span class="line">            ByteBufferUtil.debugAll(b1);</span><br><span class="line">            ByteBufferUtil.debugAll(b2);</span><br><span class="line">            ByteBufferUtil.debugAll(b3);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Gathering-Write"><a href="#Gathering-Write" class="headerlink" title="Gathering Write"></a>Gathering Write</h2><p>集中写，假设需要把多个<code>buffer</code>写入到同一个文件中，可以先把多个<code>buffer</code>汇总成一个<code>buffer</code>，也可以使用下面的方法一次性写入  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGatheringWrites</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ByteBuffer b1 = StandardCharsets.UTF_8.encode(<span class="string">&quot;hello &quot;</span>);</span><br><span class="line">        ByteBuffer b2 = StandardCharsets.UTF_8.encode(<span class="string">&quot;world!&quot;</span>);</span><br><span class="line">        ByteBuffer b3 = StandardCharsets.UTF_8.encode(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> (FileChannel channel = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;netty-demo/test1.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>).getChannel();)&#123;</span><br><span class="line">            channel.write(<span class="keyword">new</span> ByteBuffer[]&#123;b1,b2,b3&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="黏包-半包"><a href="#黏包-半包" class="headerlink" title="黏包/半包"></a>黏包/半包</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestByteBufferExam</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    网络上有多条数据发送给服务端，数据之间使用\n进行分割</span></span><br><span class="line"><span class="comment">    但是由于某些原因这些数据在接收的时候，被进行了重新组合，例如原始数据有3条：</span></span><br><span class="line"><span class="comment">    Hello World\n</span></span><br><span class="line"><span class="comment">    I&#x27;m zhangshan\n</span></span><br><span class="line"><span class="comment">    How are you?\n</span></span><br><span class="line"><span class="comment">    变成了下面的两个buffer （黏包，半包）</span></span><br><span class="line"><span class="comment">        黏包：多条数据合并成一条数据</span></span><br><span class="line"><span class="comment">        半包：一条消息被截断成了多条</span></span><br><span class="line"><span class="comment">        （因为效率问题，将多条数据合并成一条数据发送，就会有黏包的现象）</span></span><br><span class="line"><span class="comment">        （半包是因为服务器buffer大小有限制，如果数据的长度超过了buffer的大小，就会分两次读取，就会出现半包的现象）</span></span><br><span class="line"><span class="comment">    Hello World\nI&#x27;m zhangshan\nHo</span></span><br><span class="line"><span class="comment">    w are you?\n</span></span><br><span class="line"><span class="comment">    现在需要你编写程序，将错乱的数据恢复成原始的按\n分割的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ByteBuffer source = ByteBuffer.allocate(<span class="number">32</span>);</span><br><span class="line">        source.put(<span class="string">&quot;Hello World\nI&#x27;m zhangshan\nHo&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        split(source);</span><br><span class="line">        source.put(<span class="string">&quot;w are you?\n&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        split(source);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(ByteBuffer source)</span> </span>&#123;</span><br><span class="line">        source.flip();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; source.limit(); i++) &#123;</span><br><span class="line">            <span class="comment">//读取每一个字节，判断到\n的时候表示找到一条完整的消息</span></span><br><span class="line">            <span class="comment">//get(i)不会导致指针移动</span></span><br><span class="line">            <span class="keyword">if</span> (source.get(i) == <span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> length = i+<span class="number">1</span>-source.position();</span><br><span class="line">                ByteBuffer target = ByteBuffer.allocate(length);</span><br><span class="line">                <span class="comment">//从 source 向 target 写</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">                    target.put(source.get());</span><br><span class="line">                &#125;</span><br><span class="line">                ByteBufferUtil.debugAll(target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        source.compact();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="文件编程"><a href="#文件编程" class="headerlink" title="文件编程"></a>文件编程</h1><h2 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a><code>FileChannel</code></h2><blockquote>
<p><code>FileChannel</code>只能工作在阻塞模式下  </p>
</blockquote>
<h3 id="获取-FileChannel"><a href="#获取-FileChannel" class="headerlink" title="获取 FileChannel"></a>获取 <code>FileChannel</code></h3><p>不能直接打开<code>FileChannel</code>，必须通过<code>FileInputStream</code>、<code>FileOutputStream</code>或者<code>RandomAccessFile</code>来获取<code>FileChannel</code>，它们都有<code>getChannel</code>方法  </p>
<ul>
<li>通过<code>FileInputStream</code>获取的<code>channel</code>只能读</li>
<li>通过<code>FileOutputStream</code>获取的<code>channel</code>只能写</li>
<li>通过<code>RandomAccessFile</code>获取的<code>channel</code>是否能读写根据构造<code>RandomAccessFile</code>时的读写模式决定  </li>
</ul>
<h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><p>会从<code>channel</code>读取数据填充<code>ByteBuffer</code>，返回值表示读到了多少字节，-1表示到达了文件的末尾  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int readBytes = channel.read(buffer);</span><br></pre></td></tr></table></figure>

<h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><p>写入的正确姿势如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ByteBuffer buffer = ...;</span><br><span class="line">buffer.put(...);//存入数据</span><br><span class="line">buffer.flip();//切换读模式</span><br><span class="line">while(buffer.hasRemaining())&#123;//检查还有没有数据</span><br><span class="line">    channel.write(buffer);//调用方法写入</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>while</code>中调用<code>channel.write</code>是因为<code>write</code>方法并不能包装一次将<code>buffer</code>中的内容全部写入到<code>channel</code>中  </p>
<h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><p><code>channel</code>必须关闭，不过调用了<code>FileInputStream</code>、<code>FileOutputStream</code>或者<code>RandomAccessFile</code>的<code>close</code>方法会间接的调用<code>channel</code>的<code>close</code>方法  </p>
<h3 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h3><p>获取当前位置：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">long pos = channel.position();</span><br></pre></td></tr></table></figure>
<p>设置当前位</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">long newPos = ...;</span><br><span class="line">channel.position(newPos);</span><br></pre></td></tr></table></figure>
<p>设置当前位置时，如果设置为文件的末尾</p>
<ul>
<li>这时读取会返回-1</li>
<li>这时写入，会追加内容，但要注意如果<code>position</code>超过了文件末尾，再写入时会在新内容和原末尾之间有空洞（00）</li>
</ul>
<h3 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h3><p>使用<code>size</code>方法获取文件的大小</p>
<h3 id="强制写入"><a href="#强制写入" class="headerlink" title="强制写入"></a>强制写入</h3><p>操作系统出于性能考虑，会将数据缓存，不是立刻写入磁盘，可以体哦啊用<code>fore(true)</code>方法将文件内容和元数据（文件的权限等信息）立即写入磁盘  </p>
<h2 id="两个-Channel-传输数据"><a href="#两个-Channel-传输数据" class="headerlink" title="两个 Channel 传输数据"></a>两个 <code>Channel</code> 传输数据</h2><p>从<code>channel1</code>中把数据传输到<code>channel2</code>中（1传输到2）<br><strong><code>transferTo</code></strong><br>传输文件有限制，最大只能是2G</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">channel1.transferTo(0,channel.size(),channel2);</span><br></pre></td></tr></table></figure>
<p>三个参数<br><strong><code>position</code>：</strong> 起始位置<br><strong><code>count</code>：</strong> 传输数据量<br><strong><code>target</code>：</strong> 传输到哪个<code>Channel</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract long transferTo(long position, long count,WritableByteChannel target) throws IOException;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFileChannelTransferTo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (FileChannel from = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;netty-demo/data.txt&quot;</span>).getChannel();</span><br><span class="line">         FileChannel to = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;netty-demo/to.txt&quot;</span>).getChannel()) &#123;</span><br><span class="line">      <span class="comment">//效率高，底层会利用操作系统的零拷贝进行优化</span></span><br><span class="line">      <span class="comment">//from.transferTo(0,from.size(),to);</span></span><br><span class="line">      <span class="comment">//使用transferTo传输数据大小有上线，每次最多2g</span></span><br><span class="line">      <span class="comment">//可以使用下面的方法处理</span></span><br><span class="line">      <span class="keyword">long</span> size = from.size();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">long</span> left = size; left &gt; <span class="number">0</span>; ) &#123;</span><br><span class="line">        left = from.transferTo((size - left), left, to);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Path"><a href="#Path" class="headerlink" title="Path"></a><code>Path</code></h2><p>jdk7引入了<code>Path</code> 和<code>Paths</code>类</p>
<ul>
<li><code>Path</code>用来表示文件路径</li>
<li><code>Paths</code>是工具类，用来获取<code>Path</code>实例<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Path source = Paths.get(&quot;1.txt&quot;);     //相对路径，使用user.dir环境变量来定位1.txt</span><br><span class="line">Path source = Paths.get(&quot;D:\\1.txt&quot;); //绝对路径代表了 D:\1.txt </span><br><span class="line">Path source = Paths.get(&quot;D:/1.txt&quot;); //绝对路径,同样代表了 D:\1.txt </span><br><span class="line">Path source = Paths.get(&quot;D:\\data&quot;,&quot;projects&quot;); //代表了 D:\data\projects </span><br></pre></td></tr></table></figure></li>
<li><code>.</code>代表了当前路径</li>
<li><code>..</code>代表了上一级路径<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Path path = Paths.get(&quot;D:\\data\\projects\\a\\..\\b&quot;); //寻找a目录上级目录下的b目录</span><br><span class="line">System.out.println(path);</span><br><span class="line">System.out.println(path.normalize());//正常化路径</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D:\data\projects\a\..\b</span><br><span class="line">D:\data\projects\b</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Files"><a href="#Files" class="headerlink" title="Files"></a>Files</h2><ul>
<li><p>检测文件是否存在</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Path path = Paths.get(&quot;test/data.txt&quot;);</span><br><span class="line">System.out.println(Files.exists(path));</span><br></pre></td></tr></table></figure></li>
<li><p>创建一级目录</p>
<ul>
<li>如果目录已经存在，会抛出异常<code>FileAlreadyExistsException</code></li>
<li>不能一次创建多级目录，否则会抛出异常<code>NoSuchFileException</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Path path = Paths.get(&quot;test/data&quot;);</span><br><span class="line">Files.createDirectory(path);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>创建多级目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Path path = Paths.get(&quot;test/data/da&quot;);</span><br><span class="line">Files.createDirectories(path);</span><br></pre></td></tr></table></figure></li>
<li><p>拷贝文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Path source = Paths.get(&quot;test/data.txt&quot;);</span><br><span class="line">Path target = Paths.get(&quot;test/target.txt&quot;);</span><br><span class="line"></span><br><span class="line">Files.copy(source,target);</span><br></pre></td></tr></table></figure>
<p>如果文件已经存在,会抛出异常<code>FileAlreadyExistsException</code><br>如果希望用source覆盖掉target ，需要用<code>StandardCopyOption</code>来控制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Files.copy(source,target, StandardCopyOption.REPLACE_EXISTING);</span><br></pre></td></tr></table></figure>
<p>循环拷贝整个文件夹及其下面的路径：<br>这里使用的是<code>Files.walk()</code>方法，使用<code>Files.walkFileTree()</code>方法也可以达到同样的效果  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFilesCopy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String source = <span class="string">&quot;D:\\export&quot;</span>;</span><br><span class="line">        String target = <span class="string">&quot;D:\\export-aaa&quot;</span>;</span><br><span class="line">        Files.walk(Paths.get(source)).forEach(path-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//获取文件或者文件夹在新文件夹下的全路径名</span></span><br><span class="line">                String targetName = path.toString().replace(source,target);</span><br><span class="line">                <span class="comment">//如果循环的是目录</span></span><br><span class="line">                <span class="keyword">if</span> (Files.isDirectory(path))&#123;</span><br><span class="line">                    <span class="comment">//如果是目录，就在新文件夹内创建目录</span></span><br><span class="line">                    Files.createDirectory(Paths.get(targetName));</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (Files.isRegularFile(path))&#123;</span><br><span class="line">                    <span class="comment">//如果循环到的是文件，就拷贝到新文件夹下</span></span><br><span class="line">                    Files.copy(path,Paths.get(targetName));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>移动文件</p>
<ul>
<li><code>StandardCopyOption.ATOMIC_MOVE</code>保证移动文件的时候的原子性<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Path source = Paths.get(&quot;test/data.txt&quot;);</span><br><span class="line">Path target = Paths.get(&quot;test1/data.txt&quot;);</span><br><span class="line"></span><br><span class="line">Files.move(source,target,StandardCopyOption.ATOMIC_MOVE);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>删除文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Path source = Paths.get(&quot;test/data.txt&quot;);</span><br><span class="line">Files.delete(source);</span><br></pre></td></tr></table></figure></li>
<li><p>删除目录</p>
<ul>
<li>如果目录中还有内容存在，会抛出异常<code>DirectoryNotEmptyException</code></li>
<li>想要删除非空目录需要先把目录里面的内容全部删除之后才行<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Path source = Paths.get(&quot;test/data&quot;);</span><br><span class="line">Files.delete(source);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>遍历文件夹及其子目录和文件</p>
<ul>
<li>如下所示，该方法一共有两个参数</li>
<li>第一个参数是需要遍历的文件夹的根目录</li>
<li>第二个参数是通过访问者模式实现，通过对具体方法的重写，达到在遍历每个阶段插入自己代码逻辑的目的<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static Path walkFileTree(Path start, FileVisitor&lt;? super Path&gt; visitor) throws IOException&#123;&#125;</span><br></pre></td></tr></table></figure>
示例如下，使用的是<code>SimpleFileVisitor</code>类来实现逻辑，<code>FileVisitor</code>接口有四个方法，分别如下：  </li>
</ul>
</li>
<li><p><code>preVisitDirectory()</code>：在遍历到文件夹前会调用该方法</p>
</li>
<li><p><code>visitFile()</code>：在遍历到文件时会调用该方法</p>
</li>
<li><p><code>visitFileFailed()</code>：遍历文件失败时会调用该方法</p>
</li>
<li><p><code>postVisitDirectory()</code>：遍历文件夹之后会调用该方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFilesWalkFileTree</span> </span>&#123;</span><br><span class="line">    <span class="comment">//删除文件夹下的所有文件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Files.walkFileTree(Paths.get(<span class="string">&quot;E:\\export&quot;</span>),<span class="keyword">new</span> SimpleFileVisitor&lt;Path&gt;()&#123;</span><br><span class="line">            <span class="comment">//先删除文件</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                Files.delete(file);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.visitFile(file, attrs);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//遍历文件夹结束后删除文件夹，因为遍历文件夹里面的文件的时候，已经把文件全部删除了</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">postVisitDirectory</span><span class="params">(Path dir, IOException exc)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                Files.delete(dir);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.postVisitDirectory(dir, exc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历文件夹下所有jar包文件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main2</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        AtomicInteger jarCount = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">        Files.walkFileTree(Paths.get(<span class="string">&quot;D:\\jdk\\jdk8&quot;</span>),<span class="keyword">new</span> SimpleFileVisitor&lt;Path&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (file.toString().endsWith(<span class="string">&quot;.jar&quot;</span>))&#123;</span><br><span class="line">                    System.out.println(file);</span><br><span class="line">                    jarCount.incrementAndGet();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.visitFile(file, attrs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;jar count:&quot;</span>+jarCount.get());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历文件夹下所有的文件和文件夹</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main1</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        AtomicInteger dirCount = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">        AtomicInteger fileCount = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">        Files.walkFileTree(Paths.get(<span class="string">&quot;D:\\jdk\\jdk8&quot;</span>),<span class="keyword">new</span> SimpleFileVisitor&lt;Path&gt;()&#123;</span><br><span class="line">            <span class="comment">//遍历到文件夹前，会执行该方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">preVisitDirectory</span><span class="params">(Path dir, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;=====&gt;&quot;</span>+dir);</span><br><span class="line">                dirCount.incrementAndGet();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.preVisitDirectory(dir, attrs);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//遍历到文件会执行该方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(file);</span><br><span class="line">                fileCount.incrementAndGet();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.visitFile(file, attrs);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//遍历文件异常时会调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">visitFileFailed</span><span class="params">(Path file, IOException exc)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.visitFileFailed(file, exc);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//遍历文件夹后会调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">postVisitDirectory</span><span class="params">(Path dir, IOException exc)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.postVisitDirectory(dir, exc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;dir count:&quot;</span>+dirCount.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;file count:&quot;</span>+fileCount.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="阻塞-VS-非阻塞"><a href="#阻塞-VS-非阻塞" class="headerlink" title="阻塞 VS 非阻塞"></a>阻塞 VS 非阻塞</h2><h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><ul>
<li>阻塞模式下，相关方法都会导致线程暂停<ul>
<li><code>ServerSocketChannel.accept()</code>会在没有连接建立时让线程暂停</li>
<li><code>SocketChannel.read()</code>会在没有数据可读时让线程暂停</li>
<li>阻塞的表现其实就是线程暂停了，暂停期间不会占用cpu，但线程相当于闲置</li>
</ul>
</li>
<li>单线程下，阻塞方法之间相互影响，几乎不能正常工作，需要多线程支持</li>
<li>但多线程下，有新的问题，体现在一下几个方面<ul>
<li>32位JVM一个线程320k，64位JVM一个线程1024k，如果连接数过多，必然导致OOM，并且线程太多，反而会因为频繁上下文切换导致性能降低</li>
<li>可以采用线程池技术来减少线程数和线程上下文切换，但治标不治本，如果有很多连接建立，但长时间<code>inactive</code>，会阻塞线程池中所有线程，因此不适合长连接，只适合短连接</li>
</ul>
</li>
</ul>
<p>阻塞模式，单线程方式，如下所示：<br>调用<code>ssc.accept()</code>方法的时候会等待新的连接建立，陷入阻塞中<br>当连接建立后，<code>channel.read(buffer)</code>，从<code>channel</code>中读取数据的时候同样会陷入阻塞<br>假设，我们创建了一个连接，然后发送了一条消息，这个过程是没有问题的<br>但是因为只有一个线程，当进入下一次循环的时候，会继续调用<code>ssc.accept()</code>方法等待连接，这个时候，第一个建立连接的方法再次发送消息，是收不到的，<br>只能等再次有新的连接建立后才能收到消息<br>假设第一个连接建立之后，并没有发消息，同样会在<code>read</code>方法进行阻塞，这个时候在有新的连接建立同样是接收不到的，必须等第一个连接发送了消息之后才行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//使用 nio 来理解阻塞模式</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//0、ByteBuffer</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">        <span class="comment">//1、创建一个服务器</span></span><br><span class="line">        ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">//2、绑定坚挺端口</span></span><br><span class="line">        ssc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、连接集合</span></span><br><span class="line">        List&lt;SocketChannel&gt; channels = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//4、简历与客户端的连接,SocketChannel用来与客户端之间通信</span></span><br><span class="line">            log.debug(<span class="string">&quot;connecting...&quot;</span>);</span><br><span class="line">            <span class="comment">//阻塞方法，线程停止运行，</span></span><br><span class="line">            SocketChannel sc = ssc.accept();</span><br><span class="line">            log.debug(<span class="string">&quot;connected... &#123;&#125;&quot;</span>,sc);</span><br><span class="line">            channels.add(sc);</span><br><span class="line">            <span class="keyword">for</span> (SocketChannel channel : channels) &#123;</span><br><span class="line">                <span class="comment">//5、接收客户端发送的数据</span></span><br><span class="line">                log.debug(<span class="string">&quot;before read... &#123;&#125;&quot;</span>,channel);</span><br><span class="line">                <span class="comment">//阻塞方法，线程停止运行</span></span><br><span class="line">                channel.read(buffer);</span><br><span class="line">                buffer.flip();</span><br><span class="line">                ByteBufferUtil.debugRead(buffer);</span><br><span class="line">                buffer.clear();</span><br><span class="line">                log.debug(<span class="string">&quot;after read... &#123;&#125;&quot;</span>,channel);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SocketChannel sc = SocketChannel.open();</span><br><span class="line">        sc.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8080</span>));</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h3><ul>
<li>非阻塞模式下，相关方法都不会让线程暂停<ul>
<li>在<code>ServerSocketChannel.accept()</code>在没有连接建立时，会返回null，继续运行</li>
<li><code>SocketChannel.read()</code>在没有数据可读时，会返回0，但线程不必阻塞，可以去执行其它<code>SocketChannel</code>的<code>read</code>方法或是去执行<code>ServerSocketChannel.accept()</code>方法</li>
<li>写数据时，线程只是等待数据写入<code>Channel</code>即可，无需等<code>Channel</code>通过网络把数据发送出去</li>
</ul>
</li>
<li>但非阻塞模式下，即使没有连接建立，和可读数据，线程仍然在不断运行，白白浪费了CPU</li>
<li>数据复制过程中，线程事件还是阻塞的（AIO改进的地方）</li>
</ul>
<p>非阻塞模式实现如下：<br>主要是通过<code>configureBlocking(false)</code>方法，将参数设置为<code>false</code>切换<br>针对<code>ServerSocketChannel</code>设置，影响的是<code>ssc.accept()</code>方法，如果没有连接，线程在执行该方法后，不会阻塞，会立即返回null<br>针对<code>SocketChannel</code>设置，影响的是<code>channel.read(buffer)</code>方法，如果没有数据，线程在执行了该方法后，不会阻塞，会立即返回0<br>线程会不停的循环  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//使用 nio 来理解阻塞模式</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//0、ByteBuffer</span></span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">    <span class="comment">//1、创建一个服务器</span></span><br><span class="line">    ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">    <span class="comment">//设置为非阻塞模式,影响的是下面的accept()方法</span></span><br><span class="line">    ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">//2、绑定坚挺端口</span></span><br><span class="line">    ssc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、连接集合</span></span><br><span class="line">    List&lt;SocketChannel&gt; channels = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="comment">//4、简历与客户端的连接,SocketChannel用来与客户端之间通信</span></span><br><span class="line">      <span class="comment">//log.debug(&quot;connecting...&quot;);</span></span><br><span class="line">      <span class="comment">//非阻塞模式下，此方法不会阻塞线程，会继续运行，不过在没有连接建立的时候sc会返回为null</span></span><br><span class="line">      SocketChannel sc = ssc.accept();</span><br><span class="line">      <span class="keyword">if</span> (sc != <span class="keyword">null</span>) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;connected... &#123;&#125;&quot;</span>, sc);</span><br><span class="line">        <span class="comment">//将SocketChannel设置为非阻塞模式，影响的是下面的read方法</span></span><br><span class="line">        sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        channels.add(sc);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (SocketChannel channel : channels) &#123;</span><br><span class="line">        <span class="comment">//5、接收客户端发送的数据</span></span><br><span class="line">        <span class="comment">//log.debug(&quot;before read... &#123;&#125;&quot;,channel);</span></span><br><span class="line">        <span class="comment">//非阻塞模式，线程不会阻塞，会继续运行，如果没有数据read返回0，</span></span><br><span class="line">        <span class="keyword">int</span> read = channel.read(buffer);</span><br><span class="line">        <span class="keyword">if</span> (read != <span class="number">0</span>) &#123;</span><br><span class="line">          buffer.flip();</span><br><span class="line">          ByteBufferUtil.debugRead(buffer);</span><br><span class="line">          buffer.clear();</span><br><span class="line">          log.debug(<span class="string">&quot;after read... &#123;&#125;&quot;</span>, channel);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Selector-多路复用"><a href="#Selector-多路复用" class="headerlink" title="(Selector)多路复用"></a>(Selector)多路复用</h2><p>单线程可以配合<code>Selector</code>完成对多个<code>Channel</code>可读写事件的监控，这称之为多路复用  </p>
<ul>
<li>多路复用仅针对网络IO、普通文件IO没法录用多路复用</li>
<li>如果不用<code>Selector</code>的非阻塞模式，线程大部分时间都是在做无用功，而<code>Selector</code>能保证<ul>
<li>有可连接事件时才去连接</li>
<li>有可读事件才去读取</li>
<li>有可写事件才去写入</li>
<li>限于网络传输能力，<code>Channel</code>未必时时可写，一旦<code>Channel</code>可写，会触发<code>Selector</code>的可写事件</li>
</ul>
</li>
</ul>
<p>好处：  </p>
<ul>
<li>一个线程配合<code>selector</code>就可以监控多个<code>channel</code>的事件，事件发生线程才去处理，避免非阻塞模式下做无用功</li>
<li>让这个线程能够被充分利用</li>
<li>节约了线程的数量</li>
<li>减少了线程上下文切换</li>
</ul>
<p><strong>创建</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure>

<p><strong>绑定<code>Channel</code>事件</strong><br>也称之为注册事件，绑定的事件<code>Selector</code>才会关心  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">channel.configureBlocking(false);</span><br><span class="line">SelectionKey sscKey = channel.register(selector, 绑定事件);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>channel</code>必须工作在非阻塞模式</li>
<li><code>FileChannel</code>没有非阻塞模式，因此不能配合<code>Selector</code>一起使用</li>
<li>绑定的事件类型可以有：<ul>
<li><code>connect</code>：客户端连接成功时触发</li>
<li><code>accept</code>：服务端成功接受连接时触发</li>
<li><code>read</code>：数据可读入时触发，有因为接受能力弱，数据暂不能读入的情况</li>
<li><code>write</code>：数据可写出时触发，有因为发送能力弱，数据暂不能写出的情况</li>
</ul>
</li>
</ul>
<p><strong>监听<code>Channel</code>事件</strong><br>可以通过下面三种方法来监听是否有事件发生，方法的返回值代表有多少<code>channel</code>发生了事件<br>方法1，阻塞知道绑定事件发生</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int count = selector.select();</span><br></pre></td></tr></table></figure>
<p>方法2，阻塞直到绑定事件发生，或是超时（时间单位ms）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int count = selector.select(long timeout);</span><br></pre></td></tr></table></figure>
<p>方法3，不会阻塞，也就是不管有没有时间，立即返回，自己根据返回值检查是否有事件  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int count = selector.selectNow();</span><br></pre></td></tr></table></figure>

<p><strong><code>select</code>何时不阻塞</strong>  </p>
<ul>
<li>事件发生时<ul>
<li>客户端发起连接请求，会触发<code>accept</code>事件</li>
<li>客户端发送数据过来，客户端正常、异常关闭时，都会触发<code>read</code>事件，另外如果发送的数据大于<code>buffer</code>缓冲区，会触发多次读取事件  </li>
<li><code>channel</code>可写，会触发<code>write</code>事件</li>
<li>在linux下nio bug发生时</li>
</ul>
</li>
<li>调用<code>selector.wakeup()</code></li>
<li>调用<code>selector.close()</code></li>
<li><code>selector</code>躲在线程<code>interrupt</code></li>
</ul>
<h2 id="处理accept和read事件"><a href="#处理accept和read事件" class="headerlink" title="处理accept和read事件"></a>处理<code>accept</code>和<code>read</code>事件</h2><p><strong>事件发生后能否不处理</strong><br>事件发生后，要么处理，要么取消（<code>cancel</code>），不能什么都不做，否则下次该事件仍然会触发，这是因为nio底层使用的水平触发  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * selector事件类型</span></span><br><span class="line"><span class="comment">   * accept       会在有连接请求时触发</span></span><br><span class="line"><span class="comment">   * connect      是客户端，连接建立后触发</span></span><br><span class="line"><span class="comment">   * read         可读事件</span></span><br><span class="line"><span class="comment">   * write        可写事件</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//1、创建Selector</span></span><br><span class="line">    Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">    ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">    ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、建立Selector和Channel的联系（注册）</span></span><br><span class="line">    <span class="comment">//SelectionKey 就是将来事件发生后，通过他可以知道是什么事件，和那个Channel发生的事件</span></span><br><span class="line">    SelectionKey sscKey = ssc.register(selector, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//key只关注accept事件</span></span><br><span class="line">    sscKey.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class="line">    log.debug(<span class="string">&quot;register key: &#123;&#125;&quot;</span>, sscKey);</span><br><span class="line">    ssc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="comment">//3、select方法，没有事件发生，线程阻塞，有事件，线程才会恢复运行</span></span><br><span class="line">      <span class="comment">//select在事件未处理时，他是不会阻塞的  （处理或者取消事件）</span></span><br><span class="line">      <span class="comment">//事件发生后，要么处理，要么取消，不能置之不理</span></span><br><span class="line">      selector.select();</span><br><span class="line">      <span class="comment">//4、处理事件,selectedKeys返回的是一个集合，内部包含了所有发生的事件</span></span><br><span class="line">      Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">      Iterator&lt;SelectionKey&gt; itr = selectionKeys.iterator();</span><br><span class="line">      <span class="keyword">while</span> (itr.hasNext()) &#123;</span><br><span class="line">        SelectionKey key = itr.next();</span><br><span class="line">        <span class="comment">//当有事件的时候，selector只会往selectedKeys集合中存放数据，并不会删除数据</span></span><br><span class="line">        <span class="comment">//所以需要我们处理完之后自己删除</span></span><br><span class="line">        itr.remove();</span><br><span class="line">        log.debug(<span class="string">&quot;key: &#123;&#125;&quot;</span>, key);</span><br><span class="line">        <span class="comment">//key.cancel();//取消事件</span></span><br><span class="line">        <span class="comment">//5、区分事件类型</span></span><br><span class="line">        <span class="keyword">if</span> (key.isAcceptable()) &#123;<span class="comment">//如果是accept事件</span></span><br><span class="line">          ServerSocketChannel channel = (ServerSocketChannel) key.channel();</span><br><span class="line">          SocketChannel sc = channel.accept();</span><br><span class="line">          sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">          SelectionKey scKey = sc.register(selector, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">          scKey.interestOps(SelectionKey.OP_READ);</span><br><span class="line">          log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, sc);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;<span class="comment">//如果是read可读事件</span></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//拿到触发事件的Channel</span></span><br><span class="line">            SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">            <span class="comment">//如果客户端正常断开，返回-1，如果客户端异常断开，会抛异常</span></span><br><span class="line">            <span class="keyword">int</span> read = channel.read(buffer);</span><br><span class="line">            <span class="keyword">if</span> (read == -<span class="number">1</span>) &#123;</span><br><span class="line">              key.cancel();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              buffer.flip();</span><br><span class="line">              ByteBufferUtil.debugRead(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="comment">//因为客户端断开了，因此需要将key取消，（从selector集合中真正删除）</span></span><br><span class="line">            key.cancel();</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么要<code>itr.remove()</code></strong><br>因为<code>select</code>在事件发生后，就会将相关<code>key</code>放进<code>selectedKeys</code>集合，但不会在处理完后从<code>selectedKeys</code>集合中移除，需要我们自己编码移除</p>
<ul>
<li>第一次触发了<code>sscKey</code>上的<code>accept</code>事件，没有移除<code>ssKey</code></li>
<li>第二次触发了<code>scKey</code>上的<code>read</code>事件，但这个时候<code>selectedKeys</code>中还有上次的<code>sscKey</code>，在处理时因为没有真正的<code>serverSocket</code>连上，就会导致空指针异常</li>
</ul>
<p><strong><code>cancel</code>的作用</strong><br><code>cancel</code>会取消注册在<code>selector</code>上的<code>channel</code>，并从<code>keys</code>集合中删除<code>key</code>后续不会再监听事件  </p>
<h3 id="处理消息边界"><a href="#处理消息边界" class="headerlink" title="处理消息边界"></a>处理消息边界</h3><p>如下图所示，我们通过网络接收到的消息的长度并不一定都是固定的，在服务端如果设置一个固定长度的<code>buffer</code>，就会出现如下的情况  </p>
<ul>
<li>接收到的消息比设定的<code>buffer</code>长，这个时候就需要想办法扩容<code>buffer</code></li>
<li>接收到的消息比<code>buffer</code>短，这样就会可能导致半包的情况，第一条消息完全接收了，第二条消息接收了一部分  </li>
<li>接收到的消息更短一些，这样就会出现黏包、半包的现象</li>
</ul>
<p><img src="/2022/01/22/netty/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B%E2%80%94%E2%80%94NIO%E5%9F%BA%E7%A1%80/%E6%B6%88%E6%81%AF%E8%BE%B9%E7%95%8C%E5%9B%BE%E7%A4%BA.png" alt="消息边界图示"></p>
<p>解决思路：</p>
<ul>
<li>一种思想是固定消息长度，数据包大小一样，服务器按预定长度读取，缺点是浪费带宽</li>
<li>另一种思路是按分隔符拆分，缺点是效率低，每次都需要将整个buffer循环一遍，查找分隔符  </li>
<li>TLV格式，即Type类型、Length长度、Value数据，类型和长度已知的情况下，就可以方便获取消息大小，分配合适的buffer，缺点是需要提前分配，如果内容过大，则影响server吞吐量<ul>
<li>Http1.1是TLV格式</li>
<li>Http2.0是LTV格式</li>
</ul>
</li>
</ul>
<blockquote>
<p>当客户端发送来一条消息，但是长度超过了buffer的长度，假设buffer为16字节，消息长度为20字节，此时第一次触发read事件，拿到了前面的16个字节，但是因为消息没有结束，所以read不会返回-1，客户端也就无法感知，但是当前read事件的数据并未处理完毕，所以会再次触发read事件，第二次循环创建了一个新的buffer，此时消息只剩下4个字节，16字节的buffer完全能够接受，最终打印就只剩下四个字节<br>改进思路：<br>buffer不能设置为局部变量，需要设置为全局变量（至少是针对当前连接的全局变量），当客户端发送请求，buffer感知到当前长度无法承载全部数据，就会进行扩容，创建一个新的buffer，然后将之前的数据存放到新的buffer中，之后因为没有完全读取消息，会再次触发read事件，第二次read事件将剩余消息获取  </p>
</blockquote>
<img src="http://www.plantuml.com/plantuml/svg/UxfkqREExSzNhpTKqBLJU3QdzsdNmgSpLrWzxP_uig7HmD38sCJKpDp2qY0nAJabDSqO269YYhZW2a6wd2fBKfrAqz9IYmojdgzPysH7mxCr2ujI4rEUhftnj7KfgY75gMcuT1jPFUjS-NJTJYua0p5KT6z_iMKk2KOgW5oqgmV5HJ1V8Ab3ruRBvm00">

<p>具体代码实现如下，<code>split(buffer)</code>方法在上面讲解黏包半包的时候已经写过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Selector selector = Selector.open();</span><br><span class="line">    ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">    ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    SelectionKey sscKey = ssc.register(selector, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">    sscKey.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class="line">    log.debug(<span class="string">&quot;register key: &#123;&#125;&quot;</span>,sscKey);</span><br><span class="line">    ssc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">      selector.select();</span><br><span class="line">      Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">      Iterator&lt;SelectionKey&gt; itr = selectionKeys.iterator();</span><br><span class="line">      <span class="keyword">while</span> (itr.hasNext())&#123;</span><br><span class="line">        SelectionKey key = itr.next();</span><br><span class="line">        itr.remove();</span><br><span class="line">        log.debug(<span class="string">&quot;key: &#123;&#125;&quot;</span>,key);</span><br><span class="line">        <span class="keyword">if</span> (key.isAcceptable())&#123;</span><br><span class="line">          ServerSocketChannel channel = (ServerSocketChannel)key.channel();</span><br><span class="line">          SocketChannel sc = channel.accept();</span><br><span class="line">          sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">          ByteBuffer buffer = ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">          SelectionKey scKey = sc.register(selector, <span class="number">0</span>, buffer);</span><br><span class="line">          scKey.interestOps(SelectionKey.OP_READ);</span><br><span class="line">          log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,sc);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable())&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            SocketChannel channel = (SocketChannel)key.channel();</span><br><span class="line">            ByteBuffer buffer =(ByteBuffer) key.attachment();</span><br><span class="line">            <span class="keyword">int</span> read = channel.read(buffer);</span><br><span class="line">            <span class="keyword">if</span> (read == -<span class="number">1</span>)&#123;</span><br><span class="line">              key.cancel();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">              split(buffer);</span><br><span class="line">              <span class="comment">//根据split方法里面的逻辑来看，当没有找到分隔符的时候，是不会改变指针的位置的</span></span><br><span class="line">              <span class="comment">//所以当buffer的指针和长度相等时，表示buffer是满的，需要扩容</span></span><br><span class="line">              <span class="keyword">if</span> (buffer.position() == buffer.limit())&#123;</span><br><span class="line">                <span class="comment">//直接按原有buffer的2倍进行扩容</span></span><br><span class="line">                ByteBuffer newBuffer = ByteBuffer.allocate(buffer.capacity() * <span class="number">2</span>);</span><br><span class="line">                <span class="comment">//切换读模式</span></span><br><span class="line">                buffer.flip();</span><br><span class="line">                <span class="comment">//将原本的buffer内容读取到新的buffer中</span></span><br><span class="line">                newBuffer.put(buffer);</span><br><span class="line">                <span class="comment">//使用新的buffer替换到原本的buffer，挂载到selectedKey上</span></span><br><span class="line">                key.attach(newBuffer);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            key.cancel();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ByteBuffer大小分配"><a href="#ByteBuffer大小分配" class="headerlink" title="ByteBuffer大小分配"></a><code>ByteBuffer</code>大小分配</h3><ul>
<li>每个<code>Channel</code>都需要记录可能被切分的消息，因为<code>ByteBuffer</code>不能被多个<code>Channel</code>共同使用，因此需要为每个<code>channel</code>维护一个独立的<code>ByteBuffer</code></li>
<li><code>ByteBuffer</code>不能太大，比如一个<code>ByteBuffer</code> 1Mb的话，要支持百万连接就要1Tb内存，因此需要设计大小可变的<code>ByteBuffer</code><ul>
<li>一种思路是首先分配一个较小的<code>buffer</code>，例如4k，如果发现数据不够，再分配8k的<code>buffer</code>，将4k内容拷贝至8k <code>buffer</code>，优点是消息连续容易处理，缺点是数据拷贝消耗性能</li>
<li>另一种思路是用多个数组组成<code>buffer</code>，一个数组不够，把多出来的内容写入新的数组，与前面的区别是消息存储不连续，解析复杂，优点是避免了拷贝引起的性能损耗  </li>
</ul>
</li>
</ul>
<h3 id="处理write事件"><a href="#处理write事件" class="headerlink" title="处理write事件"></a>处理<code>write</code>事件</h3><p>一次无法写完</p>
<ul>
<li>非阻塞模式下，无法保证把<code>buffer</code>中的所有数据都写入<code>channel</code>，因此需要追踪<code>write</code>方法的返回值（代表实际写入的字节数）</li>
<li>用<code>selector</code>监听所有<code>channel</code>的可写事件，每个<code>channel</code>都需要一个<code>key</code>来追踪<code>buffer</code>，但这样又会导致占用内存过多，就有两阶段策略<ul>
<li>当消息处理器第一次写入消息时，才将<code>channel</code>注册到<code>selector</code>上</li>
<li><code>selector</code>检查<code>channel</code>上的可写事件，如果所有的数据写完了，就取消<code>channel</code>的注册</li>
<li>如果不取消，会每次可写均会触发<code>write</code>事件</li>
</ul>
</li>
</ul>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">        ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            selector.select();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; itr = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (itr.hasNext())&#123;</span><br><span class="line">                SelectionKey key = itr.next();</span><br><span class="line">                itr.remove();</span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable())&#123;</span><br><span class="line">                    SocketChannel sc = ssc.accept();</span><br><span class="line">                    sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    SelectionKey sckey = sc.register(selector, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">                    sckey.interestOps(SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//1.向客户端发送大量数据</span></span><br><span class="line">                    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30000000</span>; i++) &#123;</span><br><span class="line">                        sb.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    ByteBuffer buffer = Charset.defaultCharset().encode(sb.toString());</span><br><span class="line">                    <span class="comment">//2.返回值代表实际写入的字节数</span></span><br><span class="line">                    <span class="keyword">int</span> write = sc.write(buffer);</span><br><span class="line">                    System.out.println(write);</span><br><span class="line">                    <span class="comment">//3.判断是否还有剩余内容</span></span><br><span class="line">                    <span class="keyword">if</span> (buffer.hasRemaining())&#123;</span><br><span class="line">                        <span class="comment">//4.关注可写事件</span></span><br><span class="line">                        sckey.interestOps(sckey.interestOps()+SelectionKey.OP_WRITE);</span><br><span class="line">                        <span class="comment">//5.把未写完的数据挂到sckey上</span></span><br><span class="line">                        sckey.attach(buffer);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable())&#123;</span><br><span class="line">                    ByteBuffer buffer = (ByteBuffer) key.attachment();</span><br><span class="line">                    SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">                    <span class="keyword">int</span> write = sc.write(buffer);</span><br><span class="line">                    System.out.println(write);</span><br><span class="line">                    <span class="comment">//6.清理操作，完成所有数据的写出之后</span></span><br><span class="line">                    <span class="keyword">if</span> (!buffer.hasRemaining())&#123;</span><br><span class="line">                        <span class="comment">//清除挂载的buffer</span></span><br><span class="line">                        key.attach(<span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">//不需要再关注写事件</span></span><br><span class="line">                        key.interestOps(key.interestOps()-SelectionKey.OP_WRITE);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SocketChannel sc = SocketChannel.open();</span><br><span class="line">        sc.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8080</span>));</span><br><span class="line">        <span class="comment">//接收服务端的数据</span></span><br><span class="line">        <span class="keyword">int</span> count =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>*<span class="number">1024</span>);</span><br><span class="line">            count+= sc.read(buffer);</span><br><span class="line">            System.out.println(count);</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>write</code>为何要取消</strong><br>只要想<code>channel</code>发送数据时，<code>socket</code>缓冲可写，这个事件就会频繁触发，因此应该只在<code>socket</code>缓冲区写不下时再关注可写事件，数据写完之后再取消关注</p>
<h3 id="更近一步（利用多线程优化）"><a href="#更近一步（利用多线程优化）" class="headerlink" title="更近一步（利用多线程优化）"></a>更近一步（利用多线程优化）</h3><p>现在都是多核CPU，设计时要充分考虑被让cpu的力量被白白浪费，前面的代码只有一个选择器，没有充分利用多核cpu，进行改进</p>
<p>分两组选择器  </p>
<ul>
<li>单线程配一个选择器，专门处理<code>accept</code>事件</li>
<li>创建cpu核心数的线程，每个线程配置一个选择器，轮流处理<code>read</code>事件  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThreadServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Thread.currentThread().setName(<span class="string">&quot;boss&quot;</span>);</span><br><span class="line">        ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">        ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        Selector boss = Selector.open();</span><br><span class="line">        SelectionKey bossKey = ssc.register(boss, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">        bossKey.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">        <span class="comment">//创建固定数量的worker,,创建CPU核数个线程</span></span><br><span class="line">        Worker[] workers = <span class="keyword">new</span> Worker[Runtime.getRuntime().availableProcessors()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; workers.length; i++) &#123;</span><br><span class="line">            workers[i] = <span class="keyword">new</span> Worker(<span class="string">&quot;worker-&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        AtomicInteger index = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            boss.select();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iter = boss.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = iter.next();</span><br><span class="line">                iter.remove();</span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    SocketChannel sc = ssc.accept();</span><br><span class="line">                    sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    log.debug(<span class="string">&quot;connected... &#123;&#125;&quot;</span>,sc.getRemoteAddress());</span><br><span class="line">                    <span class="comment">//2.关联channel</span></span><br><span class="line">                    log.debug(<span class="string">&quot;before register... &#123;&#125;&quot;</span>,sc.getRemoteAddress());</span><br><span class="line">                    <span class="comment">//轮询</span></span><br><span class="line">                    workers[index.getAndIncrement()%workers.length].register(sc);<span class="comment">//boss 调用，初始化selector，启动worker-0</span></span><br><span class="line"></span><br><span class="line">                    log.debug(<span class="string">&quot;after register... &#123;&#125;&quot;</span>,sc.getRemoteAddress());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Thread thread;</span><br><span class="line">        <span class="keyword">private</span> Selector selector;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> start = <span class="keyword">false</span>;<span class="comment">//还未初始化</span></span><br><span class="line"><span class="comment">//        private ConcurrentLinkedQueue&lt;Runnable&gt; queue = new ConcurrentLinkedQueue&lt;&gt;();</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化线程 和 selector</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(SocketChannel sc)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!start) &#123;</span><br><span class="line">                thread = <span class="keyword">new</span> Thread(<span class="keyword">this</span>, name);</span><br><span class="line">                selector = Selector.open();</span><br><span class="line">                thread.start();</span><br><span class="line">                start = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//向队列添加了任务，但这个任务并没有立即执行 boss</span></span><br><span class="line"><span class="comment">//            queue.add(()-&gt;&#123;</span></span><br><span class="line"><span class="comment">//                try &#123;</span></span><br><span class="line"><span class="comment">//                    sc.register(selector,SelectionKey.OP_READ,null);</span></span><br><span class="line"><span class="comment">//                &#125; catch (ClosedChannelException e) &#123;</span></span><br><span class="line"><span class="comment">//                    e.printStackTrace();</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;);</span></span><br><span class="line"><span class="comment">//            selector.wakeup();//唤醒select</span></span><br><span class="line">            selector.wakeup();</span><br><span class="line">            sc.register(selector,SelectionKey.OP_READ,<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当channel执行register方法注册到selector上的时候，如果selector已经执行了select方法陷入了阻塞，</span></span><br><span class="line"><span class="comment">register也会被阻塞，需要等selector下次被唤醒之后才能注册</span></span><br><span class="line"><span class="comment">第一种解决办法：</span></span><br><span class="line"><span class="comment">如上代码使用队列，保证register方法是在selector唤醒后执行，在向队列插入数据后执行wakeup唤醒select，</span></span><br><span class="line"><span class="comment">这样当有channel需要注册到selector上的时候，就会先把任务封装放进队列，然后唤醒selector，唤醒后就立刻从队列中拿出任务执行注册</span></span><br><span class="line"><span class="comment">第二种解决办法：</span></span><br><span class="line"><span class="comment">直接执行wakeup方法唤醒select，然后进行注册</span></span><br><span class="line"><span class="comment">如果在执行了select后执行wakeup方法，会唤醒select然后执行注册</span></span><br><span class="line"><span class="comment">如果是在select之前执行了wakeup方法，在执行select的时候会判断，然后跳过这次阻塞，进行下次循环</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    selector.select();<span class="comment">// worker-0 阻塞</span></span><br><span class="line"><span class="comment">//                    Runnable task = queue.poll();</span></span><br><span class="line"><span class="comment">//                    if (task != null) task.run(); //执行任务内容</span></span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">                        SelectionKey key = iterator.next();</span><br><span class="line">                        iterator.remove();</span><br><span class="line">                        <span class="keyword">if</span> (key.isReadable())&#123;</span><br><span class="line">                            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">                            SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">                            log.debug(<span class="string">&quot;after register... &#123;&#125;&quot;</span>,channel.getRemoteAddress());</span><br><span class="line">                            channel.read(buffer);</span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            ByteBufferUtil.debugAll(buffer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SocketChannel sc = SocketChannel.open();</span><br><span class="line">        sc.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8080</span>));</span><br><span class="line">        sc.write(Charset.defaultCharset().encode(<span class="string">&quot;1234567890abcdef&quot;</span>));</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>如何拿到cpu核数</strong>  </p>
<ul>
<li><code>Runtime.getRuntime().availableProcessors()</code>如果工作在docker容器下，因为容器不是物理隔离的，会拿到物理cpu个数，而不是容器申请时的个数</li>
<li>这个问题直到jdk10才修复，使用jvm参数<code>UseContainerSupport</code> 配置，默认开启</li>
</ul>
<h1 id="NIO-VS-BIO"><a href="#NIO-VS-BIO" class="headerlink" title="NIO VS BIO"></a>NIO VS BIO</h1><h2 id="stream-VS-channel"><a href="#stream-VS-channel" class="headerlink" title="stream VS channel"></a><code>stream</code> VS <code>channel</code></h2><ul>
<li><code>stream</code>不会自动缓冲数据，<code>channel</code>会利用系统提供的发送缓冲区、接收缓冲区（更为底层）</li>
<li><code>stream</code>仅支持阻塞API，<code>channel</code>同时支持阻塞、非阻塞API，网络<code>channel</code>可配合<code>selector</code>实现多路复用</li>
<li>二者均为全双工，即读写可以同时进行</li>
</ul>
<h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><p>同步阻塞、同步非阻塞、同步多路复用、异步阻塞（没有此情况）、异步非阻塞  </p>
<ul>
<li>同步：线程自己去获取结果（一个线程）</li>
<li>异步：线程自己不去获取结果，而是由其他线程发送结果（至少两个线程）</li>
</ul>
<p>当调用一次<code>channel.read</code>或者<code>stream.read</code>后，会切换至操作系统内核态来完成真正数据读取，而读取又分为两个阶段，分别为：</p>
<ul>
<li>等待数据阶段</li>
<li>复制数据阶段</li>
</ul>
<p><img src="/2022/01/22/netty/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B%E2%80%94%E2%80%94NIO%E5%9F%BA%E7%A1%80/IO%E6%A8%A1%E5%9E%8Bread%E5%9B%BE%E7%A4%BA.png" alt="IO模型read图示"></p>
<p><strong>阻塞IO</strong><br>用户线程发起<code>read</code>方法，并不一定立即就会有数据，没有数据的时候会阻塞等待数据，直到有数据之后，完成复制返回<br><img src="/2022/01/22/netty/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B%E2%80%94%E2%80%94NIO%E5%9F%BA%E7%A1%80/%E9%98%BB%E5%A1%9EIO%E5%9B%BE%E7%A4%BA.png" alt="阻塞IO图示"></p>
<p><strong>非阻塞IO</strong><br>在非阻塞的情况下，用户线程发起<code>read</code>之后并不会等待，如果没有数据会立即返回，此时可以去完成其他的业务，也可以循环继续等待数据<br><img src="/2022/01/22/netty/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B%E2%80%94%E2%80%94NIO%E5%9F%BA%E7%A1%80/%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E5%9B%BE%E7%A4%BA.png" alt="非阻塞IO图示"></p>
<p><strong>多路复用</strong><br>用户线程使用<code>select</code>方法等待数据，当有了数据之后会获取所有的数据信息返回，然后根据不同数据类型在分别进行处理<br><img src="/2022/01/22/netty/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B%E2%80%94%E2%80%94NIO%E5%9F%BA%E7%A1%80/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%9B%BE%E7%A4%BA.png" alt="多路复用图示"></p>
<p><strong>异步IO</strong><br>用户线程发起<code>read</code>方法后，如果没有数据，会立即返回，然后去做其他的处理，等有数据之后内核会调用回调方法返回数据<br><img src="/2022/01/22/netty/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B%E2%80%94%E2%80%94NIO%E5%9F%BA%E7%A1%80/%E5%BC%82%E6%AD%A5IO%E5%9B%BE%E7%A4%BA.png" alt="异步IO"></p>
<h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><p><strong>传统IO问题</strong><br>传统IO将一个文件通过<code>socket</code>写出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">File f = new File(&quot;test/data.txt&quot;);</span><br><span class="line">RandomAccessFile file = new RandomAccessFile(file,&quot;r&quot;);</span><br><span class="line">byte[] buf = new byte[(int)f.length()];</span><br><span class="line">file.read(buf);</span><br><span class="line">Socket socket = ...;</span><br><span class="line">socket.getOutputStream().write(buf);</span><br></pre></td></tr></table></figure>
<p>内部工作流程是这样的：<br><img src="/2022/01/22/netty/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B%E2%80%94%E2%80%94NIO%E5%9F%BA%E7%A1%80/%E6%96%87%E4%BB%B6%E5%86%99%E5%87%BA%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="文件写出工作流程图"></p>
<ol>
<li>java本身并不具备IO读写能力，因此<code>read</code>方法调用后，要从java程序的<strong>用户态</strong>，切换至<strong>内核态</strong>，去调用操作系统的（Kernel）的读写能力，将数据读入<strong>内核缓存区</strong>。这期间用户线程阻塞，操作系统使用DMA（Direct Memory Access）来实现文件读，期间也不会使用cpu</li>
<li>从<strong>内核态</strong>切换到<strong>用户态</strong>，将数据从<strong>内核缓冲区</strong>读入<strong>用户缓冲区</strong>（即byte[] buf），这期间cpu会参与拷贝，无法利用DMA</li>
<li>调用<code>write</code>方法，这时将数据从<strong>用户缓冲区</strong>（byte[] buf）写入<strong>socket缓冲区</strong>，cpu会参与拷贝</li>
<li>接下来要向网卡写数据，这项能力java又不具备，因此又要从<strong>用户态</strong>切换到<strong>内核态</strong>，调用操作系统的写能力，使用DMA将<strong>socket缓冲区</strong>的数据写入网卡，不会使用cpu</li>
</ol>
<p>可以看到中间环节较多，java的io实际不是物理设备级别的读写，而是缓存的复制，底层的真正读写是操作系统来完成的  </p>
<ul>
<li><strong>用户态</strong>和<strong>内核态</strong>的切换发生了3次，这个操作比较重量级</li>
<li>数据拷贝了共4次</li>
</ul>
<h3 id="NIO优化"><a href="#NIO优化" class="headerlink" title="NIO优化"></a>NIO优化</h3><p>通过<code>DirectByteBuffer</code></p>
<ul>
<li><code>ByteBuffer.allocate(10)</code> <code>HeapByteBuffer</code>使用的好还是java内存</li>
<li><code>ByteBuffer.allocateDirect(10)</code> <code>DirectByteBuffer</code>使用的是操作系统内存</li>
</ul>
<p><img src="/2022/01/22/netty/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B%E2%80%94%E2%80%94NIO%E5%9F%BA%E7%A1%80/DirectByteBuffer%E4%BC%98%E5%8C%96%E5%90%8E%E5%B7%A5%E4%BD%9C%E5%9B%BE%E7%A4%BA.png" alt="DirectByteBuffer优化后工作图示"></p>
<p>大部分步骤和优化前相同，不再多说，唯有一点：java可以使用<code>DirectByteBuffer</code>将堆外内存映射到jvm内存中来直接访问使用</p>
<ul>
<li>这块内存不受jvm垃圾回收的影响，因此内存地址固定，有助于IO读写</li>
<li>java中的<code>DirectByteBuffer</code>对象仅维护了此内存的虚引用，内存回收分成两步<ul>
<li><code>DirectByteBuffer</code>对象被垃圾回收，将虚引用加入引用队列</li>
<li>通过专门线程访问引用队列，根据虚引用释放堆外内存</li>
</ul>
</li>
<li>减少了一次数据拷贝，用户态与内核态的切换次数没有减少</li>
</ul>
<p>进一步优化（底层采用 linux2.1 后提供的<code>sendFile</code>方法），java中对应着两个<code>channel</code>调用<code>transferTo</code>/<code>transferFrom</code>方法拷贝数据<br><img src="/2022/01/22/netty/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B%E2%80%94%E2%80%94NIO%E5%9F%BA%E7%A1%80/transferTo-transferFrom%E6%96%B9%E6%B3%95%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="transferTo/transferFrom方法流程图"></p>
<ol>
<li>java调用<code>transferTo</code>方法后，要从java程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用DMA将数据读入<strong>内核缓冲区</strong>，不会使用cpu</li>
<li>数据从<strong>内核缓冲区</strong>传输到<strong>socket缓冲区</strong>，cpu会参与拷贝</li>
<li>最后使用DMA将<strong>socket缓冲区</strong>的数据写入网卡，不会使用cpu</li>
</ol>
<p>可以看到</p>
<ul>
<li>只发生了一次<strong>用户态</strong>和<strong>内核态</strong>的切换</li>
<li>数据拷贝了3次</li>
</ul>
<p>进一步优化（linux 2.4）<br><img src="/2022/01/22/netty/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B%E2%80%94%E2%80%94NIO%E5%9F%BA%E7%A1%80/linux2.4%E9%9B%B6%E6%8B%B7%E8%B4%9D%E4%BC%98%E5%8C%96.png" alt="linux2.4零拷贝优化"></p>
<ol>
<li>java调用<code>transferTo</code>方法后，要从java程序的<strong>用户态</strong>切换到<strong>内核态</strong>，使用DMA将数据读入<strong>内核缓冲区</strong>，不会使用cpu</li>
<li>只会将一些<code>offset</code>和<code>length</code>信息考入<strong>socket缓冲区</strong>，几乎无消耗</li>
<li>使用DMA将<strong>内核缓冲区</strong>的数据写入王咖啡，不会使用cpu</li>
</ol>
<p>真个过程仅只发生了一次<strong>用户态</strong>与<strong>内核态</strong>的切换，数据拷贝了2次。<br>所谓【零拷贝】，并不是真的无拷贝，而是在不会拷贝重复数据到jvm内存中，零拷贝的优点有：  </p>
<ul>
<li>更少的<strong>用户态</strong>与<strong>内核态</strong>的切换</li>
<li>不利用cpu计算，减少cpu缓冲伪共享</li>
<li>零拷贝适合小文件传输</li>
</ul>
<h3 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h3><p>AIO用来解决数据复制阶段的阻塞问题</p>
<ul>
<li>同步意味着，在进行读写操作时，线程需要等待结果，好还是相当于闲置</li>
<li>异步意味着，在进行读写操作时，线程不必等待结果，而是将来由操作系统来通过回调方式由另外的线程来获得结果</li>
</ul>
<blockquote>
<p>异步模型需要底层操作系统（Kernel）提供支持</p>
</blockquote>
<ul>
<li>Windows系统通过<code>IOCP</code>实现了真正的异步IO</li>
<li>Linux系统异步IO在2.6半包引入，但其底层实现还是用多路复用模拟了异步IO，性能没有优势</li>
</ul>
<h4 id="文件AIO"><a href="#文件AIO" class="headerlink" title="文件AIO"></a>文件AIO</h4><p><code>AsynchronousFileChannel</code>  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AioFileChannel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (AsynchronousFileChannel channel = AsynchronousFileChannel.open(Paths.get(<span class="string">&quot;netty-demo/data.txt&quot;</span>), StandardOpenOption.READ)) &#123;</span><br><span class="line">            <span class="comment">//参数1 ByteBuffer</span></span><br><span class="line">            <span class="comment">//参数2 读取的起始位置</span></span><br><span class="line">            <span class="comment">//参数3 附件（如果一次读不完，可以通过附件再次读取）</span></span><br><span class="line">            <span class="comment">//参数4 回调对象 CompletionHandler</span></span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;read begin...&quot;</span>);</span><br><span class="line">            channel.read(buffer, <span class="number">0</span>, buffer, <span class="keyword">new</span> CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span> <span class="comment">//read 成功回调方法</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;read completed...&quot;</span>);</span><br><span class="line">                    attachment.flip();</span><br><span class="line">                    ByteBufferUtil.debugAll(attachment);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span>  <span class="comment">//read 失败回调方法</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">                    exc.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            log.debug(<span class="string">&quot;read end...&quot;</span>);</span><br><span class="line">            System.in.read();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11:33:39 [DEBUG] [main] c.y.n.c.AioFileChannel - read begin...</span><br><span class="line">11:33:39 [DEBUG] [main] c.y.n.c.AioFileChannel - read end...</span><br><span class="line">11:33:39 [DEBUG] [Thread-12] c.y.n.c.AioFileChannel - read completed...</span><br><span class="line">+--------+-------------------- all ------------------------+----------------+</span><br><span class="line">position: [0], limit: [13]</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 31 32 33 34 35 36 37 38 39 30 61 62 63 00 00 00 |1234567890abc...|</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>
<p>可以看到  </p>
<ul>
<li>响应文件读取成功的是另一个线程<code>Thread-12</code></li>
<li>主线程并没有IO操作阻塞</li>
</ul>
<p><strong>💡 守护线程</strong><br>默认文件<code>AIO</code>使用的线程都是守护线程，所以最后要执行<code>System.in.read()</code>以避免守护线程意外结束  </p>
<h4 id="网络IO"><a href="#网络IO" class="headerlink" title="网络IO"></a>网络IO</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AioServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        AsynchronousServerSocketChannel ssc = AsynchronousServerSocketChannel.open();</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">        ssc.accept(<span class="keyword">null</span>, <span class="keyword">new</span> AcceptHandler(ssc));</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeChannel</span><span class="params">(AsynchronousSocketChannel sc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;[%s] %s close\n&quot;</span>, Thread.currentThread().getName(), sc.getRemoteAddress());</span><br><span class="line">            sc.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadHandler</span> <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">Integer</span>, <span class="title">ByteBuffer</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AsynchronousSocketChannel sc;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ReadHandler</span><span class="params">(AsynchronousSocketChannel sc)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.sc = sc;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (result == -<span class="number">1</span>) &#123;</span><br><span class="line">                    closeChannel(sc);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.printf(<span class="string">&quot;[%s] %s read\n&quot;</span>, Thread.currentThread().getName(), sc.getRemoteAddress());</span><br><span class="line">                attachment.flip();</span><br><span class="line">                System.out.println(Charset.defaultCharset().decode(attachment));</span><br><span class="line">                attachment.clear();</span><br><span class="line">                <span class="comment">// 处理完第一个 read 时，需要再次调用 read 方法来处理下一个 read 事件</span></span><br><span class="line">                sc.read(attachment, attachment, <span class="keyword">this</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">            closeChannel(sc);</span><br><span class="line">            exc.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteHandler</span> <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">Integer</span>, <span class="title">ByteBuffer</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AsynchronousSocketChannel sc;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">WriteHandler</span><span class="params">(AsynchronousSocketChannel sc)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.sc = sc;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 如果作为附件的 buffer 还有内容，需要再次 write 写出剩余内容</span></span><br><span class="line">            <span class="keyword">if</span> (attachment.hasRemaining()) &#123;</span><br><span class="line">                sc.write(attachment);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">            exc.printStackTrace();</span><br><span class="line">            closeChannel(sc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AcceptHandler</span> <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">AsynchronousSocketChannel</span>, <span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AsynchronousServerSocketChannel ssc;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AcceptHandler</span><span class="params">(AsynchronousServerSocketChannel ssc)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.ssc = ssc;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(AsynchronousSocketChannel sc, Object attachment)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;[%s] %s connected\n&quot;</span>, Thread.currentThread().getName(), sc.getRemoteAddress());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">            <span class="comment">// 读事件由 ReadHandler 处理</span></span><br><span class="line">            sc.read(buffer, buffer, <span class="keyword">new</span> ReadHandler(sc));</span><br><span class="line">            <span class="comment">// 写事件由 WriteHandler 处理</span></span><br><span class="line">            sc.write(Charset.defaultCharset().encode(<span class="string">&quot;server hello!&quot;</span>), ByteBuffer.allocate(<span class="number">16</span>), <span class="keyword">new</span> WriteHandler(sc));</span><br><span class="line">            <span class="comment">// 处理完第一个 accpet 时，需要再次调用 accept 方法来处理下一个 accept 事件</span></span><br><span class="line">            ssc.accept(<span class="keyword">null</span>, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Object attachment)</span> </span>&#123;</span><br><span class="line">            exc.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>Java网络编程教程-Netty深入浅出全套教程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java网络编程教程|Netty深入浅出全套教程——Netty进阶（三）</title>
    <url>/2022/02/03/netty/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B%E2%80%94%E2%80%94Netty%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h1 id="黏包与半包"><a href="#黏包与半包" class="headerlink" title="黏包与半包"></a>黏包与半包</h1><h2 id="黏包现象"><a href="#黏包现象" class="headerlink" title="黏包现象"></a>黏包现象</h2><p>服务端代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(HelloWorldServer.class);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup boss = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        NioEventLoopGroup worker = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line">            serverBootstrap.group(boss, worker);</span><br><span class="line">            serverBootstrap.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> LoggingHandler(LogLevel.DEBUG));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;connected &#123;&#125;&quot;</span>, ctx.channel());</span><br><span class="line">                            <span class="keyword">super</span>.channelActive(ctx);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;disconnect &#123;&#125;&quot;</span>, ctx.channel());</span><br><span class="line">                            <span class="keyword">super</span>.channelInactive(ctx);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">8080</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;&#123;&#125; binding...&quot;</span>, channelFuture.channel());</span><br><span class="line">            channelFuture.sync();</span><br><span class="line">            log.debug(<span class="string">&quot;&#123;&#125; bound...&quot;</span>, channelFuture.channel());</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;server error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            boss.shutdownGracefully();</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">            log.debug(<span class="string">&quot;stoped&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> HelloWorldServer().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端希望发送10条消息，每个消息16字节</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(HelloWorldClient.class);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup worker = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(worker);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;connetted...&quot;</span>);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;sending...&quot;</span>);</span><br><span class="line">                            Random r = <span class="keyword">new</span> Random();</span><br><span class="line">                            <span class="keyword">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                                ByteBuf buffer = ctx.alloc().buffer();</span><br><span class="line">                                buffer.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>&#125;);</span><br><span class="line">                                ctx.writeAndFlush(buffer);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务器端的输出，可以看到一次就接收了160个字节，而非分10次接收  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">08:24:46 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x81e0fda5] binding...</span><br><span class="line">08:24:46 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x81e0fda5, L:/0:0:0:0:0:0:0:0:8080] bound...</span><br><span class="line">08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] REGISTERED</span><br><span class="line">08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] ACTIVE</span><br><span class="line">08:24:55 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177]</span><br><span class="line">08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] READ: 160B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="line">|00000010| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="line">|00000020| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="line">|00000030| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="line">|00000040| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="line">|00000050| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="line">|00000060| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="line">|00000070| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="line">|00000080| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="line">|00000090| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] READ COMPLETE</span><br></pre></td></tr></table></figure>

<h2 id="半包现象"><a href="#半包现象" class="headerlink" title="半包现象"></a>半包现象</h2><p>客户端代码希望发送 1 个消息，这个消息是 160 字节，代码改为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ByteBuf buffer = ctx.alloc().buffer();</span><br><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    buffer.writeBytes(new byte[]&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15&#125;);</span><br><span class="line">&#125;</span><br><span class="line">ctx.writeAndFlush(buffer);</span><br></pre></td></tr></table></figure>
<p>为现象明显，服务端修改一下接收缓冲区，其它代码不变</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//此方法为设置缓冲区大小，本人测试未生效</span><br><span class="line">serverBootstrap.option(ChannelOption.SO_RCVBUF, 10);</span><br></pre></td></tr></table></figure>
<p>服务器端的某次输出，可以看到接收的消息被分为两节，第一次 20 字节，第二次 140 字节</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">08:43:49 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x4d6c6a84] binding...</span><br><span class="line">08:43:49 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x4d6c6a84, L:/0:0:0:0:0:0:0:0:8080] bound...</span><br><span class="line">08:44:23 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] REGISTERED</span><br><span class="line">08:44:23 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] ACTIVE</span><br><span class="line">08:44:23 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221]</span><br><span class="line">08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ: 20B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="line">|00000010| 00 01 02 03                                     |....            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ COMPLETE</span><br><span class="line">08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ: 140B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|</span><br><span class="line">|00000010| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|</span><br><span class="line">|00000020| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|</span><br><span class="line">|00000030| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|</span><br><span class="line">|00000040| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|</span><br><span class="line">|00000050| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|</span><br><span class="line">|00000060| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|</span><br><span class="line">|00000070| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|</span><br><span class="line">|00000080| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f             |............    |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ COMPLETE</span><br></pre></td></tr></table></figure>
<p><font color="red">注意 </font>  </p>
<blockquote>
<p><code>serverBootstrap.option(ChannelOption.SO_RCVBUF, 10)</code> 影响的底层接收缓冲区（即滑动窗口）大小，仅决定了 netty 读取的最小单位，netty 实际每次读取的一般是它的整数倍<br>(经本人测试，该方法未生效)</p>
</blockquote>
<h2 id="现象分析"><a href="#现象分析" class="headerlink" title="现象分析"></a>现象分析</h2><p><strong>黏包</strong>  </p>
<ul>
<li>现象，发送 <code>abc</code> <code>def</code>，接收<code>abcdef</code></li>
<li>原因<ul>
<li>应用层：接收方<code>ByteBuf</code>设置太大（Netty默认1024）</li>
<li>滑动窗口：假设发送方<code>256 bytes</code>表示一个完整报文，但由于接收方处理不及时，且窗口大小足够大，这<code>256 bytes</code>字节就会缓冲在接收方的滑动窗口中，当滑动窗口中缓冲了多个报文就会黏包  </li>
<li>Nagle算法：会造成黏包</li>
</ul>
</li>
</ul>
<p><strong>半包</strong>  </p>
<ul>
<li>现象，发送 <code>abcdef</code>，接收 <code>abc</code> <code>def</code></li>
<li>原因<ul>
<li>应用层：接收方<code>ByteBuf</code>小于实际发送数据量</li>
<li>滑动窗口：假设接收方的窗口只剩下<code>128 bytes</code>，发送方的报文大小是<code>256 bytes</code>这时放不下了，只能先发送前面的<code>128 bytes</code>，等待ack后才能发送剩下部分，这就造成了半包</li>
<li>MSS限制：当发送的数据超过MSS限制后，会将数据切分发送，就会造成半包  </li>
</ul>
</li>
</ul>
<blockquote>
<p>本质是因为TCP是流式协议，消息无边界  </p>
</blockquote>
<p><strong>滑动窗口</strong>  </p>
<ul>
<li>TCP以一个段（segment）为单位，每发送一个段就需要进行一次确认应答（ack）处理，但如果这么做，缺点是包的往返时间越长性能就越差<br><img src="/2022/02/03/netty/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B%E2%80%94%E2%80%94Netty%E8%BF%9B%E9%98%B6/TCP%E5%9B%BE%E7%A4%BA.png" alt="TCP图示"></li>
<li>为了解决此问题，引入了窗口概念，窗口大小即决定了无需等待应答而可以继续发送的数据最大值<br><img src="/2022/02/03/netty/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B%E2%80%94%E2%80%94Netty%E8%BF%9B%E9%98%B6/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%9B%BE%E7%A4%BA.png" alt="滑动窗口图示"></li>
<li>窗口实际就起到一个缓冲区的作用，同时也能起到流量控制的作用<ul>
<li>图中深色的部分即要发送的数据，高亮的部分即窗口</li>
<li>窗口内的数据才允许被发送，当应答未到达前，窗口必须停止滑动</li>
<li>如果 1001~2000 这个段的数据 ack 回来了，窗口就可以向前滑动</li>
<li>接收方也会维护一个窗口，只有落在窗口内的数据才能允许接收</li>
</ul>
</li>
</ul>
<p><strong>MSS限制</strong>  </p>
<ul>
<li>链路层对一次能够发送的最大数据有限制，这个限制称之为 MTU（maximum transmission unit），不同的链路设备的 MTU 值也有所不同，例如<ul>
<li>以太网的 MTU 是 1500</li>
<li>FDDI（光纤分布式数据接口）的 MTU 是 4352</li>
<li>本地回环地址的 MTU 是 65535 - 本地测试不走网卡</li>
</ul>
</li>
<li>MSS 是最大段长度（maximum segment size），它是 MTU 刨去 tcp 头和 ip 头后剩余能够作为数据传输的字节数</li>
<li>ipv4 tcp 头占用 20 bytes，ip 头占用 20 bytes，因此以太网 MSS 的值为 1500 - 40 = 1460</li>
<li>TCP 在传递大量数据时，会按照 MSS 大小将数据进行分割发送</li>
<li>MSS 的值在三次握手时通知对方自己 MSS 的值，然后在两者之间选择一个小值作为 MSS<br><img src="/2022/02/03/netty/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B%E2%80%94%E2%80%94Netty%E8%BF%9B%E9%98%B6/TCP%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%9B%BE%E7%A4%BA.png" alt="TCP网络传输图示"></li>
</ul>
<p><strong>Nagle 算法</strong>  </p>
<ul>
<li>即使发送一个字节，也需要加入 tcp 头和 ip 头，也就是总字节数会使用 41 bytes，非常不经济。因此为了提高网络利用率，tcp 希望尽可能发送足够大的数据，这就是 Nagle 算法产生的缘由</li>
<li>该算法是指发送端即使还有应该发送的数据，但如果这部分数据很少的话，则进行延迟发送<ul>
<li>如果 SO_SNDBUF 的数据达到 MSS，则需要发送</li>
<li>如果 SO_SNDBUF 中含有 FIN（表示需要连接关闭）这时将剩余数据发送，再关闭</li>
<li>如果 TCP_NODELAY = true，则需要发送</li>
<li>已发送的数据都收到 ack 时，则需要发送 </li>
<li>上述条件不满足，但发生超时（一般为 200ms）则需要发送 </li>
<li>除上述情况，延迟发送</li>
</ul>
</li>
</ul>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul>
<li>短连接，发一个包建立一次链接，这样链接建立到链接断开之间就是消息的边界，缺点效率太低</li>
<li>每条消息采用固定长度，缺点浪费空间</li>
<li>每条消息采用分隔符，例如\n，缺点需要转义</li>
<li>每条消息分为head和body，head中包含body的长度</li>
</ul>
<h3 id="短连接"><a href="#短连接" class="headerlink" title="短连接"></a>短连接</h3><p>以解决黏包为例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(HelloWorldClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 分 10 次发送</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            send();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup worker = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(worker);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;conneted...&quot;</span>);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> LoggingHandler(LogLevel.DEBUG));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;sending...&quot;</span>);</span><br><span class="line">                            ByteBuf buffer = ctx.alloc().buffer();</span><br><span class="line">                            buffer.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>&#125;);</span><br><span class="line">                            ctx.writeAndFlush(buffer);</span><br><span class="line">                            <span class="comment">// 发完即关</span></span><br><span class="line">                            ctx.close();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这种方法虽然可以解决黏包问题，但是半包还是不好用，因为接收方的缓冲区大小是有限制的</p>
</blockquote>
<h3 id="固定长度"><a href="#固定长度" class="headerlink" title="固定长度"></a>固定长度</h3><p>让所有数据包长度固定（假设长度为 8 字节），服务器端加入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ch.pipeline().addLast(new FixedLengthFrameDecoder(8));</span><br></pre></td></tr></table></figure>
<p>客户端测试代码，注意, 采用这种方法后，客户端什么时候 flush 都可以</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(HelloWorldClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup worker = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(worker);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;connetted...&quot;</span>);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> LoggingHandler(LogLevel.DEBUG));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;sending...&quot;</span>);</span><br><span class="line">                            <span class="comment">// 发送内容随机的数据包</span></span><br><span class="line">                            Random r = <span class="keyword">new</span> Random();</span><br><span class="line">                            <span class="keyword">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                            ByteBuf buffer = ctx.alloc().buffer();</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                                <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>];</span><br><span class="line">                                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; r.nextInt(<span class="number">8</span>); j++) &#123;</span><br><span class="line">                                    bytes[j] = (<span class="keyword">byte</span>) c;</span><br><span class="line">                                &#125;</span><br><span class="line">                                c++;</span><br><span class="line">                                buffer.writeBytes(bytes);</span><br><span class="line">                            &#125;</span><br><span class="line">                            ctx.writeAndFlush(buffer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">&quot;192.168.0.103&quot;</span>, <span class="number">9090</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端输出 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - connetted...</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2] REGISTERED</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2] CONNECT: /192.168.0.103:9090</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:/192.168.0.103:53155 - R:/192.168.0.103:9090] ACTIVE</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - sending...</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:/192.168.0.103:53155 - R:/192.168.0.103:9090] WRITE: 80B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 61 61 61 61 00 00 00 00 62 00 00 00 00 00 00 00 |aaaa....b.......|</span><br><span class="line">|00000010| 63 63 00 00 00 00 00 00 64 00 00 00 00 00 00 00 |cc......d.......|</span><br><span class="line">|00000020| 00 00 00 00 00 00 00 00 66 66 66 66 00 00 00 00 |........ffff....|</span><br><span class="line">|00000030| 67 67 67 00 00 00 00 00 68 00 00 00 00 00 00 00 |ggg.....h.......|</span><br><span class="line">|00000040| 69 69 69 69 69 00 00 00 6a 6a 6a 6a 00 00 00 00 |iiiii...jjjj....|</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:/192.168.0.103:53155 - R:/192.168.0.103:9090] FLUSH</span><br></pre></td></tr></table></figure>
<p>服务端输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12:06:51 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xe3d9713f] binding...</span><br><span class="line">12:06:51 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xe3d9713f, L:/192.168.0.103:9090] bound...</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] REGISTERED</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] ACTIVE</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155]</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 61 61 61 61 00 00 00 00                         |aaaa....        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 62 00 00 00 00 00 00 00                         |b.......        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 63 63 00 00 00 00 00 00                         |cc......        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 64 00 00 00 00 00 00 00                         |d.......        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 00 00 00 00 00 00 00 00                         |........        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 66 66 66 66 00 00 00 00                         |ffff....        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 67 67 67 00 00 00 00 00                         |ggg.....        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 68 00 00 00 00 00 00 00                         |h.......        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 69 69 69 69 69 00 00 00                         |iiiii...        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 6a 6a 6a 6a 00 00 00 00                         |jjjj....        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ COMPLETE</span><br></pre></td></tr></table></figure>

<p>缺点是，数据包的大小不好把握</p>
<ul>
<li>长度定的太大，浪费</li>
<li>长度定的太小，对某些数据包又显得不够</li>
</ul>
<h3 id="固定分隔符"><a href="#固定分隔符" class="headerlink" title="固定分隔符"></a>固定分隔符</h3><p>服务端加入，默认以 \n 或 \r\n 作为分隔符，如果超出指定长度仍未出现分隔符，则抛出异常</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ch.pipeline().addLast(new LineBasedFrameDecoder(1024));</span><br></pre></td></tr></table></figure>
<p>客户端在每条消息之后，加入 \n 分隔符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(HelloWorldClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup worker = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(worker);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;connetted...&quot;</span>);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> LoggingHandler(LogLevel.DEBUG));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;sending...&quot;</span>);</span><br><span class="line">                            Random r = <span class="keyword">new</span> Random();</span><br><span class="line">                            <span class="keyword">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                            ByteBuf buffer = ctx.alloc().buffer();</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= r.nextInt(<span class="number">16</span>)+<span class="number">1</span>; j++) &#123;</span><br><span class="line">                                    buffer.writeByte((<span class="keyword">byte</span>) c);</span><br><span class="line">                                &#125;</span><br><span class="line">                                buffer.writeByte(<span class="number">10</span>);</span><br><span class="line">                                c++;</span><br><span class="line">                            &#125;</span><br><span class="line">                            ctx.writeAndFlush(buffer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">&quot;192.168.0.103&quot;</span>, <span class="number">9090</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - connetted...</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755] REGISTERED</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755] CONNECT: /192.168.0.103:9090</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:/192.168.0.103:63641 - R:/192.168.0.103:9090] ACTIVE</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - sending...</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:/192.168.0.103:63641 - R:/192.168.0.103:9090] WRITE: 60B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 61 0a 62 62 62 0a 63 63 63 0a 64 64 0a 65 65 65 |a.bbb.ccc.dd.eee|</span><br><span class="line">|00000010| 65 65 65 65 65 65 65 0a 66 66 0a 67 67 67 67 67 |eeeeeee.ff.ggggg|</span><br><span class="line">|00000020| 67 67 0a 68 68 68 68 0a 69 69 69 69 69 69 69 0a |gg.hhhh.iiiiiii.|</span><br><span class="line">|00000030| 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 0a             |jjjjjjjjjjj.    |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:/192.168.0.103:63641 - R:/192.168.0.103:9090] FLUSH</span><br></pre></td></tr></table></figure>
<p>服务端输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] c.i.n.HelloWorldServer - connected [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641]</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 1B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 61                                              |a               |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 3B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 62 62 62                                        |bbb             |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 3B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 63 63 63                                        |ccc             |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 2B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 64 64                                           |dd              |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 10B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 65 65 65 65 65 65 65 65 65 65                   |eeeeeeeeee      |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 2B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 66 66                                           |ff              |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 7B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 67 67 67 67 67 67 67                            |ggggggg         |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 4B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 68 68 68 68                                     |hhhh            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 7B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 69 69 69 69 69 69 69                            |iiiiiii         |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 11B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a                |jjjjjjjjjjj     |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ COMPLETE</span><br></pre></td></tr></table></figure>

<p>缺点，处理字符数据比较合适，但如果内容本身包含了分隔符（字节数据常常会有此情况），那么就会解析错误</p>
<h3 id="预设长度"><a href="#预设长度" class="headerlink" title="预设长度"></a>预设长度</h3><p>在发送消息前，先约定用定长字节表示接下来数据的长度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 最大长度，长度偏移，长度占用字节，长度调整，剥离字节数</span><br><span class="line">ch.pipeline().addLast(new LengthFieldBasedFrameDecoder(1024, 0, 1, 0, 1));</span><br></pre></td></tr></table></figure>
<p>客户端代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(HelloWorldClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup worker = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(worker);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;connetted...&quot;</span>);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> LoggingHandler(LogLevel.DEBUG));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;sending...&quot;</span>);</span><br><span class="line">                            Random r = <span class="keyword">new</span> Random();</span><br><span class="line">                            <span class="keyword">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                            ByteBuf buffer = ctx.alloc().buffer();</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                                <span class="keyword">byte</span> length = (<span class="keyword">byte</span>) (r.nextInt(<span class="number">16</span>) + <span class="number">1</span>);</span><br><span class="line">                                <span class="comment">// 先写入长度</span></span><br><span class="line">                                buffer.writeByte(length);</span><br><span class="line">                                <span class="comment">// 再</span></span><br><span class="line">                                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= length; j++) &#123;</span><br><span class="line">                                    buffer.writeByte((<span class="keyword">byte</span>) c);</span><br><span class="line">                                &#125;</span><br><span class="line">                                c++;</span><br><span class="line">                            &#125;</span><br><span class="line">                            ctx.writeAndFlush(buffer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">&quot;192.168.0.103&quot;</span>, <span class="number">9090</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - connetted...</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8] REGISTERED</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8] CONNECT: /192.168.0.103:9090</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8, L:/192.168.0.103:49979 - R:/192.168.0.103:9090] ACTIVE</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - sending...</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8, L:/192.168.0.103:49979 - R:/192.168.0.103:9090] WRITE: 97B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 09 61 61 61 61 61 61 61 61 61 09 62 62 62 62 62 |.aaaaaaaaa.bbbbb|</span><br><span class="line">|00000010| 62 62 62 62 06 63 63 63 63 63 63 08 64 64 64 64 |bbbb.cccccc.dddd|</span><br><span class="line">|00000020| 64 64 64 64 0f 65 65 65 65 65 65 65 65 65 65 65 |dddd.eeeeeeeeeee|</span><br><span class="line">|00000030| 65 65 65 65 0d 66 66 66 66 66 66 66 66 66 66 66 |eeee.fffffffffff|</span><br><span class="line">|00000040| 66 66 02 67 67 02 68 68 0e 69 69 69 69 69 69 69 |ff.gg.hh.iiiiiii|</span><br><span class="line">|00000050| 69 69 69 69 69 69 69 09 6a 6a 6a 6a 6a 6a 6a 6a |iiiiiii.jjjjjjjj|</span><br><span class="line">|00000060| 6a                                              |j               |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8, L:/192.168.0.103:49979 - R:/192.168.0.103:9090] FLUSH</span><br></pre></td></tr></table></figure>
<p>服务端输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">14:36:50 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xdff439d3] binding...</span><br><span class="line">14:36:51 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xdff439d3, L:/192.168.0.103:9090] bound...</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] REGISTERED</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] ACTIVE</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979]</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 9B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 61 61 61 61 61 61 61 61 61                      |aaaaaaaaa       |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 9B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 62 62 62 62 62 62 62 62 62                      |bbbbbbbbb       |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 6B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 63 63 63 63 63 63                               |cccccc          |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 64 64 64 64 64 64 64 64                         |dddddddd        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 15B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 65 65 65 65 65 65 65 65 65 65 65 65 65 65 65    |eeeeeeeeeeeeeee |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 13B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 66 66 66 66 66 66 66 66 66 66 66 66 66          |fffffffffffff   |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 2B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 67 67                                           |gg              |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 2B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 68 68                                           |hh              |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 14B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 69 69 69 69 69 69 69 69 69 69 69 69 69 69       |iiiiiiiiiiiiii  |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 9B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 6a 6a 6a 6a 6a 6a 6a 6a 6a                      |jjjjjjjjj       |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ COMPLETE</span><br></pre></td></tr></table></figure>

<h1 id="协议设计与解析"><a href="#协议设计与解析" class="headerlink" title="协议设计与解析"></a>协议设计与解析</h1><h2 id="为什么需要协议"><a href="#为什么需要协议" class="headerlink" title="为什么需要协议"></a>为什么需要协议</h2><p>TCP/IP中消息传输基于流的方式，没有边界<br>协议的目的就是划定消息的边界，制定通信双方要共同准守的通信规则</p>
<h2 id="redis协议举例"><a href="#redis协议举例" class="headerlink" title="redis协议举例"></a>redis协议举例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRedis</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup worker = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">byte</span>[] LINE = &#123;<span class="number">13</span>, <span class="number">10</span>&#125;;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(worker);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> LoggingHandler());</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">                        <span class="comment">// 会在连接 channel 建立成功后，会触发 active 事件</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">                            set(ctx);</span><br><span class="line">                            get(ctx);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">                            ByteBuf buf = ctx.alloc().buffer();</span><br><span class="line">                            buf.writeBytes(<span class="string">&quot;*2&quot;</span>.getBytes());</span><br><span class="line">                            buf.writeBytes(LINE);</span><br><span class="line">                            buf.writeBytes(<span class="string">&quot;$3&quot;</span>.getBytes());</span><br><span class="line">                            buf.writeBytes(LINE);</span><br><span class="line">                            buf.writeBytes(<span class="string">&quot;get&quot;</span>.getBytes());</span><br><span class="line">                            buf.writeBytes(LINE);</span><br><span class="line">                            buf.writeBytes(<span class="string">&quot;$3&quot;</span>.getBytes());</span><br><span class="line">                            buf.writeBytes(LINE);</span><br><span class="line">                            buf.writeBytes(<span class="string">&quot;aaa&quot;</span>.getBytes());</span><br><span class="line">                            buf.writeBytes(LINE);</span><br><span class="line">                            ctx.writeAndFlush(buf);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">                            ByteBuf buf = ctx.alloc().buffer();</span><br><span class="line">                            buf.writeBytes(<span class="string">&quot;*3&quot;</span>.getBytes());</span><br><span class="line">                            buf.writeBytes(LINE);</span><br><span class="line">                            buf.writeBytes(<span class="string">&quot;$3&quot;</span>.getBytes());</span><br><span class="line">                            buf.writeBytes(LINE);</span><br><span class="line">                            buf.writeBytes(<span class="string">&quot;set&quot;</span>.getBytes());</span><br><span class="line">                            buf.writeBytes(LINE);</span><br><span class="line">                            buf.writeBytes(<span class="string">&quot;$3&quot;</span>.getBytes());</span><br><span class="line">                            buf.writeBytes(LINE);</span><br><span class="line">                            buf.writeBytes(<span class="string">&quot;aaa&quot;</span>.getBytes());</span><br><span class="line">                            buf.writeBytes(LINE);</span><br><span class="line">                            buf.writeBytes(<span class="string">&quot;$3&quot;</span>.getBytes());</span><br><span class="line">                            buf.writeBytes(LINE);</span><br><span class="line">                            buf.writeBytes(<span class="string">&quot;bbb&quot;</span>.getBytes());</span><br><span class="line">                            buf.writeBytes(LINE);</span><br><span class="line">                            ctx.writeAndFlush(buf);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">                            System.out.println(buf.toString(Charset.defaultCharset()));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">6379</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Http协议举例"><a href="#Http协议举例" class="headerlink" title="Http协议举例"></a>Http协议举例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup boss = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        NioEventLoopGroup worker = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line">            serverBootstrap.group(boss, worker);</span><br><span class="line">            serverBootstrap.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> LoggingHandler(LogLevel.DEBUG));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> HttpServerCodec());</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> SimpleChannelInboundHandler&lt;HttpRequest&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, HttpRequest msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            <span class="comment">// 获取请求</span></span><br><span class="line">                            log.debug(msg.uri());</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 返回响应</span></span><br><span class="line">                            DefaultFullHttpResponse response =</span><br><span class="line">                                    <span class="keyword">new</span> DefaultFullHttpResponse(msg.protocolVersion(), HttpResponseStatus.OK);</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">byte</span>[] bytes = <span class="string">&quot;&lt;h1&gt;Hello, world!&lt;/h1&gt;&quot;</span>.getBytes();</span><br><span class="line"></span><br><span class="line">                            response.headers().setInt(HttpHeaderNames.CONTENT_LENGTH, bytes.length);</span><br><span class="line">                            response.content().writeBytes(bytes);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 写回响应</span></span><br><span class="line">                            ctx.writeAndFlush(response);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">/*ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;</span></span><br><span class="line"><span class="comment">                @Override</span></span><br><span class="line"><span class="comment">                public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span></span><br><span class="line"><span class="comment">                    log.debug(&quot;&#123;&#125;&quot;, msg.getClass());</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                    if (msg instanceof HttpRequest) &#123; // 请求行，请求头</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                    &#125; else if (msg instanceof HttpContent) &#123; //请求体</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;);*/</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">8080</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;server error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            boss.shutdownGracefully();</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义协议要素"><a href="#自定义协议要素" class="headerlink" title="自定义协议要素"></a>自定义协议要素</h2><ul>
<li>魔数，用来在第一时间判断是否是无效数据包</li>
<li>版本号，可以支持协议的升级</li>
<li>序列化算法，消息正文到底采用哪种序列化反序列化方式，可以由此扩展，例如：json、protobuf、hessian、jdk</li>
<li>指令类型，是登陆、注册、单聊、群聊…跟业务相关</li>
<li>请求序号，为了双工通信，提供异步能力</li>
<li>正文长度</li>
<li>消息正文</li>
</ul>
<p><strong>编解码器</strong><br>根据上面的要素，设计一个登陆请求消息和登陆响应消息，并使用Netty完成收发  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageCodec</span> <span class="keyword">extends</span> <span class="title">ByteToMessageCodec</span>&lt;<span class="title">Message</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Message msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 4 字节的魔数</span></span><br><span class="line">        out.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">        <span class="comment">// 2. 1 字节的版本,</span></span><br><span class="line">        out.writeByte(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3. 1 字节的序列化方式 jdk 0 , json 1</span></span><br><span class="line">        out.writeByte(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 4. 1 字节的指令类型</span></span><br><span class="line">        out.writeByte(msg.getMessageType());</span><br><span class="line">        <span class="comment">// 5. 4 个字节</span></span><br><span class="line">        out.writeInt(msg.getSequenceId());</span><br><span class="line">        <span class="comment">// 无意义，对齐填充</span></span><br><span class="line">        out.writeByte(<span class="number">0xff</span>);</span><br><span class="line">        <span class="comment">// 6. 获取内容的字节数组</span></span><br><span class="line">        ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line">        oos.writeObject(msg);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = bos.toByteArray();</span><br><span class="line">        <span class="comment">// 7. 长度</span></span><br><span class="line">        out.writeInt(bytes.length);</span><br><span class="line">        <span class="comment">// 8. 写入内容</span></span><br><span class="line">        out.writeBytes(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> magicNum = in.readInt();</span><br><span class="line">        <span class="keyword">byte</span> version = in.readByte();</span><br><span class="line">        <span class="keyword">byte</span> serializerType = in.readByte();</span><br><span class="line">        <span class="keyword">byte</span> messageType = in.readByte();</span><br><span class="line">        <span class="keyword">int</span> sequenceId = in.readInt();</span><br><span class="line">        in.readByte();</span><br><span class="line">        <span class="keyword">int</span> length = in.readInt();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">        in.readBytes(bytes, <span class="number">0</span>, length);</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(bytes));</span><br><span class="line">        Message message = (Message) ois.readObject();</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, magicNum, version, serializerType, messageType, sequenceId, length);</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, message);</span><br><span class="line">        out.add(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EmbeddedChannel channel = new EmbeddedChannel(</span><br><span class="line">    new LoggingHandler(),</span><br><span class="line">    new LengthFieldBasedFrameDecoder(</span><br><span class="line">        1024, 12, 4, 0, 0),</span><br><span class="line">    new MessageCodec()</span><br><span class="line">);</span><br><span class="line">// encode</span><br><span class="line">LoginRequestMessage message = new LoginRequestMessage(&quot;zhangsan&quot;, &quot;123&quot;, &quot;张三&quot;);</span><br><span class="line">//        channel.writeOutbound(message);</span><br><span class="line">// decode</span><br><span class="line">ByteBuf buf = ByteBufAllocator.DEFAULT.buffer();</span><br><span class="line">new MessageCodec().encode(null, message, buf);</span><br><span class="line"></span><br><span class="line">ByteBuf s1 = buf.slice(0, 100);</span><br><span class="line">ByteBuf s2 = buf.slice(100, buf.readableBytes() - 100);</span><br><span class="line">s1.retain(); // 引用计数 2</span><br><span class="line">channel.writeInbound(s1); // release 1</span><br><span class="line">channel.writeInbound(s2);</span><br></pre></td></tr></table></figure>
<p><img src="/2022/02/03/netty/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8BNetty%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B%E2%80%94%E2%80%94Netty%E8%BF%9B%E9%98%B6/%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E6%B6%88%E6%81%AF%E8%A7%A3%E8%AF%BB%E5%9B%BE%E7%A4%BA.png" alt="编解码器消息解读图示"></p>
<p><strong>💡 什么时候可以加@Sharable</strong>  </p>
<ul>
<li>当handler不保存状态时，就可以安全的在多线程下被共享</li>
<li>但是要注意对于编码器类，不能继承ByteToMessageCodec 或者CombinedChannelDuplexHandler 父类，他们的构造方法对@Sharable有限制  </li>
<li>如果能确保编码器不会保存状态，可以继承MessageToMessageCodec 父类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 必须和 LengthFieldBasedFrameDecoder 一起使用，确保接到的 ByteBuf 消息是完整的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageCodecSharable</span> <span class="keyword">extends</span> <span class="title">MessageToMessageCodec</span>&lt;<span class="title">ByteBuf</span>, <span class="title">Message</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Message msg, List&lt;Object&gt; outList)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuf out = ctx.alloc().buffer();</span><br><span class="line">        <span class="comment">// 1. 4 字节的魔数</span></span><br><span class="line">        out.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">        <span class="comment">// 2. 1 字节的版本,</span></span><br><span class="line">        out.writeByte(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3. 1 字节的序列化方式 jdk 0 , json 1</span></span><br><span class="line">        out.writeByte(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 4. 1 字节的指令类型</span></span><br><span class="line">        out.writeByte(msg.getMessageType());</span><br><span class="line">        <span class="comment">// 5. 4 个字节</span></span><br><span class="line">        out.writeInt(msg.getSequenceId());</span><br><span class="line">        <span class="comment">// 无意义，对齐填充</span></span><br><span class="line">        out.writeByte(<span class="number">0xff</span>);</span><br><span class="line">        <span class="comment">// 6. 获取内容的字节数组</span></span><br><span class="line">        ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line">        oos.writeObject(msg);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = bos.toByteArray();</span><br><span class="line">        <span class="comment">// 7. 长度</span></span><br><span class="line">        out.writeInt(bytes.length);</span><br><span class="line">        <span class="comment">// 8. 写入内容</span></span><br><span class="line">        out.writeBytes(bytes);</span><br><span class="line">        outList.add(out);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> magicNum = in.readInt();</span><br><span class="line">        <span class="keyword">byte</span> version = in.readByte();</span><br><span class="line">        <span class="keyword">byte</span> serializerType = in.readByte();</span><br><span class="line">        <span class="keyword">byte</span> messageType = in.readByte();</span><br><span class="line">        <span class="keyword">int</span> sequenceId = in.readInt();</span><br><span class="line">        in.readByte();</span><br><span class="line">        <span class="keyword">int</span> length = in.readInt();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">        in.readBytes(bytes, <span class="number">0</span>, length);</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(bytes));</span><br><span class="line">        Message message = (Message) ois.readObject();</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, magicNum, version, serializerType, messageType, sequenceId, length);</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, message);</span><br><span class="line">        out.add(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="聊天室案例"><a href="#聊天室案例" class="headerlink" title="聊天室案例"></a>聊天室案例</h1><h2 id="聊天室业务介绍"><a href="#聊天室业务介绍" class="headerlink" title="聊天室业务介绍"></a>聊天室业务介绍</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户管理接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username 用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password 密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 登录成功返回 true, 否则返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">login</span><span class="params">(String username, String password)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 会话管理接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Session</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定会话</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel 哪个 channel 要绑定会话</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username 会话绑定用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bind</span><span class="params">(Channel channel, String username)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解绑会话</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel 哪个 channel 要解绑会话</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unbind</span><span class="params">(Channel channel)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取属性</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel 哪个 channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 属性名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 属性值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Object <span class="title">getAttribute</span><span class="params">(Channel channel, String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置属性</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel 哪个 channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 属性名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 属性值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(Channel channel, String name, Object value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据用户名获取 channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username 用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> channel</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Channel <span class="title">getChannel</span><span class="params">(String username)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 聊天组会话管理接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GroupSession</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个聊天组, 如果不存在才能创建成功, 否则返回 null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 组名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> members 成员</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成功时返回组对象, 失败返回 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Group <span class="title">createGroup</span><span class="params">(String name, Set&lt;String&gt; members)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加入聊天组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 组名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> member 成员名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果组不存在返回 null, 否则返回组对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Group <span class="title">joinMember</span><span class="params">(String name, String member)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除组成员</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 组名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> member 成员名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果组不存在返回 null, 否则返回组对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Group <span class="title">removeMember</span><span class="params">(String name, String member)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除聊天组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 组名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果组不存在返回 null, 否则返回组对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Group <span class="title">removeGroup</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取组成员</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 组名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成员集合, 没有成员会返回 empty set</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Set&lt;String&gt; <span class="title">getMembers</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取组成员的 channel 集合, 只有在线的 channel 才会返回</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 组名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成员 channel 集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;Channel&gt; <span class="title">getMembersChannel</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="聊天室业务-登录"><a href="#聊天室业务-登录" class="headerlink" title="聊天室业务-登录"></a>聊天室业务-登录</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup boss = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        NioEventLoopGroup worker = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        LoggingHandler LOGGING_HANDLER = <span class="keyword">new</span> LoggingHandler(LogLevel.DEBUG);</span><br><span class="line">        MessageCodecSharable MESSAGE_CODEC = <span class="keyword">new</span> MessageCodecSharable();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line">            serverBootstrap.group(boss, worker);</span><br><span class="line">            serverBootstrap.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> ProcotolFrameDecoder());</span><br><span class="line">                    ch.pipeline().addLast(LOGGING_HANDLER);</span><br><span class="line">                    ch.pipeline().addLast(MESSAGE_CODEC);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> SimpleChannelInboundHandler&lt;LoginRequestMessage&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, LoginRequestMessage msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            String username = msg.getUsername();</span><br><span class="line">                            String password = msg.getPassword();</span><br><span class="line">                            <span class="keyword">boolean</span> login = UserServiceFactory.getUserService().login(username, password);</span><br><span class="line">                            LoginResponseMessage message;</span><br><span class="line">                            <span class="keyword">if</span>(login) &#123;</span><br><span class="line">                                message = <span class="keyword">new</span> LoginResponseMessage(<span class="keyword">true</span>, <span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                message = <span class="keyword">new</span> LoginResponseMessage(<span class="keyword">false</span>, <span class="string">&quot;用户名或密码不正确&quot;</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                            ctx.writeAndFlush(message);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            Channel channel = serverBootstrap.bind(<span class="number">8080</span>).sync().channel();</span><br><span class="line">            channel.closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;server error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            boss.shutdownGracefully();</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        LoggingHandler LOGGING_HANDLER = <span class="keyword">new</span> LoggingHandler(LogLevel.DEBUG);</span><br><span class="line">        MessageCodecSharable MESSAGE_CODEC = <span class="keyword">new</span> MessageCodecSharable();</span><br><span class="line">        CountDownLatch WAIT_FOR_LOGIN = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        AtomicBoolean LOGIN = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(group);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> ProcotolFrameDecoder());</span><br><span class="line"><span class="comment">//                    ch.pipeline().addLast(LOGGING_HANDLER);</span></span><br><span class="line">                    ch.pipeline().addLast(MESSAGE_CODEC);</span><br><span class="line">                    ch.pipeline().addLast(<span class="string">&quot;client handler&quot;</span>, <span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">                        <span class="comment">// 接收响应消息</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;msg: &#123;&#125;&quot;</span>, msg);</span><br><span class="line">                            <span class="keyword">if</span> ((msg <span class="keyword">instanceof</span> LoginResponseMessage)) &#123;</span><br><span class="line">                                LoginResponseMessage response = (LoginResponseMessage) msg;</span><br><span class="line">                                <span class="keyword">if</span> (response.isSuccess()) &#123;</span><br><span class="line">                                    <span class="comment">// 如果登录成功</span></span><br><span class="line">                                    LOGIN.set(<span class="keyword">true</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">// 唤醒 system in 线程</span></span><br><span class="line">                                WAIT_FOR_LOGIN.countDown();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 在连接建立后触发 active 事件</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            <span class="comment">// 负责接收用户在控制台的输入，负责向服务器发送各种消息</span></span><br><span class="line">                            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                                Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">                                System.out.println(<span class="string">&quot;请输入用户名:&quot;</span>);</span><br><span class="line">                                String username = scanner.nextLine();</span><br><span class="line">                                System.out.println(<span class="string">&quot;请输入密码:&quot;</span>);</span><br><span class="line">                                String password = scanner.nextLine();</span><br><span class="line">                                <span class="comment">// 构造消息对象</span></span><br><span class="line">                                LoginRequestMessage message = <span class="keyword">new</span> LoginRequestMessage(username, password);</span><br><span class="line">                                <span class="comment">// 发送消息</span></span><br><span class="line">                                ctx.writeAndFlush(message);</span><br><span class="line">                                System.out.println(<span class="string">&quot;等待后续操作...&quot;</span>);</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    WAIT_FOR_LOGIN.await();</span><br><span class="line">                                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                    e.printStackTrace();</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">// 如果登录失败</span></span><br><span class="line">                                <span class="keyword">if</span> (!LOGIN.get()) &#123;</span><br><span class="line">                                    ctx.channel().close();</span><br><span class="line">                                    <span class="keyword">return</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                                    System.out.println(<span class="string">&quot;==================================&quot;</span>);</span><br><span class="line">                                    System.out.println(<span class="string">&quot;send [username] [content]&quot;</span>);</span><br><span class="line">                                    System.out.println(<span class="string">&quot;gsend [group name] [content]&quot;</span>);</span><br><span class="line">                                    System.out.println(<span class="string">&quot;gcreate [group name] [m1,m2,m3...]&quot;</span>);</span><br><span class="line">                                    System.out.println(<span class="string">&quot;gmembers [group name]&quot;</span>);</span><br><span class="line">                                    System.out.println(<span class="string">&quot;gjoin [group name]&quot;</span>);</span><br><span class="line">                                    System.out.println(<span class="string">&quot;gquit [group name]&quot;</span>);</span><br><span class="line">                                    System.out.println(<span class="string">&quot;quit&quot;</span>);</span><br><span class="line">                                    System.out.println(<span class="string">&quot;==================================&quot;</span>);</span><br><span class="line">                                    String command = scanner.nextLine();</span><br><span class="line">                                    String[] s = command.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                                    <span class="keyword">switch</span> (s[<span class="number">0</span>])&#123;</span><br><span class="line">                                        <span class="keyword">case</span> <span class="string">&quot;send&quot;</span>:</span><br><span class="line">                                            ctx.writeAndFlush(<span class="keyword">new</span> ChatRequestMessage(username, s[<span class="number">1</span>], s[<span class="number">2</span>]));</span><br><span class="line">                                            <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">case</span> <span class="string">&quot;gsend&quot;</span>:</span><br><span class="line">                                            ctx.writeAndFlush(<span class="keyword">new</span> GroupChatRequestMessage(username, s[<span class="number">1</span>], s[<span class="number">2</span>]));</span><br><span class="line">                                            <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">case</span> <span class="string">&quot;gcreate&quot;</span>:</span><br><span class="line">                                            Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(s[<span class="number">2</span>].split(<span class="string">&quot;,&quot;</span>)));</span><br><span class="line">                                            set.add(username); <span class="comment">// 加入自己</span></span><br><span class="line">                                            ctx.writeAndFlush(<span class="keyword">new</span> GroupCreateRequestMessage(s[<span class="number">1</span>], set));</span><br><span class="line">                                            <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">case</span> <span class="string">&quot;gmembers&quot;</span>:</span><br><span class="line">                                            ctx.writeAndFlush(<span class="keyword">new</span> GroupMembersRequestMessage(s[<span class="number">1</span>]));</span><br><span class="line">                                            <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">case</span> <span class="string">&quot;gjoin&quot;</span>:</span><br><span class="line">                                            ctx.writeAndFlush(<span class="keyword">new</span> GroupJoinRequestMessage(username, s[<span class="number">1</span>]));</span><br><span class="line">                                            <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">case</span> <span class="string">&quot;gquit&quot;</span>:</span><br><span class="line">                                            ctx.writeAndFlush(<span class="keyword">new</span> GroupQuitRequestMessage(username, s[<span class="number">1</span>]));</span><br><span class="line">                                            <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">case</span> <span class="string">&quot;quit&quot;</span>:</span><br><span class="line">                                            ctx.channel().close();</span><br><span class="line">                                            <span class="keyword">return</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;, <span class="string">&quot;system in&quot;</span>).start();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            Channel channel = bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>).sync().channel();</span><br><span class="line">            channel.closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="聊天室业务-单聊"><a href="#聊天室业务-单聊" class="headerlink" title="聊天室业务-单聊"></a>聊天室业务-单聊</h2><p>服务器端将 handler 独立出来  </p>
<p>登录 handler  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginRequestMessageHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">LoginRequestMessage</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, LoginRequestMessage msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String username = msg.getUsername();</span><br><span class="line">        String password = msg.getPassword();</span><br><span class="line">        <span class="keyword">boolean</span> login = UserServiceFactory.getUserService().login(username, password);</span><br><span class="line">        LoginResponseMessage message;</span><br><span class="line">        <span class="keyword">if</span>(login) &#123;</span><br><span class="line">            SessionFactory.getSession().bind(ctx.channel(), username);</span><br><span class="line">            message = <span class="keyword">new</span> LoginResponseMessage(<span class="keyword">true</span>, <span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            message = <span class="keyword">new</span> LoginResponseMessage(<span class="keyword">false</span>, <span class="string">&quot;用户名或密码不正确&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ctx.writeAndFlush(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单聊 handler</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatRequestMessageHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">ChatRequestMessage</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, ChatRequestMessage msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String to = msg.getTo();</span><br><span class="line">        Channel channel = SessionFactory.getSession().getChannel(to);</span><br><span class="line">        <span class="comment">// 在线</span></span><br><span class="line">        <span class="keyword">if</span>(channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            channel.writeAndFlush(<span class="keyword">new</span> ChatResponseMessage(msg.getFrom(), msg.getContent()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不在线</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ctx.writeAndFlush(<span class="keyword">new</span> ChatResponseMessage(<span class="keyword">false</span>, <span class="string">&quot;对方用户不存在或者不在线&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="聊天室业务-群聊"><a href="#聊天室业务-群聊" class="headerlink" title="聊天室业务-群聊"></a>聊天室业务-群聊</h2><p>创建群聊</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupCreateRequestMessageHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">GroupCreateRequestMessage</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, GroupCreateRequestMessage msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String groupName = msg.getGroupName();</span><br><span class="line">        Set&lt;String&gt; members = msg.getMembers();</span><br><span class="line">        <span class="comment">// 群管理器</span></span><br><span class="line">        GroupSession groupSession = GroupSessionFactory.getGroupSession();</span><br><span class="line">        Group group = groupSession.createGroup(groupName, members);</span><br><span class="line">        <span class="keyword">if</span> (group == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 发生成功消息</span></span><br><span class="line">            ctx.writeAndFlush(<span class="keyword">new</span> GroupCreateResponseMessage(<span class="keyword">true</span>, groupName + <span class="string">&quot;创建成功&quot;</span>));</span><br><span class="line">            <span class="comment">// 发送拉群消息</span></span><br><span class="line">            List&lt;Channel&gt; channels = groupSession.getMembersChannel(groupName);</span><br><span class="line">            <span class="keyword">for</span> (Channel channel : channels) &#123;</span><br><span class="line">                channel.writeAndFlush(<span class="keyword">new</span> GroupCreateResponseMessage(<span class="keyword">true</span>, <span class="string">&quot;您已被拉入&quot;</span> + groupName));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ctx.writeAndFlush(<span class="keyword">new</span> GroupCreateResponseMessage(<span class="keyword">false</span>, groupName + <span class="string">&quot;已经存在&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>群聊</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatRequestMessageHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">GroupChatRequestMessage</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, GroupChatRequestMessage msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List&lt;Channel&gt; channels = GroupSessionFactory.getGroupSession()</span><br><span class="line">                .getMembersChannel(msg.getGroupName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Channel channel : channels) &#123;</span><br><span class="line">            channel.writeAndFlush(<span class="keyword">new</span> GroupChatResponseMessage(msg.getFrom(), msg.getContent()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加入群聊</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupJoinRequestMessageHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">GroupJoinRequestMessage</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, GroupJoinRequestMessage msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Group group = GroupSessionFactory.getGroupSession().joinMember(msg.getGroupName(), msg.getUsername());</span><br><span class="line">        <span class="keyword">if</span> (group != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ctx.writeAndFlush(<span class="keyword">new</span> GroupJoinResponseMessage(<span class="keyword">true</span>, msg.getGroupName() + <span class="string">&quot;群加入成功&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ctx.writeAndFlush(<span class="keyword">new</span> GroupJoinResponseMessage(<span class="keyword">true</span>, msg.getGroupName() + <span class="string">&quot;群不存在&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>退出群聊</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupQuitRequestMessageHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">GroupQuitRequestMessage</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, GroupQuitRequestMessage msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Group group = GroupSessionFactory.getGroupSession().removeMember(msg.getGroupName(), msg.getUsername());</span><br><span class="line">        <span class="keyword">if</span> (group != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ctx.writeAndFlush(<span class="keyword">new</span> GroupJoinResponseMessage(<span class="keyword">true</span>, <span class="string">&quot;已退出群&quot;</span> + msg.getGroupName()));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ctx.writeAndFlush(<span class="keyword">new</span> GroupJoinResponseMessage(<span class="keyword">true</span>, msg.getGroupName() + <span class="string">&quot;群不存在&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看成员</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupMembersRequestMessageHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">GroupMembersRequestMessage</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, GroupMembersRequestMessage msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Set&lt;String&gt; members = GroupSessionFactory.getGroupSession()</span><br><span class="line">                .getMembers(msg.getGroupName());</span><br><span class="line">        ctx.writeAndFlush(<span class="keyword">new</span> GroupMembersResponseMessage(members));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="聊天室业务-退出"><a href="#聊天室业务-退出" class="headerlink" title="聊天室业务-退出"></a>聊天室业务-退出</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuitHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当连接断开时触发 inactive 事件</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SessionFactory.getSession().unbind(ctx.channel());</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125; 已经断开&quot;</span>, ctx.channel());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当出现异常时触发</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SessionFactory.getSession().unbind(ctx.channel());</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125; 已经异常断开 异常是&#123;&#125;&quot;</span>, ctx.channel(), cause.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="聊天室业务-空闲检测"><a href="#聊天室业务-空闲检测" class="headerlink" title="聊天室业务-空闲检测"></a>聊天室业务-空闲检测</h2><h3 id="连接假死"><a href="#连接假死" class="headerlink" title="连接假死"></a>连接假死</h3><p>原因</p>
<ul>
<li>网络设备出现故障，例如网卡，机房等，底层的 TCP 连接已经断开了，但应用程序没有感知到，仍然占用着资源。</li>
<li>公网网络不稳定，出现丢包。如果连续出现丢包，这时现象就是客户端数据发不出去，服务端也一直收不到数据，就这么一直耗着</li>
<li>应用程序线程阻塞，无法进行数据读写</li>
</ul>
<p>问题</p>
<ul>
<li>假死的连接占用的资源不能自动释放</li>
<li>向假死的连接发送数据，得到的反馈是发送超时</li>
</ul>
<p>服务器端解决</p>
<ul>
<li>怎么判断客户端连接是否假死呢？如果能收到客户端数据，说明没有假死。因此策略就可以定为，每隔一段时间就检查这段时间内是否接收到客户端数据，没有就可以判定为连接假死</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 用来判断是不是 读空闲时间过长，或 写空闲时间过长</span><br><span class="line">// 5s 内如果没有收到 channel 的数据，会触发一个 IdleState#READER_IDLE 事件</span><br><span class="line">ch.pipeline().addLast(new IdleStateHandler(5, 0, 0));</span><br><span class="line">// ChannelDuplexHandler 可以同时作为入站和出站处理器</span><br><span class="line">ch.pipeline().addLast(new ChannelDuplexHandler() &#123;</span><br><span class="line">    // 用来触发特殊事件</span><br><span class="line">    @Override</span><br><span class="line">    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception&#123;</span><br><span class="line">        IdleStateEvent event = (IdleStateEvent) evt;</span><br><span class="line">        // 触发了读空闲事件</span><br><span class="line">        if (event.state() == IdleState.READER_IDLE) &#123;</span><br><span class="line">            log.debug(&quot;已经 5s 没有读到数据了&quot;);</span><br><span class="line">            ctx.channel().close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>客户端定时心跳</p>
<ul>
<li>客户端可以定时向服务器端发送数据，只要这个时间间隔小于服务器定义的空闲检测的时间间隔，那么就能防止前面提到的误判，客户端可以定义如下心跳处理器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 用来判断是不是 读空闲时间过长，或 写空闲时间过长</span><br><span class="line">// 3s 内如果没有向服务器写数据，会触发一个 IdleState#WRITER_IDLE 事件</span><br><span class="line">ch.pipeline().addLast(new IdleStateHandler(0, 3, 0));</span><br><span class="line">// ChannelDuplexHandler 可以同时作为入站和出站处理器</span><br><span class="line">ch.pipeline().addLast(new ChannelDuplexHandler() &#123;</span><br><span class="line">    // 用来触发特殊事件</span><br><span class="line">    @Override</span><br><span class="line">    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception&#123;</span><br><span class="line">        IdleStateEvent event = (IdleStateEvent) evt;</span><br><span class="line">        // 触发了写空闲事件</span><br><span class="line">        if (event.state() == IdleState.WRITER_IDLE) &#123;</span><br><span class="line">            //                                log.debug(&quot;3s 没有写数据了，发送一个心跳包&quot;);</span><br><span class="line">            ctx.writeAndFlush(new PingMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>Java网络编程教程-Netty深入浅出全套教程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发核心知识体系精讲——线程8大核心基础(一)</title>
    <url>/2021/11/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B8%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="实现多线程的方法到底是1种还是2种还是4种？"><a href="#实现多线程的方法到底是1种还是2种还是4种？" class="headerlink" title="实现多线程的方法到底是1种还是2种还是4种？"></a>实现多线程的方法到底是1种还是2种还是4种？</h1><h2 id="网上的说法"><a href="#网上的说法" class="headerlink" title="网上的说法"></a>网上的说法</h2><p><img src="/2021/11/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B8%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E7%BD%91%E4%B8%8A%E8%AF%B4%E6%B3%95.png" alt="多线程实现方式网上说法"><br>网上说法很多，有两种、三种、四种，每一种说法看起来都很有说服力，都是从不同的角度进行分析。  </p>
<h2 id="正确的说法"><a href="#正确的说法" class="headerlink" title="正确的说法"></a>正确的说法</h2><p>Oracle官网的文档是如何写的？<br><img src="/2021/11/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B8%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/Orceal%E5%AE%98%E7%BD%91%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95-%E8%8B%B1%E6%96%87.png" alt="Orceal官网多线程实现方法-英文"><br>翻译成中文后如下：<br><img src="/2021/11/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B8%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/Orceal%E5%AE%98%E7%BD%91%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95-%E4%B8%AD%E6%96%87.png" alt="Orceal官网多线程实现方法-中文"><br>如图中描述，第一种是声明成Thread类的子类，第二种方法是实现Runnable接口。<br><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html">oracle官网文档</a></p>
<h3 id="方法一：实现Runnable接口"><a href="#方法一：实现Runnable接口" class="headerlink" title="方法一：实现Runnable接口"></a>方法一：实现Runnable接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableStyle</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> RunnableStyle()).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用Runnable方法实现线程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：继承Thread类"><a href="#方法二：继承Thread类" class="headerlink" title="方法二：继承Thread类"></a>方法二：继承Thread类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadStyle</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ThreadStyle().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用Thread方法实现线程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="两种方法对比"><a href="#两种方法对比" class="headerlink" title="两种方法对比"></a>两种方法对比</h3><h4 id="方法一（实现Runnable接口更好）"><a href="#方法一（实现Runnable接口更好）" class="headerlink" title="方法一（实现Runnable接口更好）"></a>方法一（实现Runnable接口更好）</h4><ul>
<li>首先从架构角度，线程执行的任务，也就是run中运行的具体代码，应该是和Thread类是解耦的；</li>
<li>使用继承Thread类的方法，无法使用线程池；</li>
<li>由于java不支持多继承，所以继承了Thread之后就无法再继承其他类，不便于扩展。</li>
</ul>
<h4 id="两种方法的本质对比"><a href="#两种方法的本质对比" class="headerlink" title="两种方法的本质对比"></a>两种方法的本质对比</h4><h5 id="方法一：最总调用target-run"><a href="#方法一：最总调用target-run" class="headerlink" title="方法一：最总调用target.run()"></a>方法一：最总调用<code>target.run()</code></h5><p><code>target</code>就是通过<code>Thread</code>有参构造传入的<code>Runnable</code>接口的实现类，所以再<code>Thread</code>中最终还是会调用<code>Runnable</code>的实现类重写的<code>run()</code>方法  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    if (target != null) &#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="方法二：run-整个都被重写"><a href="#方法二：run-整个都被重写" class="headerlink" title="方法二：run()整个都被重写"></a>方法二：<code>run()</code>整个都被重写</h5><p><code>run()</code>方法整个都被重写之后，<code>Thread</code>最终就会直接调用被重写后<code>run()</code>方法</p>
<h4 id="如果同时使用两种方法会怎么样？"><a href="#如果同时使用两种方法会怎么样？" class="headerlink" title="如果同时使用两种方法会怎么样？"></a>如果同时使用两种方法会怎么样？</h4><p>代码如下：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BothRunnableThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我来自Runnable&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我来自Thread&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终打印结果是<code>我来自Thread</code>，因为在<code>Thread</code>类中，是先调用<code>Thread</code>类的<code>run()</code>方法，然后<code>target.run()</code>再调用作为参数的Runnable接口的实现的<code>run()</code>方法，<br>而代码中直接重写了<code>Thread</code>的<code>run()</code>方法，就不会再调用<code>target.run()</code>  </p>
<h3 id="总结：最精准的描述"><a href="#总结：最精准的描述" class="headerlink" title="总结：最精准的描述"></a>总结：最精准的描述</h3><ul>
<li>通常我们可以分为两类，Oracle也是这么说的；  </li>
<li>准确的讲，创建线程只有一种方法那就是构建Thread类，而实现线程的执行单元有两种方式。<blockquote>
<p>方法一：实现Runnable接口的run方法，并把Runnable实例传给Thread类；<br>方法二：重写Thread的run方法（继承Thread类）</p>
</blockquote>
</li>
</ul>
<h2 id="经典的错误观点"><a href="#经典的错误观点" class="headerlink" title="经典的错误观点"></a>经典的错误观点</h2><h3 id="线程池创建线程也算是一种新建线程的方法"><a href="#线程池创建线程也算是一种新建线程的方法" class="headerlink" title="线程池创建线程也算是一种新建线程的方法"></a>线程池创建线程也算是一种新建线程的方法</h3><p>对线程池的创建，最终都会调用到如图所示的方法，其中使用了<code>Executors.defaultThreadFactory()</code>，这个工程类就是创建线程池用的<br><img src="/2021/11/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B8%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%88%9B%E5%BB%BA%E5%9B%BE.png" alt="线程池创建图"></p>
<p>最终在默认情况下，使用的<code>DefaultThreadFactory</code>类，如图中所示，最终还是通过<code>Thread</code>类来创建的线程<br><img src="/2021/11/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B8%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/DefaultThreadFactory%E7%B1%BB%E5%9B%BE.png" alt="DefaultThreadFactory类图"></p>
<h3 id="通过Callable和FutureTask创建线程，也算是一种新建线程的方式"><a href="#通过Callable和FutureTask创建线程，也算是一种新建线程的方式" class="headerlink" title="通过Callable和FutureTask创建线程，也算是一种新建线程的方式"></a>通过<code>Callable</code>和<code>FutureTask</code>创建线程，也算是一种新建线程的方式</h3><img src="http://www.plantuml.com/plantuml/svg/RP1D3e8m44RtFSKi8O74FOQDYGSmX7s5KOcbcFuG4-Jkja1BRTnrEgyphr_75OeRRH0kcdDwPGWJ6OUk1Q5vaXPa9fr7pbffWSUwD4mDTrGnSAACsHaEQKmTCsxFFWpV2dahVITRMpyxICEeb50z1D8Mklx5i4UkPAZjZueAyx0WAsq7RAU8C8tbgzAKPWzCSr0VaZG8mlRcJMBLgwXyMli_BYlWWjpn9Cp7PfEwZG4JEMOrZ1vRL4on1RCuRP4CUVufmIkuwpmVWk742KJtNm00">


<p><code>Callable</code>主要是依赖于<code>FutureTask</code>，而FutureTask是继承于<code>Runnable</code>，最后依然还是需要依靠<code>Thread</code>来进行创建线程</p>
<img src="http://www.plantuml.com/plantuml/svg/PP312i8m38RlVOeUDzYUGF4Y-00YkzSkIh7Bf4s7CFhkjhfsizuIykN__qGXWRa92Vpi4CLL0v_PDAgU6uTLlMEUgOoS73a3--uGc8xVWKhWABIE6WcHeI-PvBEAmOi0UvidpNVquy6a5jOk2Ix2FkAY6fuQ1a2oXMgwOSMhRRGOgvxz7vDVGC84vwRZKyO-xmZDaYbKdYLDthRZHkSD">


<h3 id="无返回值是实现Runnable接口，有返回值是实现Callable接口，所以Callable是新的实现线程的方式"><a href="#无返回值是实现Runnable接口，有返回值是实现Callable接口，所以Callable是新的实现线程的方式" class="headerlink" title="无返回值是实现Runnable接口，有返回值是实现Callable接口，所以Callable是新的实现线程的方式"></a>无返回值是实现Runnable接口，有返回值是实现Callable接口，所以Callable是新的实现线程的方式</h3><p>此观点和上面的观点是一样的，<code>Callable</code>接口获取返回值依靠的是<code>FutureTask</code>，而<code>FutureTask</code>依然是对<code>Runnable</code>的实现</p>
<h3 id="定时器创建线程"><a href="#定时器创建线程" class="headerlink" title="定时器创建线程"></a>定时器创建线程</h3><p>代码如下，创建了一个每隔一秒打印线程名称的定时器，定时器的逻辑部分主要是依靠抽象类TimerTask的run()方法来实现的，而TimerTask也是继承与Runnable接口，Timer类内部依然是通过Thread来运行的线程  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoTimerTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">        timer.scheduleAtFixedRate(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">1000</span>,<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="匿名内部类创建线程"><a href="#匿名内部类创建线程" class="headerlink" title="匿名内部类创建线程"></a>匿名内部类创建线程</h3><p>具体代码如下，直接通过匿名内部类重写<code>Thread</code>或者实现<code>Runnable</code>的<code>run()</code>方法，实际上和通过类继承<code>Thread</code>类或者实现<code>Runnable</code>接口去重写<code>run()</code>没有什么区别  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonymousInnerClassDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="典型错误观点总结"><a href="#典型错误观点总结" class="headerlink" title="典型错误观点总结"></a>典型错误观点总结</h3><ul>
<li>多线程的实现方式，在代码中写法千变万化，但其本质万变不离其宗，都是通过之前所说的那两种方法实现的（继承<code>Thread</code>重写<code>run()</code>方法或实现<code>Runnable</code>接口实现<code>run()</code>方法）</li>
</ul>
<h3 id="Lambda表达式创建线程"><a href="#Lambda表达式创建线程" class="headerlink" title="Lambda表达式创建线程"></a>Lambda表达式创建线程</h3><p>代码如下，实际是通过函数式编程实现的，其本质和实现<code>Runnable</code>的匿名内部类没有区别  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lambda</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt; System.out.println(Thread.currentThread().getName())).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="如何从宏观和微观两个方面来提升技术？如何了解技术领域的前沿动态？如何在业务开发中成长？"><a href="#如何从宏观和微观两个方面来提升技术？如何了解技术领域的前沿动态？如何在业务开发中成长？" class="headerlink" title="如何从宏观和微观两个方面来提升技术？如何了解技术领域的前沿动态？如何在业务开发中成长？"></a>如何从宏观和微观两个方面来提升技术？如何了解技术领域的前沿动态？如何在业务开发中成长？</h2><h3 id="宏观上"><a href="#宏观上" class="headerlink" title="宏观上"></a>宏观上</h3><ul>
<li>并不是靠工作年限，有的人工作了5年技术却还只是懂皮毛。  </li>
<li>要有强大的责任心，不放过任何bug，找到原因并去解决，这就是提高。  </li>
<li>主动：永远不会觉得自己的时间多余，重构、优化、学习、总结等。  </li>
<li>敢于承担：虽然这个技术难题以前没有碰到过，但是在一定的了解调研后，敢于承担技术难题，让工作充满挑战，这一次次攻克难关的过程中，进步是飞速的。  </li>
<li>关系产品，关系业务，而不只是写的代码。</li>
</ul>
<h3 id="微观上"><a href="#微观上" class="headerlink" title="微观上"></a>微观上</h3><ul>
<li>看经典书籍（指外国人写的经典的中国译本，比如说Java并发编程实战、自顶向下计算机网络）</li>
<li>看官方文档</li>
<li>英文搜google和stackoverflow</li>
<li>自己动手，实践写demo，尝试用到项目里面</li>
<li>不理解的参考该领域的多个书本，综合判断  </li>
<li>学习开源项目，分析源码（学习synchronized原理，反编译看cpp代码）</li>
</ul>
<h2 id="常见面试问题"><a href="#常见面试问题" class="headerlink" title="常见面试问题"></a>常见面试问题</h2><h3 id="有多少中实现线程大的方法？"><a href="#有多少中实现线程大的方法？" class="headerlink" title="有多少中实现线程大的方法？"></a>有多少中实现线程大的方法？</h3><ul>
<li>从不同的角度看，会有不同的答案</li>
<li>典型答案是两种</li>
<li>我们看原理，两种本质都是一样的</li>
<li>具体展开说其他的方式</li>
<li>结论</li>
</ul>
<h3 id="实现Runnable接口和继承Thread类那种方式更好"><a href="#实现Runnable接口和继承Thread类那种方式更好" class="headerlink" title="实现Runnable接口和继承Thread类那种方式更好"></a>实现<code>Runnable</code>接口和继承<code>Thread</code>类那种方式更好</h3><ul>
<li>从代码架构角度（可以将线程分为两个部分，一是线程运行的具体任务，也就是实现run方法中的内容，二是线程的生命周期，也就是创建线程启动线程运行线程结束线程，这部分是<code>Thread</code>类实现的）  </li>
<li>新建线程大的损耗（继承<code>Thread</code>类的话，每次我们想要运行任务都需要创建一个线程，而实现<code>Runnable</code>接口的话，可以使用线程池，每次都使用同一个线程运行）【继承<code>Thread</code>类应该也是可以使用线程池的，只要不调用<code>start</code>方法去创建线程，线程池需要的是一个<code>Runnable</code>的实现类，而<code>Thread</code>本身也是<code>Runnable</code>接口大的实现类】    </li>
<li>Java不支持双继承</li>
</ul>
<h1 id="怎样才是正确的线程启动方式？"><a href="#怎样才是正确的线程启动方式？" class="headerlink" title="怎样才是正确的线程启动方式？"></a>怎样才是正确的线程启动方式？</h1><h2 id="start-和run-的比较"><a href="#start-和run-的比较" class="headerlink" title="start()和run()的比较"></a><code>start()</code>和<code>run()</code>的比较</h2><p>代码如下： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StartAndRunMethhodd</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable runnable = () -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125;;</span><br><span class="line">        runnable.run();</span><br><span class="line">        <span class="keyword">new</span> Thread(runnable).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main</span><br><span class="line">Thread-0</span><br></pre></td></tr></table></figure>

<h2 id="start-方法原理解读"><a href="#start-方法原理解读" class="headerlink" title="start()方法原理解读"></a><code>start()</code>方法原理解读</h2><h3 id="start-方法的含义"><a href="#start-方法的含义" class="headerlink" title="start()方法的含义"></a><code>start()</code>方法的含义</h3><ul>
<li><p>启动新线程</p>
<blockquote>
<p>当主线程在调用了<code>start</code>方法之后，会告诉jvm需要启动一个新大的线程，至于线程何时能够启动，是由线程调度器决定的，<br>并不是说调用了<code>start</code>方法之后线程就已经开始运行了，调用<code>start</code>方法只是一个通知，有可能立刻就还会执行，也可能会等一会执行，<br>调用<code>start</code>方法之后，是有两个线程在执行的，主线程以及开启的新线程  </p>
</blockquote>
</li>
<li><p>准备工作</p>
<blockquote>
<p>新线程在执行之前是需要做一些准备工作，首先会进入到就绪状态，此时已经获取到了除了cpu之外的其他资源，比如上下文内容等，<br>之后会被调度到执行状态，在执行状态才能去等待cpu资源获取cpu资源</p>
</blockquote>
</li>
<li><p>不能重复调用<code>start()</code></p>
<blockquote>
<p>会抛出异常，如下图，一旦线程开始运行，就会更改状态，运行完毕就会更改为终止状态，无法在切换到其他状态，所以第二次执行就会抛出异常  </p>
</blockquote>
</li>
</ul>
<p><img src="/2021/11/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B8%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/%E5%A4%9A%E6%AC%A1%E6%89%A7%E8%A1%8Cstart%E6%96%B9%E6%B3%95%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8.png" alt="多次执行start方法抛出异常"></p>
<h3 id="start-源码解析"><a href="#start-源码解析" class="headerlink" title="start()源码解析"></a><code>start()</code>源码解析</h3><h4 id="启动新线程检查线程状态"><a href="#启动新线程检查线程状态" class="headerlink" title="启动新线程检查线程状态"></a>启动新线程检查线程状态</h4><p>如下图，可以看到<code>start</code>方法中，第一步就是先去检查线程的状态是不是0<br><img src="/2021/11/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B8%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/Thread%E4%B8%ADstart%E6%96%B9%E6%B3%95.png" alt="Thread中start方法"><br>线程状态threadStatus字段初始值为0<br><img src="/2021/11/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B8%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/threadStatus%E5%B1%9E%E6%80%A7%E5%88%9D%E5%A7%8B%E4%B8%BA0.png" alt="threadStatus属性初始为0"></p>
<h4 id="加入线程组"><a href="#加入线程组" class="headerlink" title="加入线程组"></a>加入线程组</h4><p>如上面的图所示，可以看到，检查完线程状态，会加入有个group组<code>group.add(this);</code></p>
<h4 id="start0"><a href="#start0" class="headerlink" title="start0()"></a><code>start0()</code></h4><p>之后就会调用<code>start0()</code>方法，<code>start0()</code>方法是一个<code>native</code>方法，是由C++实现的    </p>
<h2 id="run-方法原理解读"><a href="#run-方法原理解读" class="headerlink" title="run()方法原理解读"></a><code>run()</code>方法原理解读</h2><p>直接调用<code>run</code>方法，其实就是调用一个普通的方法，并不会启动新的线程，只是一个对象调用了一个普通的方法。  </p>
<h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><h3 id="一个线程两次调用start-方法，会出现什么情况？为什么？"><a href="#一个线程两次调用start-方法，会出现什么情况？为什么？" class="headerlink" title="一个线程两次调用start()方法，会出现什么情况？为什么？"></a>一个线程两次调用<code>start()</code>方法，会出现什么情况？为什么？</h3><p>刚刚上面已经讲解</p>
<h3 id="既然start-方法会调用run-方法，为什么我们选择调用start-方法，而不是直接调用run-方法呢？"><a href="#既然start-方法会调用run-方法，为什么我们选择调用start-方法，而不是直接调用run-方法呢？" class="headerlink" title="既然start()方法会调用run()方法，为什么我们选择调用start()方法，而不是直接调用run()方法呢？"></a>既然<code>start()</code>方法会调用<code>run()</code>方法，为什么我们选择调用<code>start()</code>方法，而不是直接调用<code>run()</code>方法呢？</h3><p>上面已经讲解</p>
<h1 id="上山容易下山难——如何正确停止线程？"><a href="#上山容易下山难——如何正确停止线程？" class="headerlink" title="上山容易下山难——如何正确停止线程？"></a>上山容易下山难——如何正确停止线程？</h1><h2 id="讲解原理"><a href="#讲解原理" class="headerlink" title="讲解原理"></a>讲解原理</h2><ul>
<li>原理介绍：使用<code>interrupt</code>来通知，而不是强制<blockquote>
<p>interrupt是通过启用一个线程来通知另一个线程停止的操作，java中没有强制停止一个线程的机制，只能做到通知，<br>被停止的线程拥有最高权限，它可以自己判断是否要停止，<br>因为被停止的线程一般收到停止通知之后，会需要做一些收尾工作，比如数据回滚数据保存之类，所以通知线程只能是通知，无法做到强制。</p>
</blockquote>
</li>
</ul>
<h2 id="最佳实践：如何正确停止线程"><a href="#最佳实践：如何正确停止线程" class="headerlink" title="最佳实践：如何正确停止线程"></a>最佳实践：如何正确停止线程</h2><h3 id="通常线程会在什么情况下停止"><a href="#通常线程会在什么情况下停止" class="headerlink" title="通常线程会在什么情况下停止"></a>通常线程会在什么情况下停止</h3><ul>
<li><code>run</code>方法的所有代码都运行完毕，线程会自动停止</li>
<li>有异常出现，并且方法中没有捕获异常会导致线程停止</li>
</ul>
<h3 id="正确的停止的方法：interrupt"><a href="#正确的停止的方法：interrupt" class="headerlink" title="正确的停止的方法：interrupt"></a>正确的停止的方法：interrupt</h3><h4 id="通常线程会在什么情况下停止普通情况"><a href="#通常线程会在什么情况下停止普通情况" class="headerlink" title="通常线程会在什么情况下停止普通情况"></a>通常线程会在什么情况下停止普通情况</h4><p>代码如下所示，<code>Thread.currentThread().isInterrupted()</code>方法是查看线程是否中断，需要不停大的在循环中查看线程状态，才能正确的停止线程，<br>否则的话线程是不会理会停止操作的。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RightWayStopThreadWithoutSleep</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RightWayStopThreadWithoutSleep());</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted() &amp;&amp; num &lt;= Integer.MAX_VALUE/<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (num % <span class="number">10000</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(num+<span class="string">&quot;是10000的倍数&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;任务运行结束了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="线程可能被堵塞"><a href="#线程可能被堵塞" class="headerlink" title="线程可能被堵塞"></a>线程可能被堵塞</h4><p>代码如下所示，我们要做的就是让线程处于<code>sleep</code>的时候收到中断通知  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RightWayStopThreadWithSleep</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Runnable runnable = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (num &lt;= <span class="number">300</span> &amp;&amp; !Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                    <span class="keyword">if</span> (num % <span class="number">100</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                        System.out.println(num+<span class="string">&quot;是100的倍数&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如图所示，当线程处于sleep的时候收到中断通知，会直接抛出异常<br><img src="/2021/11/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B8%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/sleep%E7%8A%B6%E6%80%81%E4%B8%8B%E6%94%B6%E5%88%B0%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD%E9%80%9A%E7%9F%A5.png" alt="sleep状态下收到线程中断通知"></p>
<h4 id="如果线程每次迭代后都堵塞"><a href="#如果线程每次迭代后都堵塞" class="headerlink" title="如果线程每次迭代后都堵塞"></a>如果线程每次迭代后都堵塞</h4><p>代码如下所示，在这种情况下，我们就没必须每次循环都调用<code>Thread.currentThread().isInterrupted()</code>去检查线程是否已经中断，因为每次循环的时候都会进行<code>sleep</code>，<code>sleep</code>对中断做了处理  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RightWayStopThreadWithSleepEveryLoop</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Runnable runnable = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (num &lt;= <span class="number">10000</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (num % <span class="number">100</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(num + <span class="string">&quot;是100的倍数&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    num++;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="while内try-catch的问题"><a href="#while内try-catch的问题" class="headerlink" title="while内try/catch的问题"></a><code>while</code>内<code>try/catch</code>的问题</h4><ul>
<li>如果将<code>try/catch</code>放到循环内部的话，中断会失败，因为上面的代码其实是依靠异常来中断了循环，然后再被循环外面的<code>try/catch</code>处理，而如果把<code>try/catch</code>放到循环里面，就无法依靠异常中断循环，所以循环将会继续  </li>
<li>把<code>try/catch</code>循环里面在while循环条件里面添加上<code>Thread.currentThread().isInterrupted()</code>判断是否中断，这样也是无效的，因为线程在获取到一次标记之后，就会清除标记，所以如果<code>sleep</code>获取了标记，<code>Thread.currentThread().isInterrupted()</code>就无法再成功检查了（极小概率再<code>sleep</code>之后，<code>while</code>循环之前收到中断通知，这样再进行判断的话就会中断循环，但概率极小）  </li>
</ul>
<h4 id="实际开发中的两种最佳实践"><a href="#实际开发中的两种最佳实践" class="headerlink" title="实际开发中的两种最佳实践"></a>实际开发中的两种最佳实践</h4><h5 id="优先选择：传递中断"><a href="#优先选择：传递中断" class="headerlink" title="优先选择：传递中断"></a>优先选择：传递中断</h5><p>如代码中所示，如果我们在调用其他方法的时候，有<code>sleep</code>的操作，那么不应该在方法里面捕获异常，而应该将异常上抛得到<code>run</code>方法里面，否则<code>run</code>方法里面无法感知到线程中断通知  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RightWayStopThreadInProd</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RightWayStopThreadInProd());</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;w&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                throwInMethod();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;收到中断请求&quot;</span>);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">throwInMethod</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="不想或无法传递：恢复中断"><a href="#不想或无法传递：恢复中断" class="headerlink" title="不想或无法传递：恢复中断"></a>不想或无法传递：恢复中断</h5><p>如下代码所示，如果下级方法想要自己处理异常，那么可以调用<code>Thread.currentThread().interrupt()</code>将中断通知恢复，以便于上级<code>run</code>方法感应到中断通知  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RightWayStopThreadInProd2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RightWayStopThreadInProd2());</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;收到中断通知，程序运行结束&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;w&quot;</span>);</span><br><span class="line">            reInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="不应该屏蔽中断"><a href="#不应该屏蔽中断" class="headerlink" title="不应该屏蔽中断"></a>不应该屏蔽中断</h5><p>既不在方法签名中抛出，也不在捕获异常后重新恢复中断，这样会导致上级<code>run</code>方法无法收到中断通知，以至于无法终止操作  </p>
<h3 id="响应中断的方法总结列表"><a href="#响应中断的方法总结列表" class="headerlink" title="响应中断的方法总结列表"></a>响应中断的方法总结列表</h3><ul>
<li>Object.wait() / wait(long) / wait(long, int)</li>
<li>Thread.sleep(long) / sleep(long, int)</li>
<li>Thread.join() / join(long) / join(long, int)</li>
<li>java.util.concurrent.BlockingQueue.task() / put(E)</li>
<li>java.util.concurrent.locks.Lock.lockInterruptibly()</li>
<li>java.util.concurrent.CountDownLatch.await()</li>
<li>java.util.concurrent.CyclicBarrier.await()</li>
<li>java.util.concurrent.Exchanger.exchange(V)</li>
<li>java.nio.channels.InterruptibleChannel 相关方法</li>
<li>java.nio.channels.Selector相关方法</li>
</ul>
<h3 id="正确停止带来的好处"><a href="#正确停止带来的好处" class="headerlink" title="正确停止带来的好处"></a>正确停止带来的好处</h3><p>使用<code>interrupt</code>来停止线程，可以由被停止的线程来判断要不要停止，也可以让被停止大的线程做好一些收尾工作  </p>
<h2 id="停止线程的错误方法"><a href="#停止线程的错误方法" class="headerlink" title="停止线程的错误方法"></a>停止线程的错误方法</h2><h3 id="被弃用的stop，suspend和resume方法"><a href="#被弃用的stop，suspend和resume方法" class="headerlink" title="被弃用的stop，suspend和resume方法"></a>被弃用的<code>stop</code>，<code>suspend</code>和<code>resume</code>方法</h3><ul>
<li>stop方法会导致线程突然停止，这样对线程中运行的代码是非常不友好的，假如正在处理一个任务，想要撤销，有时候会需要对一些数据进行回滚，突然停止会导致数据无法进行处理</li>
<li><code>suspend</code>和<code>resume</code>方法，挂起和唤醒，<code>suspend</code>方法在挂起的时候并不会释放它已经持有大的锁，而如果需要唤醒它的线程需要获取锁才能唤醒，就会导致死锁  </li>
</ul>
<h3 id="用volatile设置boolean标记位"><a href="#用volatile设置boolean标记位" class="headerlink" title="用volatile设置boolean标记位"></a>用<code>volatile</code>设置<code>boolean</code>标记位</h3><h4 id="看上去可行（有些时候确实是可用的）"><a href="#看上去可行（有些时候确实是可用的）" class="headerlink" title="看上去可行（有些时候确实是可用的）"></a>看上去可行（有些时候确实是可用的）</h4><p>代码如下，通过更改<code>canceled</code>字段的值，来使线程停止  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WrongWayVolatile</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> canceled = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (num &lt;= <span class="number">100000</span> &amp;&amp; !canceled)&#123;</span><br><span class="line">                <span class="keyword">if</span> (num % <span class="number">100</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                    System.out.println(num + <span class="string">&quot;是100的倍数&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                num++;</span><br><span class="line">                Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        WrongWayVolatile a = <span class="keyword">new</span> WrongWayVolatile();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(a);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        a.canceled = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="错误之处（有些时候会报错）"><a href="#错误之处（有些时候会报错）" class="headerlink" title="错误之处（有些时候会报错）"></a>错误之处（有些时候会报错）</h4><p>代码如下，生产者以较快的速度生产任务，消费者以较慢的速度消费任务，当队列满了之后，就会将生产者的异步堵塞，而这个时候，即便是更改<code>canceled</code>字段的值，代码也无法检测到  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WrongWayVolatileCantStop</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ArrayBlockingQueue storage = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">10</span>);</span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer(storage);</span><br><span class="line">        Thread producerThread = <span class="keyword">new</span> Thread(producer);</span><br><span class="line">        producerThread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer(storage);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (consumer.needMoreNums())&#123;</span><br><span class="line">            System.out.println(consumer.storage.take()+<span class="string">&quot;被消费了&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者不需要更多数据了&quot;</span>);</span><br><span class="line">        producer.canceled = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> canceled = <span class="keyword">false</span>;</span><br><span class="line">    BlockingQueue storage;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(BlockingQueue storage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.storage = storage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (num &lt;= <span class="number">100000</span> &amp;&amp; !canceled) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num % <span class="number">100</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    storage.put(num);</span><br><span class="line">                    System.out.println(num + <span class="string">&quot;是100的倍数,放入仓库了&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者停止运行&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    BlockingQueue storage;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(BlockingQueue storage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.storage = storage;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">needMoreNums</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Math.random() &gt; <span class="number">0.95</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="修正方案"><a href="#修正方案" class="headerlink" title="修正方案"></a>修正方案</h4><p>修正后的代码如下，使用<code>interrupt()</code>方法中断线程，并在循环的时候检查线程状态  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WrongWayVolatileFixed</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        WrongWayVolatileFixed body = <span class="keyword">new</span> WrongWayVolatileFixed();</span><br><span class="line">        ArrayBlockingQueue storage = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">10</span>);</span><br><span class="line">        Producer producer = body.n<span class="function">ew <span class="title">Producer</span><span class="params">(storage)</span></span>;</span><br><span class="line">        Thread producerThread = <span class="keyword">new</span> Thread(producer);</span><br><span class="line">        producerThread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        Consumer consumer = body.n<span class="function">ew <span class="title">Consumer</span><span class="params">(storage)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (consumer.needMoreNums())&#123;</span><br><span class="line">            System.out.println(consumer.storage.take()+<span class="string">&quot;被消费了&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者不需要更多数据了&quot;</span>);</span><br><span class="line">        producerThread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        BlockingQueue storage;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(BlockingQueue storage)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.storage = storage;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (num &lt;= <span class="number">100000</span> &amp;&amp; !Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (num % <span class="number">100</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                        storage.put(num);</span><br><span class="line">                        System.out.println(num + <span class="string">&quot;是100的倍数,放入仓库了&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;生产者停止运行&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">        BlockingQueue storage;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(BlockingQueue storage)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.storage = storage;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">needMoreNums</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (Math.random() &gt; <span class="number">0.95</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="重要函数的源码解析"><a href="#重要函数的源码解析" class="headerlink" title="重要函数的源码解析"></a>重要函数的源码解析</h2><h3 id="interrupt-方法"><a href="#interrupt-方法" class="headerlink" title="interrupt()方法"></a><code>interrupt()</code>方法</h3><p>如图所示，<code>interrupt()</code>方法中的主要逻辑都是调用<code>interrupt0()</code>方法实现的，<code>interrupt0()</code>方法是一个native方法<br><img src="/2021/11/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B8%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/interrupt%E6%96%B9%E6%B3%95%E4%BB%A3%E7%A0%81%E5%86%85%E5%AE%B9.png" alt="interrupt方法代码内容"><br><img src="/2021/11/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B8%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/interrupt%E6%96%B9%E6%B3%95native%E5%86%85%E5%AE%B9%E8%AE%B2%E8%A7%A3.png" alt="interrupt方法native内容讲解"></p>
<h3 id="判断是否已被中断的相关方法"><a href="#判断是否已被中断的相关方法" class="headerlink" title="判断是否已被中断的相关方法"></a>判断是否已被中断的相关方法</h3><h4 id="static-boolean-interrupted"><a href="#static-boolean-interrupted" class="headerlink" title="static boolean interrupted()"></a>static boolean interrupted()</h4><ul>
<li>返回当前线程是否被中断，获取之后清除当前状态</li>
<li>这个静态方法的目标对象是调用它的线程</li>
<li>如下图，参数为true，表示要清除状态</li>
</ul>
<p><img src="/2021/11/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B8%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/interrupted%E6%96%B9%E6%B3%95%E4%BB%A3%E7%A0%81%E5%86%85%E5%AE%B9.png" alt="interrupted方法代码内容"></p>
<h4 id="boolean-isInterrupt"><a href="#boolean-isInterrupt" class="headerlink" title="boolean isInterrupt()"></a>boolean isInterrupt()</h4><ul>
<li>返回当前线程是否被中断，获取之后不清除状态</li>
<li>如下图，参数为false，表示不进行清除</li>
</ul>
<p><img src="/2021/11/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B8%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/isInterrupt%E6%96%B9%E6%B3%95%E4%BB%A3%E7%A0%81%E5%86%85%E5%AE%B9.png" alt="isInterrupt方法代码内容"></p>
<h4 id="Thread-interrupted-的目标对象"><a href="#Thread-interrupted-的目标对象" class="headerlink" title="Thread.interrupted()的目标对象"></a>Thread.interrupted()的目标对象</h4><ul>
<li>目标对象是调用它的线程，即便使用的是其他线程的对象调用的这个静态方法，得到的结果依然是当前线程的</li>
<li>如果再main主线程中调用，无论是使用Thread直接调用，还是通过开启的多线程对象调用，得到的结果都是主线程的结果。</li>
</ul>
<h2 id="常见面试问题-1"><a href="#常见面试问题-1" class="headerlink" title="常见面试问题"></a>常见面试问题</h2><h3 id="如何停止线程"><a href="#如何停止线程" class="headerlink" title="如何停止线程"></a>如何停止线程</h3><ul>
<li>原理：用<code>interrupt</code>来请求、好处（使用interrupt停止线程，只是通知线程需要中断，可以给线程预留处理后续数据的时间）</li>
<li>想要停止线程，需要请求方、被停止方、子方法被调用方相互配合（请求方发出中断通知，被停止方需要在循环中监听中断状态，子方法需要将中断异常上抛，或者捕获后重新恢复中断状态）</li>
<li>最后再说错误的方法：<code>stop/suspend</code>已废弃，<code>volatile</code>的boolean无法处理长时间阻塞的情况（<code>stop</code>方法会直接停止线程，导致线程无法正确回滚数据；<code>suspend</code>方法可能会导致死锁；<code>volatile+boolean</code>的方法，在阻塞的情况下是无法中断线程的）</li>
</ul>
<h3 id="如何处理不可中断阻塞"><a href="#如何处理不可中断阻塞" class="headerlink" title="如何处理不可中断阻塞"></a>如何处理不可中断阻塞</h3><ul>
<li>没有通用的处理方法，只能根据不同的场景，尽量使用能够响应线程中断的方法</li>
</ul>
<h1 id="线程的一生——6个状态（生命周期）"><a href="#线程的一生——6个状态（生命周期）" class="headerlink" title="线程的一生——6个状态（生命周期）"></a>线程的一生——6个状态（生命周期）</h1><h2 id="有哪6中状态？每个状态是什么含义？"><a href="#有哪6中状态？每个状态是什么含义？" class="headerlink" title="有哪6中状态？每个状态是什么含义？"></a>有哪6中状态？每个状态是什么含义？</h2><ul>
<li><p>New</p>
<blockquote>
<p>已创建还未启动<br>当我们使用new Thread()创建了一个线程，还没有执行start方法，这个时候这个线程就处于这个状态  </p>
</blockquote>
</li>
<li><p>Runnable</p>
<blockquote>
<p>可运行/运行中<br>一旦线程调用了start方法，就会处于这个状态，有可能这个时候线程调度器还没有分配线程进行执行（此时可以称为可运行状态）<br>cpu分配了资源，进入运行状态，此时为运行中，依然是Runnable状态（运行中）<br>如果cpu调度器将资源突然调度到其他地方，那么该线程依然为Runnable状态（可运行）  </p>
</blockquote>
</li>
<li><p>Blocked</p>
<blockquote>
<p>被阻塞<br>进入synchronized代码块并且没有拿到锁时，处于该状态<br>当线程拿到锁之后，会切换到Runnable状态执行<br>只有synchronized锁，会进入此种状态  </p>
</blockquote>
</li>
<li><p>Waiting</p>
<blockquote>
<p>不计时等待<br>当调用这几个方法的时候，会使线程进入当前状态：Object.wait() \ Thread.join() \ LockSupport.park()<br>当调用这几个方法时，会唤醒等待，使线程重新进入Runnable状态：Object.notify() \ Object.notifyAll() \ LockSupport.unpark()<br>注意：方法都是不带时间的，如果代理时间参数，就会进入到计时等待  </p>
</blockquote>
</li>
<li><p>Timed Waiting </p>
<blockquote>
<p>计时等待<br>调用这几个方法，会进入当前状态：Thread.sleep(time) \ Object.wait(time) \ Thread.join(time) \ LockSupport.parkNanos(time) \ LockSupport.parkUntil(time)<br>当达到等待时间，或者调用这几个方法，会唤醒线程进入Runnable状态：Object.notify() \ Object.notifyAll() \ LockSupport.unpark()</p>
</blockquote>
</li>
<li><p>Terminated  </p>
<blockquote>
<p>已终止<br>当run方法已经执行完毕，会进入当前状态<br>或者抛出一个未捕获的异常，也会进入当前状态  </p>
</blockquote>
</li>
</ul>
<h2 id="状态间的转化图示"><a href="#状态间的转化图示" class="headerlink" title="状态间的转化图示"></a>状态间的转化图示</h2><img src="http://www.plantuml.com/plantuml/svg/fL9VIy9G77tVfzYZ1Ve1UWWqHqWwmHGVCcBfmlddJkOax2aXOvML3wMH5Ma8KVY7Z3GNxiliRlEfhz3r_vpurCE5o_cTUpZdTmz9-F4rN2aqeL22OlVt9wSylC5y0vw_OXuVILfjJW8Hu7L3a_9QEOVPdEwDBSAECAtothyJOVa9yriTNWUvYJ2vSwdLoqhnIwsTmLuMypfSX7rlDfyV4XwNWxHwXsgm_Q6AWbAhODZEwYvkDg_Z9E77q1dUTLwyOOwcGfOaJt6yQGMRsKGqdJkf1BFLP1e4mnmBc2Cw94lrVhMftf-efGxCjfJ2jzAw3G15A6Z7MLbyKPypyB68uYiN4XIQ_PlCDEoy0Usg3Nj5kNiQHy8yomsOEXU8F0lite_GGTvoI378Anu04_SHbW4ZmCa6ezkfH8BbU4k2ug8eqkIv8VXO2x0ySv0UFPw3hB7OecGAZ4Nr3f6kyMScMutHTCB4Ct5Qhp-qFmNr4QQWCGP90JQvVEm3F1CRZGqbCHjIZyg2MjClVg9lMKZzlqKCDh6aXZeSiL0f_m00">

<h3 id="状态之间转换代码演示"><a href="#状态之间转换代码演示" class="headerlink" title="状态之间转换代码演示"></a>状态之间转换代码演示</h3><ul>
<li>NEW -&gt; RUNNABLE -&gt; RUNNABLE -&gt; TERMINATED<blockquote>
<p>代码未执行start方法时状态为 NEW<br>代码执行start方法后状态为 RUNNABLE   （此时无法分辨是还未调用cpu资源还是已经调用cpu资源）<br>run在循环中，状态为 RUNNABLE<br>run方法运行结束后，状态为 TERMINATED</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewRunnableTerminated</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> NewRunnableTerminated());</span><br><span class="line">        System.out.println(thread.getState());</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(thread.getState());</span><br><span class="line">        Thread.sleep(<span class="number">5</span>);</span><br><span class="line">        System.out.println(thread.getState());</span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        System.out.println(thread.getState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>TIMED_WAITING -&gt; BLOCKED -&gt; WAITING<blockquote>
<p>线程1进入了<code>syn()</code>方法，执行了休眠1秒，此时的状态为 TIMED_WAITING<br>因为<code>syn()</code>方法是<code>synchronized</code>修饰的，线程1进入之后，线程2无法再拿到锁，所以此时线程2的状态为  BLOCKED<br>线程1休眠1秒种之后，进入<code>wait()</code>方法，此时状态为  WAITING</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockedWaitingTimedWaiting</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        BlockedWaitingTimedWaiting runnable = <span class="keyword">new</span> BlockedWaitingTimedWaiting();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        thread1.start();</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        thread2.start();</span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        System.out.println(thread1.getState());</span><br><span class="line">        System.out.println(thread2.getState());</span><br><span class="line">        Thread.sleep(<span class="number">1200</span>);</span><br><span class="line">        System.out.println(thread1.getState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        syn();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="阻塞状态是什么？"><a href="#阻塞状态是什么？" class="headerlink" title="阻塞状态是什么？"></a>阻塞状态是什么？</h2><ul>
<li>一般习惯而言，把<code>Blocked</code>（被阻塞）、<code>Waiting</code>（等待）、<code>Timed_Waiting</code>（计时等待）都称为阻塞状态  </li>
<li>不仅仅是<code>Blocked</code>  </li>
</ul>
<h2 id="常见面试问题-2"><a href="#常见面试问题-2" class="headerlink" title="常见面试问题"></a>常见面试问题</h2><h3 id="线程有哪几种状态？生命周期是什么？"><a href="#线程有哪几种状态？生命周期是什么？" class="headerlink" title="线程有哪几种状态？生命周期是什么？"></a>线程有哪几种状态？生命周期是什么？</h3><p>具体回答可以根据上面的线程状态流转图进行回答</p>
<h1 id="Thread和Object类中的重要方法详解"><a href="#Thread和Object类中的重要方法详解" class="headerlink" title="Thread和Object类中的重要方法详解"></a>Thread和Object类中的重要方法详解</h1><h2 id="方法概览"><a href="#方法概览" class="headerlink" title="方法概览"></a>方法概览</h2><table>
<thead>
<tr>
<th align="center">类</th>
<th align="left">方法名</th>
<th align="left">简介</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Thread</td>
<td align="left">sleep相关</td>
<td align="left">本表格的”相关”，指的是重载方法，也就是方法名相同，但参数个数不同，例如sleep有多个方法，只是参数不同，实际作用大同小异</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">join</td>
<td align="left">等待其他线程执行完毕</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">yield相关</td>
<td align="left">放弃已经获取到的cpu资源</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">currentThread</td>
<td align="left">获取当前执行线程的引用</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">start,ren相关</td>
<td align="left">启动线程相关</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">interrupt相关</td>
<td align="left">中断线程</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">stop(),suspend(),resuem()相关</td>
<td align="left">已废弃</td>
</tr>
<tr>
<td align="center">Object</td>
<td align="left">wait/notify/notifyAll相关</td>
<td align="left">让线程暂停时休息和唤醒</td>
</tr>
</tbody></table>
<h2 id="wait，notify，notifyAll方法详解"><a href="#wait，notify，notifyAll方法详解" class="headerlink" title="wait，notify，notifyAll方法详解"></a><code>wait</code>，<code>notify</code>，<code>notifyAll</code>方法详解</h2><h3 id="作用，用法"><a href="#作用，用法" class="headerlink" title="作用，用法"></a>作用，用法</h3><h4 id="阻塞阶段"><a href="#阻塞阶段" class="headerlink" title="阻塞阶段"></a>阻塞阶段</h4><ul>
<li>执行<code>wait</code>方法进入阻塞阶段的时候，必须要拥有monitor锁</li>
<li>进入阻塞阶段之后，直到以下4种情况之一发生时，才会被唤醒<blockquote>
<p>1）另一个线程调用这个对象的<code>notify()</code>方法且刚好被唤醒的是本线程<br>2）另一个线程调用这个对象的<code>notifyAll()</code>方法<br>3）过了<code>wait(long timeout)</code>规定的超时时间，如果传入0就是永远等待<br>4）线程自身调用了interrupt()</p>
</blockquote>
</li>
</ul>
<h4 id="唤醒阶段"><a href="#唤醒阶段" class="headerlink" title="唤醒阶段"></a>唤醒阶段</h4><ul>
<li><code>notify()</code>，随机唤醒一个线程</li>
<li><code>notifyAll()</code>，唤醒所有的线程</li>
</ul>
<h4 id="遇到中断"><a href="#遇到中断" class="headerlink" title="遇到中断"></a>遇到中断</h4><ul>
<li>会抛出<code>InterruptedException</code>异常，然后释放锁</li>
</ul>
<h3 id="代码演示：4种情况"><a href="#代码演示：4种情况" class="headerlink" title="代码演示：4种情况"></a>代码演示：4种情况</h3><h4 id="普通用法"><a href="#普通用法" class="headerlink" title="普通用法"></a>普通用法</h4><blockquote>
<p>代码如下所示<br>我们先启动线程1，使线程1先进入到synchronized代码块中，并且已经执行了wait方法，然后在启动线程2<br>由打印结果我们可以看出来，线程1在执行了wait方法之后，是已经释放锁了的，不然线程2无法进入同步代码块执行notify方法，也无法将线程1唤醒<br>由结果打印顺序也可以看出，我们是先运行了线程1，打印线程已经执行，然后线程2调用notify方法，之后打印输出，然后线程1再打印输出<br>所以，线程2将线程1唤醒之后，线程1是处于阻塞状态，不会立即执行代码，而是会等线程2执行完毕，线程1才能再次获取锁，然后开始执行  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wait</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;已经开始执行了&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    object.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;获取到了锁&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread2</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">                object.notify();</span><br><span class="line">                System.out.println(<span class="string">&quot;线程&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;调用了notify()方法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread1 thread1 = <span class="keyword">new</span> Thread1();</span><br><span class="line">        Thread2 thread2 = <span class="keyword">new</span> Thread2();</span><br><span class="line">        thread1.start();</span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thread-0已经开始执行了</span><br><span class="line">线程Thread-1调用了notify()方法</span><br><span class="line">Thread-0获取到了锁</span><br></pre></td></tr></table></figure>

<h4 id="notify和notifyAll展示"><a href="#notify和notifyAll展示" class="headerlink" title="notify和notifyAll展示"></a>notify和notifyAll展示</h4><blockquote>
<p>代码如下所示<br>线程A和线程B同时启动，然后串行执行同步代码块，线程A执行到wait方法，释放锁，线程B开始执行，线程B执行到wait方法后，释放锁<br>等待200毫秒之后，线程C开始执行，线程C执行了<code>notifyAll</code>方法，唤醒了阻塞中的线程A和线程B，然后线程A和线程B执行结束<br>如果使用的是<code>notify</code>方法的话，那么线程A和线程B只能唤醒一个，另一个将进行无尽的等待</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyAll</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object resourceA = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Runnable r = <span class="keyword">new</span> WaitNotifyAll();</span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        Thread threadC = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (resourceA) &#123;</span><br><span class="line">                    resourceA.notifyAll();</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程C notifyAll&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        threadC.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (resourceA)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;获取到锁&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;即将释放锁&quot;</span>);</span><br><span class="line">                resourceA.wait();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;程序即将结束&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thread-0获取到锁</span><br><span class="line">Thread-0即将释放锁</span><br><span class="line">Thread-1获取到锁</span><br><span class="line">Thread-1即将释放锁</span><br><span class="line">线程C notifyAll</span><br><span class="line">Thread-1程序即将结束</span><br><span class="line">Thread-0程序即将结束</span><br></pre></td></tr></table></figure>

<h4 id="只释放当前monitor展示"><a href="#只释放当前monitor展示" class="headerlink" title="只释放当前monitor展示"></a>只释放当前monitor展示</h4><blockquote>
<p>创建两把锁，A和B<br>线程1先获取锁A，然后获取锁B，然后释放锁A<br>线程2先获取锁A，然后尝试获取锁B<br>从结果可以看出，线程2是无法获取锁B的，因为线程1只释放了锁A<br>只释放当前monitor，不会影响已经拿到的其他monitor</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyReleaseOwnMonitor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Object resourceA = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Object resourceB = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (resourceA) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程1获取到resourceA锁&quot;</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (resourceB) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程1获取到resourceB锁&quot;</span>);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;线程1释放resourceA锁&quot;</span>);</span><br><span class="line">                            resourceA.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (resourceA) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程2获取到resourceA锁&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程2准备获取resourceB锁&quot;</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (resourceB) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程2获取到resourceB锁&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">线程1获取到resourceA锁</span><br><span class="line">线程1获取到resourceB锁</span><br><span class="line">线程1释放resourceA锁</span><br><span class="line">线程2获取到resourceA锁</span><br><span class="line">线程2准备获取resourceB锁</span><br></pre></td></tr></table></figure>

<h3 id="特点，性质"><a href="#特点，性质" class="headerlink" title="特点，性质"></a>特点，性质</h3><ul>
<li>调用wait或者notify或者notifyAll必须先拥有monitor（否则还会抛异常：IllegalMonitorStateException）  </li>
<li>notify只能唤醒一个，这一个是随机唤醒，无法指定  </li>
<li>这三个方法都属于Object类，所以所有对象都可以调用这三个方法  </li>
<li>类似功能的Condition（依赖与Lock锁）</li>
<li>同时持有多把锁大的情况（释放锁的时候要注意是多把锁，需要避免死锁）</li>
</ul>
<h3 id="手写生产者消费者设计模式"><a href="#手写生产者消费者设计模式" class="headerlink" title="手写生产者消费者设计模式"></a>手写生产者消费者设计模式</h3><blockquote>
<p>代码如下所示，使用<code>wait</code>和<code>notify</code>实现生产者消费者</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumerModel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EventStorage eventStorage = <span class="keyword">new</span> EventStorage();</span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer(eventStorage);</span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer(eventStorage);</span><br><span class="line">        <span class="keyword">new</span> Thread(producer).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(consumer).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EventStorage storage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(EventStorage storage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.storage = storage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            storage.put();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EventStorage storage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(EventStorage storage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.storage = storage;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            storage.task();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventStorage</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Date&gt; storage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EventStorage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">this</span>.storage = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (storage.size() == maxSize)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        storage.add(<span class="keyword">new</span> Date());</span><br><span class="line">        System.out.println(<span class="string">&quot;仓库里面有了 &quot;</span>+storage.size()+<span class="string">&quot; 件产品&quot;</span>);</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">task</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (storage.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;拿到了 &quot;</span>+storage.poll() + <span class="string">&quot;,现在仓库还剩&quot;</span>+storage.size());</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常见面试题-1"><a href="#常见面试题-1" class="headerlink" title="常见面试题"></a>常见面试题</h3><h4 id="用程序实现两个线程交替打印0-100的奇偶数"><a href="#用程序实现两个线程交替打印0-100的奇偶数" class="headerlink" title="用程序实现两个线程交替打印0~100的奇偶数"></a>用程序实现两个线程交替打印0~100的奇偶数</h4><ul>
<li><p>基本思路：<code>synchronized</code></p>
<blockquote>
<p>使用synchronized实现代码如下<br>使用位移运算符判断奇偶数进行打印，打印后自增1<br>两个线程使用同一把锁，如果线程抢到了锁，判断不符合自己的条件，就只是空循环，打印也不会加1<br>这个方法的问题就是可能会等导致线程多次抢到锁之后空转  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyPrintOddEvenSyn</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (count &lt; <span class="number">100</span>) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                        <span class="keyword">if</span> ((count &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + count++);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;偶数&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (count &lt; <span class="number">100</span>) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                        <span class="keyword">if</span> ((count &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + count++);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;奇数&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>更好的办法：<code>wait/notify</code></p>
<blockquote>
<p>使用wait/notify的代码如下<br>线程打印完之后，会去唤醒另外一个线程，然后自己进行休眠，线程交替唤醒交替休眠，第一个启动的线程为偶数  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyPrintOddEvenWait</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count ;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> TurningRunner(),<span class="string">&quot;偶数&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> TurningRunner(),<span class="string">&quot;奇数&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TurningRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (count &lt;= <span class="number">100</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;：&quot;</span>+count++);</span><br><span class="line">                    lock.notify();</span><br><span class="line">                    <span class="keyword">if</span> (count &lt;= <span class="number">100</span>)&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="手写生产者消费者设计模式-1"><a href="#手写生产者消费者设计模式-1" class="headerlink" title="手写生产者消费者设计模式"></a>手写生产者消费者设计模式</h4><ul>
<li>上面已经有了具体实现方法</li>
</ul>
<h4 id="为什么wait需要再同步代码块中使用，而sleep不需要"><a href="#为什么wait需要再同步代码块中使用，而sleep不需要" class="headerlink" title="为什么wait需要再同步代码块中使用，而sleep不需要"></a>为什么<code>wait</code>需要再同步代码块中使用，而<code>sleep</code>不需要</h4><blockquote>
<p>java语言设计的时候为了防止死锁<br>假设一个线程在执行代码，后面是调用<code>wait</code>方法，另一个线程后面是<code>notify</code>方法，如果不能同步的话，可能会存在执行到<code>wait</code>之前，先执行了<code>notify</code>方法，这样就会导致第一个线程在调用了wait之后陷入永久等待<br>而<code>sleep</code>所影响的只是当前线程所以可以不在同步代码块中  </p>
</blockquote>
<h4 id="为什么线程通信的方法wait-、notify-、notifyAll-被定义在Object类里面？而sleep定义在Thread类里？"><a href="#为什么线程通信的方法wait-、notify-、notifyAll-被定义在Object类里面？而sleep定义在Thread类里？" class="headerlink" title="为什么线程通信的方法wait()、notify()、notifyAll()被定义在Object类里面？而sleep定义在Thread类里？"></a>为什么线程通信的方法<code>wait()、notify()、notifyAll()</code>被定义在<code>Object</code>类里面？而<code>sleep</code>定义在<code>Thread</code>类里？</h4><blockquote>
<p>因为<code>wait()、notify()、notifyAll()</code>方法是属于锁级别的，而每一个锁都是一个对象<br>java实现锁的原理也是在对象头中做标记<br>如果将这三个方法放到每个线程中，每个线程也可能会持有多把锁，这样每次休眠和唤醒会非常麻烦  </p>
</blockquote>
<h4 id="wait方法是属于Object对象的，那调用Thread-wait会怎么样？"><a href="#wait方法是属于Object对象的，那调用Thread-wait会怎么样？" class="headerlink" title="wait方法是属于Object对象的，那调用Thread.wait会怎么样？"></a><code>wait</code>方法是属于<code>Object</code>对象的，那调用<code>Thread.wait</code>会怎么样？</h4><blockquote>
<p><code>Thread</code>也可以做锁对象，但是<code>Thread</code>比较特殊，最好不要用它来做锁对象<br>在线程退出的时候，会调用<code>Thread</code>类的<code>notifyAll</code>方法，所以如果使用<code>Thread</code>类做锁对象可能会导致线程总是被无故唤醒   </p>
</blockquote>
<h4 id="如何选择用notify还是notifyAll"><a href="#如何选择用notify还是notifyAll" class="headerlink" title="如何选择用notify还是notifyAll"></a>如何选择用<code>notify</code>还是<code>notifyAll</code></h4><blockquote>
<p>主要看是像唤醒多个线程还是一个线程，根据具体情况进行选择  </p>
</blockquote>
<h4 id="notifyAll之后所有的线程都会再次抢夺锁，如果某个线程抢夺失败怎么办？"><a href="#notifyAll之后所有的线程都会再次抢夺锁，如果某个线程抢夺失败怎么办？" class="headerlink" title="notifyAll之后所有的线程都会再次抢夺锁，如果某个线程抢夺失败怎么办？"></a><code>notifyAll</code>之后所有的线程都会再次抢夺锁，如果某个线程抢夺失败怎么办？</h4><blockquote>
<p>其他被唤醒但是没有获得锁的线程，会陷入阻塞状态，继续等待拿到锁  </p>
</blockquote>
<h4 id="用suspend-和resume-来阻塞线程可以吗？为什么？"><a href="#用suspend-和resume-来阻塞线程可以吗？为什么？" class="headerlink" title="用suspend()和resume()来阻塞线程可以吗？为什么？"></a>用<code>suspend()</code>和<code>resume()</code>来阻塞线程可以吗？为什么？</h4><blockquote>
<p>上面已经做出了解释  </p>
</blockquote>
<h2 id="sleep方法详解"><a href="#sleep方法详解" class="headerlink" title="sleep方法详解"></a><code>sleep</code>方法详解</h2><ul>
<li>作用：我只想让线程在预期的时间执行，其他时候不要占用CPU资源  </li>
</ul>
<h3 id="sleep方法不释放锁"><a href="#sleep方法不释放锁" class="headerlink" title="sleep方法不释放锁"></a><code>sleep</code>方法不释放锁</h3><ul>
<li>包括<code>synchronized</code>和<code>lock </code> </li>
<li>和<code>wait</code>不同  </li>
</ul>
<h3 id="sleep方法响应中断"><a href="#sleep方法响应中断" class="headerlink" title="sleep方法响应中断"></a><code>sleep</code>方法响应中断</h3><ul>
<li>抛出<code>InterruptedException</code>异常</li>
<li>清理中断状态<blockquote>
<p>代码如下，在sleep中被中断，还会抛出异常，然后继续执行  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepInterrupted</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SleepInterrupted());</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">6500</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> Date());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我被中断了&quot;</span>);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>sleep方法可以让线程进入Waiting状态，并且不占用CPU资源，但是不释放锁，直到规定时间后再执行，休眠期间如果被中断，会抛出异常并清除中断状态  </li>
</ul>
<h3 id="常见面试题-2"><a href="#常见面试题-2" class="headerlink" title="常见面试题"></a>常见面试题</h3><h4 id="wait-notify、sleep异同（方法属于那个对象？线程状态怎么切换？）"><a href="#wait-notify、sleep异同（方法属于那个对象？线程状态怎么切换？）" class="headerlink" title="wait/notify、sleep异同（方法属于那个对象？线程状态怎么切换？）"></a>wait/notify、sleep异同（方法属于那个对象？线程状态怎么切换？）</h4><ul>
<li><p>相同</p>
<blockquote>
<p>阻塞<br>响应中断</p>
</blockquote>
</li>
<li><p>不同</p>
<blockquote>
<p>同步方法<br>释放锁<br>指定时间<br>所属类</p>
</blockquote>
</li>
</ul>
<h2 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h2><ul>
<li>作用：因为新的线程加入了我们，所以我们要等待他执行完再出发</li>
<li>用法：main等待thread1执行完毕，注意谁等谁</li>
</ul>
<h3 id="普通用法-1"><a href="#普通用法-1" class="headerlink" title="普通用法"></a>普通用法</h3><blockquote>
<p>执行join之后，主线程会进行等待，等子线程执行完毕之后才会继续运行后面的代码  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Join</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;开始等待所有子线程运行结束&quot;</span>);</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;所有子线程执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="遇到中断-1"><a href="#遇到中断-1" class="headerlink" title="遇到中断"></a>遇到中断</h3><blockquote>
<p>join抓取的中断异常是主线程的中断异常</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinInterrupted</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread mainThread = Thread.currentThread();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    mainThread.interrupt();</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程执行完毕&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程中断&quot;</span>);</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;等待子线程执行完毕&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            thread.interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;子线程运行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在join期间，线程是什么状态？：waiting"><a href="#在join期间，线程是什么状态？：waiting" class="headerlink" title="在join期间，线程是什么状态？：waiting"></a>在join期间，线程是什么状态？：waiting</h3><blockquote>
<p>join期间，主线程处于<code>Waiting</code>状态</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinThreadState</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread mainThread = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                    System.out.println(mainThread.getState());</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread-0运行完毕&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;等待子线程运行&quot;</span>);</span><br><span class="line">        thread.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;子线程运行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>CountDownLatch或CyclicBarrier是经过封装的，可以实现和join一样的功能<h3 id="join源码"><a href="#join源码" class="headerlink" title="join源码"></a>join源码</h3><blockquote>
<p>由图可以看出，join方法也是通过wait实现的<br>而在Thread线程结束后，会调用一次notifyAll方法，唤醒线程，具体代码在C++部分<br>这也不能用Thread类做锁的原因  </p>
</blockquote>
</li>
</ul>
<p><img src="/2021/11/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B8%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/join%E6%BA%90%E7%A0%81%E5%9B%BE.png" alt="join源码图"></p>
<blockquote>
<p>线程退出源码</p>
</blockquote>
<p><img src="/2021/11/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B8%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/%E7%BA%BF%E7%A8%8B%E9%80%80%E5%87%BA%E6%BA%90%E7%A0%81.png" alt="线程退出源码"></p>
<h3 id="join等价代码"><a href="#join等价代码" class="headerlink" title="join等价代码"></a>join等价代码</h3><blockquote>
<p>可以使用wait来进行替换，上面的源码已经显示，线程在退出的时候，会唤醒所有的线程，所以在线程运行完毕之后，会唤醒wait的休眠</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinPrinciple</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;开始等待所有子线程运行结束&quot;</span>);</span><br><span class="line"><span class="comment">//        thread1.join();</span></span><br><span class="line">        <span class="keyword">synchronized</span> (thread1)&#123;</span><br><span class="line">            thread1.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;所有子线程执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="面试常见问题"><a href="#面试常见问题" class="headerlink" title="面试常见问题"></a>面试常见问题</h3><h4 id="在join期间，线程处于哪种线程状态？"><a href="#在join期间，线程处于哪种线程状态？" class="headerlink" title="在join期间，线程处于哪种线程状态？"></a>在join期间，线程处于哪种线程状态？</h4><ul>
<li>处于Waiting状态  </li>
</ul>
<h2 id="yield方法"><a href="#yield方法" class="headerlink" title="yield方法"></a>yield方法</h2><ul>
<li>作用：释放我的CPU时间片（释放时间片之后，状态依然是Runnable状态，随时有可能会被CPU调度执行）  </li>
<li>定位：JVM不保证遵循（根据具体的情况，有可能不生效，不同的cpu实现原理也可能会导致有不同的效果）</li>
<li>yield和sleep的区别：是否随时可能再次被调度（sleep线程认为是阻塞的，不会再调度起来，yield则随时可能被调度起来）</li>
</ul>
<h2 id="获取当前执行线程的引用：Thread-currentThread-方法"><a href="#获取当前执行线程的引用：Thread-currentThread-方法" class="headerlink" title="获取当前执行线程的引用：Thread.currentThread()方法"></a>获取当前执行线程的引用：Thread.currentThread()方法</h2><ul>
<li>返回当前所执行的线程的引用  </li>
</ul>
<h2 id="start和run方法"><a href="#start和run方法" class="headerlink" title="start和run方法"></a>start和run方法</h2><ul>
<li>前面已经有介绍</li>
<li>start会启动一个线程，run则只是调用对象的普通方法  </li>
</ul>
<h2 id="stop，suspend，resume方法"><a href="#stop，suspend，resume方法" class="headerlink" title="stop，suspend，resume方法"></a>stop，suspend，resume方法</h2><ul>
<li>已弃用</li>
</ul>
<h1 id="线程的各个属性"><a href="#线程的各个属性" class="headerlink" title="线程的各个属性"></a>线程的各个属性</h1><table>
<thead>
<tr>
<th align="center">属性名称</th>
<th align="left">用途</th>
<th align="left">注意事项</th>
</tr>
</thead>
<tbody><tr>
<td align="center">编号(ID)</td>
<td align="left">每个线程都有自己的ID，用于标识不同的线程</td>
<td align="left">被后续创建大的线程使用；唯一性；不允许被修改</td>
</tr>
<tr>
<td align="center">名称(Name)</td>
<td align="left">作用让用户或者程序员在开发、调试或运行过程中，更容易区分不同的线程、定位问题等。</td>
<td align="left">清晰有意义的名字；默认的名字</td>
</tr>
<tr>
<td align="center">是否是守护线程(isDaemon)</td>
<td align="left">true代表该线程是【守护线程】，false代表线程是非守护线程，也就是【用户线程】</td>
<td align="left">二选一；继承父线程；setDaemon</td>
</tr>
<tr>
<td align="center">优先级(Priority)</td>
<td align="left">优先级这个属性的目的是告诉线程调度器，用户希望哪些线程相对多运行、那些少运行</td>
<td align="left">默认和父线程的优先级相等；共10个等级；默认值是5；不应该依赖</td>
</tr>
</tbody></table>
<h2 id="线程Id"><a href="#线程Id" class="headerlink" title="线程Id"></a>线程Id</h2><ul>
<li>每个线程都有一个Id</li>
<li>线程Id是不能修改的</li>
<li>线程的Id是自增的，从1开始，main线程是第一个Id</li>
<li>但是在main方法里面创建的第一个线程绝对不是2，因为jvm启动大的时候会创建一些其他的线程</li>
<li>Thread类中获取Id的方法入下，<code>threadSeqNumber</code>初始为0，因为<code>++</code>在前，所以第一个线程的Id是1</li>
</ul>
<p><img src="/2021/11/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B8%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/nextThhreadId.png" alt="nextThreadId"></p>
<h2 id="线程名字"><a href="#线程名字" class="headerlink" title="线程名字"></a>线程名字</h2><ul>
<li>线程的名称如果没有设置默认是’Thread_0’，后面的数字递增</li>
<li>创建线程如果没有设置名称，会如下图设置一个默认名称，名称后面的编号是递增，从0开始</li>
</ul>
<p><img src="/2021/11/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B8%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/%E7%BA%BF%E7%A8%8B%E9%BB%98%E8%AE%A4%E5%90%8D%E7%A7%B0.png" alt="线程默认名称"><br><img src="/2021/11/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B8%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/%E7%BA%BF%E7%A8%8B%E9%BB%98%E8%AE%A4%E5%90%8D%E7%A7%B0%E7%BC%96%E5%8F%B7%E8%8E%B7%E5%8F%96.png" alt="线程默认名称编号获取"></p>
<ul>
<li>线程名称如下图，会设置两个名称，一个线程在java层面的名称，一个是在native的名称</li>
<li>设置名称时会判断线程状态，如果线程已经不是未启动状态，无法修改native层面的名称</li>
</ul>
<p><img src="/2021/11/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B8%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E5%90%8D%E7%A7%B0%E6%BA%90%E7%A0%81.png" alt="设置线程名称源码"></p>
<h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><ul>
<li>作用：给用户线程提供服务<h3 id="三个特性"><a href="#三个特性" class="headerlink" title="三个特性"></a>三个特性</h3></li>
<li>线程类型默认继承自父线程</li>
<li>被谁启动（通常都是由JVM启动的）</li>
<li>不影响JVM退出（JVM退出时只判断有没有用户线程，不会判断守护线程）</li>
</ul>
<h3 id="守护线程和普通线程的区别"><a href="#守护线程和普通线程的区别" class="headerlink" title="守护线程和普通线程的区别"></a>守护线程和普通线程的区别</h3><ul>
<li>整体无区别（都是为了执行任务，不过有的是用户的任务，有的是JVM的任务）</li>
<li>唯一的区别在于JVM的离开（用户线程会影响JVM是否退出，守护线程不会影响）</li>
</ul>
<h3 id="常见面试问题-3"><a href="#常见面试问题-3" class="headerlink" title="常见面试问题"></a>常见面试问题</h3><ul>
<li><p>守护线程和普通线程的区别</p>
<blockquote>
<p>答案同上</p>
</blockquote>
</li>
<li><p>我们是否需要给线程设置为守护线程</p>
<blockquote>
<p>不应该设置为守护线程，因为如果现在在处理数据，设置成守护线程，JVM退出的时候不会考虑它是否还在运行</p>
</blockquote>
</li>
</ul>
<h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><ul>
<li>优先级一共由10个级别，线程的优先级默认是5</li>
<li>程序设计不应该依赖于优先级<blockquote>
<p>不同的操作系统对优先级的理解是不一样的（每种操作系统的优先级级别设置是不一样的，需要一些映射，这样可能会和原本的期望不一致）<br>优先级会被操作系统修改（）</p>
</blockquote>
</li>
</ul>
<h1 id="未捕获异常如何处理？"><a href="#未捕获异常如何处理？" class="headerlink" title="未捕获异常如何处理？"></a>未捕获异常如何处理？</h1><h2 id="线程未捕获异常UncaughtException应该如何处理？"><a href="#线程未捕获异常UncaughtException应该如何处理？" class="headerlink" title="线程未捕获异常UncaughtException应该如何处理？"></a>线程未捕获异常<code>UncaughtException</code>应该如何处理？</h2><ul>
<li>可以使用<code>UncaughtExceptionHandler</code>类来进行处理</li>
</ul>
<h3 id="为什么要用UncaughtExceptionHandler处理？"><a href="#为什么要用UncaughtExceptionHandler处理？" class="headerlink" title="为什么要用UncaughtExceptionHandler处理？"></a>为什么要用<code>UncaughtExceptionHandler</code>处理？</h3><ul>
<li>主线程可以轻松发现异常，子线程却不行</li>
<li>子线程的异常无法使用传统办法捕获</li>
<li>如果不对子线程的异常进行处理，那么会导致线程中断，任务无法处理，不利于程序的健壮性</li>
</ul>
<h3 id="两种解决办法"><a href="#两种解决办法" class="headerlink" title="两种解决办法"></a>两种解决办法</h3><ul>
<li>方案一（不推荐）：手动在每个run方法里面进行try/catch</li>
<li>方案二（推荐）：利用<code>UncaughtExceptionHandler</code><blockquote>
<p>UncaughtExceptionHandler接口</p>
</blockquote>
</li>
</ul>
<p><img src="/2021/11/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B8%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/UncaughtExceptionHandler%E6%8E%A5%E5%8F%A3%E4%BB%A3%E7%A0%81.png" alt="UncaughtExceptionHandler接口代码"></p>
<h3 id="异常处理器的调用策略"><a href="#异常处理器的调用策略" class="headerlink" title="异常处理器的调用策略"></a>异常处理器的调用策略</h3><ul>
<li>默认线程处理器（ThreadGroup）逻辑如下<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void uncaughtException(Thread t, Throwable e) &#123;</span><br><span class="line">    //默认情况下parent是null</span><br><span class="line">    if (parent != null) &#123;</span><br><span class="line">        parent.uncaughtException(t, e);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //调用Thread.setDefaultUncaughtExceptionHandler(...)</span><br><span class="line">        //方法设置的全局handler进行处理</span><br><span class="line">        Thread.UncaughtExceptionHandler ueh =</span><br><span class="line">            Thread.getDefaultUncaughtExceptionHandler();</span><br><span class="line">        if (ueh != null) &#123;</span><br><span class="line">            ueh.uncaughtException(t, e);</span><br><span class="line">        &#125; else if (!(e instanceof ThreadDeath)) &#123;</span><br><span class="line">            //全局handler也不存在就输出异常栈</span><br><span class="line">            System.err.print(&quot;Exception in thread \&quot;&quot;</span><br><span class="line">                             + t.getName() + &quot;\&quot; &quot;);</span><br><span class="line">            e.printStackTrace(System.err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
代码实现异常捕获器：<br>新建捕获器：  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyUncaughtExceptionHandler</span> <span class="keyword">implements</span> <span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyUncaughtExceptionHandler</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">        Logger logger = Logger.getAnonymousLogger();</span><br><span class="line">        logger.log(Level.WARNING, <span class="string">&quot;线程异常，终止了&quot;</span> + t.getName(), e);</span><br><span class="line">        System.out.println(name + <span class="string">&quot;捕获了异常&quot;</span> + t.getName() + <span class="string">&quot;异常：&quot;</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
具体使用：  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseOwnUncaughtExceptionHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> MyUncaughtExceptionHandler(<span class="string">&quot;捕获器1&quot;</span>));</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> CantCatchDirectly(),<span class="string">&quot;MyThread-1&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">300</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> CantCatchDirectly(),<span class="string">&quot;MyThread-2&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">300</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> CantCatchDirectly(),<span class="string">&quot;MyThread-3&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">300</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> CantCatchDirectly(),<span class="string">&quot;MyThread-4&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常见面试问题-4"><a href="#常见面试问题-4" class="headerlink" title="常见面试问题"></a>常见面试问题</h2><h3 id="Java异常体系"><a href="#Java异常体系" class="headerlink" title="Java异常体系"></a>Java异常体系</h3><h3 id="如何全局处理异常？为什么要全局处理异常？不处理行不行"><a href="#如何全局处理异常？为什么要全局处理异常？不处理行不行" class="headerlink" title="如何全局处理异常？为什么要全局处理异常？不处理行不行?"></a>如何全局处理异常？为什么要全局处理异常？不处理行不行?</h3>上面已经有了讲解<h3 id="run方法是否可以抛出异常？如果抛出异常，线程的状态会怎么样？"><a href="#run方法是否可以抛出异常？如果抛出异常，线程的状态会怎么样？" class="headerlink" title="run方法是否可以抛出异常？如果抛出异常，线程的状态会怎么样？"></a>run方法是否可以抛出异常？如果抛出异常，线程的状态会怎么样？</h3></li>
<li>run方法不能再向上抛出异常</li>
<li>如果是可检查异常，只能再run方法中进行捕获处理</li>
<li>如果是不可检查异常，抛出后，线程会终止运行</li>
</ul>
<h3 id="线程中如何处理某个未处理异常"><a href="#线程中如何处理某个未处理异常" class="headerlink" title="线程中如何处理某个未处理异常"></a>线程中如何处理某个未处理异常</h3><ul>
<li>UncaughtExceptionHandler</li>
</ul>
<h1 id="双刃剑：多线程会导致的问题"><a href="#双刃剑：多线程会导致的问题" class="headerlink" title="双刃剑：多线程会导致的问题"></a>双刃剑：多线程会导致的问题</h1><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><h3 id="什么是线程安全"><a href="#什么是线程安全" class="headerlink" title="什么是线程安全"></a>什么是线程安全</h3><blockquote>
<p>不管业务中遇到怎样的多个线程访问某个对象或者方法的情况，而再编译这个业务逻辑的时候，都不需要额外等地的做任何额外的处理（也就是可以像单线程编程一样），程序也可以正常运行（不会因为多线程而出错，就可以称为线程安全）</p>
</blockquote>
<h3 id="什么情况下会出现线程安全问题，怎么避免？"><a href="#什么情况下会出现线程安全问题，怎么避免？" class="headerlink" title="什么情况下会出现线程安全问题，怎么避免？"></a>什么情况下会出现线程安全问题，怎么避免？</h3><h4 id="运行结果错误：a-多线程下出现消失的请求现象"><a href="#运行结果错误：a-多线程下出现消失的请求现象" class="headerlink" title="运行结果错误：a++多线程下出现消失的请求现象"></a>运行结果错误：a++多线程下出现消失的请求现象</h4><blockquote>
<p>最终代码演示如下所示</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThreadError</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;表面上的结果&quot;</span> + instance.index);</span><br><span class="line">        System.out.println(<span class="string">&quot;正在的运行次数&quot;</span> + realIndex.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;出错的次数&quot;</span> + wrongCount.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> MultiThreadError instance = <span class="keyword">new</span> MultiThreadError();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> CyclicBarrier cyclicBarrier1 = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> CyclicBarrier cyclicBarrier2 = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">static</span> AtomicInteger realIndex = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="keyword">static</span> AtomicInteger wrongCount = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">boolean</span>[] marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">1000000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        marked[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cyclicBarrier2.reset();</span><br><span class="line">                cyclicBarrier1.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cyclicBarrier1.reset();</span><br><span class="line">                cyclicBarrier2.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            realIndex.incrementAndGet();</span><br><span class="line">            <span class="keyword">synchronized</span> (instance) &#123;</span><br><span class="line">                <span class="keyword">if</span> (marked[index] &amp;&amp; marked[index - <span class="number">1</span>]) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;发生了错误&quot;</span> + index);</span><br><span class="line">                    wrongCount.incrementAndGet();</span><br><span class="line">                &#125;</span><br><span class="line">                marked[index] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="活跃性问题：死锁、活锁、饥饿"><a href="#活跃性问题：死锁、活锁、饥饿" class="headerlink" title="活跃性问题：死锁、活锁、饥饿"></a>活跃性问题：死锁、活锁、饥饿</h4><blockquote>
<p>死锁示例代码如下  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThreadError</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> Object o2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MultiThreadError r1 = <span class="keyword">new</span> MultiThreadError();</span><br><span class="line">        MultiThreadError r2 = <span class="keyword">new</span> MultiThreadError();</span><br><span class="line">        r1.flag = <span class="number">1</span>;</span><br><span class="line">        r2.flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">new</span> Thread(r1).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(r2).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;flag = &quot;</span>+flag);</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o1)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (o2)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o2)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (o1)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="对象发布和初始化的时候的安全问题"><a href="#对象发布和初始化的时候的安全问题" class="headerlink" title="对象发布和初始化的时候的安全问题"></a>对象发布和初始化的时候的安全问题</h4><h5 id="什么是发布"><a href="#什么是发布" class="headerlink" title="什么是发布"></a>什么是发布</h5><ul>
<li>对象可以在超过当前类的范围外使用  </li>
<li>public修饰的属性对象  </li>
<li>一个方法return出一个对象  </li>
<li>将一个对象作为参数传到其他类的方法中 </li>
</ul>
<h5 id="什么是逸出"><a href="#什么是逸出" class="headerlink" title="什么是逸出"></a>什么是逸出</h5><ul>
<li>1.方法返回一个private对象（private的本意是不让外部访问）</li>
<li>2.还未完成初始化（构造函数没有完全执行完毕）就把对象提供给外界，比如：<ul>
<li>在构造函数中未初始化完毕就this赋值</li>
<li>隐式逸出——注册监听事件</li>
<li>构造函数中运行线程</li>
</ul>
</li>
</ul>
<h2 id="各种需要考虑线程安全的情况"><a href="#各种需要考虑线程安全的情况" class="headerlink" title="各种需要考虑线程安全的情况"></a>各种需要考虑线程安全的情况</h2><ul>
<li>访问共享的变量或资源，会有并发风险，比如对象的属性、静态变量、共享缓存、数据库等  </li>
<li>所有依赖时序的操作，即使每一步操作都是线程安全的，还是存在并发问题：read-modify-write、check0then-act</li>
<li>不同的数据之间存在捆绑关系的时候</li>
<li>我们使用其他类的时候，如果对方没有声明自己是线程安全的  </li>
</ul>
<h2 id="为什么多线程会带来性能问题"><a href="#为什么多线程会带来性能问题" class="headerlink" title="为什么多线程会带来性能问题"></a>为什么多线程会带来性能问题</h2><h3 id="调度：上下文切换"><a href="#调度：上下文切换" class="headerlink" title="调度：上下文切换"></a>调度：上下文切换</h3><ul>
<li>主要是值当线程发生调度的时候</li>
<li>当可运行的线程数超过了CPU的核数，就会开始调度线程，以便于让每个线程都有机会运行</li>
</ul>
<h4 id="什么是上下文"><a href="#什么是上下文" class="headerlink" title="什么是上下文"></a>什么是上下文</h4><ul>
<li>主要和一些程序计数器相关  </li>
<li>切换的时候首先需要挂起一个线程，将线程的运行状态保存得到内存中的某处</li>
<li>包括线程运行时需要的一些数据</li>
</ul>
<h4 id="缓存开销"><a href="#缓存开销" class="headerlink" title="缓存开销"></a>缓存开销</h4><ul>
<li>CPU为了运行速度，会先在通过计算，在内存中缓存一些可能用到的数据</li>
<li>而进行了上下文切换之后，这些缓存的数据大部分都已经没用了</li>
</ul>
<h4 id="何时会导致密集的上下文切换"><a href="#何时会导致密集的上下文切换" class="headerlink" title="何时会导致密集的上下文切换"></a>何时会导致密集的上下文切换</h4><ul>
<li>频繁的抢锁，频繁的IO操作 </li>
</ul>
<h3 id="协作：内存同步"><a href="#协作：内存同步" class="headerlink" title="协作：内存同步"></a>协作：内存同步</h3><ul>
<li>线程在运行的时候，会在线程内部缓存一些数据，如果使用锁，会强制同步线程的缓存数据和主内存的数据</li>
<li>使线程缓存数据失效，只能使用主内存数据  </li>
</ul>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java并发核心知识体系精讲</tag>
      </tags>
  </entry>
  <entry>
    <title>黑马JVM课程——类加载（三）</title>
    <url>/2022/08/20/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<h1 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h1><p>参考文档：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">Chapter 4. The class File Format (oracle.com)</a></p>
<p>以一个简单的 HelloWorld..java 为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行 <code>javac -parameters -d . HelloWorld.java</code> 编译<ul>
<li>使用 <code>-parameters</code> 参数，可以在编译只保留方法参数的名称信息</li>
</ul>
</li>
</ul>
<ul>
<li><p>编译之后的class文件以16进制打开如下所示： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# od -t xC HelloWorld.class</span><br><span class="line">0000000 ca fe ba be 00 00 00 34 00 1f 0a 00 06 00 11 09</span><br><span class="line">0000020 00 12 00 13 08 00 14 0a 00 15 00 16 07 00 17 07</span><br><span class="line">0000040 00 18 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29</span><br><span class="line">0000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e</span><br><span class="line">0000100 75 6d 62 65 72 54 61 62 6c 65 01 00 04 6d 61 69</span><br><span class="line">0000120 6e 01 00 16 28 5b 4c 6a 61 76 61 2f 6c 61 6e 67</span><br><span class="line">0000140 2f 53 74 72 69 6e 67 3b 29 56 01 00 10 4d 65 74</span><br><span class="line">0000160 68 6f 64 50 61 72 61 6d 65 74 65 72 73 01 00 04</span><br><span class="line">0000200 61 72 67 73 01 00 0a 53 6f 75 72 63 65 46 69 6c</span><br><span class="line">0000220 65 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64 2e 6a</span><br><span class="line">0000240 61 76 61 0c 00 07 00 08 07 00 19 0c 00 1a 00 1b</span><br><span class="line">0000260 01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64 07 00</span><br><span class="line">0000300 1c 0c 00 1d 00 1e 01 00 21 63 6f 6d 2f 65 78 61</span><br><span class="line">0000320 6d 70 6c 65 2f 64 65 6d 6f 31 2f 74 65 73 74 2f</span><br><span class="line">0000340 48 65 6c 6c 6f 57 6f 72 6c 64 01 00 10 6a 61 76</span><br><span class="line">0000360 61 2f 6c 61 6e 67 2f 4f 62 6a 65 63 74 01 00 10</span><br><span class="line">0000400 6a 61 76 61 2f 6c 61 6e 67 2f 53 79 73 74 65 6d</span><br><span class="line">0000420 01 00 03 6f 75 74 01 00 15 4c 6a 61 76 61 2f 69</span><br><span class="line">0000440 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d 3b 01 00</span><br><span class="line">0000460 13 6a 61 76 61 2f 69 6f 2f 50 72 69 6e 74 53 74</span><br><span class="line">0000500 72 65 61 6d 01 00 07 70 72 69 6e 74 6c 6e 01 00</span><br><span class="line">0000520 15 28 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72</span><br><span class="line">0000540 69 6e 67 3b 29 56 00 21 00 05 00 06 00 00 00 00</span><br><span class="line">0000560 00 02 00 01 00 07 00 08 00 01 00 09 00 00 00 1d</span><br><span class="line">0000600 00 01 00 01 00 00 00 05 2a b7 00 01 b1 00 00 00</span><br><span class="line">0000620 01 00 0a 00 00 00 06 00 01 00 00 00 07 00 09 00</span><br><span class="line">0000640 0b 00 0c 00 02 00 09 00 00 00 25 00 02 00 01 00</span><br><span class="line">0000660 00 00 09 b2 00 02 12 03 b6 00 04 b1 00 00 00 01</span><br><span class="line">0000700 00 0a 00 00 00 0a 00 02 00 00 00 09 00 08 00 0a</span><br><span class="line">0000720 00 0d 00 00 00 05 01 00 0e 00 00 00 01 00 0f 00</span><br><span class="line">0000740 00 00 02 00 10</span><br><span class="line">0000745</span><br></pre></td></tr></table></figure></li>
<li><p>使用<code>javap -v HelloWorld.class</code>命令反编译后如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Classfile /E:/project/java/demo2/src/main/java/com/example/demo1/test/com/example/demo1/test/HelloWorld.class</span><br><span class="line">  Last modified <span class="number">2022</span>-<span class="number">8</span>-<span class="number">20</span>; size <span class="number">485</span> bytes</span><br><span class="line">  MD5 checksum fceb30d0e6ac220c6aad48757e3affde</span><br><span class="line">  Compiled from <span class="string">&quot;HelloWorld.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">example</span>.<span class="title">demo1</span>.<span class="title">test</span>.<span class="title">HelloWorld</span></span></span><br><span class="line"><span class="class">  <span class="title">minor</span> <span class="title">version</span>: 0</span></span><br><span class="line"><span class="class">  <span class="title">major</span> <span class="title">version</span>: 52</span></span><br><span class="line"><span class="class">  <span class="title">flags</span>: <span class="title">ACC_PUBLIC</span>, <span class="title">ACC_SUPER</span></span></span><br><span class="line"><span class="class"><span class="title">Constant</span> <span class="title">pool</span>:</span></span><br><span class="line"><span class="class">   #1 </span>= Methodref          #<span class="number">6.</span>#<span class="number">17</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Fieldref           #<span class="number">18.</span>#<span class="number">19</span>        <span class="comment">// java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">   #<span class="number">3</span> = String             #<span class="number">20</span>            <span class="comment">// hello world</span></span><br><span class="line">   #<span class="number">4</span> = Methodref          #<span class="number">21.</span>#<span class="number">22</span>        <span class="comment">// java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">   #<span class="number">5</span> = Class              #<span class="number">23</span>            <span class="comment">// com/example/demo1/test/HelloWorld</span></span><br><span class="line">   #<span class="number">6</span> = Class              #<span class="number">24</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">   #<span class="number">7</span> = Utf8               &lt;init&gt;</span><br><span class="line">   #<span class="number">8</span> = Utf8               ()V</span><br><span class="line">   #<span class="number">9</span> = Utf8               Code</span><br><span class="line">  #<span class="number">10</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">11</span> = Utf8               main</span><br><span class="line">  #<span class="number">12</span> = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #<span class="number">13</span> = Utf8               MethodParameters</span><br><span class="line">  #<span class="number">14</span> = Utf8               args</span><br><span class="line">  #<span class="number">15</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">16</span> = Utf8               HelloWorld.java</span><br><span class="line">  #<span class="number">17</span> = NameAndType        #<span class="number">7</span>:#<span class="number">8</span>          <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">18</span> = Class              #<span class="number">25</span>            <span class="comment">// java/lang/System</span></span><br><span class="line">  #<span class="number">19</span> = NameAndType        #<span class="number">26</span>:#<span class="number">27</span>        <span class="comment">// out:Ljava/io/PrintStream;</span></span><br><span class="line">  #<span class="number">20</span> = Utf8               hello world</span><br><span class="line">  #<span class="number">21</span> = Class              #<span class="number">28</span>            <span class="comment">// java/io/PrintStream</span></span><br><span class="line">  #<span class="number">22</span> = NameAndType        #<span class="number">29</span>:#<span class="number">30</span>        <span class="comment">// println:(Ljava/lang/String;)V</span></span><br><span class="line">  #<span class="number">23</span> = Utf8               com/example/demo1/test/HelloWorld</span><br><span class="line">  #<span class="number">24</span> = Utf8               java/lang/Object</span><br><span class="line">  #<span class="number">25</span> = Utf8               java/lang/System</span><br><span class="line">  #<span class="number">26</span> = Utf8               out</span><br><span class="line">  #<span class="number">27</span> = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #<span class="number">28</span> = Utf8               java/io/PrintStream</span><br><span class="line">  #<span class="number">29</span> = Utf8               println</span><br><span class="line">  #<span class="number">30</span> = Utf8               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> com.example.demo1.test.HelloWorld();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">         <span class="number">3</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String hello world</span></span><br><span class="line">         <span class="number">5</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">9</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">10</span>: <span class="number">8</span></span><br><span class="line">    MethodParameters:</span><br><span class="line">      Name                           Flags</span><br><span class="line">      args</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;HelloWorld.java&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>根据JVM规范，类文件结构如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassFile&#123;</span><br><span class="line">	u4               magic;<span class="comment">//魔数</span></span><br><span class="line">	u2               minor_version;<span class="comment">//小版本号</span></span><br><span class="line">	u2               major_version;<span class="comment">//注版本号</span></span><br><span class="line">	u2               constant_pool_count;<span class="comment">//常量池信息</span></span><br><span class="line">	cp_info          constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池信息</span></span><br><span class="line">	u2               access_flags;<span class="comment">//访问修饰符</span></span><br><span class="line">	u2               this_class;<span class="comment">//当前类名信息</span></span><br><span class="line">	u2               super_class;<span class="comment">//父类信息</span></span><br><span class="line">	u2               interfaces_count;<span class="comment">//接口信息</span></span><br><span class="line">	u2               interfaces[interfaces_count];<span class="comment">//接口信息</span></span><br><span class="line">	u2               fields_count;<span class="comment">//类中成员变量信息</span></span><br><span class="line">	field_info       fields[fields_count];<span class="comment">//类中成员变量信息</span></span><br><span class="line">	u2               methods_count;<span class="comment">//类中方法信息</span></span><br><span class="line">	method_info      methods[methods_count];<span class="comment">//类中方法信息</span></span><br><span class="line">	u2               attributes_count;<span class="comment">//类中附加信息</span></span><br><span class="line">	attribute+info   attributes[attributes_count];<span class="comment">//类中附加信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h2><p>0-3字节，表示他是否是【class】类型的文件<br>0000000 <font color="red">ca fe ba be</font> 00 00 00 34 00 1f 0a 00 06 00 11 09</p>
<h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>4-7字节，表示类的版本，00 34（16进制，10进制为52，jdk8）表示jdk8<br>0-3字节，表示他是否是【class】类型的文件<br>0000000 ca fe ba be <font color="red">00 00 00 34</font> 00 1f 0a 00 06 00 11 09</p>
<h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><p><strong>常量池信息对照表</strong></p>
<table>
<thead>
<tr>
<th align="left">Content Type</th>
<th align="left">Value</th>
</tr>
</thead>
<tbody><tr>
<td align="left">CONSTANT_Class</td>
<td align="left">7</td>
</tr>
<tr>
<td align="left">CONSTANT_Fielaref</td>
<td align="left">9</td>
</tr>
<tr>
<td align="left">CONSTANT_Methidref</td>
<td align="left">10</td>
</tr>
<tr>
<td align="left">CONSTANT_InterfaceMetodref</td>
<td align="left">11</td>
</tr>
<tr>
<td align="left">CONSTANT_String</td>
<td align="left">8</td>
</tr>
<tr>
<td align="left">CONSTANT_Integer</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">CONSTANT_Float</td>
<td align="left">4</td>
</tr>
<tr>
<td align="left">CONSTANT_Long</td>
<td align="left">5</td>
</tr>
<tr>
<td align="left">CONSTANT_Double</td>
<td align="left">6</td>
</tr>
<tr>
<td align="left">CONSTANT_NameAndType</td>
<td align="left">12</td>
</tr>
<tr>
<td align="left">CONSTANT_Utf8</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">CONSTANT_MethodHandle</td>
<td align="left">15</td>
</tr>
<tr>
<td align="left">CONSTANT_MethodType</td>
<td align="left">16</td>
</tr>
<tr>
<td align="left">CONSTANT_InvokeDynamic</td>
<td align="left">18</td>
</tr>
</tbody></table>
<h3 id="常量池长度"><a href="#常量池长度" class="headerlink" title="常量池长度"></a>常量池长度</h3><p>8~9字节，表示常量池的长度，00 1f（31）表示常量池有#1-#30项，注意，#0项不计入，也没有值<br>0000000 ca fe ba be 00 00 00 34 <font color="red">00 1f</font> 0a 00 06 00 11 09</p>
<h4 id="1"><a href="#1" class="headerlink" title="#1"></a>#1</h4><p>第#1项，0a（10）表示一个Method信息，00 06和 00 11（17） 表示它引用了常量池中#6和#17项来获得这个方法的【所属类】和【方法名】<br>0000000 ca fe ba be 00 00 00 34 00 1f <font color="red">0a 00 06 00 11</font> 09</p>
<h4 id="2"><a href="#2" class="headerlink" title="#2"></a>#2</h4><p>第#2项，09 表示一个Field信息，向后数4个字节，00 12（18）和 00 13（19） 表示它引用了常量池中#18和#19项来获得这个方法的【所属类】和【成员变量名】<br>0000000 ca fe ba be 00 00 00 34 00 1f 0a 00 06 00 11 <font color="red">09</font><br>0000020 <font color="red">00 12 00 13</font> 08 00 14 0a 00 15 00 16 07 00 17 07</p>
<h4 id="3"><a href="#3" class="headerlink" title="#3"></a>#3</h4><p>第#3项，08 表示一个字符串常量名称，向后数2个字节，00 14（20）， 表示它引用了常量池中#20项<br>0000020 00 12 00 13 <font color="red">08 00 14</font> 0a 00 15 00 16 07 00 17 07</p>
<h4 id="4"><a href="#4" class="headerlink" title="#4"></a>#4</h4><p>第#4项，0a（10）表示一个Method信息，00 15（21）和 00 16（22） 表示它引用了常量池中#21和#22项来获得这个方法的【所属类】和【方法名】<br>0000020 00 12 00 13 08 00 14 <font color="red">0a 00 15 00 16</font> 07 00 17 07</p>
<h4 id="5"><a href="#5" class="headerlink" title="#5"></a>#5</h4><p>第#5项，07 表示一个Class信息，00 17（23） 表示它引用了常量池中#23项<br>0000020 00 12 00 13 08 00 14 0a 00 15 00 16 <font color="red">07 00 17</font> 07</p>
<h4 id="6"><a href="#6" class="headerlink" title="#6"></a>#6</h4><p>第#6项，07 表示一个Class信息，00 18（24） 表示它引用了常量池中#24项<br>0000020 00 12 00 13 08 00 14 0a 00 15 00 16 07 00 17 <font color="red">07</font><br>0000040 <font color="red">00 18</font> 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29</p>
<h4 id="7"><a href="#7" class="headerlink" title="#7"></a>#7</h4><p>第#7项，01 表示一个UTF8串，00 06表示字符串的长度，【3c 69 6e 69 74 3e】=【&lt;init&gt;】<br>0000040 00 18 <font color="red">01 00 06 3c 69 6e 69 74 3e</font> 01 00 03 28 29</p>
<h4 id="8"><a href="#8" class="headerlink" title="#8"></a>#8</h4><p>第#8项，01 表示一个UTF8串，00 03表示字符串的长度，【28 29 56】=【()V】<br>0000040 00 18 01 00 06 3c 69 6e 69 74 3e <font color="red">01 00 03 28 29</font><br>0000060 <font color="red">56</font> 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e</p>
<h4 id="9"><a href="#9" class="headerlink" title="#9"></a>#9</h4><p>第#9项，01 表示一个UTF8串，00 04表示字符串的长度，【43 6f 64 65】=【Code】<br>0000060 56 <font color="red">01 00 04 43 6f 64 65</font> 01 00 0f 4c 69 6e 65 4e</p>
<h4 id="10"><a href="#10" class="headerlink" title="#10"></a>#10</h4><p>第#10项，01 表示一个UTF8串，00 0f（15）表示字符串的长度，【4c 69 6e 65 4e 75 6d 62 65 72 54 61 62 6c 65】=【LineNumberTable】<br>0000060 56 01 00 04 43 6f 64 65 <font color="red">01 00 0f 4c 69 6e 65 4e</font><br>0000100 <font color="red">75 6d 62 65 72 54 61 62 6c 65</font> 01 00 04 6d 61 69</p>
<h4 id="11"><a href="#11" class="headerlink" title="#11"></a>#11</h4><p>第#11项，01 表示一个UTF8串，00 04表示字符串的长度，【6d 61 69 6e】=【main】<br>0000100 75 6d 62 65 72 54 61 62 6c 65 <font color="red">01 00 04 6d 61 69</font><br>0000120 <font color="red">6e</font> 01 00 16 28 5b 4c 6a 61 76 61 2f 6c 61 6e 67</p>
<h4 id="12"><a href="#12" class="headerlink" title="#12"></a>#12</h4><p>第#12项，01 表示一个UTF8串，00 16（22）表示字符串的长度，【28 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b 29 56】=【([Ljava/lang/String;)V】<br>0000120 6e <font color="red">01 00 16 28 5b 4c 6a 61 76 61 2f 6c 61 6e 67</font><br>0000140 <font color="red">2f 53 74 72 69 6e 67 3b 29 56</font> 01 00 10 4d 65 74</p>
<h4 id="13"><a href="#13" class="headerlink" title="#13"></a>#13</h4><p>第#13项，01 表示一个UTF8串，00 10（16）表示字符串的长度，【4d 65 74 68 6f 64 50 61 72 61 6d 65 74 65 72 73】=【MethodParameters】<br>0000140 2f 53 74 72 69 6e 67 3b 29 56 <font color="red">01 00 10 4d 65 74</font><br>0000160 <font color="red">68 6f 64 50 61 72 61 6d 65 74 65 72 73</font> 01 00 04</p>
<h4 id="14"><a href="#14" class="headerlink" title="#14"></a>#14</h4><p>第#14项，01 表示一个UTF8串，00 04（16）表示字符串的长度，【61 72 67 73】=【args】<br>0000160 68 6f 64 50 61 72 61 6d 65 74 65 72 73 <font color="red">01 00 04</font><br>0000200 <font color="red">61 72 67 73</font> 01 00 0a 53 6f 75 72 63 65 46 69 6c</p>
<h4 id="15"><a href="#15" class="headerlink" title="#15"></a>#15</h4><p>第#15项，01 表示一个UTF8串，00 0a（10）表示字符串的长度，【53 6f 75 72 63 65 46 69 6c 65】=【SourceFile】<br>0000200 61 72 67 73 <font color="red">01 00 0a 53 6f 75 72 63 65 46 69 6c</font><br>0000220 <font color="red">65</font> 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64 2e 6a</p>
<h4 id="16"><a href="#16" class="headerlink" title="#16"></a>#16</h4><p>第#16项，01 表示一个UTF8串，00 0f（15）表示字符串的长度，【48 65 6c 6c 6f 57 6f 72 6c 64 2e 6a 61 76 61】=【HelloWorld.java】<br>0000220 65 <font color="red">01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64 2e 6a</font><br>0000240 <font color="red">61 76 61</font> 0c 00 07 00 08 07 00 19 0c 00 1a 00 1b</p>
<h4 id="17"><a href="#17" class="headerlink" title="#17"></a>#17</h4><p>第#17项，0c（12） 表示一个NameAndType【名+类型】，00 07和00 08表示引用了常量池中的#7和#8项【&lt;init&gt;:()V】<br>0000240 61 76 61 <font color="red">0c 00 07 00 08</font> 07 00 19 0c 00 1a 00 1b</p>
<h4 id="18"><a href="#18" class="headerlink" title="#18"></a>#18</h4><p>第#18项，07 表示一个Class信息，00 19（25） 表示它引用了常量池中#25项<br>0000240 61 76 61 0c 00 07 00 08 <font color="red">07 00 19</font> 0c 00 1a 00 1b</p>
<h4 id="19"><a href="#19" class="headerlink" title="#19"></a>#19</h4><p>第#19项，0c（12） 表示一个NameAndType【名+类型】，00 1a（26）和00 1b（27）表示引用了常量池中的#26和#27项<br>0000240 61 76 61 0c 00 07 00 08 07 00 19 <font color="red">0c 00 1a 00 1b</font></p>
<h4 id="20"><a href="#20" class="headerlink" title="#20"></a>#20</h4><p>第#20项，01 表示一个UTF8串，00 0b（11）表示字符串的长度，【68 65 6c 6c 6f 20 77 6f 72 6c 64】=【hello world】<br>0000260  <font color="red">01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64</font> 07 00</p>
<h4 id="21"><a href="#21" class="headerlink" title="#21"></a>#21</h4><p>第#21项，07 表示一个Class信息，00 1c（28） 表示它引用了常量池中#28项<br>0000260  01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64 <font color="red">07 00</font><br>0000300 <font color="red">1c</font> 0c 00 1d 00 1e 01 00 21 63 6f 6d 2f 65 78 61</p>
<h4 id="22"><a href="#22" class="headerlink" title="#22"></a>#22</h4><p>第#22项，0c（12） 表示一个NameAndType【名+类型】，00 1d（29）和00 1e（30）表示引用了常量池中的#29和#30项<br>0000300 1c <font color="red">0c 00 1d 00 1e </font>01 00 21 63 6f 6d 2f 65 78 61</p>
<h4 id="23"><a href="#23" class="headerlink" title="#23"></a>#23</h4><p>第#23项，01 表示一个UTF8串，00 21（33）表示字符串的长度，【63 6f 6d 2f 65 78 61 6d 70 6c 65 2f 64 65 6d 6f 31 2f 74 65 73 74 2f 48 65 6c 6c 6f 57 6f 72 6c 64】=【com/example/demo1/test/HelloWorld】<br>0000300 1c 0c 00 1d 00 1e <font color="red">01 00 21 63 6f 6d 2f 65 78 61</font><br>0000320 <font color="red">6d 70 6c 65 2f 64 65 6d 6f 31 2f 74 65 73 74 2f</font><br>0000340 <font color="red">48 65 6c 6c 6f 57 6f 72 6c 64</font> 01 00 10 6a 61 76</p>
<h4 id="24"><a href="#24" class="headerlink" title="#24"></a>#24</h4><p>第#24项，01 表示一个UTF8串，00 10（16）表示字符串的长度，【6a 61 76 61 2f 6c 61 6e 67 2f 4f 62 6a 65 63 74】=【java/lang/Object】<br>0000340 48 65 6c 6c 6f 57 6f 72 6c 64 <font color="red">01 00 10 6a 61 76</font><br>0000360 <font color="red">61 2f 6c 61 6e 67 2f 4f 62 6a 65 63 74</font> 01 00 10</p>
<h4 id="25"><a href="#25" class="headerlink" title="#25"></a>#25</h4><p>第#25项，01 表示一个UTF8串，00 10（16）表示字符串的长度，【6a 61 76 61 2f 6c 61 6e 67 2f 53 79 73 74 65 6d】=【java/lang/System】<br>0000360 61 2f 6c 61 6e 67 2f 4f 62 6a 65 63 74 <font color="red">01 00 10</font><br>0000400 <font color="red">6a 61 76 61 2f 6c 61 6e 67 2f 53 79 73 74 65 6d</font></p>
<h4 id="26"><a href="#26" class="headerlink" title="#26"></a>#26</h4><p>第#26项，01 表示一个UTF8串，00 03（16）表示字符串的长度，【6f 75 74】=【out】<br>0000420 <font color="red">01 00 03 6f 75 74</font> 01 00 15 4c 6a 61 76 61 2f 69</p>
<h4 id="27"><a href="#27" class="headerlink" title="#27"></a>#27</h4><p>第#27项，01 表示一个UTF8串，00 15（21）表示字符串的长度，【4c 6a 61 76 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d 3b】=【Ljava/io/PrintStream;】<br>0000420 01 00 03 6f 75 74 <font color="red">01 00 15 4c 6a 61 76 61 2f 69</font><br>0000440 <font color="red">6f 2f 50 72 69 6e 74 53 74 72 65 61 6d 3b</font> 01 00</p>
<h4 id="28"><a href="#28" class="headerlink" title="#28"></a>#28</h4><p>第#28项，01 表示一个UTF8串，00 13（19）表示字符串的长度，【6a 61 76 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d】=【java/io/PrintStream】<br>0000440 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d 3b <font color="red">01 00</font><br>0000460 <font color="red">13 6a 61 76 61 2f 69 6f 2f 50 72 69 6e 74 53 74</font><br>0000500 <font color="red">72 65 61 6d</font> 01 00 07 70 72 69 6e 74 6c 6e 01 00</p>
<h4 id="29"><a href="#29" class="headerlink" title="#29"></a>#29</h4><p>第#29项，01 表示一个UTF8串，00 07表示字符串的长度，【70 72 69 6e 74 6c 6e】=【println】<br>0000500 72 65 61 6d <font color="red">01 00 07 70 72 69 6e 74 6c 6e</font> 01 00</p>
<h4 id="30"><a href="#30" class="headerlink" title="#30"></a>#30</h4><p>第#30项，01 表示一个UTF8串，00 15（21）表示字符串的长度，【28 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b 29 56】=【(Ljava/lang/String;)V】<br>0000500 72 65 61 6d 01 00 07 70 72 69 6e 74 6c 6e <font color="red">01 00</font><br>0000520 <font color="red">15 28 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72</font><br>0000540 <font color="red">69 6e 67 3b 29 56</font> 00 21 00 05 00 06 00 00 00 00</p>
<h2 id="访问标识与继承信息"><a href="#访问标识与继承信息" class="headerlink" title="访问标识与继承信息"></a>访问标识与继承信息</h2><table>
<thead>
<tr>
<th align="left">Flag Name</th>
<th align="left">Value</th>
<th align="left">Interpretation</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ACC_PUBLIC</td>
<td align="left">0x0001</td>
<td align="left">表示是公开的，public</td>
</tr>
<tr>
<td align="left">ACC_FINAL</td>
<td align="left">0x0010</td>
<td align="left">表示是final的</td>
</tr>
<tr>
<td align="left">ACC_SUPER</td>
<td align="left">0x0020</td>
<td align="left">表示是一个类</td>
</tr>
<tr>
<td align="left">ACC_INTERFACE</td>
<td align="left">0x0200</td>
<td align="left">表示是一个接口</td>
</tr>
<tr>
<td align="left">ACC_ABSTRACT</td>
<td align="left">0x0400</td>
<td align="left">表示是一个抽象的</td>
</tr>
<tr>
<td align="left">ACC_SYNTHETIC</td>
<td align="left">0x1000</td>
<td align="left">表示是人工合成的，不是原生的</td>
</tr>
<tr>
<td align="left">ACC_ANNOTATION</td>
<td align="left">0x2000</td>
<td align="left">表示是一个注解</td>
</tr>
<tr>
<td align="left">ACC_ENUM</td>
<td align="left">0X4000</td>
<td align="left">表示是一个枚举</td>
</tr>
</tbody></table>
<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>00 21 表示（0x0001）+（0x0020），表示该class是一个公共的类<br>0000540 69 6e 67 3b 29 56 <font color="red">00 21</font> 00 05 00 06 00 00 00 00</p>
<h3 id="全限定名"><a href="#全限定名" class="headerlink" title="全限定名"></a>全限定名</h3><p>00 05 表示全限定名的位置，常量池中#5项的位置【com/example/demo1/test/HelloWorld】<br>0000540 69 6e 67 3b 29 56 00 21 <font color="red">00 05</font> 00 06 00 00 00 00</p>
<h3 id="父类全限定名"><a href="#父类全限定名" class="headerlink" title="父类全限定名"></a>父类全限定名</h3><p>00 06 表示父类全限定名的位置，常量池中#6项的位置【java/lang/Object】<br>0000540 69 6e 67 3b 29 56 00 21 00 05 <font color="red">00 06</font> 00 00 00 00</p>
<h3 id="接口信息"><a href="#接口信息" class="headerlink" title="接口信息"></a>接口信息</h3><p>00 00 表示该类继承的接口数量，现在表示没有继承接口，如果继承了接口，后面就会跟随接口的描述信息<br>0000540 69 6e 67 3b 29 56 00 21 00 05 00 06 <font color="red">00 00</font> 00 00</p>
<h2 id="成员变量信息-Field"><a href="#成员变量信息-Field" class="headerlink" title="成员变量信息(Field)"></a>成员变量信息(Field)</h2><p>00 00 表示该类的成员变量的数量，现在表示没有成员变量，如果有成员变量，后面会跟随成员变量的信息<br>0000540 69 6e 67 3b 29 56 00 21 00 05 00 06 00 00 <font color="red">00 00</font></p>
<table>
<thead>
<tr>
<th align="left">FieldType</th>
<th align="left">Type</th>
<th align="left">Interpretation</th>
</tr>
</thead>
<tbody><tr>
<td align="left">B</td>
<td align="left">byte</td>
<td align="left">字节类型</td>
</tr>
<tr>
<td align="left">C</td>
<td align="left">char</td>
<td align="left">字符类型</td>
</tr>
<tr>
<td align="left">D</td>
<td align="left">double</td>
<td align="left">双精度浮点类型</td>
</tr>
<tr>
<td align="left">F</td>
<td align="left">float</td>
<td align="left">单精度浮点类型</td>
</tr>
<tr>
<td align="left">I</td>
<td align="left">int</td>
<td align="left">整型</td>
</tr>
<tr>
<td align="left">J</td>
<td align="left">long</td>
<td align="left">长整型</td>
</tr>
<tr>
<td align="left">L ClassName;</td>
<td align="left">reference</td>
<td align="left">引用类型,例如【Ljava/io/PrintStream;】</td>
</tr>
<tr>
<td align="left">S</td>
<td align="left">short</td>
<td align="left">短整数</td>
</tr>
<tr>
<td align="left">Z</td>
<td align="left">boolean</td>
<td align="left">布尔类型</td>
</tr>
<tr>
<td align="left">[</td>
<td align="left">reference</td>
<td align="left">数组类型</td>
</tr>
</tbody></table>
<h2 id="方法信息（Method）"><a href="#方法信息（Method）" class="headerlink" title="方法信息（Method）"></a>方法信息（Method）</h2><h3 id="方法数量"><a href="#方法数量" class="headerlink" title="方法数量"></a>方法数量</h3><p>00 02 表示该类中的方法数量，当前类里面是有2个方法，【无参构造，main方法】<br>0000560 <font color="red">00 02</font> 00 01 00 07 00 08 00 01 00 09 00 00 00 1d</p>
<h3 id="方法组成"><a href="#方法组成" class="headerlink" title="方法组成"></a>方法组成</h3><p>一个方法由访问修饰符，名称，参数描述，方法属性数量，方法属性组成</p>
<h3 id="第一个方法的详细解析"><a href="#第一个方法的详细解析" class="headerlink" title="第一个方法的详细解析"></a>第一个方法的详细解析</h3><ul>
<li>蓝色部分的 00 01 表示方法的访问修饰，当前表示是一个公共方法</li>
<li>绿色部分的 00 07 表示要查询常量池中的第#7项得到方法的名字【&lt;init&gt;】</li>
<li>黄色部分的 00 08 表示要查询常量池中的#8项获得方法的参数和返回值信息【()V】（无参，返回值是void）</li>
<li>紫色部分的 00 01 表示方法的属性数量，当前是1个</li>
<li>剩下的红色部分代表方法属性<ul>
<li>00 09表示方法的属性名称，需要查询常量池中的#9 【Code】</li>
<li>00 00 00 1d 表示该属性占据的字节码长度是29</li>
<li>00 01 表示【操作数栈】最大深度</li>
<li>00 01 表示【局部变量表】最大槽（slot）数</li>
<li>00 00 00 05 表示【Code】属性内的（代码）字节码长度</li>
<li>2a b7 00 01 b1 方法内的具体代码</li>
<li>00 00 00 01 表示方法细节属性数量（code属性的有些子属性）</li>
<li>00 0a 表示引用了常量池中的#10项，发现是【LineNumberTable】属性（将字节码行号和java代码行号对应）<ul>
<li>00 00 00 06 【LineNumberTable】属性的字节码总长度，6</li>
<li>00 01 【LineNumberTable】属性的长度（有几对）</li>
<li>00 00 00 07，00 00 表示【字节码】行号，00 04 表示【java源码】行号</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>0000560 00 02 <font color="blue">00 01</font> <font color="green">00 07</font> <font color="yellow">00 08</font> <font color="purple">00 01</font> <font color="red">00 09 00 00 00 1d</font><br>0000600 <font color="red">00 01 00 01 00 00 00 05 2a b7 00 01 b1 00 00 00</font><br>0000620 <font color="red">01 00 0a 00 00 00 06 00 01 00 00 00 07</font> 00 09 00</p>
<h3 id="第二个方法的详细解析"><a href="#第二个方法的详细解析" class="headerlink" title="第二个方法的详细解析"></a>第二个方法的详细解析</h3><ul>
<li>蓝色部分的 00 09 表示方法的访问修饰，相当于是（08+01）08是静态，当前表示是一个静态公共方法</li>
<li>绿色部分的 00 0b (11)表示要查询常量池中的第#11项得到方法的名字【main】</li>
<li>黄色部分的 00 0c (12) 表示要查询常量池中的#12项获得方法的参数和返回值信息【([Ljava/lang/String;)V】（如此是引用数组类型，返回值是void）</li>
<li>紫色部分的 00 02 表示方法的属性数量，当前是2个</li>
<li>剩下的红色部分代表方法属性<ul>
<li>00 09表示方法的第一个属性名称，需要查询常量池中的#9 【Code】<ul>
<li>00 00 00 25 表示该属性的占据的字节码长度是37</li>
<li>00 02 表示【操作数栈】最大深度2</li>
<li>00 01 表示【局部变量表】最大槽（slot）数</li>
<li>00 00 00 09 表示【Code】属性内的（代码）字节码长度</li>
<li>b2 00 02 12 03 b6 00 04 b1 方法内的具体代码</li>
<li>00 00 00 01 表示方法细节属性数量（code属性的有些子属性）</li>
<li>00 0a 表示引用了常量池中的#10项，发现是【LineNumberTable】属性（将字节码行号和java代码行号对应）<ul>
<li>00 00 00 0a 【LineNumberTable】属性的字节码总长度，10</li>
<li>00 02 【LineNumberTable】属性的长度（有几对）</li>
<li>00 00 00 09，00 00 表示【字节码】行号，00 09 表示【java源码】行号</li>
<li>00 08 00 0a，00 08 表示【字节码】行号，00 0a (10) 表示【java源码】行号</li>
</ul>
</li>
</ul>
</li>
<li>00 0d(13)表示方法的第一个属性名称，需要查询常量池中的#13 【MethodParameters】<ul>
<li>00 00 00 05 表示该属性的占据的字节码长度是5</li>
<li>01 参数的数量</li>
<li>00 0e (14) 参数的名字，引用了常量池中的#14项，【args】</li>
<li>00 00 访问修饰符</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>0000620 01 00 0a 00 00 00 06 00 01 00 00 00 07 <font color="blue">00 09</font> <font color="green">00</font><br>0000640 <font color="green">0b</font> <font color="yellow">00 0c</font> <font color="purple">00 02</font> <font color="red">00 09 00 00 00 25 00 02 00 01 00</font><br>0000660 <font color="red">00 00 09 b2 00 02 12 03 b6 00 04 b1 00 00 00 01</font><br>0000700 <font color="red">00 0a 00 00 00 0a 00 02 00 00 00 09 00 08 00 0a</font><br>0000720 <font color="red">00 0d 00 00 00 05 01 00 0e 00 00</font> 00 01 00 0f 00</p>
<h2 id="附加属性"><a href="#附加属性" class="headerlink" title="附加属性"></a>附加属性</h2><ul>
<li>00 01 表示附加属性的数量</li>
<li>00 0f（15） 表示引用了常量池中的#15项【SourceFile】</li>
<li>00 00 00 02 表示此属性的长度</li>
<li>00 10（16） 表示引用了常量池#16项，【HelloWorld.java】</li>
</ul>
<p>0000720 00 0d 00 00 00 05 01 00 0e 00 00 <font color="red">00 01 00 0f 00</font><br>0000740 <font color="red">00 00 02 00 10</font><br>0000745</p>
<h1 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a>字节码指令</h1><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>可参考文章：</p>
<ul>
<li><a href="https://ysymj.gitee.io/2021/11/16/java%E5%9F%BA%E7%A1%80/Java%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E5%A4%A7%E5%85%A8/">Java字节码指令大全 | YS (gitee.io)</a></li>
<li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html">Chapter 6. The Java Virtual Machine Instruction Set (oracle.com)</a></li>
</ul>
<p>上面的方法编译后，留下了两组字节码指令没有讲解</p>
<p><strong>构造方法中的5个字节码指令</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2a b7 00 01 b1</span><br></pre></td></tr></table></figure>
<ul>
<li>2a =&gt; <code>aload_0</code>，从局部变量0中装载引用类型值入栈，及<code>this</code>，做为下面的 <code>invokespecial</code> 构造方法调用的参数</li>
<li>b7 =&gt; <code>invokespecial</code> ，编译时方法绑定调用方法（预备调用构造方法），调用那个方法？</li>
<li>00 01 引用常量池中 #1 项，即【Method java/lang/Object.&lt;init&gt;:()V】</li>
<li>b1 =&gt;return， viod函数返回</li>
</ul>
<p><strong>main方法中的9个字节码指令</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b2 00 02 12 03 b6 00 04 b1</span><br></pre></td></tr></table></figure>
<ul>
<li>b2 =&gt; <code>getstatic</code>，获取静态字段的值（加载静态变量），那个静态变量呢？</li>
<li>00 02 引用常量池中#2项，即【Field java/lang/System.out:Ljava/io/PrintStream;】</li>
<li>12 =&gt; <code>ldc</code>，常量池中的常量值入栈（加载参数），加载那个参数？</li>
<li>03 引用常量池中#3项，即【String hello world】</li>
<li>b6 =&gt; <code>invokvirtual</code>，运行时方法绑定调用方法（预备调用成员方法），调用那个方法？</li>
<li>00 04 引用常量池中#4项，即【Method java/io/PrintStream.println:(Ljava/lang/String;)V】</li>
<li>b1 =&gt;return， viod函数返回</li>
</ul>
<h2 id="javap-工具"><a href="#javap-工具" class="headerlink" title="javap 工具"></a>javap 工具</h2><ul>
<li>jdk提供了<code>javap</code>工具来进行反编译，具体操作方式，见上面内容</li>
</ul>
<h2 id="图解方法执行流程"><a href="#图解方法执行流程" class="headerlink" title="图解方法执行流程"></a>图解方法执行流程</h2><h3 id="原始java代码"><a href="#原始java代码" class="headerlink" title="原始java代码"></a>原始java代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;  </span><br><span class="line">        <span class="keyword">int</span> b = Short.MAX_VALUE +<span class="number">1</span> ;  </span><br><span class="line">        <span class="keyword">int</span> c = a+b;  </span><br><span class="line">        System.out.println(c);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="编译后的字节码文件"><a href="#编译后的字节码文件" class="headerlink" title="编译后的字节码文件"></a>编译后的字节码文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Classfile /E:/project/java/demo2/src/main/java/com/example/demo1/test/com/example/demo1/test/Test1.class</span><br><span class="line">  Last modified <span class="number">2022</span>-<span class="number">8</span>-<span class="number">21</span>; size <span class="number">488</span> bytes</span><br><span class="line">  MD5 checksum b8a87685b4f2ed97f03db1e25823271e</span><br><span class="line">  Compiled from <span class="string">&quot;Test1.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">example</span>.<span class="title">demo1</span>.<span class="title">test</span>.<span class="title">Test1</span></span></span><br><span class="line"><span class="class">  <span class="title">minor</span> <span class="title">version</span>: 0</span></span><br><span class="line"><span class="class">  <span class="title">major</span> <span class="title">version</span>: 52</span></span><br><span class="line"><span class="class">  <span class="title">flags</span>: <span class="title">ACC_PUBLIC</span>, <span class="title">ACC_SUPER</span></span></span><br><span class="line"><span class="class"><span class="title">Constant</span> <span class="title">pool</span>:</span></span><br><span class="line"><span class="class">   #1 </span>= Methodref          #<span class="number">7.</span>#<span class="number">18</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Class              #<span class="number">19</span>            <span class="comment">// java/lang/Short</span></span><br><span class="line">   #<span class="number">3</span> = Integer            <span class="number">32768</span></span><br><span class="line">   #<span class="number">4</span> = Fieldref           #<span class="number">20.</span>#<span class="number">21</span>        <span class="comment">// java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">   #<span class="number">5</span> = Methodref          #<span class="number">22.</span>#<span class="number">23</span>        <span class="comment">// java/io/PrintStream.println:(I)V</span></span><br><span class="line">   #<span class="number">6</span> = Class              #<span class="number">24</span>            <span class="comment">// com/example/demo1/test/Test1</span></span><br><span class="line">   #<span class="number">7</span> = Class              #<span class="number">25</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">   #<span class="number">8</span> = Utf8               &lt;init&gt;</span><br><span class="line">   #<span class="number">9</span> = Utf8               ()V</span><br><span class="line">  #<span class="number">10</span> = Utf8               Code</span><br><span class="line">  #<span class="number">11</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">12</span> = Utf8               main</span><br><span class="line">  #<span class="number">13</span> = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #<span class="number">14</span> = Utf8               MethodParameters</span><br><span class="line">  #<span class="number">15</span> = Utf8               args</span><br><span class="line">  #<span class="number">16</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">17</span> = Utf8               Test1.java</span><br><span class="line">  #<span class="number">18</span> = NameAndType        #<span class="number">8</span>:#<span class="number">9</span>          <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">19</span> = Utf8               java/lang/Short</span><br><span class="line">  #<span class="number">20</span> = Class              #<span class="number">26</span>            <span class="comment">// java/lang/System</span></span><br><span class="line">  #<span class="number">21</span> = NameAndType        #<span class="number">27</span>:#<span class="number">28</span>        <span class="comment">// out:Ljava/io/PrintStream;</span></span><br><span class="line">  #<span class="number">22</span> = Class              #<span class="number">29</span>            <span class="comment">// java/io/PrintStream</span></span><br><span class="line">  #<span class="number">23</span> = NameAndType        #<span class="number">30</span>:#<span class="number">31</span>        <span class="comment">// println:(I)V</span></span><br><span class="line">  #<span class="number">24</span> = Utf8               com/example/demo1/test/Test1</span><br><span class="line">  #<span class="number">25</span> = Utf8               java/lang/Object</span><br><span class="line">  #<span class="number">26</span> = Utf8               java/lang/System</span><br><span class="line">  #<span class="number">27</span> = Utf8               out</span><br><span class="line">  #<span class="number">28</span> = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #<span class="number">29</span> = Utf8               java/io/PrintStream</span><br><span class="line">  #<span class="number">30</span> = Utf8               println</span><br><span class="line">  #<span class="number">31</span> = Utf8               (I)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> com.example.demo1.test.Test1();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">4</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: bipush        <span class="number">10</span></span><br><span class="line">         <span class="number">2</span>: istore_1</span><br><span class="line">         <span class="number">3</span>: ldc           #<span class="number">3</span>                  <span class="comment">// int 32768</span></span><br><span class="line">         <span class="number">5</span>: istore_2</span><br><span class="line">         <span class="number">6</span>: iload_1</span><br><span class="line">         <span class="number">7</span>: iload_2</span><br><span class="line">         <span class="number">8</span>: iadd</span><br><span class="line">         <span class="number">9</span>: istore_3</span><br><span class="line">        <span class="number">10</span>: getstatic     #<span class="number">4</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">        <span class="number">13</span>: iload_3</span><br><span class="line">        <span class="number">14</span>: invokevirtual #<span class="number">5</span>                  <span class="comment">// Method java/io/PrintStream.println:(I)V</span></span><br><span class="line">        <span class="number">17</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">9</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">10</span>: <span class="number">3</span></span><br><span class="line">        line <span class="number">11</span>: <span class="number">6</span></span><br><span class="line">        line <span class="number">12</span>: <span class="number">10</span></span><br><span class="line">        line <span class="number">13</span>: <span class="number">17</span></span><br><span class="line">    MethodParameters:</span><br><span class="line">      Name                           Flags</span><br><span class="line">      args</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;Test1.java&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="常量池载入运行时常量池"><a href="#常量池载入运行时常量池" class="headerlink" title="常量池载入运行时常量池"></a>常量池载入运行时常量池</h3><blockquote>
<p>一些比较小的数字，不会存储在常量池中，而是跟方法的字节码存在一起，比如<code>int a = 10;</code> 中10就是存在字节码中的<br> 而<code>b</code>的值<code>32768</code>则是存在常量池中的</p>
</blockquote>
<p><img src="/2022/08/20/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0%E5%9B%BE%E7%A4%BA.png" alt="运行时常量池图示"></p>
<h3 id="方法字节码载入方法区"><a href="#方法字节码载入方法区" class="headerlink" title="方法字节码载入方法区"></a>方法字节码载入方法区</h3><blockquote>
<p>方法区域中的字节码，会载入到方法区</p>
</blockquote>
<p><img src="/2022/08/20/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD/%E6%96%B9%E6%B3%95%E5%8C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E8%BD%BD%E5%85%A5%E5%9B%BE%E7%A4%BA.png" alt="方法区字节码载入图示"></p>
<h3 id="main-线程开始运行，分配栈帧内存"><a href="#main-线程开始运行，分配栈帧内存" class="headerlink" title="main 线程开始运行，分配栈帧内存"></a>main 线程开始运行，分配栈帧内存</h3><p>(stack=2, locals=4)<br><img src="/2022/08/20/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD/%E4%B8%BB%E7%BA%BF%E7%A8%8B%E5%88%86%E9%85%8D%E6%A0%88%E5%B8%A7%E5%86%85%E5%AD%98%E5%9B%BE%E7%A4%BA.png" alt="主线程分配栈帧内存图示"></p>
<h3 id="执行引擎开始执行字节码"><a href="#执行引擎开始执行字节码" class="headerlink" title="执行引擎开始执行字节码"></a>执行引擎开始执行字节码</h3><h4 id="bipush-10"><a href="#bipush-10" class="headerlink" title="bipush 10"></a>bipush 10</h4><ul>
<li>将一个<code>byte</code>压入操作数栈（操作数栈宽度是4，<code>byte</code>是1，不足的部分会补足），类似的指令还有<ul>
<li><code>sipush</code> 将一个<code>short</code> 压入操作数栈，（长度会补足4个字节）</li>
<li><code>ldc</code> 将一个<code>int</code> 压入操作数栈</li>
<li><code>ldc2_w</code> 将一个<code>long</code>压入操作数栈，（<code>long</code>为8字节，操作数栈4字节，会分两次压）</li>
<li>这里小的数字都是和字节码指令存在一起，超过<code>short</code>范围的数字存入了常量池 </li>
</ul>
</li>
</ul>
<p><img src="/2022/08/20/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD/java%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E5%9B%BE%E7%A4%BA1.png" alt="java代码运行图示1"></p>
<h4 id="istore-1"><a href="#istore-1" class="headerlink" title="istore_1"></a>istore_1</h4><ul>
<li>将操作数栈顶数据弹出，存入局部变量表的<code>slot_1</code></li>
</ul>
<p><img src="/2022/08/20/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD/java%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E5%9B%BE%E7%A4%BA2.png" alt="java代码运行图示2"></p>
<ul>
<li>实现给a变量赋值<br><img src="/2022/08/20/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD/java%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E5%9B%BE%E7%A4%BA3.png" alt="java代码运行图示3"></li>
</ul>
<h4 id="ldc-32"><a href="#ldc-32" class="headerlink" title="ldc #32"></a>ldc #32</h4><ul>
<li>从常量池中加载#3项数据到操作数栈</li>
<li><strong>注意</strong> <code>short.MAX_VALUE</code> 是 <code>32767</code>，所以<code>32768=Short.MAX_VALUE + 1</code>实际是在编译期间计算好的</li>
</ul>
<p><img src="/2022/08/20/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD/java%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E5%9B%BE%E7%A4%BA4.png" alt="java代码运行图示4"></p>
<h4 id="istore-2"><a href="#istore-2" class="headerlink" title="istore_2"></a>istore_2</h4><ul>
<li>将操作数栈顶数据弹出，放入局部变量表<code>slot_2</code><br><img src="/2022/08/20/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD/java%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E5%9B%BE%E7%A4%BA5.png" alt="java代码运行图示5"></li>
<li>数据读取之后入图所示：<br><img src="/2022/08/20/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD/java%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E5%9B%BE%E7%A4%BA6.png" alt="java代码运行图示6"><h4 id="iload-1"><a href="#iload-1" class="headerlink" title="iload_1"></a>iload_1</h4></li>
<li>将局部变量表中1位置的变量读取到操作数栈<br><img src="/2022/08/20/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD/java%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E5%9B%BE%E7%A4%BA7.png" alt="java代码运行图示7"></li>
</ul>
<h4 id="iload-2"><a href="#iload-2" class="headerlink" title="iload_2"></a>iload_2</h4><ul>
<li>将局部变量表中2位置的变量读取到操作数栈<br><img src="/2022/08/20/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD/java%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E5%9B%BE%E7%A4%BA8.png" alt="java代码运行图示8"></li>
</ul>
<h4 id="iadd"><a href="#iadd" class="headerlink" title="iadd"></a>iadd</h4><ul>
<li>  将栈顶两int类型整数相加，结果入栈<br><img src="/2022/08/20/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD/java%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E5%9B%BE%E7%A4%BA9.png" alt="java代码运行图示9"></li>
</ul>
<p><img src="/2022/08/20/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD/java%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E5%9B%BE%E7%A4%BA10.png" alt="java代码运行图示10"></p>
<h4 id="istore-3"><a href="#istore-3" class="headerlink" title="istore_3"></a>istore_3</h4><ul>
<li>将操作数栈中的数据取出来存到局部变量表3的位置<br><img src="/2022/08/20/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD/java%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E5%9B%BE%E7%A4%BA11.png" alt="java代码运行图示11"></li>
<li>执行之后：<br><img src="/2022/08/20/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD/java%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E5%9B%BE%E7%A4%BA12.png" alt="java代码运行图示12"></li>
</ul>
<h4 id="getstatic-4"><a href="#getstatic-4" class="headerlink" title="getstatic #4"></a>getstatic #4</h4><ul>
<li>从常量池中找到对应类型，然后从堆中找到该类型的对象（或者创建对象），然后将引用放入操作数栈</li>
</ul>
<p><img src="/2022/08/20/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD/java%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E5%9B%BE%E7%A4%BA13.png" alt="java代码运行图示13"></p>
<ul>
<li>注意：放入操作数栈的并不是对象，而是对象的引用<br><img src="/2022/08/20/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD/java%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E5%9B%BE%E7%A4%BA14.png" alt="java代码运行图示14"></li>
</ul>
<h4 id="iload-3"><a href="#iload-3" class="headerlink" title="iload_3"></a>iload_3</h4><ul>
<li>将局部变量表3号位置的数据放入操作数栈<br><img src="/2022/08/20/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD/java%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E5%9B%BE%E7%A4%BA15.png" alt="java代码运行图示15"></li>
</ul>
<p><img src="/2022/08/20/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD/java%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E5%9B%BE%E7%A4%BA16.png" alt="java代码运行图示16"></p>
<h4 id="invokevirtual-5"><a href="#invokevirtual-5" class="headerlink" title="invokevirtual #5"></a>invokevirtual #5</h4><ul>
<li>找到常量池中#5项</li>
<li>定位到方法区 【java/io/PrintStream.println:(I)V】 方法</li>
<li>生成新的栈帧，（分配<code>locals</code>，<code>stack</code>等）</li>
<li>传递参数，执行新栈帧中的字节码<br><img src="/2022/08/20/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD/java%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E5%9B%BE%E7%A4%BA17.png" alt="java代码运行图示17"></li>
<li>执行完毕，弹出栈帧</li>
<li>清除main操作数栈内容<br><img src="/2022/08/20/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD/java%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E5%9B%BE%E7%A4%BA18.png" alt="java代码运行图示18"></li>
</ul>
<h4 id="return"><a href="#return" class="headerlink" title="return"></a>return</h4><ul>
<li>完成main方法调用，弹出main栈帧</li>
<li>程序结束</li>
</ul>
<h2 id="练习-分析-i"><a href="#练习-分析-i" class="headerlink" title="练习-分析 i++"></a>练习-分析 i++</h2><p>目的：从字节码角度分析 <code>a++</code> 相关题目<br>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 从字节码角度分析  a++ 相关题目  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;  </span><br><span class="line">        <span class="keyword">int</span> b = a++ + ++ a + a--;  </span><br><span class="line">        System.out.println(a);  </span><br><span class="line">        System.out.println(b);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Classfile /E:/project/java/demo2/src/main/java/com/example/demo1/test/com/example/demo1/test/com/example/demo1/test/com/example/demo1/test/Test2.class</span><br><span class="line">  Last modified <span class="number">2022</span>-<span class="number">8</span>-<span class="number">21</span>; size <span class="number">500</span> bytes</span><br><span class="line">  MD5 checksum 540a55d259f5e8971e2576618da6c5b7</span><br><span class="line">  Compiled from <span class="string">&quot;Test2.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">example</span>.<span class="title">demo1</span>.<span class="title">test</span>.<span class="title">com</span>.<span class="title">example</span>.<span class="title">demo1</span>.<span class="title">test</span>.<span class="title">Test2</span></span></span><br><span class="line"><span class="class">  <span class="title">minor</span> <span class="title">version</span>: 0</span></span><br><span class="line"><span class="class">  <span class="title">major</span> <span class="title">version</span>: 52</span></span><br><span class="line"><span class="class">  <span class="title">flags</span>: <span class="title">ACC_PUBLIC</span>, <span class="title">ACC_SUPER</span></span></span><br><span class="line"><span class="class"><span class="title">Constant</span> <span class="title">pool</span>:</span></span><br><span class="line"><span class="class">   #1 </span>= Methodref          #<span class="number">5.</span>#<span class="number">16</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Fieldref           #<span class="number">17.</span>#<span class="number">18</span>        <span class="comment">// java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">   #<span class="number">3</span> = Methodref          #<span class="number">19.</span>#<span class="number">20</span>        <span class="comment">// java/io/PrintStream.println:(I)V</span></span><br><span class="line">   #<span class="number">4</span> = Class              #<span class="number">21</span>            <span class="comment">// com/example/demo1/test/com/example/demo1/test/Test2</span></span><br><span class="line">   #<span class="number">5</span> = Class              #<span class="number">22</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">   #<span class="number">6</span> = Utf8               &lt;init&gt;</span><br><span class="line">   #<span class="number">7</span> = Utf8               ()V</span><br><span class="line">   #<span class="number">8</span> = Utf8               Code</span><br><span class="line">   #<span class="number">9</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">10</span> = Utf8               main</span><br><span class="line">  #<span class="number">11</span> = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #<span class="number">12</span> = Utf8               MethodParameters</span><br><span class="line">  #<span class="number">13</span> = Utf8               args</span><br><span class="line">  #<span class="number">14</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">15</span> = Utf8               Test2.java</span><br><span class="line">  #<span class="number">16</span> = NameAndType        #<span class="number">6</span>:#<span class="number">7</span>          <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">17</span> = Class              #<span class="number">23</span>            <span class="comment">// java/lang/System</span></span><br><span class="line">  #<span class="number">18</span> = NameAndType        #<span class="number">24</span>:#<span class="number">25</span>        <span class="comment">// out:Ljava/io/PrintStream;</span></span><br><span class="line">  #<span class="number">19</span> = Class              #<span class="number">26</span>            <span class="comment">// java/io/PrintStream</span></span><br><span class="line">  #<span class="number">20</span> = NameAndType        #<span class="number">27</span>:#<span class="number">28</span>        <span class="comment">// println:(I)V</span></span><br><span class="line">  #<span class="number">21</span> = Utf8               com/example/demo1/test/com/example/demo1/test/Test2</span><br><span class="line">  #<span class="number">22</span> = Utf8               java/lang/Object</span><br><span class="line">  #<span class="number">23</span> = Utf8               java/lang/System</span><br><span class="line">  #<span class="number">24</span> = Utf8               out</span><br><span class="line">  #<span class="number">25</span> = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #<span class="number">26</span> = Utf8               java/io/PrintStream</span><br><span class="line">  #<span class="number">27</span> = Utf8               println</span><br><span class="line">  #<span class="number">28</span> = Utf8               (I)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> com.example.demo1.test.com.example.demo1.test.Test2();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">11</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: bipush        <span class="number">10</span></span><br><span class="line">         <span class="number">2</span>: istore_1</span><br><span class="line">         <span class="number">3</span>: iload_1</span><br><span class="line">         <span class="number">4</span>: iinc          <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">         <span class="number">7</span>: iinc          <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="number">10</span>: iload_1</span><br><span class="line">        <span class="number">11</span>: iadd</span><br><span class="line">        <span class="number">12</span>: iload_1</span><br><span class="line">        <span class="number">13</span>: iinc          <span class="number">1</span>, -<span class="number">1</span></span><br><span class="line">        <span class="number">16</span>: iadd</span><br><span class="line">        <span class="number">17</span>: istore_2</span><br><span class="line">        <span class="number">18</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">        <span class="number">21</span>: iload_1</span><br><span class="line">        <span class="number">22</span>: invokevirtual #<span class="number">3</span>                  <span class="comment">// Method java/io/PrintStream.println:(I)V</span></span><br><span class="line">        <span class="number">25</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">        <span class="number">28</span>: iload_2</span><br><span class="line">        <span class="number">29</span>: invokevirtual #<span class="number">3</span>                  <span class="comment">// Method java/io/PrintStream.println:(I)V</span></span><br><span class="line">        <span class="number">32</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">13</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">14</span>: <span class="number">3</span></span><br><span class="line">        line <span class="number">15</span>: <span class="number">18</span></span><br><span class="line">        line <span class="number">16</span>: <span class="number">25</span></span><br><span class="line">        line <span class="number">17</span>: <span class="number">32</span></span><br><span class="line">    MethodParameters:</span><br><span class="line">      Name                           Flags</span><br><span class="line">      args</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;Test2.java&quot;</span></span><br></pre></td></tr></table></figure>

<p>分析：</p>
<ul>
<li>注意 <code>iinc</code> 指令是直接在局部变量<code>slot</code>上进行运算</li>
<li><code>a++</code> 和 <code>++a</code> 的区别是先执行<code>iload</code>还是先执行<code>iinc</code><ul>
<li><code>a++</code> 先执行<code> iload</code>，然后再<code>iinc</code>自增</li>
<li><code>++a</code> 先执行<code>iinc</code>自增，再执行<code>iload</code></li>
</ul>
</li>
</ul>
<h3 id="bipush-10-1"><a href="#bipush-10-1" class="headerlink" title="bipush 10"></a>bipush 10</h3><ul>
<li>把10先放到操作数栈<br><img src="/2022/08/20/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD/%E5%88%86%E6%9E%90%E5%9B%BE%E7%A4%BA1.png"></li>
</ul>
<h3 id="istore-1-1"><a href="#istore-1-1" class="headerlink" title="istore_1"></a>istore_1</h3><ul>
<li>把操作数栈中栈顶的数据弹出，存到局部变量表一号桶位<br><img src="/2022/08/20/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD/%E5%88%86%E6%9E%90%E5%9B%BE%E7%A4%BA2.png"></li>
</ul>
<h3 id="iload-1-1"><a href="#iload-1-1" class="headerlink" title="iload_1"></a>iload_1</h3><ul>
<li>把局部变量表一号槽位中的数据读取到操作数栈<br><img src="/2022/08/20/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD/%E5%88%86%E6%9E%90%E5%9B%BE%E7%A4%BA3.png"></li>
</ul>
<h3 id="iinc-1-1"><a href="#iinc-1-1" class="headerlink" title="iinc 1,1"></a>iinc 1,1</h3><ul>
<li>执行 <code>a++</code></li>
<li>局部变量表一号槽位数据自增1</li>
<li>前面的1表示局部变量表的槽位，后面的1表示自增1</li>
<li>该操作直接在局部变量表中完成，并不会影响操作数栈中的数据<br><img src="/2022/08/20/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD/%E5%88%86%E6%9E%90%E5%9B%BE%E7%A4%BA4.png"></li>
</ul>
<h3 id="iinc-1-1-1"><a href="#iinc-1-1-1" class="headerlink" title="iinc 1,1"></a>iinc 1,1</h3><ul>
<li>执行<code>++a</code></li>
<li>局部变量表一号槽位自增1（不会影响到操作数栈）<br><img src="/2022/08/20/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD/%E5%88%86%E6%9E%90%E5%9B%BE%E7%A4%BA5.png"></li>
</ul>
<h3 id="iload-1-2"><a href="#iload-1-2" class="headerlink" title="iload_1"></a>iload_1</h3><ul>
<li>把局部变量表一号槽位的数据加载到操作数栈（12加载到操作数栈）<br><img src="/2022/08/20/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD/%E5%88%86%E6%9E%90%E5%9B%BE%E7%A4%BA6.png"></li>
</ul>
<h3 id="iadd-1"><a href="#iadd-1" class="headerlink" title="iadd"></a>iadd</h3><ul>
<li>将栈顶两int类型整数相加，结果入栈<br><img src="/2022/08/20/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-20220826210747224.png"></li>
</ul>
<h3 id="iload-1-3"><a href="#iload-1-3" class="headerlink" title="iload_1"></a>iload_1</h3><ul>
<li><code>a--</code> 先<code>iload</code>再<code>iinc</code></li>
<li>先将12放入操作数栈<br><img src="/2022/08/20/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-20220826211136301.png"></li>
</ul>
<h3 id="iinc-1-1-2"><a href="#iinc-1-1-2" class="headerlink" title="iinc 1,-1"></a>iinc 1,-1</h3><ul>
<li>执行 <code>a--</code></li>
<li>局部变量表一号槽位增加-1，也就是减1<br><img src="/2022/08/20/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-20220826211226285.png"><h3 id="iadd-2"><a href="#iadd-2" class="headerlink" title="iadd"></a>iadd</h3></li>
<li> 将栈顶两int类型整数相加，结果入栈<br><img src="/2022/08/20/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-20220826211519082.png"></li>
</ul>
<h3 id="istore-2-1"><a href="#istore-2-1" class="headerlink" title="istore_2"></a>istore_2</h3><ul>
<li>把操作数栈顶的数据弹出到局部变了表2号槽位<br><img src="/2022/08/20/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-20220826211549138.png"></li>
</ul>
<h2 id="条件判断指令"><a href="#条件判断指令" class="headerlink" title="条件判断指令"></a>条件判断指令</h2><p>详情见《Java字节码指令大全》&lt;1.11  控制流指令——条件跳转指令&gt;<br><a href="https://ysymj.gitee.io/2021/11/16/java%E5%9F%BA%E7%A1%80/Java%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E5%A4%A7%E5%85%A8/">Java字节码指令大全 | YS (gitee.io)</a></p>
<p><font color="red">说明:</font></p>
<ul>
<li>byte、short、char都会按 int 比较，因为操作数栈是4个字节</li>
<li>goto用来跳转到指定行号的字节码</li>
</ul>
<h3 id="循环控制指令"><a href="#循环控制指令" class="headerlink" title="循环控制指令"></a>循环控制指令</h3><ul>
<li>其实循环也是依靠上面的判断指令完成的<br>源码： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">int</span> a = <span class="number">0</span>;  </span><br><span class="line">      <span class="keyword">while</span> (a &lt; <span class="number">10</span>)&#123;  </span><br><span class="line">          a++;  </span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>编译后的字节码如下：<br>iconst_0 准备一个0值入栈<br>istore_1 将操作数栈顶的数据，也就是刚刚的0值，存放到局部变量表1号位<br>iload_1 将局部变量表1号位，也就是刚刚的0值存入操作数栈<br>bipush 准备一个数字10入栈<br>if_icmpge 若栈顶两int类型值前大于等于后则跳转，也就说0所代表的变量大于等于10的时候，可以跳转到第14行字节码<br>iinc 局部变量表1号位自增1，也就是0值的位置，现在为1<br>goto 跳转到第2行字节码执行<br>然后会继续循环判断<br>以此实现循环，当满足条件的时候就会跳转到14行return</p>
</blockquote>
</li>
</ul>
<p>字节码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>: iconst_0</span><br><span class="line"><span class="number">1</span>: istore_1</span><br><span class="line"><span class="number">2</span>: iload_1</span><br><span class="line"><span class="number">3</span>: bipush        <span class="number">10</span></span><br><span class="line"><span class="number">5</span>: if_icmpge     <span class="number">14</span></span><br><span class="line"><span class="number">8</span>: iinc          <span class="number">1</span>, <span class="number">1</span></span><br><span class="line"><span class="number">11</span>: goto          <span class="number">2</span></span><br><span class="line"><span class="number">14</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><h3 id="lt-cinit-gt-V"><a href="#lt-cinit-gt-V" class="headerlink" title="&lt;cinit&gt;()V"></a>&lt;cinit&gt;()V</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">10</span>;  </span><br><span class="line">    <span class="keyword">static</span> &#123;  </span><br><span class="line">        a = <span class="number">20</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">static</span> &#123;  </span><br><span class="line">        a = <span class="number">30</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态变量的赋值操作和静态代码块的内容，最终会被合并成一个操作<br>编译器会按从上向下的顺序，收集所有static几台代码块和静态成员赋值的代码，合并为一个特殊的方法<br><code>&lt;cinit&gt;()V</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>: bipush        <span class="number">10</span></span><br><span class="line"><span class="number">2</span>: putstatic     #<span class="number">2</span>                  <span class="comment">// Field a:I</span></span><br><span class="line"><span class="number">5</span>: bipush        <span class="number">20</span></span><br><span class="line"><span class="number">7</span>: putstatic     #<span class="number">2</span>                  <span class="comment">// Field a:I</span></span><br><span class="line"><span class="number">10</span>: bipush        <span class="number">30</span></span><br><span class="line"><span class="number">12</span>: putstatic     #<span class="number">2</span>                  <span class="comment">// Field a:I</span></span><br><span class="line"><span class="number">15</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p><code>&lt;cinit&gt;()V</code> 方法会在类加载的初始化阶段被调用</p>
<h3 id="lt-init-gt-V"><a href="#lt-init-gt-V" class="headerlink" title="&lt;init&gt;()V"></a>&lt;init&gt;()V</h3><p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String a = <span class="string">&quot;S1&quot;</span>;  </span><br><span class="line">    &#123;  </span><br><span class="line">        b = <span class="number">20</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b = <span class="number">10</span>;  </span><br><span class="line">    &#123;  </span><br><span class="line">        a = <span class="string">&quot;S2&quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test3</span><span class="params">(String a, <span class="keyword">int</span> b)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.a = a;  </span><br><span class="line">        <span class="keyword">this</span>.b = b;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        Test3 test3 = <span class="keyword">new</span> Test3(<span class="string">&quot;S3&quot;</span>,<span class="number">30</span>);  </span><br><span class="line">        System.out.println(test3.a);  </span><br><span class="line">        System.out.println(test3.b);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>编译器会按从上到下的顺序，收集所有<code>&#123;&#125;</code>代码块和成员变量赋值的代码，形成新的构造方法，但原始构造方法内的代码总是在最后面<br>先调用父类<code>Object</code>类的<code>&lt;init&gt;</code>方法<br>然后给<code>this.a</code>赋值<code>S1</code><br>然后给<code>this.b</code>赋值为<code>20</code>（并不是先赋值初始化的<code>10</code>，而是处于上面的代码块的<code>20</code>）<br>然后给<code>this.b</code>赋值为<code>10</code><br>给<code>this.a</code>赋值为<code>S2</code><br>然后下面的是原本构造方法里面的代码<br>将局部变量表1号位的数据赋值给<code>this.a</code><br>将局部变量表2号位的数据赋值给<code>this.b</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> com.example.demo1.test1.Test3(java.lang.String, <span class="keyword">int</span>);</span><br><span class="line">   descriptor: (Ljava/lang/String;I)V</span><br><span class="line">   flags: ACC_PUBLIC</span><br><span class="line">   Code:</span><br><span class="line">     stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">3</span></span><br><span class="line">        <span class="number">0</span>: aload_0</span><br><span class="line">        <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">        <span class="number">4</span>: aload_0</span><br><span class="line">        <span class="number">5</span>: ldc           #<span class="number">2</span>                  <span class="comment">// String S1</span></span><br><span class="line">        <span class="number">7</span>: putfield      #<span class="number">3</span>                  <span class="comment">// Field a:Ljava/lang/String;</span></span><br><span class="line">       <span class="number">10</span>: aload_0</span><br><span class="line">       <span class="number">11</span>: bipush        <span class="number">20</span></span><br><span class="line">       <span class="number">13</span>: putfield      #<span class="number">4</span>                  <span class="comment">// Field b:I</span></span><br><span class="line">       <span class="number">16</span>: aload_0</span><br><span class="line">       <span class="number">17</span>: bipush        <span class="number">10</span></span><br><span class="line">       <span class="number">19</span>: putfield      #<span class="number">4</span>                  <span class="comment">// Field b:I</span></span><br><span class="line">       <span class="number">22</span>: aload_0</span><br><span class="line">       <span class="number">23</span>: ldc           #<span class="number">5</span>                  <span class="comment">// String S2</span></span><br><span class="line">       <span class="number">25</span>: putfield      #<span class="number">3</span>                  <span class="comment">// Field a:Ljava/lang/String;</span></span><br><span class="line">       <span class="number">28</span>: aload_0       <span class="comment">//---------------------------------------------------</span></span><br><span class="line">       <span class="number">29</span>: aload_1</span><br><span class="line">       <span class="number">30</span>: putfield      #<span class="number">3</span>                  <span class="comment">// Field a:Ljava/lang/String;</span></span><br><span class="line">       <span class="number">33</span>: aload_0</span><br><span class="line">       <span class="number">34</span>: iload_2</span><br><span class="line">       <span class="number">35</span>: putfield      #<span class="number">4</span>                  <span class="comment">// Field b:I</span></span><br><span class="line">       <span class="number">38</span>: <span class="keyword">return</span></span><br><span class="line">     LineNumberTable:</span><br><span class="line">       line <span class="number">17</span>: <span class="number">0</span></span><br><span class="line">       line <span class="number">8</span>: <span class="number">4</span></span><br><span class="line">       line <span class="number">10</span>: <span class="number">10</span></span><br><span class="line">       line <span class="number">12</span>: <span class="number">16</span></span><br><span class="line">       line <span class="number">14</span>: <span class="number">22</span></span><br><span class="line">       line <span class="number">18</span>: <span class="number">28</span></span><br><span class="line">       line <span class="number">19</span>: <span class="number">33</span></span><br><span class="line">       line <span class="number">20</span>: <span class="number">38</span></span><br><span class="line">   MethodParameters:</span><br><span class="line">     Name                           Flags</span><br><span class="line">     a</span><br><span class="line">     b</span><br></pre></td></tr></table></figure>

<h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test4</span><span class="params">()</span> </span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        Test4 t = <span class="keyword">new</span> Test4();<span class="comment">//调用构造方法  </span></span><br><span class="line">        t.test1();<span class="comment">//调用私有普通方法  </span></span><br><span class="line">        t.test2();<span class="comment">//调用final方法  </span></span><br><span class="line">        t.test3();<span class="comment">//调用公有普通方法  </span></span><br><span class="line">        t.test4();<span class="comment">//通过对象调用静态方法  </span></span><br><span class="line">        Test4.test4();<span class="comment">//通过类名调用静态方法  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过字节码可以看出，调用<code>构造方法</code>和<code>私有普通方法</code>以及<code>final方法</code>，都是使用的<code>invokespecial</code>指令<br>调用<code>普通公共方法</code>使用的是<code>invokevirtual</code>指令<br>调用<code>静态方法</code>使用的是<code>invokestatic</code>指令</p>
<blockquote>
<p><code>invokespecial</code>：编译时方法绑定调用方法<br><code>invokestatic</code>：调用静态方法<br><code>invokevirtual</code>：运行时方法绑定调用方法<br><code> invokespecial</code>和<code>invokestatic</code>属于静态绑定，在字节码生成的时候，就已经知道需要找到那个类的那个方法了，性能相比之下会更高一点<br><code>invokevirtual</code>并不能在生成字节码的时候就知道调用的是那个类的，因为java多态的原因，方法可能会被重写，有可能调用的是父类的方法，也可能调用的是子类额方法</p>
</blockquote>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  <span class="comment">// class com/example/demo1/test1/Test4</span></span><br><span class="line"><span class="number">3</span>: dup</span><br><span class="line"><span class="number">4</span>: invokespecial #<span class="number">3</span>                  <span class="comment">// Method &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line"><span class="number">7</span>: astore_1</span><br><span class="line"><span class="number">8</span>: aload_1</span><br><span class="line"><span class="number">9</span>: invokespecial #<span class="number">4</span>                  <span class="comment">// Method test1:()V</span></span><br><span class="line"><span class="number">12</span>: aload_1</span><br><span class="line"><span class="number">13</span>: invokespecial #<span class="number">5</span>                  <span class="comment">// Method test2:()V</span></span><br><span class="line"><span class="number">16</span>: aload_1</span><br><span class="line"><span class="number">17</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method test3:()V</span></span><br><span class="line"><span class="number">20</span>: aload_1</span><br><span class="line"> <span class="number">21</span>: pop</span><br><span class="line"><span class="number">22</span>: invokestatic  #<span class="number">7</span>                  <span class="comment">// Method test4:()V</span></span><br><span class="line"><span class="number">25</span>: invokestatic  #<span class="number">7</span>                  <span class="comment">// Method test4:()V </span></span><br><span class="line"><span class="number">28</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<h2 id="多态的原理"><a href="#多态的原理" class="headerlink" title="多态的原理"></a>多态的原理</h2><blockquote>
<p>示例代码如下，内容很简单<br>创建一个<code>Animal</code>的抽象类，他有两个子类实现了他的抽象方法<code>eat()</code><br>之后在<code>test()</code>方法中以父类去调用<code>eat()</code>，<code>main()</code>方法中传入不同的实现</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 演示多态原理，注意加上下面的 JVM 参数，禁止指针压缩  </span></span><br><span class="line"><span class="comment"> * -XX:-UseCompressedOops -XX:UseCompressedClassPointers  </span></span><br><span class="line"><span class="comment"> */</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test5</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Animal animal)</span></span>&#123;  </span><br><span class="line">        animal.eat();  </span><br><span class="line">        System.out.println(animal.toString());  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">        test(<span class="keyword">new</span> Dog());  </span><br><span class="line">        test(<span class="keyword">new</span> Cat());  </span><br><span class="line">        System.in.read();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我是&quot;</span>+<span class="keyword">this</span>.getClass().getSimpleName();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;啃骨头&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;吃鱼&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul>
<li>在方法启动的时候需要添加以下参数，禁止虚拟机自动压缩指针<ul>
<li><code>-XX:-UseCompressedOops -XX:-UseCompressedClassPointers </code></li>
</ul>
</li>
<li>使用<code>System.in.read();</code>暂停程序，然后使用<code>jps</code>命令获取进程id</li>
<li>运行HSDB工具<ul>
<li>进入JDK安装目录，执行下面的命令：</li>
<li><code>java -cp ./lib/sa-jdi.jar sun.jvm.hotspot.HSDB</code></li>
<li>进入图形界面输入程序的进程id</li>
</ul>
</li>
<li>打开图形界面，点击file再点击<code>Attach to HotSpot...</code>，之后输入进程id，就会连上当前进程</li>
<li>然后点击<code>Tools</code>，再点击<code>Find Object by Query</code>，之后输入查询语句，类似于sql语句<ul>
<li><code>select + 别名 + from + 需要查询的类的全限定名 + 别名</code></li>
<li>如：<code>select d from com.example.demo1.test1.Dog d</code><br><img src="/2022/08/20/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-20220827200010149.png"></li>
</ul>
</li>
<li>如下图所示，可以在<code>Inspector</code>框里面查看对象的相关信息，不过这些并不是对象的真正信息</li>
<li>点击标记1处，会弹出标记2处的框，然后使用mem指令查看对象头信息的地址信息</li>
<li><code>mem</code>命令后面跟随的是标记3处的地址信息，后面的2表示要查看几个mark word<br><img src="/2022/08/20/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-20220827201110213.png"></li>
<li>在标记1处敲击回车，就会显示出类型的指针</li>
<li>然后再在<code>Tools</code>处打开一个<code>Inspector</code>框，使用刚刚查出来的类型指针查询</li>
<li>如标记2处，就是对象在虚拟机中完整的类型表示<br><img src="/2022/08/20/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-20220827201623999.png"></li>
<li>类的多态方法都存在一个<code>vtable</code>表中，也就是最后一行箭头所指的位置</li>
<li><code>vtable</code>的和当前类型指针的偏移量是<code>1b8</code>，所以只需要以16进制将当前指针地址加上<code>1b8</code>就可以得到<code>vtable</code>的地址<ul>
<li><code>0x000000001c7c3ca0 + 1b8 = 0x000000001c7c3e58</code></li>
</ul>
</li>
<li>下面就是执行<code>mem</code>指令，从上面第二张图可以看到<code>vtable_len=6</code>，所以查6个mark<ul>
<li><code>eme 0x000000001c7c3e58 6</code><br><img src="/2022/08/20/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-20220827202159236.png"></li>
</ul>
</li>
<li>如图所示，查询出对应的work，一共有六个，<code>Dog</code>类对应的多态方法</li>
<li>可以通过<code>Class Browser</code>查询<code>Dog</code>类，对应一下这六个方法</li>
<li>从图中可以看出，<code>0x000000001c453c48</code> 对应的是<code>cat()</code>方法<br><img src="/2022/08/20/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-20220827220420879.png"></li>
<li>如图所示，<code>0x000000001c453768</code> 对应的是<code>Dog</code>类的父类<code>Animal</code>类的<code>toString()</code>方法</li>
<li><code> toString()</code>方法也是一个多态方法，只不过<code>Dog</code>并没有重写这个方法，所以使用的是父类的方法<br><img src="/2022/08/20/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-20220827220754264.png"></li>
<li>剩下的四个方法均来自<code>Animal</code>的父类<code>Object</code>，对应关系如下图所示</li>
<li><code>finalize()</code>：该方法并没有在<code>Animal</code>和<code>Dog</code>类中重写，所以使用的是所有类的超类<code>Object</code>类的</li>
<li><code>equals()</code>：该方法同样没有重写，使用的也是<code>Object</code>中的</li>
<li><code> hashCode()</code>：同样使用的是<code>Object</code>中的</li>
<li><code> clone()</code>：同样使用的是<code>Object</code>中的<br><img src="/2022/08/20/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-20220827221154955.png"></li>
<li>虚方法表是在类加载链接阶段就会诞生的，所以就是说在类链接阶段，就已经配置好了每个方法需要调用的具体实现</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>执行<code>invokevirtual</code>指令时</p>
<ul>
<li>先通过栈帧中的对象引用找到对象</li>
<li>分析对象头，找到对象的实际 <code>Class</code></li>
<li><code>Class</code> 结构中有 <code>vtable</code>，它在类加载的<code>链接阶段</code>就已经根据方法的重写规划生成好了</li>
<li>查表的到方法的具体地址</li>
<li>执行方法中的字节码</li>
</ul>
<h2 id="异常梳理"><a href="#异常梳理" class="headerlink" title="异常梳理"></a>异常梳理</h2><h3 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test6</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            a = <span class="number">10</span>;  </span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;  </span><br><span class="line">            a = <span class="number">20</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从下面的字节码中可以看出：</p>
<blockquote>
<p>0值入栈，然后放入局部变量表中，然后数值10入栈，然后赋值给局部变量表1号位，然后<code>goto</code>到12行<br>如果没有异常，那么执行到5行后就会跳转到12行结束</p>
</blockquote>
<p>不过可以看出，多出来了一个<code>Exception table</code>的结构，<code>[from，to)</code>是前闭后开的检测范围，一旦这个范围内的字节码执行出现了异常，则通过<code>type</code>匹配异常类型，如果一致则进入<code>target</code>所指示的行号<br>8行的字节码指令<code>astore_2</code>是将异常对象引用存入局部变量表的2号位</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">  descriptor: ([Ljava/lang/String;)V</span><br><span class="line">  flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">1</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">       <span class="number">0</span>: iconst_0</span><br><span class="line">       <span class="number">1</span>: istore_1</span><br><span class="line">       <span class="number">2</span>: bipush        <span class="number">10</span></span><br><span class="line">       <span class="number">4</span>: istore_1</span><br><span class="line">       <span class="number">5</span>: goto          <span class="number">12</span></span><br><span class="line">       <span class="number">8</span>: astore_2</span><br><span class="line">       <span class="number">9</span>: bipush        <span class="number">20</span></span><br><span class="line">      <span class="number">11</span>: istore_1</span><br><span class="line">      <span class="number">12</span>: <span class="keyword">return</span></span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           <span class="number">2</span>     <span class="number">5</span>     <span class="number">8</span>   Class java/lang/Exception</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">9</span>: <span class="number">0</span></span><br><span class="line">      line <span class="number">11</span>: <span class="number">2</span></span><br><span class="line">      line <span class="number">14</span>: <span class="number">5</span></span><br><span class="line">      line <span class="number">12</span>: <span class="number">8</span></span><br><span class="line">      line <span class="number">13</span>: <span class="number">9</span></span><br><span class="line">      line <span class="number">15</span>: <span class="number">12</span></span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          <span class="number">9</span>       <span class="number">3</span>     <span class="number">2</span>     e   Ljava/lang/Exception;</span><br><span class="line">          <span class="number">0</span>      <span class="number">13</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">          <span class="number">2</span>      <span class="number">11</span>     <span class="number">1</span>     a   I</span><br><span class="line">    StackMapTable: number_of_entries = <span class="number">2</span></span><br><span class="line">      frame_type = <span class="number">255</span> <span class="comment">/* full_frame */</span></span><br><span class="line">        offset_delta = <span class="number">8</span></span><br><span class="line">        locals = [ <span class="class"><span class="keyword">class</span> &quot;[<span class="title">Ljava</span>/<span class="title">lang</span>/<span class="title">String</span></span>;<span class="string">&quot;, int ]</span></span><br><span class="line"><span class="string">        stack = [ class java/lang/Exception ]</span></span><br><span class="line"><span class="string">      frame_type = 3 /* same */</span></span><br><span class="line"><span class="string">  MethodParameters:</span></span><br><span class="line"><span class="string">    Name                           Flags</span></span><br><span class="line"><span class="string">    args</span></span><br></pre></td></tr></table></figure>

<h3 id="多个catch块的情况-single-catch"><a href="#多个catch块的情况-single-catch" class="headerlink" title="多个catch块的情况(single-catch)"></a>多个catch块的情况(single-catch)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test7</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            a = <span class="number">10</span>;  </span><br><span class="line">        &#125;<span class="keyword">catch</span> (ArithmeticException e)&#123;  </span><br><span class="line">            a = <span class="number">30</span>;  </span><br><span class="line">        &#125;<span class="keyword">catch</span> (NullPointerException e)&#123;  </span><br><span class="line">            a = <span class="number">40</span>;  </span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;  </span><br><span class="line">            a = <span class="number">50</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从编译出的字节码中可以看出，多个<code>catch</code>一样都是监控的第2到5行字节码（不包含5）<br>区别在于后面的<code>type</code>，会根据<code>type</code>匹配到不同的异常之后，进行不同的跳转行（根据target判断跳转到哪一行）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">  descriptor: ([Ljava/lang/String;)V</span><br><span class="line">  flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">1</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">       <span class="number">0</span>: iconst_0</span><br><span class="line">       <span class="number">1</span>: istore_1</span><br><span class="line">       <span class="number">2</span>: bipush        <span class="number">10</span></span><br><span class="line">       <span class="number">4</span>: istore_1</span><br><span class="line">       <span class="number">5</span>: goto          <span class="number">26</span></span><br><span class="line">       <span class="number">8</span>: astore_2</span><br><span class="line">       <span class="number">9</span>: bipush        <span class="number">30</span></span><br><span class="line">      <span class="number">11</span>: istore_1</span><br><span class="line">      <span class="number">12</span>: goto          <span class="number">26</span></span><br><span class="line">      <span class="number">15</span>: astore_2</span><br><span class="line">      <span class="number">16</span>: bipush        <span class="number">40</span></span><br><span class="line">      <span class="number">18</span>: istore_1</span><br><span class="line">      <span class="number">19</span>: goto          <span class="number">26</span></span><br><span class="line">      <span class="number">22</span>: astore_2</span><br><span class="line">      <span class="number">23</span>: bipush        <span class="number">50</span></span><br><span class="line">      <span class="number">25</span>: istore_1</span><br><span class="line">      <span class="number">26</span>: <span class="keyword">return</span></span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           <span class="number">2</span>     <span class="number">5</span>     <span class="number">8</span>   Class java/lang/ArithmeticException</span><br><span class="line">           <span class="number">2</span>     <span class="number">5</span>    <span class="number">15</span>   Class java/lang/NullPointerException</span><br><span class="line">           <span class="number">2</span>     <span class="number">5</span>    <span class="number">22</span>   Class java/lang/Exception</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">9</span>: <span class="number">0</span></span><br><span class="line">      line <span class="number">11</span>: <span class="number">2</span></span><br><span class="line">      line <span class="number">18</span>: <span class="number">5</span></span><br><span class="line">      line <span class="number">12</span>: <span class="number">8</span></span><br><span class="line">      line <span class="number">13</span>: <span class="number">9</span></span><br><span class="line">      line <span class="number">18</span>: <span class="number">12</span></span><br><span class="line">      line <span class="number">14</span>: <span class="number">15</span></span><br><span class="line">      line <span class="number">15</span>: <span class="number">16</span></span><br><span class="line">      line <span class="number">18</span>: <span class="number">19</span></span><br><span class="line">      line <span class="number">16</span>: <span class="number">22</span></span><br><span class="line">      line <span class="number">17</span>: <span class="number">23</span></span><br><span class="line">      line <span class="number">19</span>: <span class="number">26</span></span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          <span class="number">9</span>       <span class="number">3</span>     <span class="number">2</span>     e   Ljava/lang/ArithmeticException;</span><br><span class="line">         <span class="number">16</span>       <span class="number">3</span>     <span class="number">2</span>     e   Ljava/lang/NullPointerException;</span><br><span class="line">      frame_type = <span class="number">70</span> <span class="comment">/* same_locals_1_stack_item */</span></span><br><span class="line">        stack = [ <span class="class"><span class="keyword">class</span> <span class="title">java</span>/<span class="title">lang</span>/<span class="title">Exception</span> ]</span></span><br><span class="line"><span class="class">      <span class="title">frame_type</span> </span>= <span class="number">3</span> <span class="comment">/* same */</span></span><br><span class="line">  MethodParameters:</span><br><span class="line">    Name                           Flags</span><br><span class="line">    args</span><br></pre></td></tr></table></figure>

<h3 id="multi-catch的情况"><a href="#multi-catch的情况" class="headerlink" title="multi-catch的情况"></a>multi-catch的情况</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test8</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            Method test = Test8.class.getMethod(<span class="string">&quot;test&quot;</span>);  </span><br><span class="line">            test.invoke(<span class="keyword">null</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException | NoSuchMethodException | IllegalAccessException e) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;OK&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>编译后的字节码如下所示：<br>三个异常监控的范围都是<code>0-22</code>，然后根据<code>type</code>去进行匹配，如果匹配到了就会跳转到<code>25</code>行<br>和多个<code>catch</code>块的形式唯一的区别就是匹配到异常之后跳转的位置是相同的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">  descriptor: ([Ljava/lang/String;)V</span><br><span class="line">  flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">3</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">       <span class="number">0</span>: ldc           #<span class="number">2</span>                  <span class="comment">// class com/example/demo1/test1/Test8</span></span><br><span class="line">       <span class="number">2</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String test</span></span><br><span class="line">       <span class="number">4</span>: iconst_0</span><br><span class="line">       <span class="number">5</span>: anewarray     #<span class="number">4</span>                  <span class="comment">// class java/lang/Class</span></span><br><span class="line">       <span class="number">8</span>: invokevirtual #<span class="number">5</span>                  <span class="comment">// Method java/lang/Class.getMethod:(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;</span></span><br><span class="line">      <span class="number">11</span>: astore_1</span><br><span class="line">      <span class="number">12</span>: aload_1</span><br><span class="line">      <span class="number">13</span>: aconst_null</span><br><span class="line">      <span class="number">14</span>: iconst_0</span><br><span class="line">      <span class="number">15</span>: anewarray     #<span class="number">6</span>                  <span class="comment">// class java/lang/Object</span></span><br><span class="line">      <span class="number">18</span>: invokevirtual #<span class="number">7</span>                  <span class="comment">// Method java/lang/reflect/Method.invoke:(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;</span></span><br><span class="line">      <span class="number">21</span>: pop</span><br><span class="line">      <span class="number">22</span>: goto          <span class="number">35</span></span><br><span class="line">      <span class="number">25</span>: astore_1</span><br><span class="line">      <span class="number">26</span>: <span class="keyword">new</span>           #<span class="number">11</span>                 <span class="comment">// class java/lang/RuntimeException</span></span><br><span class="line">      <span class="number">29</span>: dup</span><br><span class="line">      <span class="number">30</span>: aload_1</span><br><span class="line">      <span class="number">31</span>: invokespecial #<span class="number">12</span>                 <span class="comment">// Method java/lang/RuntimeException.&quot;&lt;init&gt;&quot;:(Ljava/lang/Throwable;)V</span></span><br><span class="line">      <span class="number">34</span>: athrow</span><br><span class="line">      <span class="number">35</span>: <span class="keyword">return</span></span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           <span class="number">0</span>    <span class="number">22</span>    <span class="number">25</span>   Class java/lang/reflect/InvocationTargetException</span><br><span class="line">           <span class="number">0</span>    <span class="number">22</span>    <span class="number">25</span>   Class java/lang/NoSuchMethodException</span><br><span class="line">           <span class="number">0</span>    <span class="number">22</span>    <span class="number">25</span>   Class java/lang/IllegalAccessException</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">13</span>: <span class="number">0</span></span><br><span class="line">      line <span class="number">14</span>: <span class="number">12</span></span><br><span class="line">      line <span class="number">17</span>: <span class="number">22</span></span><br><span class="line">      line <span class="number">15</span>: <span class="number">25</span></span><br><span class="line">      line <span class="number">16</span>: <span class="number">26</span></span><br><span class="line">      line <span class="number">18</span>: <span class="number">35</span></span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">         <span class="number">12</span>      <span class="number">10</span>     <span class="number">1</span>  test   Ljava/lang/reflect/Method;</span><br><span class="line">       <span class="number">3</span>: ldc           #<span class="number">14</span>                 <span class="comment">// String OK</span></span><br><span class="line">       <span class="number">5</span>: invokevirtual #<span class="number">15</span>                 <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">       <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">20</span>: <span class="number">0</span></span><br><span class="line">      line <span class="number">21</span>: <span class="number">8</span></span><br></pre></td></tr></table></figure>

<h3 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test9</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            a = <span class="number">10</span>;  </span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;  </span><br><span class="line">            a = <span class="number">20</span>;  </span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;  </span><br><span class="line">            a = <span class="number">30</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从下面的字节码中可以看出，<code>finally</code>的代码块其实就是在编译的时候复制到每一个代码块的最后位置<br>如，<code>try</code>，最后两行的字节码就是<code>finally</code>里面的内容<br><code>catch</code>里面的也是一样<br>不过从异常表中可以看出，多了两个<code>any</code>的异常监控，<code>any</code>表示所有异常<br><code>any</code>监控<code>2-5</code>行，则是为了防止有超出<code>Exception</code>的异常发生，比如<code>Exception</code>的父类或者兄弟类<br>监控<code>11-15</code>行，这时为了防止执行<code>Exception</code>的<code>catch</code>块的时候再发生异常<br>通过字节码来控制，保证每一块代码块跳转之前都会执行<code>finally</code>里面的异常，即便是发生了未知的异常，也能够跳转到<code>finally</code>的代码块中执行<br>整个字节码一共有三个分支：</p>
<blockquote>
<p>1.try分支<br>2.catch分支<br>3.catch没有匹配到的异常的分支（最后会把异常再上抛）</p>
</blockquote>
<p>如果在<code>finally</code>中<code>return</code>，将会吞掉代码块中的异常</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">  descriptor: ([Ljava/lang/String;)V</span><br><span class="line">  flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">1</span>, locals=<span class="number">4</span>, args_size=<span class="number">1</span></span><br><span class="line">       <span class="number">0</span>: iconst_0</span><br><span class="line">       <span class="number">1</span>: istore_1             <span class="comment">// 0 -&gt; a</span></span><br><span class="line">       <span class="number">2</span>: bipush        <span class="number">10</span>     <span class="comment">// try ---------------------------</span></span><br><span class="line">       <span class="number">4</span>: istore_1             <span class="comment">// 10 -&gt; a                       |</span></span><br><span class="line">       <span class="number">5</span>: bipush        <span class="number">30</span>     <span class="comment">// finally                       |</span></span><br><span class="line">       <span class="number">7</span>: istore_1             <span class="comment">// 30 -&gt; a                       |</span></span><br><span class="line">       <span class="number">8</span>: goto          <span class="number">27</span>     <span class="comment">// return-------------------------</span></span><br><span class="line">      <span class="number">11</span>: astore_2             <span class="comment">// catch Exception -&gt; e-----------</span></span><br><span class="line">      <span class="number">12</span>: bipush        <span class="number">20</span>     <span class="comment">//                               |</span></span><br><span class="line">      <span class="number">14</span>: istore_1             <span class="comment">// 20 -&gt; a                       |</span></span><br><span class="line">      <span class="number">15</span>: bipush        <span class="number">30</span>     <span class="comment">// finally                       |</span></span><br><span class="line">      <span class="number">17</span>: istore_1             <span class="comment">// 30 -&gt; a                       |</span></span><br><span class="line">      <span class="number">18</span>: goto          <span class="number">27</span>     <span class="comment">// return-------------------------</span></span><br><span class="line">      <span class="number">21</span>: astore_3             <span class="comment">// catch any -&gt; slot 3 -----------</span></span><br><span class="line">      <span class="number">22</span>: bipush        <span class="number">30</span>     <span class="comment">// finally                       |</span></span><br><span class="line">      <span class="number">24</span>: istore_1             <span class="comment">// 30 -&gt; a                       |</span></span><br><span class="line">      <span class="number">25</span>: aload_3              <span class="comment">// &lt;- slot 3                     |</span></span><br><span class="line">      <span class="number">26</span>: athrow               <span class="comment">// throw--------------------------</span></span><br><span class="line">      <span class="number">27</span>: <span class="keyword">return</span></span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           <span class="number">2</span>     <span class="number">5</span>    <span class="number">11</span>   Class java/lang/Exception</span><br><span class="line">           <span class="number">2</span>     <span class="number">5</span>    <span class="number">21</span>   any</span><br><span class="line">          <span class="number">11</span>    <span class="number">15</span>    <span class="number">21</span>   any</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">9</span>: <span class="number">0</span></span><br><span class="line">      line <span class="number">11</span>: <span class="number">2</span></span><br><span class="line">      line <span class="number">15</span>: <span class="number">5</span></span><br><span class="line">      line <span class="number">16</span>: <span class="number">8</span></span><br><span class="line">      line <span class="number">12</span>: <span class="number">11</span></span><br><span class="line">      frame_type = <span class="number">73</span> <span class="comment">/* same_locals_1_stack_item */</span></span><br><span class="line">        stack = [ <span class="class"><span class="keyword">class</span> <span class="title">java</span>/<span class="title">lang</span>/<span class="title">Throwable</span> ]</span></span><br><span class="line"><span class="class">      <span class="title">frame_type</span> </span>= <span class="number">5</span> <span class="comment">/* same */</span></span><br><span class="line">  MethodParameters:</span><br><span class="line">    Name                           Flags</span><br><span class="line">    args</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        Object lock = <span class="keyword">new</span> Object();  </span><br><span class="line">        <span class="keyword">synchronized</span> (lock)&#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;OK&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>字节码如下所示，其实和finally的字节码类似<br>会将一份普通代码分为两个分支，一个是正常结束的分支，一个是异常结束的分支，无论在哪个分支上，都会复制一份解锁的字节码，以保证加锁后肯定能够解锁</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">  descriptor: ([Ljava/lang/String;)V</span><br><span class="line">  flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">2</span>, locals=<span class="number">4</span>, args_size=<span class="number">1</span></span><br><span class="line">       <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  <span class="comment">// class java/lang/Object</span></span><br><span class="line">       <span class="number">3</span>: dup</span><br><span class="line">       <span class="number">4</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">7</span>: astore_1</span><br><span class="line">       <span class="number">8</span>: aload_1</span><br><span class="line">       <span class="number">9</span>: dup</span><br><span class="line">      <span class="number">10</span>: astore_2</span><br><span class="line">      <span class="number">11</span>: monitorenter</span><br><span class="line">      <span class="number">12</span>: getstatic     #<span class="number">3</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">      <span class="number">15</span>: ldc           #<span class="number">4</span>                  <span class="comment">// String OK</span></span><br><span class="line">      <span class="number">17</span>: invokevirtual #<span class="number">5</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="number">20</span>: aload_2</span><br><span class="line">      <span class="number">21</span>: monitorexit</span><br><span class="line">      <span class="number">22</span>: goto          <span class="number">30</span></span><br><span class="line">      <span class="number">25</span>: astore_3</span><br><span class="line">      <span class="number">26</span>: aload_2</span><br><span class="line">      <span class="number">27</span>: monitorexit</span><br><span class="line">      <span class="number">28</span>: aload_3</span><br><span class="line">      <span class="number">29</span>: athrow</span><br><span class="line">    StackMapTable: number_of_entries = <span class="number">2</span></span><br><span class="line">      frame_type = <span class="number">255</span> <span class="comment">/* full_frame */</span></span><br><span class="line">        offset_delta = <span class="number">25</span></span><br><span class="line">        locals = [ <span class="class"><span class="keyword">class</span> &quot;[<span class="title">Ljava</span>/<span class="title">lang</span>/<span class="title">String</span></span>;<span class="string">&quot;, class java/lang/Object, class java/lang/Object ]</span></span><br><span class="line"><span class="string">        stack = [ class java/lang/Throwable ]</span></span><br><span class="line"><span class="string">      frame_type = 250 /* chop */</span></span><br><span class="line"><span class="string">        offset_delta = 4</span></span><br><span class="line"><span class="string">  MethodParameters:</span></span><br><span class="line"><span class="string">    Name                           Flags</span></span><br><span class="line"><span class="string">    args</span></span><br></pre></td></tr></table></figure>


<h1 id="编译期处理"><a href="#编译期处理" class="headerlink" title="编译期处理"></a>编译期处理</h1><blockquote>
<p>所谓的语法糖，其实就是指<code>java</code> 编译器把<code>*.java</code>源代码编译为<code>*.class</code>字节码的过程中，自动生成和转换的一些代码，主要是为了减轻程序员的负担，算是<code>java</code>编译器给我们的一个额外福利<br>注意：以下代码的分析，借助了<code>javap</code>工具，idea的反编译功能，idea插件<code>jclasslib</code>等工具。另外，编译器转换的结果直接就是class字节码，只是为了便于阅读，给出了几乎等价的java源码方式，并不是编译器还会转换出中间的java源码，切记。</p>
</blockquote>
<h2 id="默认构造器"><a href="#默认构造器" class="headerlink" title="默认构造器"></a>默认构造器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>编译成class之后：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//这个无参构造器就是编译器帮助我们加上的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test1</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	    <span class="comment">//即调用父类Object的无参构造，调用java/lang/Object.&lt;init&gt;:()V</span></span><br><span class="line">	    <span class="keyword">super</span>();</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="自动拆装箱"><a href="#自动拆装箱" class="headerlink" title="自动拆装箱"></a>自动拆装箱</h2><ul>
<li>这个特性是JDk5开始加入的，代码片段1：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        Integer x = <span class="number">1</span>;  </span><br><span class="line">        <span class="keyword">int</span> y = x;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在JDK5之前按照上面这样写是无法进行编译的，必须写成下面代码片段2的形式：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        Integer x = Integer.valueOf(<span class="number">1</span>);  </span><br><span class="line">        <span class="keyword">int</span> y = x.intValue();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="泛型集合取值"><a href="#泛型集合取值" class="headerlink" title="泛型集合取值"></a>泛型集合取值</h2><ul>
<li>泛型也是在JDK5开始加入的特性，但java在编译泛型代码后，会执行泛型擦除的动作，即泛型信息在编译为字节码之后就丢失了，实际的类型都是当做了Object类型来处理的</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();  </span><br><span class="line">        list.add(<span class="number">10</span>);<span class="comment">//实际调用的List.add(Object o)  </span></span><br><span class="line">        Integer x = list.get(<span class="number">0</span>);<span class="comment">//实际调用的是Object o = List.get(int index);  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>所以在取值时，编译器真正生成的字节码中，还要额外做一个类型转换操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需要将 Object 转换成 Integer</span></span><br><span class="line">Integer x = (Integer)list.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>如果前面的x变量类型修改为int基本类型，那么最终生成的字节码是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需要将 Object 转换成 Integer ,并执行拆箱操作</span></span><br><span class="line"><span class="keyword">int</span> x = (Integer)list.get(<span class="number">0</span>).intValue();</span><br></pre></td></tr></table></figure></li>
<li><p>下面是编译之后的字节码</p>
<ul>
<li>第11行对应的就是<code>list.add(10)</code>，因为<code>list</code>要放的是包装类型，<code>10</code>是基本类型，所以先调用了<code>Integer.valueOf()</code>方法把<code>10</code>转换成了<code>Integer</code>类型</li>
<li>第14行可以看到，其实调用的就是<code>list.add(Object o)</code>方法，并没有泛型的类型</li>
<li>第22行也可以看到，获取数据调用的<code>List.get()</code>的返回值也是一个<code>Object</code>类型</li>
<li>第27行，<code>checkcast</code>表示强转，将<code>get</code>的<code>Object</code>类型强转成<code>Integer</code>类型</li>
</ul>
</li>
<li><p>泛型擦除掉的是字节码上的泛型信息，可以看到<code>LocalVariableTypeTable</code>仍然保留了方法参数泛型的信息</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">  descriptor: ([Ljava/lang/String;)V</span><br><span class="line">  flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">       <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  <span class="comment">// class java/util/ArrayList</span></span><br><span class="line">       <span class="number">3</span>: dup</span><br><span class="line">       <span class="number">4</span>: invokespecial #<span class="number">3</span>                  <span class="comment">// Method java/util/ArrayList.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">7</span>: astore_1</span><br><span class="line">       <span class="number">8</span>: aload_1</span><br><span class="line">       <span class="number">9</span>: bipush        <span class="number">10</span></span><br><span class="line">      <span class="number">11</span>: invokestatic  #<span class="number">4</span>                  <span class="comment">// Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span></span><br><span class="line">      <span class="number">14</span>: invokeinterface #<span class="number">5</span>,  <span class="number">2</span>            <span class="comment">// InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z</span></span><br><span class="line">      <span class="number">19</span>: pop</span><br><span class="line">      <span class="number">20</span>: aload_1</span><br><span class="line">      <span class="number">21</span>: iconst_0</span><br><span class="line">      <span class="number">22</span>: invokeinterface #<span class="number">6</span>,  <span class="number">2</span>            <span class="comment">// InterfaceMethod java/util/List.get:(I)Ljava/lang/Object;</span></span><br><span class="line">      <span class="number">27</span>: checkcast     #<span class="number">7</span>                  <span class="comment">// class java/lang/Integer</span></span><br><span class="line">      <span class="number">30</span>: astore_2</span><br><span class="line">      <span class="number">31</span>: <span class="keyword">return</span></span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">12</span>: <span class="number">0</span></span><br><span class="line">      line <span class="number">13</span>: <span class="number">8</span></span><br><span class="line">      line <span class="number">14</span>: <span class="number">20</span></span><br><span class="line">      line <span class="number">15</span>: <span class="number">31</span></span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          <span class="number">0</span>      <span class="number">32</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">          <span class="number">8</span>      <span class="number">24</span>     <span class="number">1</span>  list   Ljava/util/List;</span><br><span class="line">         <span class="number">31</span>       <span class="number">1</span>     <span class="number">2</span>     x   Ljava/lang/Integer;</span><br><span class="line">    LocalVariableTypeTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          <span class="number">8</span>      <span class="number">24</span>     <span class="number">1</span>  list   Ljava/util/List&lt;Ljava/lang/Integer;&gt;;</span><br><span class="line">  MethodParameters:</span><br><span class="line">    Name                           Flags</span><br><span class="line">    args</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>方法上的泛型信息，可以通过反射 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;Integer&gt; <span class="title">test</span><span class="params">(List&lt;String&gt; list, Map&lt;Integer,Object&gt; map)</span></span>&#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    Method test = Test4.class.getMethod(<span class="string">&quot;test&quot;</span>,List.class,Map.class);  </span><br><span class="line">    Type[] types = test.getGenericParameterTypes();  </span><br><span class="line">    <span class="keyword">for</span> (Type type : types) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType)&#123;  </span><br><span class="line">            ParameterizedType parameterizedType = (ParameterizedType)type;  </span><br><span class="line">            System.out.println(<span class="string">&quot;原始类型 - &quot;</span>+parameterizedType.getRawType());  </span><br><span class="line">            Type[] arguments = parameterizedType.getActualTypeArguments();  </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arguments.length; i++) &#123;  </span><br><span class="line">                System.out.printf(<span class="string">&quot;泛型参数【%d】-%s\n&quot;</span>,i,arguments[i]);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原始类型 - interface java.util.List</span><br><span class="line">泛型参数【0】-class java.lang.String</span><br><span class="line">原始类型 - interface java.util.Map</span><br><span class="line">泛型参数【0】-class java.lang.Integer</span><br><span class="line">泛型参数【1】-class java.lang.Object</span><br></pre></td></tr></table></figure>

<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><ul>
<li><p>可变参数也是JDk5开始加入的新特性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test5</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(String... args)</span></span>&#123;  </span><br><span class="line">        String[] array = args;<span class="comment">//直接赋值  </span></span><br><span class="line">        System.out.println(array);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        foo(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>可变参数<code>String... args</code>其实就是一个<code>String[] args</code>，从代码中的赋值语句就可以看出来</p>
</li>
<li><p>同样java编译会在编译期间将上述代码转换为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test5</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(String[] args)</span></span>&#123;  </span><br><span class="line">        String[] array = args;<span class="comment">//直接赋值  </span></span><br><span class="line">        System.out.println(array);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        foo(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>&#125;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>注意</strong>：<br>如果调用了<code>foo()</code>无参，则等价代码为<code>foo(new String[]&#123;&#125;)</code>，创建了一个空的数组，而不会传递<code>null</code>进去</p>
<h2 id="foreach循环"><a href="#foreach循环" class="headerlink" title="foreach循环"></a>foreach循环</h2><ul>
<li><p>在JDK5开始引入的语法糖，数组循环：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test6</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;<span class="comment">//数组赋值的简化写法，也是语法糖  </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : array) &#123;  </span><br><span class="line">            System.out.println(i);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会被编译转换为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test6</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length(); i++) &#123;</span><br><span class="line">	        <span class="keyword">int</span> e = array[i];  </span><br><span class="line">            System.out.println(e);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>而集合的循环：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test7</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);  </span><br><span class="line">        <span class="keyword">for</span> (Integer i : list) &#123;  </span><br><span class="line">            System.out.println(i);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>实际会被编译器转换为迭代器调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test7</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);  </span><br><span class="line">        Iterator var2 = list.iterator();  </span><br><span class="line">        <span class="keyword">while</span>(var2.hasNext()) &#123;  </span><br><span class="line">            Integer i = (Integer)var2.next();  </span><br><span class="line">            System.out.println(i);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：<br><code>foreach</code>循环写法，能够配合数组，以及所有实现了<code>Iterable</code>接口的集合类一起使用，其中<code>Iterable</code>用来获取集合的迭代器(<code>Iterable</code>)</p>
<h2 id="switch-字符串"><a href="#switch-字符串" class="headerlink" title="switch 字符串"></a>switch 字符串</h2><ul>
<li>从JDK7开始，switch可以用于字符串和枚举类，这个功能其实也是语法糖，例如：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test8</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">choose</span><span class="params">(String str)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">switch</span> (str) &#123;  </span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;hello&quot;</span>:  </span><br><span class="line">                System.out.println(<span class="string">&quot;H&quot;</span>);  </span><br><span class="line">                <span class="keyword">break</span>;            <span class="keyword">case</span> <span class="string">&quot;world&quot;</span>:  </span><br><span class="line">                System.out.println(<span class="string">&quot;W&quot;</span>);  </span><br><span class="line">                <span class="keyword">break</span>;        </span><br><span class="line">            &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>注意：</strong><br>switch配合String和枚举使用时，变量不能为null，原因分析完语法糖转换后的代码自然清楚</p>
<p>上面的代码会被编译器转换成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test8</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        System.out.println( <span class="string">&quot;hello&quot;</span>.hashCode());  </span><br><span class="line">        System.out.println( <span class="string">&quot;world&quot;</span>.hashCode());  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">choose</span><span class="params">(String str)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">byte</span> x = -<span class="number">1</span>;  </span><br><span class="line">        <span class="keyword">switch</span> (str.hashCode())&#123;  </span><br><span class="line">            <span class="keyword">case</span> <span class="number">99162322</span>: <span class="comment">//hello的hashCode  </span></span><br><span class="line">                <span class="keyword">if</span> (str.equals(<span class="string">&quot;hello&quot;</span>))&#123;  </span><br><span class="line">                    x = <span class="number">0</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            <span class="keyword">case</span> <span class="number">113318802</span>:<span class="comment">//world的hashCode  </span></span><br><span class="line">                <span class="keyword">if</span> (str.equals(<span class="string">&quot;world&quot;</span>))&#123;  </span><br><span class="line">                    x = <span class="number">1</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">switch</span> (x) &#123;  </span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:  </span><br><span class="line">                System.out.println(<span class="string">&quot;H&quot;</span>);  </span><br><span class="line">                <span class="keyword">break</span>;            </span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:  </span><br><span class="line">                System.out.println(<span class="string">&quot;W&quot;</span>);  </span><br><span class="line">                <span class="keyword">break</span>;        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从上面的代码可以看到，字符串使用<code>switch</code>其实是被拆成了两个整数的<code>switch</code>来执行的，第一遍是根据字符串的<code>hashCode</code>和<code>equals</code>将字符串转换成对应<code>byte</code>类型，第二遍才是利用<code>byte</code>执行进行比较<br>为什么第一遍时必须比较<code>hashCode</code>又利用<code>equals</code>比较呢？</p>
<blockquote>
<p><code>hashCode</code>是为了提高效率，减少可能的比较，而<code>equals</code>是为了防止<code>hashCode</code>冲突，例如<code>BM</code>和<code>C.</code>，这两个字符串的<code>hashCode</code>都是<code>2123</code></p>
</blockquote>
</blockquote>
<h2 id="switch-枚举"><a href="#switch-枚举" class="headerlink" title="switch 枚举"></a>switch 枚举</h2><p><code>switch</code> 枚举的例子，原始代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Sex sex)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">switch</span> (sex)&#123;  </span><br><span class="line">            <span class="keyword">case</span> MALE:  </span><br><span class="line">                System.out.println(<span class="string">&quot;男&quot;</span>);  </span><br><span class="line">                <span class="keyword">break</span>;            <span class="keyword">case</span> FEMALE:  </span><br><span class="line">                System.out.println(<span class="string">&quot;女&quot;</span>);  </span><br><span class="line">                <span class="keyword">break</span>;        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转换后代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 定义一个合成类(仅JVM使用，对我们不可见)  </span></span><br><span class="line"><span class="comment">     * 用来映射枚举的 ordinal 与数组元素的关系  </span></span><br><span class="line"><span class="comment">     * 枚举的 ordinal 表示枚举对象的序号，从0开始  </span></span><br><span class="line"><span class="comment">     * 即 MALE 的 ordinal()=0,FEMALE 的 ordinal() = 1  </span></span><br><span class="line"><span class="comment">     */</span>    <span class="comment">//com/example/demo1/test3/Test$1.$SwitchMap$com$example$demo1$test3$Sex  </span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> $<span class="title">MAP</span></span>&#123;  </span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];  </span><br><span class="line">        <span class="keyword">static</span> &#123;  </span><br><span class="line">            map[Sex.MALE.ordinal()] = <span class="number">1</span>;  </span><br><span class="line">            map[Sex.FEMALE.ordinal()] = <span class="number">2</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Sex sex)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> x = $MAP.map[sex.ordinal()];  </span><br><span class="line">        <span class="keyword">switch</span> (x)&#123;  </span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:  </span><br><span class="line">                System.out.println(<span class="string">&quot;男&quot;</span>);  </span><br><span class="line">                <span class="keyword">break</span>;            <span class="keyword">case</span> <span class="number">2</span>:  </span><br><span class="line">                System.out.println(<span class="string">&quot;女&quot;</span>);  </span><br><span class="line">                <span class="keyword">break</span>;        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>JDK7新增了枚举类，以前面的性别枚举为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Sex</span> </span>&#123;  </span><br><span class="line">    MALE,FEMALE;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sex</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">Sex</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Sex MALE;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Sex FEMALE;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Sex[] $VALUES;  </span><br><span class="line">    <span class="keyword">static</span> &#123;  </span><br><span class="line">        MALE = <span class="keyword">new</span> Sex(<span class="string">&quot;MALE&quot;</span>,<span class="number">0</span>);  </span><br><span class="line">        FEMALE = <span class="keyword">new</span> Sex(<span class="string">&quot;FEMALE&quot;</span>,<span class="number">1</span>);  </span><br><span class="line">        $VALUES = <span class="keyword">new</span> Sex[]&#123;MALE,FEMALE&#125;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Sex1</span><span class="params">(String name, <span class="keyword">int</span> ordinal)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">super</span>(name, ordinal);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Sex[] values()&#123;  </span><br><span class="line">        <span class="keyword">return</span> $VALUES.clone();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Sex <span class="title">valueOf</span><span class="params">(String name)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> Enum.valueOf(Sex.class,name);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a>try-with-resources</h2><p>JDK7开始新增了对需要关闭的资源处理的特殊语法 <code>try-with-resources</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>(资源变量 = 创建资源对象)&#123;</span><br><span class="line">	</span><br><span class="line">&#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中资源对象需要实现AutoCloseable接口，例如 <code>InputStream</code>、<code>OutputStream</code>等接口都实现了AutoCloseable接口，使用<code>try-with-resources</code>可以不写finally语句块，编译器会帮助生成关闭资源代码，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">try</span> (InputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;&quot;</span>))&#123;  </span><br><span class="line">            System.out.println(inputStream);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译转换后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            InputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;&quot;</span>);  </span><br><span class="line">            Throwable var2 = <span class="keyword">null</span>;  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                System.out.println(inputStream);  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable var12) &#123;  </span><br><span class="line">	            <span class="comment">// var2就是我们业务代码块运行的时候可能出现的异常</span></span><br><span class="line">                var2 = var12;  </span><br><span class="line">                <span class="keyword">throw</span> var12;  </span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">	            <span class="comment">//判断资源不为空，否则不用关闭</span></span><br><span class="line">                <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>) &#123;  </span><br><span class="line">	                <span class="comment">//如果我们的业务代码块有异常</span></span><br><span class="line">                    <span class="keyword">if</span> (var2 != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                        <span class="keyword">try</span> &#123;  </span><br><span class="line">                            inputStream.close();  </span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Throwable var11) &#123;  </span><br><span class="line">	                        <span class="comment">//如果我们的业务代码块有异常，并且关闭资源的时候也出现了异常，会作为被压制异常添加(保证两个异常都不会丢失)</span></span><br><span class="line">                            var2.addSuppressed(var11);  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">	                    <span class="comment">//如果我们的业务代码块没有异常，直接关闭资源，如果关闭资源出现了异常，那么该异常就是最后的异常，可能会被catch捕捉</span></span><br><span class="line">                        inputStream.close();  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var14) &#123;  </span><br><span class="line">            var14.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么要设计一个<code>addSuppressed(Throwable e)</code>(添加被压制异常)的方法呢？<br>是为了防止异常信息丢失，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">try</span> (MyResource myResource = <span class="keyword">new</span> MyResource())&#123;  </span><br><span class="line">            <span class="keyword">int</span> a = <span class="number">1</span>/<span class="number">0</span>;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyResource</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span></span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;close 异常&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br>除0异常和手动抛出来的close异常都未丢失</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.ArithmeticException: / by zero</span><br><span class="line">	at com.example.demo1.test3.Test3.main(Test3.java:<span class="number">10</span>)</span><br><span class="line">	Suppressed: java.lang.Exception: close 异常</span><br><span class="line">		at com.example.demo1.test3.MyResource.close(Test3.java:<span class="number">20</span>)</span><br><span class="line">		at com.example.demo1.test3.Test3.main(Test3.java:<span class="number">11</span>)</span><br></pre></td></tr></table></figure>

<h2 id="方法重写时的桥接方法"><a href="#方法重写时的桥接方法" class="headerlink" title="方法重写时的桥接方法"></a>方法重写时的桥接方法</h2><p>一般来说方法重写分两种情况：</p>
<ul>
<li>父类和子类返回值完全一致</li>
<li>子类返回值可以是父类返回值的子类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">m</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Number <span class="title">m</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于子类，java编译器会做如下处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">m</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//此方法才是真正重写了父类，public Number m()方法  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> synthetic bridge Number <span class="title">m</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> m();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中桥接方法比较特殊，仅对java虚拟机可见，并且与原来的public Number m()没有命名冲突，可以使用下面的反射代码来验证：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> (Method method : A.class.getDeclaredMethods()) &#123;  </span><br><span class="line">        System.out.println(method);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> java.lang.Integer com.example.demo1.test3.A.m()</span><br><span class="line"><span class="keyword">public</span> java.lang.Number com.example.demo1.test3.A.m()</span><br></pre></td></tr></table></figure>

<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test5</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> Runnable() &#123;  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                System.out.println(<span class="string">&quot;OK&quot;</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转换后代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//额外生成的一个类</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Test5</span>$1 <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    Test5$<span class="number">1</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;OK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test5</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> Test5$<span class="number">1</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>引用局部变量的匿名内部类，源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test5</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> a)</span> </span>&#123;  </span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> Runnable() &#123;  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                System.out.println(<span class="string">&quot;OK&quot;</span>+a);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转换后代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//额外生成的代码</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Test5</span>$1 <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> val$a;</span><br><span class="line">    Test5$<span class="number">1</span>(<span class="keyword">final</span> <span class="keyword">int</span> val$a) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val$a = val$a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;OK&quot;</span> + <span class="keyword">this</span>.val$a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test5</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> a)</span> </span>&#123;  </span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> Test5$<span class="number">1</span>(a);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong><br>这同时解释了为什么匿名内部类引用局部变量时，局部变量必须是final的原因<br>    因为在创建<code>Test5$1</code>对象时，将<code>a</code>的值赋值给了<code>Test5$1</code>对象的<code>val$a</code>属性，所以<code>a</code>不应该再发生变化了，如果变化，那么<code>val$a</code>属性就没有机会再跟着一起变化</p>
<h1 id="类加载阶段"><a href="#类加载阶段" class="headerlink" title="类加载阶段"></a>类加载阶段</h1><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><ul>
<li>将类的字节码载入方法区中，内部采用<code>C++</code>的<code>instanceKlass</code>描述<code>java</code>类，他的重要<code>field</code>有：<ul>
<li><code>_java_mirror</code>即<code>java</code>的类镜像，例如对<code>String</code>来说，<code>String.class</code>，作用就是把<code>klass</code>暴露给<code>java</code>使用</li>
<li><code>_super</code> 即父类</li>
<li><code>_fields</code>即成员变量</li>
<li><code>_methods</code> 即方法</li>
<li><code>_constants</code> 即常量池</li>
<li><code>_class_loader</code> 即类加载器</li>
<li><code>_vtable</code> 虚方法表</li>
<li><code>_itable</code> 接口方法表</li>
</ul>
</li>
<li>如果这个类还有父类没有加载，先加载父类</li>
<li>加载和链接可能是交替运行的</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li><code>instanceKlass</code> 这样的【元数据】是存储在方法区的（jdk1.8之后的元空间），但<code>_java_mirror</code>是存储在堆中的</li>
<li>可以通过前面介绍的<code>HSDB</code>工具查看</li>
<li>类加载之后，会在堆中保留一份信息，也就是类对象，类对象中会有地址指向元空间中的元数据，元空间中<code>_java_mirror</code>也会有指针指向堆中的元数据，可以通过类对象创建实例对象，创建出来的实例对象中，对象头里面会保留类对象信息<br><img src="/2022/08/20/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-20220828193546824.png"></li>
</ul>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><ul>
<li>验证类是否符合JVM规范，安全性检查<br>用可以编辑16进制文件的工具修改编译后的class内容，然后在控制台运行：<br>(报错内容为magic魔数部分值不正确)<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Error: A JNI error has occurred, please check your installation and <span class="keyword">try</span> again</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.ClassFormatError: Incompatible magic value <span class="number">3405691578</span> in <span class="class"><span class="keyword">class</span> <span class="title">file</span> <span class="title">com</span>/<span class="title">example</span>/<span class="title">demo1</span>/<span class="title">test3</span>/<span class="title">Test6</span></span></span><br><span class="line"><span class="class">        <span class="title">at</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">ClassLoader</span>.<span class="title">defineClass1</span>(<span class="title">Native</span> <span class="title">Method</span>)</span></span><br><span class="line"><span class="class">        <span class="title">at</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">ClassLoader</span>.<span class="title">defineClass</span>(<span class="title">ClassLoader</span>.<span class="title">java</span>:763)</span></span><br><span class="line"><span class="class">        <span class="title">at</span> <span class="title">java</span>.<span class="title">security</span>.<span class="title">SecureClassLoader</span>.<span class="title">defineClass</span>(<span class="title">SecureClassLoader</span>.<span class="title">java</span>:142)</span></span><br><span class="line"><span class="class">        <span class="title">at</span> <span class="title">java</span>.<span class="title">net</span>.<span class="title">URLClassLoader</span>.<span class="title">defineClass</span>(<span class="title">URLClassLoader</span>.<span class="title">java</span>:467)</span></span><br><span class="line"><span class="class">        <span class="title">at</span> <span class="title">java</span>.<span class="title">net</span>.<span class="title">URLClassLoader</span>.<span class="title">access</span>$100(<span class="title">URLClassLoader</span>.<span class="title">java</span>:73)</span></span><br><span class="line"><span class="class">        <span class="title">at</span> <span class="title">java</span>.<span class="title">net</span>.<span class="title">URLClassLoader</span>$1.<span class="title">run</span>(<span class="title">URLClassLoader</span>.<span class="title">java</span>:368)</span></span><br><span class="line"><span class="class">        <span class="title">at</span> <span class="title">java</span>.<span class="title">net</span>.<span class="title">URLClassLoader</span>$1.<span class="title">run</span>(<span class="title">URLClassLoader</span>.<span class="title">java</span>:362)</span></span><br><span class="line"><span class="class">        <span class="title">at</span> <span class="title">java</span>.<span class="title">security</span>.<span class="title">AccessController</span>.<span class="title">doPrivileged</span>(<span class="title">Native</span> <span class="title">Method</span>)</span></span><br><span class="line"><span class="class">        <span class="title">at</span> <span class="title">java</span>.<span class="title">net</span>.<span class="title">URLClassLoader</span>.<span class="title">findClass</span>(<span class="title">URLClassLoader</span>.<span class="title">java</span>:361)</span></span><br><span class="line"><span class="class">        <span class="title">at</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">ClassLoader</span>.<span class="title">loadClass</span>(<span class="title">ClassLoader</span>.<span class="title">java</span>:424)</span></span><br><span class="line"><span class="class">        <span class="title">at</span> <span class="title">sun</span>.<span class="title">misc</span>.<span class="title">Launcher</span>$<span class="title">AppClassLoader</span>.<span class="title">loadClass</span>(<span class="title">Launcher</span>.<span class="title">java</span>:338)</span></span><br><span class="line"><span class="class">        <span class="title">at</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">ClassLoader</span>.<span class="title">loadClass</span>(<span class="title">ClassLoader</span>.<span class="title">java</span>:357)</span></span><br><span class="line"><span class="class">        <span class="title">at</span> <span class="title">sun</span>.<span class="title">launcher</span>.<span class="title">LauncherHelper</span>.<span class="title">checkAndLoadMain</span>(<span class="title">LauncherHelper</span>.<span class="title">java</span>:495)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul>
<li>为<code>static</code>变量分配空间，设置默认值<ul>
<li><code>static</code> 变量在JDK7之前存储于<code>instanceKlass</code>末尾，从JDK7开始，存储于<code>_java_mirror</code>末尾</li>
<li><code>static</code> 变量分配空间和赋值是两个步骤，分配空间在准备阶段完成，赋值在初始化阶段完成</li>
<li>如果<code>static</code>变量是<code>final</code>的基本类型，以及字符串常量，那么编译阶段值就确定了，赋值在准备阶段完成</li>
<li>如果<code>static</code>变量是<code>final</code>的，但属于引用类型，那么赋值也会在初始化阶段完成</li>
</ul>
</li>
</ul>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><ul>
<li>将常量池中的符号引用解析为直接引用</li>
<li>符号引用替换为直接引用的理解：<ul>
<li>符号引用：比如一个类中引用了其他类，但是JVM不知道实际引用的其他类地址会在哪，所以就会用符号引用代表，等到解析的时候，再根据唯一符号引用去找到其他类的地址，不止是其他类的代表，符号引用也可以代表方法，字段等，主要注意的是符号引用与虚拟机布局无关，引用的目标不一定已经加载到内存</li>
<li>直接引用：直接引用与虚拟机布局有关，如果使用直接引用，那么引用的目标一定已经加载到内存中</li>
<li>符号引用要转换成直接引用才有效，这也说明直接引用的效率要比符号引用高，那么为什么要用符号引用呢？这时 因为类加载之前，javac会将源代码编译成class文件，这个时候javac是不知道被编译的类中所引用的类、方法或者变量他们的引用地址在哪，所以只能用符号引用来代表，当然，符号引用也是要准备JVM虚拟机规范的</li>
</ul>
</li>
</ul>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="lt-cinit-gt-V-方法"><a href="#lt-cinit-gt-V-方法" class="headerlink" title="&lt;cinit&gt;()V 方法"></a>&lt;cinit&gt;()V 方法</h3><p>初始化即调用<code>&lt;cinit&gt;()V</code>，虚拟机会保证这个类【构造方法】的线程安全</p>
<h3 id="发生的时机"><a href="#发生的时机" class="headerlink" title="发生的时机"></a>发生的时机</h3><p>类的初始化是懒惰的，并不会在程序启动的时候全部初始化，而是等需要的时候初始化</p>
<p><strong>会导致初始化的情况：</strong></p>
<ul>
<li><code>main</code>方法所在的类，总是被首先初始化</li>
<li>首次访问这个类的静态变量或者静态方法时</li>
<li>子类初始化，如果父类还没有初始化，会引发</li>
<li>子类访问父类静态变量，只会触发父类的初始化</li>
<li><code>Class.forName()</code></li>
<li><code>new</code> 会导致初始化</li>
</ul>
<p><strong>不会导致初始化的情况</strong>：</p>
<ul>
<li>访问类的<code>static final</code>静态常量（基本类型和字符串类型）不会触初始化</li>
<li><code>类对象.class</code>不会触发初始化</li>
<li>创建该类的数组不会触发初始化</li>
<li>类加载器的 <code>loadClass </code>方法</li>
<li><code> Class.forName()</code>方法的参数2为<code>false</code>时</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">static</span> &#123;  </span><br><span class="line">        <span class="comment">//main方法所在的类，总是会被初始化  </span></span><br><span class="line">        System.out.println(<span class="string">&quot;main init&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;  </span><br><span class="line">        <span class="comment">//1.静态常量不会触发初始化  </span></span><br><span class="line"><span class="comment">//        System.out.println(B.b);  </span></span><br><span class="line">        <span class="comment">//2.类对象.class不会触发初始化  </span></span><br><span class="line"><span class="comment">//        System.out.println(B.class);  </span></span><br><span class="line">        <span class="comment">// 3.创建该类的数组，不会导致初始化  </span></span><br><span class="line"><span class="comment">//        System.out.println(new B[0]);  </span></span><br><span class="line">        <span class="comment">//4.不会初始化类B，但是会加载 B、A  </span></span><br><span class="line"><span class="comment">//        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();  </span></span><br><span class="line"><span class="comment">//        classLoader.loadClass(&quot;com.example.demo1.test5.B&quot;);  </span></span><br><span class="line">        <span class="comment">//5. 不会初始化类B，但是会加载 B、A  </span></span><br><span class="line"><span class="comment">//        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();  </span></span><br><span class="line"><span class="comment">//        Class.forName(&quot;com.example.demo1.test5.B&quot;,false,classLoader);  </span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 1.首次访问这个类的静态变量或者静态方法时，会初始化  </span></span><br><span class="line"><span class="comment">//        System.out.println(A.a);  </span></span><br><span class="line">        <span class="comment">//2. 子类初始化，如果父类还没有初始化，会引发  </span></span><br><span class="line"><span class="comment">//        System.out.println(B.c);  </span></span><br><span class="line">        <span class="comment">//3.子类访问父类静态变量，只会初始化父类  </span></span><br><span class="line"><span class="comment">//        System.out.println(B.a);  </span></span><br><span class="line">        <span class="comment">//4.会初始化类B，并且先初始化类A  </span></span><br><span class="line"><span class="comment">//        Class.forName(&quot;com.example.demo1.test5.B&quot;);  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">static</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;a init&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;  </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">double</span> b = <span class="number">5.0</span>;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> c = <span class="keyword">false</span>;  </span><br><span class="line">    <span class="keyword">static</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;b init&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>以JDK8为例：</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">描述</th>
<th align="center">加载目录</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Bootstrap ClassLoader</td>
<td align="center">启动类加载器</td>
<td align="center">JAVA_HOME/jre/lib</td>
<td align="center">无法直接访问</td>
</tr>
<tr>
<td align="center">Extension ClassLoader</td>
<td align="center">扩展类加载器</td>
<td align="center">JAVA_HOME/jre/lib/ext</td>
<td align="center">上级为Bootstrap，显示为null</td>
</tr>
<tr>
<td align="center">Application ClassLoader</td>
<td align="center">应用程序类加载器</td>
<td align="center">classpath</td>
<td align="center">上级为Extension</td>
</tr>
<tr>
<td align="center">自定义类加载器</td>
<td align="center">自定义</td>
<td align="center">自定义类加载器</td>
<td align="center">上级为Application</td>
</tr>
</tbody></table>
<h2 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h2><p>使用Bootstrap类加载器加载类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">F</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">static</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;F init&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;  </span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;com.example.demo1.test5.F&quot;</span>);  </span><br><span class="line">        System.out.println(aClass.getClassLoader());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ java -Xbootclasspath/a:. com.example.demo1.test5.Test1</span><br><span class="line">F init</span><br><span class="line">null</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-Xbootclasspath</code> 表示设置 <code>bootclasspath</code></li>
<li>其中<code>/a:.</code> 表示将当前目录追加至 <code>bootclasspath</code> 之后</li>
<li>可以使用这个方法替换核心类<ul>
<li><code>java -Xbootclasspath:&lt;new bootclasspath&gt;</code>   完全替换路径</li>
<li><code>java -Xbootclasspath/a:&lt;向后追加路径&gt;</code></li>
<li><code>java -Xbootclasspath/p:&lt;向前追加路径&gt;</code></li>
</ul>
</li>
</ul>
<h2 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h2><p>源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">G</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">static</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;classpath G init&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;  </span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;com.example.demo1.test5.G&quot;</span>);  </span><br><span class="line">        System.out.println(aClass.getClassLoader());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">classpath G init</span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br></pre></td></tr></table></figure>
<ul>
<li>可以看到，默认情况下使用的是 <code>AppClassLoader</code> 类加载器</li>
<li>那么怎么才能使用扩展类加载器加载呢？<ul>
<li>将对应的类，打成jar包，放到扩展目录下</li>
</ul>
</li>
</ul>
<p>源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">G</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">static</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;ext G init&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更改输出内容，打包放入扩展目录，可以根据输出内容的不同，判断是加载的哪一个类<br>使用命令打包 <code>jar -cvf my.jar com/example/demo1/test5/G.class</code><br>将jar包放入JAVA_HOME/jre/lib/ext目录下后，改回类中的输出内容，再次运行代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ext G init</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@69663380</span><br></pre></td></tr></table></figure>
<p>从输出的内容可以看出，使用的是 <code>ExtClassLoader</code> 类加载器 </p>
<h2 id="双亲委派模式"><a href="#双亲委派模式" class="headerlink" title="双亲委派模式"></a>双亲委派模式</h2><p>所谓双亲委派，就是指调用类加载器的<code>loadClass</code>方法时，查找类的规则</p>
<blockquote>
<p><strong>注意：</strong><br>    这里的双亲，翻译为上级似乎更为合适，因为他们并没有继承关系</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)  </span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException  &#123;  </span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;  </span><br><span class="line">        <span class="comment">// 检查该类加载器中有没有已经加载过</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);  </span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;  <span class="comment">// 如果没有加载过</span></span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                <span class="comment">// 有上级的话，委派上级 loadClass</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);  </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                <span class="comment">// 如果上级为空（ExtClassLoader），则委派 BootstrapClassLoader</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                <span class="comment">// 如果上一层找不到，调用 findClass方法（每个类加载器自己扩展）来加载</span></span><br><span class="line">                <span class="comment">// 对于ExtClassLoader和AppClassLoader来说，如果上级找不到，会调用自己的findClass方法来寻找</span></span><br><span class="line">                c = findClass(name);  </span><br><span class="line">  </span><br><span class="line">                <span class="comment">// 记录耗时 </span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);  </span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);  </span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;  </span><br><span class="line">            resolveClass(c);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> c;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程上下文类加载器（SPI）"><a href="#线程上下文类加载器（SPI）" class="headerlink" title="线程上下文类加载器（SPI）"></a>线程上下文类加载器（SPI）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String url = <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line">Connection conn = DriverManager.getConnection(url,username,password);</span><br></pre></td></tr></table></figure>
<p>上面是获取数据库连接，并没有写去加载哪一个数据库驱动<br>不需要<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code>来加载，也可以正确加载驱动</p>
<p>代码中并没有指定使用的是哪一个数据库驱动，是如何做到的呢？</p>
<p>源码：(代码中省略了部分代码，只保留了需要观察的部分)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DriverManager</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 注册驱动集合</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">	<span class="comment">// 初始化驱动</span></span><br><span class="line">	<span class="keyword">static</span> &#123;  </span><br><span class="line">    loadInitialDrivers();  </span><br><span class="line">    println(<span class="string">&quot;JDBC DriverManager initialized&quot;</span>);  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中可以看出，静态代码块中主要逻辑在 <code>loadInitialDrivers();</code>方法中，那我们来看一下 <code>loadInitialDrivers();</code>的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadInitialDrivers</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    String drivers;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        drivers = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;String&gt;() &#123;  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                <span class="keyword">return</span> System.getProperty(<span class="string">&quot;jdbc.drivers&quot;</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;  </span><br><span class="line">        drivers = <span class="keyword">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">      <span class="comment">// 1)使用 ServiceLoader 机制加载驱动， 即SPI</span></span><br><span class="line">    AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">            ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);  </span><br><span class="line">            Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();  </span><br><span class="line">	        <span class="keyword">try</span>&#123;  </span><br><span class="line">                <span class="keyword">while</span>(driversIterator.hasNext()) &#123;  </span><br><span class="line">                    driversIterator.next();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125; <span class="keyword">catch</span>(Throwable t) &#123;  </span><br><span class="line">            <span class="comment">// Do nothing  </span></span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;);  </span><br><span class="line">  </span><br><span class="line">    println(<span class="string">&quot;DriverManager.initialize: jdbc.drivers = &quot;</span> + drivers);  </span><br><span class="line">	  <span class="comment">//2) 使用 jdbc.drivers 定义的驱动名加载驱动</span></span><br><span class="line">    <span class="keyword">if</span> (drivers == <span class="keyword">null</span> || drivers.equals(<span class="string">&quot;&quot;</span>)) &#123;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    String[] driversList = drivers.split(<span class="string">&quot;:&quot;</span>);  </span><br><span class="line">    println(<span class="string">&quot;number of Drivers:&quot;</span> + driversList.length);  </span><br><span class="line">    <span class="keyword">for</span> (String aDriver : driversList) &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="comment">// 这里  ClassLoader.getSystemClassLoader() 就是应用程序类加载器</span></span><br><span class="line">            println(<span class="string">&quot;DriverManager.Initialize: loading &quot;</span> + aDriver);  </span><br><span class="line">            Class.forName(aDriver, <span class="keyword">true</span>,  </span><br><span class="line">                    ClassLoader.getSystemClassLoader());  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;  </span><br><span class="line">            println(<span class="string">&quot;DriverManager.Initialize: load failed: &quot;</span> + ex);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面代码标记1处的<code>ServiceLoader </code>就是大名鼎鼎的<code> Service Provider Interface (SPI)</code></li>
<li>约定如下：<ul>
<li>在jar包的<code>META-INF/service</code>包下，以接口全限定名为文件名，文件内容是实现类名称</li>
</ul>
</li>
</ul>
<p>如图，mysql的驱动：<br><img src="/2022/08/20/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-20220829210956575.png"></p>
<ul>
<li><p>这样就可以通过下面的方法使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServiceLoader&lt;接口类型&gt; loader = ServiceLoader.load(接口类型.class);  </span><br><span class="line">Iterator&lt;接口类型&gt; iterator = loader.iterator();  </span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;  </span><br><span class="line">    iterator.next();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>接着看<code>ServiceLoader.load()</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">load</span><span class="params">(Class&lt;S&gt; service)</span> </span>&#123;  </span><br><span class="line">		<span class="comment">// 获取线程上下文类加载器</span></span><br><span class="line">    ClassLoader cl = Thread.currentThread().getContextClassLoader();  </span><br><span class="line">    <span class="keyword">return</span> ServiceLoader.load(service, cl);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>线程上下文类加载器是当前线程使用的类加载器，默认就是应用程序加载器，它内部又是由<code>Class.forName()</code>调用了线程上下文类加载器完成类加载，具体代码在 <code>ServiceLoader</code> 的内部类 <code>LazyIterator</code> 中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> S <span class="title">nextService</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (!hasNextService())  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();  </span><br><span class="line">    String cn = nextName;  </span><br><span class="line">    nextName = <span class="keyword">null</span>;  </span><br><span class="line">    Class&lt;?&gt; c = <span class="keyword">null</span>;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        c = Class.forName(cn, <span class="keyword">false</span>, loader);  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException x) &#123;  </span><br><span class="line">        fail(service,  </span><br><span class="line">             <span class="string">&quot;Provider &quot;</span> + cn + <span class="string">&quot; not found&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (!service.isAssignableFrom(c)) &#123;  </span><br><span class="line">        fail(service,  </span><br><span class="line">             <span class="string">&quot;Provider &quot;</span> + cn  + <span class="string">&quot; not a subtype&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        S p = service.cast(c.newInstance());  </span><br><span class="line">        providers.put(cn, p);  </span><br><span class="line">        <span class="keyword">return</span> p;  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable x) &#123;  </span><br><span class="line">        fail(service,  </span><br><span class="line">             <span class="string">&quot;Provider &quot;</span> + cn + <span class="string">&quot; could not be instantiated&quot;</span>,  </span><br><span class="line">             x);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Error();          <span class="comment">// This cannot happen  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h2><h3 id="什么时候需要自定义类加载器？"><a href="#什么时候需要自定义类加载器？" class="headerlink" title="什么时候需要自定义类加载器？"></a>什么时候需要自定义类加载器？</h3><ul>
<li>想要加载非 <code>classpath</code> 随意路径中的类文件</li>
<li>都是通过接口来实现，希望解耦时，常用在框架设计</li>
<li>这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于 tomcat 容器</li>
</ul>
<h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ul>
<li>继承 <code>ClassLoader</code> 类</li>
<li>要准从双亲委派机制，重写 <code>findClass</code> 方法<ul>
<li>注意不是重写<code>loadClass</code>方法，否则不会走双亲委派机制</li>
</ul>
</li>
<li>读取类文件的字节码</li>
<li>调用父类的 <code>defineClass</code> 方法来加载类 </li>
<li>使用者调用该类加载器的 <code>loadClass</code> 方法 </li>
</ul>
<p>如下所示，MyClassLoader 就是我们自定义的类加载器，可以到自定义的目录下进行类加载：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;  </span><br><span class="line">        MyClassLoader myClassLoader = <span class="keyword">new</span> MyClassLoader();  </span><br><span class="line">        Class&lt;?&gt; c1 = myClassLoader.loadClass(<span class="string">&quot;MapImpl1&quot;</span>);  </span><br><span class="line">        Class&lt;?&gt; c2 = myClassLoader.loadClass(<span class="string">&quot;MapImpl1&quot;</span>);  </span><br><span class="line">        System.out.println(c2 == c1);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;  </span><br><span class="line">        String path = <span class="string">&quot;D:\\myclasspath\\&quot;</span>+name+<span class="string">&quot;.class&quot;</span>;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            ByteArrayOutputStream os = <span class="keyword">new</span> ByteArrayOutputStream();  </span><br><span class="line">            Files.copy(Paths.get(path), os);  </span><br><span class="line">            <span class="keyword">byte</span>[] bytes = os.toByteArray();  </span><br><span class="line">            <span class="keyword">return</span> defineClass(name, bytes, <span class="number">0</span>, bytes.length);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">&quot;未找到对应的类文件&quot;</span>,e);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="运行期优化"><a href="#运行期优化" class="headerlink" title="运行期优化"></a>运行期优化</h1><h2 id="即时编译"><a href="#即时编译" class="headerlink" title="即时编译"></a>即时编译</h2><h3 id="分层编译"><a href="#分层编译" class="headerlink" title="分层编译"></a>分层编译</h3><p>运行下面的例子，可以看到，每次创建的一千个对象的时间，会从最开始的每次<code>31000</code>纳秒，到二百次之后降低到<code>11900</code>左右</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;  </span><br><span class="line">            <span class="keyword">long</span> start = System.nanoTime();  </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;  </span><br><span class="line">                <span class="keyword">new</span> Object();  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">long</span> end = System.nanoTime();  </span><br><span class="line">            System.out.println(i+<span class="string">&quot;   &quot;</span>+(end-start));  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>原因是什么？</strong></p>
<p>** JVM将执行状态分成了5个层次：**</p>
<ul>
<li>0层：解释执行（Interpreter）</li>
<li>1层：使用C1即时编译器编译执行（不带profiling）</li>
<li>2层：使用C1即时编译器编译执行（带基本的profiling）</li>
<li>3层：使用C1即时编译器编译执行（带完全的profiling）</li>
<li>4层：使用C2即时编译器编译执行</li>
</ul>
<blockquote>
<p><code>profiling</code> 是指在运行过程中收集一些程序执行状态的数据，例如【方法的调用次数】，【循环的回放次数】等</p>
</blockquote>
<p><strong>即时编译器（JIT）和解释器的区别：</strong></p>
<ul>
<li>解释器是将字节码解释为机器码，下次即使遇到相同的字节码，仍会执行重复的解释</li>
<li>JIT是将一些字节码编译为机器码，并存入<code>Code Cache</code>，下次遇到相同的代码，直接执行，无需编译</li>
<li>解释器是将字节码解释为针对所有平台都通用的机器码</li>
<li>JIT会根据平台类型，生成平台特定的机器码</li>
</ul>
<blockquote>
<p>对于占据大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；<br>另一方面，对于占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度；<br>执行效率上简单比较一下 <code>Interpreter &lt; C1 &lt; c2</code><br>总的目标是发现热点代码（hotspot名称的由来），优化之</p>
</blockquote>
<blockquote>
<p>上面的一种优化手段称之为【逃逸分析】，检查新创建的对象是否逃逸。<br>可以使用<code>-XX:-DoEscapeAnalysis</code>关闭逃逸分析，再运行刚才的示例观察结果<br>如果开启逃逸分析，编译器发现新创建的对象在循环外面没有调用，那么就会选择不创建对象</p>
</blockquote>
<h3 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h3><p>（Inlining）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> i)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> i * i;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(square(<span class="number">9</span>));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果发现<code>square()</code>方法是热点方法，并且长度不太长，会进行内联，所谓的内联就是把方法内代码拷贝、黏贴到调用者的位置</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="number">9</span> * <span class="number">9</span>);</span><br></pre></td></tr></table></figure>

<p>还能够进行常量折叠（<code>constant folding</code>）的优化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="number">81</span>);</span><br></pre></td></tr></table></figure>

<p>可以使用参数打印内联信息<code>-XX:+UnlockDiagnosticVMOptions -XX:+PrintInlining</code><br>从输出的结果可以看到，自定义的 <code>square()</code> 方法已经内联优化<br><img src="/2022/08/20/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-20220830211359736.png"></p>
<p>也可以使用参数禁用内联<code>-XX:CompileCommand=dontinline,*Test.square</code>   （*号表示所有包下的Test类中的square方法）</p>
<h3 id="字段优化"><a href="#字段优化" class="headerlink" title="字段优化"></a>字段优化</h3><p>JWH基准测试请参考 ： <a href="https://openjdk.org/projects/code-tools/jmh/">OpenJDK: jmh</a></p>
<p>创建Maven工程，添加以下依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jmh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jmh-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.35<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jmh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jmh-generator-annprocess<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.35<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>编写基准测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//预热，预热2伦，每次间隔1毫秒  </span></span><br><span class="line"><span class="meta">@Warmup(iterations = 2,time = 1)</span>  </span><br><span class="line"><span class="comment">//进5伦测试，每次间隔1毫秒  </span></span><br><span class="line"><span class="meta">@Measurement(iterations = 5,time = 1)</span>  </span><br><span class="line"><span class="meta">@State(Scope.Benchmark)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span>[] elements = randomInts(<span class="number">1000</span>);  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] randomInts(<span class="keyword">int</span> size)&#123;  </span><br><span class="line">        Random random = ThreadLocalRandom.current();  </span><br><span class="line">        <span class="keyword">int</span>[] values = <span class="keyword">new</span> <span class="keyword">int</span>[size];  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;  </span><br><span class="line">            values[i] = random.nextInt();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> values;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">@Benchmark</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; elements.length; i++) &#123;  </span><br><span class="line">            doSum(elements[i]);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">@Benchmark</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">int</span>[] local = <span class="keyword">this</span>.elements;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; local.length; i++) &#123;  </span><br><span class="line">            doSum(local[i]);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">@Benchmark</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> element : elements) &#123;  </span><br><span class="line">            doSum(element);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> sum = <span class="number">0</span>;  </span><br><span class="line">    <span class="meta">@CompilerControl(CompilerControl.Mode.INLINE)</span>  </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSum</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;  </span><br><span class="line">        sum+=x;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException </span>&#123;  </span><br><span class="line">        Options options = <span class="keyword">new</span> OptionsBuilder()  </span><br><span class="line">                .include(Test.class.getSimpleName())  </span><br><span class="line">                .forks(<span class="number">1</span>).build();  </span><br><span class="line">        <span class="keyword">new</span> Runner(options).run();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码运行之后，输出结果：<br>Score项为评分，可以看到，三种循环方式，评分并没有太大的差异</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Benchmark    Mode  Cnt        Score        Error  Units</span><br><span class="line">Test.test1  thrpt    5  4152019.656 ±  43675.816  ops/s</span><br><span class="line">Test.test2  thrpt    5  4128473.418 ± 228612.603  ops/s</span><br><span class="line">Test.test3  thrpt    5  4130624.821 ± 180536.674  ops/s</span><br></pre></td></tr></table></figure>

<p>可以把<code>doSum()</code>方法上的注解参数修改为<code>@CompilerControl(CompilerControl.Mode.DONT_INLINE)</code>，禁止方法内联<br>再次运行代码：<br>可以看出，得分比较与第一次，全都有了大幅度下降</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Benchmark    Mode  Cnt       Score       Error  Units</span><br><span class="line">Test.test1  thrpt    5  210418.245 ± 40126.738  ops/s</span><br><span class="line">Test.test2  thrpt    5  627385.384 ± 27072.723  ops/s</span><br><span class="line">Test.test3  thrpt    5  640138.597 ± 11598.502  ops/s</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong><br>在刚才的示例中，<code>doSum()</code>方法是否内联会影响<code>elements</code>成员变量读取的优化<br>如果<code>doSum()</code>方法内联了，刚才的<code>test1</code>方法会被优化成下面的样子（伪代码）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Benchmark</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;  </span><br><span class="line"> <span class="comment">//elements.length 首次读取会缓存起来，后续的所有操作都是从缓存中进行的 --&gt; int[] local</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; elements.length; i++) &#123;   <span class="comment">//后续999次求长度 &lt;-- local</span></span><br><span class="line">        doSum(elements[i]);  <span class="comment">// 1000 次取下标 i 的元素 &lt;-- local </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>可以省去 <code>1999</code> 次<code>Field</code>读取操作<br>但如果<code>doSum()</code>方法没有内联，则不会有上面的优化</p>
<h3 id="反射优化"><a href="#反射优化" class="headerlink" title="反射优化"></a>反射优化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;foo...&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException, IOException </span>&#123;  </span><br><span class="line">        Method foo = Test.class.getMethod(<span class="string">&quot;foo&quot;</span>);  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">16</span>; i++) &#123;  </span><br><span class="line">            System.out.printf(<span class="string">&quot;%d\t&quot;</span>,i);  </span><br><span class="line">            foo.invoke(<span class="keyword">null</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.in.read();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>foo.invoke()</code>前面0-15次调用，使用的是 MethodAccessor 的 NativeMethodAccessorImpl 实现<br> 之后会生成一个新的实现<br>下面的代码是 <code>NativeMethodAccessorImpl</code> 类删减之后的内容<br>可以看到，每次调用<code> this.numInvocations</code> 都会加一，当大于<code>ReflectionFactory.inflationThreshold()</code>的结果时就会进入判断中的内容，而判断中会通过字节码技术，重新生成一个 <code>MethodAccessorImpl</code> 的实现类 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NativeMethodAccessorImpl</span> <span class="keyword">extends</span> <span class="title">MethodAccessorImpl</span> </span>&#123;  </span><br><span class="line">	......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object var1, Object[] var2)</span> <span class="keyword">throws</span> IllegalArgumentException, InvocationTargetException </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (++<span class="keyword">this</span>.numInvocations &gt; ReflectionFactory.inflationThreshold() &amp;&amp; !ReflectUtil.isVMAnonymousClass(<span class="keyword">this</span>.method.getDeclaringClass())) &#123;  </span><br><span class="line">            MethodAccessorImpl var3 = (MethodAccessorImpl)(<span class="keyword">new</span> MethodAccessorGenerator()).generateMethod(<span class="keyword">this</span>.method.getDeclaringClass(), <span class="keyword">this</span>.method.getName(), <span class="keyword">this</span>.method.getParameterTypes(), <span class="keyword">this</span>.method.getReturnType(), <span class="keyword">this</span>.method.getExceptionTypes(), <span class="keyword">this</span>.method.getModifiers());  </span><br><span class="line">            <span class="keyword">this</span>.parent.setDelegate(var3);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> invoke0(<span class="keyword">this</span>.method, var1, var2);  </span><br><span class="line">    &#125;  </span><br><span class="line">	  ........</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Object <span class="title">invoke0</span><span class="params">(Method var0, Object var1, Object[] var2)</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过 阿里巴巴提供的工具包 arthas-boot 来查看通过字节码技术生成的类  下载路径：   <a href="https://arthas.gitee.io/arthas-boot.jar">https://arthas.gitee.io/arthas-boot.jar</a><br><code>java -jar .\arthas-boot.jar</code><br>工具启动后会列出来对应的程序，主要选择自己想要查看的程序即可<br><img src="/2022/08/20/JVM/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B/%E9%BB%91%E9%A9%ACJVM%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-20220902062543333.png"></p>
<p>然后使用 <code>jad sun.reflect.GeneratedMethodAccessor1</code> 命令，后面是需要查看的类的全限定名称<br>下面是自动生成的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Decompiled with CFR.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Could not load the following classes:</span></span><br><span class="line"><span class="comment"> *  com.example.demo1.test11.Test</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> sun.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.demo1.test11.Test;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> sun.reflect.MethodAccessorImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeneratedMethodAccessor1</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">MethodAccessorImpl</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Loose catch block</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object object, Object[] objectArray)</span> <span class="keyword">throws</span> InvocationTargetException </span>&#123;</span><br><span class="line">		    <span class="comment">//如果有参数，直接抛出非法参数异常</span></span><br><span class="line">		    <span class="comment">//会根据调用方法的实际情况来生成，如果方法有一个参数，则会限制为1个参数</span></span><br><span class="line">		    <span class="comment">//如果方法为普通方法，object为对象，会使用object.fangfa()调用</span></span><br><span class="line">        block4: &#123;</span><br><span class="line">            <span class="keyword">if</span> (objectArray == <span class="keyword">null</span> || objectArray.length == <span class="number">0</span>) <span class="keyword">break</span> block4;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">	        <span class="comment">//可以看到，这里已经是使用直接调用了</span></span><br><span class="line">            Test.foo();</span><br><span class="line">            <span class="comment">//没有返回值</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvocationTargetException(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ClassCastException | NullPointerException runtimeException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="keyword">super</span>.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>注意：</em><br>通过查看 <code>ReflectionFactory</code> 源码可以知道：</p>
<ul>
<li><code>sun.reflect.noInflation</code> 可以用来禁止膨胀（直接生成 <code>sun.reflect.GeneratedMethodAccessor1</code>，但是首次生成比较耗时，如果反射只使用一次，不划算）</li>
<li><code>sun.reflect.inflationThreshold</code> 可以修改膨胀阀值</li>
</ul>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>黑马JVM课程</tag>
      </tags>
  </entry>
</search>
