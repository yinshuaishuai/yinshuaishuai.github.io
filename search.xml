<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux命令</title>
    <url>/2021/10/20/Linux%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h2><p>就是list的缩写，通过ls命令不仅可以查看linux文件夹包含的文件，而且可以查看文件的权限，查看目录等信息  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -a     # 列出所有目录所有文件，包含.开始的隐藏文件</span><br><span class="line">ls -A     # 列出除.及..的其他文件</span><br><span class="line">ls -r     # 反序排列</span><br><span class="line">ls -t     # 以文件修改时间排序</span><br><span class="line">ls -S     # 以文件大小排序</span><br><span class="line">ls -h     # 以易读大小排序</span><br><span class="line">ls -l     # 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来</span><br></pre></td></tr></table></figure>

<h2 id="ll命令"><a href="#ll命令" class="headerlink" title="ll命令"></a>ll命令</h2><p>相当于<code>ls -l</code>命令的缩写，具体参数和<code>ls</code>命令相同</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ll</span><br></pre></td></tr></table></figure>

<h2 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h2><p>cd命令语法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd [目录名]</span><br></pre></td></tr></table></figure>
<p>进入根目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /</span><br></pre></td></tr></table></figure>
<p>进入用户目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~</span><br></pre></td></tr></table></figure>

<h2 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h2><p>查看当前工作目录路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwd         # 查看当前路径</span><br><span class="line">pwd -P      # 查看软连接的实际路径</span><br></pre></td></tr></table></figure>

<h2 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h2><p>用于创建文件夹<br>可用选项：</p>
<ul>
<li><strong>-m</strong>：对新建目录设置存取权限，也可以使用<code>chmod</code>命令设置</li>
<li><strong>-p</strong>：可以是一个路径名称，此时若路径中的某些目录尚不存在，加上此选项后，系统将自动创建那些不存在的目录，即一次可以创建多层目录<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir t                     # 在当前工作目录下创建文件夹名称为t的目录</span><br><span class="line">mkdir -p /tmp/test/t1/t     # 创建多层目录</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h2><p>删除一个目录中的一个或者多个文件或者目录，如果没有使用-r选项，则rm不会删除目录。如果使用rm来删除文件，通常仍可以将该文件恢复原状。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm [选项] 文件...</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm -i *.log         # 删除所有.log文件，删除前逐一询问确认</span><br><span class="line">rm -rf test         # 删除test目录以及其子目录中的所有文件并不用一一确认</span><br><span class="line">rm -- -f*           # 删除所有以f开头的文件</span><br></pre></td></tr></table></figure>

<h2 id="rmdir命令"><a href="#rmdir命令" class="headerlink" title="rmdir命令"></a>rmdir命令</h2><p>从一个目录中删除一个或者多个子目录，删除某个目录时必须拥有其父目录的写权限（不能删除非空目录）  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rmdir -p parent/chid/chid1      # 当parent子目录被删除后，它也成为空目录的话，也会一并删除</span><br></pre></td></tr></table></figure>

<h2 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h2><p>移动文件或者修改文件名，根据第二个参数类型（如目录，则移动文件，如为文件名，则重命名该文件）<br>当第二个参数为目录时，第一个参数可以是多个以空格分隔的文件或者目录，然后移动第一个参数指定的多个文件到第二个参数指定的目录中。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv test.log test1.txt                   # 将test.log重命名为test1.txt</span><br><span class="line">mv log1.txt log2.txt log3.txt /test     # 将log1.txt log2.txt log3.txt三个文件移动到根目录下的test目录中</span><br><span class="line">mv -i log1.txt log2.txt                 # 将文件1改名为文件2，如果文件2已经存在，则询问是否覆盖</span><br><span class="line">mv * ../                                # 移动当前文件夹下的所有文件到上一级目录</span><br></pre></td></tr></table></figure>

<h2 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h2><p>将源文件复制至目标文件，或将多个源文件复制到目标目录<br>注意：命令行复制，如果目标文件已经存在，会提示是否覆盖，而在shell脚本中，如果不加<code>-i</code>参数，则不会提示，而是直接覆盖</p>
<ul>
<li><strong>-i</strong>：提示</li>
<li><strong>-r</strong>：复制目录及目录中的所有文件</li>
<li><strong>-a</strong>：复制的文件与源文件时间保持一致<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp -ai a.txt test       # 复制a.txt到test目录下，保持源文件时间，如果源文件存在，提示是否覆盖</span><br><span class="line">cp -s a.txt link_a.txt  # 为a.txt建立一个连接（快捷方式）</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h2><p>cat命令三大功能：<br>1.一次显示整个文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat filename</span><br></pre></td></tr></table></figure>
<p>2.从键盘创建一个文件(只能创建文件，不能编辑已存在的文件)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat &gt; filename</span><br></pre></td></tr></table></figure>
<p>3.将几个文件合并成一个文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat file1 file2 &gt; file</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>-b</strong>：对非空输出行号</li>
<li><strong>-n</strong>：输出所有行号<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat -n log1.log log2.log        # 将log1.log的文件内容加上行号后输入到log2.log文件里面</span><br><span class="line">cat -b log1.lo log2.lo log.log  # 将log1.log和log2.log的文件内容加上行号（空白行不加）之后将内容附加到log.log里面</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="more命令"><a href="#more命令" class="headerlink" title="more命令"></a>more命令</h2><p>功能类似于cat，more会一页一页的显示方便使用者逐页阅读，而最基本的指令就算按空白键（space）就往下一页显示，按b键就会往回（back）一页显示<br><strong>命令参数：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+n          # 从第n行开始显示</span><br><span class="line">-n          # 定义屏幕大小未n行</span><br><span class="line">+/pattern   # 再每个档案显示前搜索该字符串（pattern），然后从该字符串前两行之后开始显示</span><br><span class="line">-c          # 从顶部清屏，然后显示</span><br><span class="line">-d          # 提示“Press space to continue &#x27;q&#x27; to quit(按空格键继续，按q键退出)”，禁用响铃功能</span><br><span class="line">-l          # 忽略Ctrl+l（换页）字符</span><br><span class="line">-p          # 通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似</span><br><span class="line">-s          # 把连续的多个空行显示为一行</span><br><span class="line">-u          # 把文件内容中的下划线去掉</span><br></pre></td></tr></table></figure>
<p><strong>常用的操作命令：</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Enter       # 向下n行，需要定义，默认为1行</span><br><span class="line">Ctrl+f      # 向下滚动一屏</span><br><span class="line">空格键       # 向下滚动一屏</span><br><span class="line">Ctrl+B      # 返回上一屏</span><br><span class="line">=           # 输出当前行的行号</span><br><span class="line">:f          # 输出文件名和当前行号</span><br><span class="line">V           # 调用vi编辑器</span><br><span class="line">!           # 调用shell，并执行命令</span><br><span class="line">q           # 退出more</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">more +3 text.txt        # 显示文件中从第三行开始的内容</span><br><span class="line">ls -l | more -5         # 再所列出的文件目录信息中，借助管道符每次显示5行</span><br></pre></td></tr></table></figure>

<h2 id="less命令"><a href="#less命令" class="headerlink" title="less命令"></a>less命令</h2><p>less与more类似，但使用less可以随意浏览文件，而more仅能向前移动，却不能向后移动，而且less在查看直接之前不会加载整个文件<br><strong>常用命令参数：</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-i          # 忽略搜索时的大小写</span><br><span class="line">-N          # 显示每行的行号</span><br><span class="line">-o          # &lt;文件名&gt; 将less输出的内容在指定文件中保存起来</span><br><span class="line">-s          # 显示连续空行为一行</span><br><span class="line">/字符串      # 向下搜索字符串的功能</span><br><span class="line">?字符串      # 向上搜索字符串的功能</span><br><span class="line">n           # 重复前一个搜索</span><br><span class="line">N           # 反向重复前一个搜索</span><br><span class="line">-x          # &lt;数字&gt; 将“tab”键显示为规定的数字空格</span><br><span class="line">b           # 向后翻一页</span><br><span class="line">d           # 向后翻半页</span><br><span class="line">h           # 显示帮助界面</span><br><span class="line">Q           # 退出less命令</span><br><span class="line">u           # 向前滚动半页</span><br><span class="line">y           # 向前滚动一行</span><br><span class="line">空格键       # 滚动一行</span><br><span class="line">回车键       # 滚动一行</span><br><span class="line">[pagediwn]  # 向下翻动一页</span><br><span class="line">[pageup]    # 向上翻动一页</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -aux | less -N       # ps查看进程信息，并通过less分页显示</span><br><span class="line">less 1.log z.log        # 查看多个文件(可以通过n查看下一个，p查看前一个)</span><br></pre></td></tr></table></figure>





















































































<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>通过gitee和hexo搭建个人博客</title>
    <url>/2021/06/12/%E9%80%9A%E8%BF%87gitee%E5%92%8Chexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul>
<li>git（提供git命令）<a href="https://git-scm.com/">git官网</a></li>
<li>node（hexo依赖）<a href="https://nodejs.org/en/">nodejs官网</a></li>
<li>gitee（事先注册码云账号）<a href="https://gitee.com/">码云主页</a></li>
<li>编辑器（根据个人喜好使用即可）</li>
</ul>
<h2 id="码云配置"><a href="#码云配置" class="headerlink" title="码云配置"></a>码云配置</h2><p>在gitee上创建一个仓库<br><img src="/2021/06/12/%E9%80%9A%E8%BF%87gitee%E5%92%8Chexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/gitee%E6%96%B0%E5%BB%BA%E4%BB%93%E5%BA%93.png" alt="gitee新建仓库"><br>点击Gitee Pages配置博客地址<br><img src="/2021/06/12/%E9%80%9A%E8%BF%87gitee%E5%92%8Chexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/gitee%E9%85%8D%E7%BD%AE%E5%8D%9A%E5%AE%A2.png" alt="gitee配置博客"><br>具体命名格式可查看下面连接<br><a href="https://gitee.com/help/articles/4136#article-header0">gitee帮助中心</a>  </p>
<h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><blockquote>
<p>其他软件安装步骤省略，此处只说说hexo的安装和配置  </p>
</blockquote>
<ul>
<li>通过npm安装hexo<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g hexo 		# -g 指定全局安装，可以使用hexo命令</span><br></pre></td></tr></table></figure></li>
<li>打开工作文件夹，执行以下命令<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo init test		# 初始化创建，会在工作文件夹下创建test文件夹</span><br><span class="line">cd test				# 进入test目录</span><br><span class="line">npm install			# 进一步安装hexo所需文件</span><br></pre></td></tr></table></figure></li>
<li>安装之后可以启动进行预览<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo clean			# 清除所有记录</span><br><span class="line">hexo generate		# 生成静态网页</span><br><span class="line">hexo server     	# 启动服务,默认是在4000端口启动，可使用-p参数指定启动端口</span><br></pre></td></tr></table></figure></li>
<li>访问<a href="http://localhost:4000/">http://localhost:4000</a>预览<br><img src="/2021/06/12/%E9%80%9A%E8%BF%87gitee%E5%92%8Chexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A1%B5.png" alt="hexo默认主页">  </li>
</ul>
<blockquote>
<p>想要更换主题可以访问 <a href="https://hexo.io/themes/">hexo官网主题</a> 预览下载<br>将下载的主题放到themes文件夹下，然后更改_config.yml配置即可</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">sky</span>   <span class="comment">#值为你放在themes文件夹里的主题文件夹名称</span></span><br></pre></td></tr></table></figure>
<p>其他配置可以参考<a href="https://hexo.io/zh-cn/docs/">hexo官方文档</a></p>
<p>新建文章</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new test		# 会在test/source/_posts下会生成test.md文件</span><br></pre></td></tr></table></figure>

<h2 id="上传gitee"><a href="#上传gitee" class="headerlink" title="上传gitee"></a>上传gitee</h2><ul>
<li>需要先安装一个插件  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save  #安装git插件</span><br></pre></td></tr></table></figure></li>
<li>复制刚刚gitee创建的项目的url，打开_config.yml文件进行配置<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://gitee.com/ysymj/ysymj</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo deploy	# 上传到gitee</span><br><span class="line"><span class="meta">#</span><span class="bash">上传时会提示输入gitee的账户密码</span></span><br></pre></td></tr></table></figure></li>
<li>点击仓库主页-&gt;服务-&gt;Gitee Pages<br><img src="/2021/06/12/%E9%80%9A%E8%BF%87gitee%E5%92%8Chexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/gitee%E9%85%8D%E7%BD%AE%E5%8D%9A%E5%AE%A2.png" alt="gitee配置博客">  </li>
<li>点击更新，之后就可以通过配置的网址进行访问了<br><img src="/2021/06/12/%E9%80%9A%E8%BF%87gitee%E5%92%8Chexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2.png" alt="更新博客"></li>
</ul>
<h2 id="hexo博客访问图片问题"><a href="#hexo博客访问图片问题" class="headerlink" title="hexo博客访问图片问题"></a>hexo博客访问图片问题</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-image --save	# 安装hexo插件</span><br></pre></td></tr></table></figure>

<ul>
<li>修改_config.yml配置<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li>
<li>打开<code>/node_modules/hexo-asset-image/index.js</code>文件，将文件内容替换为一下内容<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">&#x27;cheerio&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPosition</span>(<span class="params">str, m, i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.split(m, i).join(m).length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> version = <span class="built_in">String</span>(hexo.version).split(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">hexo.extend.filter.register(<span class="string">&#x27;after_post_render&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> config = hexo.config;</span><br><span class="line">  <span class="keyword">if</span>(config.post_asset_folder)&#123;</span><br><span class="line">        <span class="keyword">var</span> link = data.permalink;</span><br><span class="line">    <span class="keyword">if</span>(version.length &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">Number</span>(version[<span class="number">0</span>]) == <span class="number">3</span>)</span><br><span class="line">       <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">       <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.</span></span><br><span class="line">    <span class="keyword">var</span> endPos = link.lastIndexOf(<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line">    link = link.substring(beginPos, endPos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> toprocess = [<span class="string">&#x27;excerpt&#x27;</span>, <span class="string">&#x27;more&#x27;</span>, <span class="string">&#x27;content&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; toprocess.length; i++)&#123;</span><br><span class="line">      <span class="keyword">var</span> key = toprocess[i];</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">var</span> $ = cheerio.load(data[key], &#123;</span><br><span class="line">        <span class="attr">ignoreWhitespace</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">xmlMode</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">lowerCaseTags</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">decodeEntities</span>: <span class="literal">false</span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      $(<span class="string">&#x27;img&#x27;</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ($(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>))&#123;</span><br><span class="line">            <span class="comment">// For windows style path, we replace &#x27;\&#x27; to &#x27;/&#x27;.</span></span><br><span class="line">            <span class="keyword">var</span> src = $(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span>(!<span class="regexp">/http[s]*.*|\/\/.*/</span>.test(src) &amp;&amp;</span><br><span class="line">               !<span class="regexp">/^\s*\//</span>.test(src)) &#123;</span><br><span class="line">              <span class="comment">// For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed.</span></span><br><span class="line">              <span class="comment">// In addition, to support multi-level local directory.</span></span><br><span class="line">              <span class="keyword">var</span> linkArray = link.split(<span class="string">&#x27;/&#x27;</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">              &#125;);</span><br><span class="line">              <span class="keyword">var</span> srcArray = src.split(<span class="string">&#x27;/&#x27;</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span> &amp;&amp; elem != <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">              &#125;);</span><br><span class="line">              <span class="keyword">if</span>(srcArray.length &gt; <span class="number">1</span>)</span><br><span class="line">                srcArray.shift();</span><br><span class="line">              src = srcArray.join(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">              $(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>, config.root + link + src);</span><br><span class="line">              <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">&quot;update link as:--&gt;&quot;</span>+config.root + link + src);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">&quot;no src attr, skipped...&quot;</span>);</span><br><span class="line">            <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info($(<span class="built_in">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      data[key] = $.html();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new test		# 生成新的文章</span><br></pre></td></tr></table></figure>
<p>执行命令生成新的文章，在生成新的文章的时候，会在同级目录下生成一个同名的文件夹，将图片放在文件夹中，md文件中图片配置为同级目录即可</p>
<h2 id="博客评论功能"><a href="#博客评论功能" class="headerlink" title="博客评论功能"></a>博客评论功能</h2><p>本博客评论功能是基于<code>valine</code>实现。<br>1.注册账号<br>需要登录leancloud（<a href="https://console.leancloud.cn/">https://console.leancloud.cn/</a> ）网站注册账号<br><img src="/2021/06/12/%E9%80%9A%E8%BF%87gitee%E5%92%8Chexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/leancloud%E7%99%BB%E5%BD%95.png" alt="leancloud登录"></p>
<p>2.创建应用<br>登录后点击创建应用，应用名称随便填，一般免费版使用开发板即可，使用商用版也可以，不过需要费出一定的费用。<br><img src="/2021/06/12/%E9%80%9A%E8%BF%87gitee%E5%92%8Chexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/leancloud%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8.png" alt="leancloud创建应用"></p>
<p>3.查看应用key<br>一次点击<code>新建的应用-设置-应用凭证</code>，可以看到入下图，复制AppID和AppKey一会需要用到。<br><img src="/2021/06/12/%E9%80%9A%E8%BF%87gitee%E5%92%8Chexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/leancloud-key%E6%9F%A5%E7%9C%8B.png" alt="leancloud-key查看"></p>
<p>4.改代码<br>在项目的<code>_config.yml</code>中增加以下配置，其中的appId和appKey就是上面复制的AppID和AppKey。    </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">comment:</span></span><br><span class="line">  <span class="attr">appId:</span> <span class="string">leancloud中的AppID</span></span><br><span class="line">  <span class="attr">appKey:</span> <span class="string">leancloud中的AppKey</span></span><br></pre></td></tr></table></figure>
<p>修改模板文件，在对应的模板中增加以下代码，作者的是<code>post.ejs</code>，具体应该会根据模板的不同而有所不同。  </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;comment-container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&#x27;//unpkg.com/valine/dist/Valine.min.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Valine(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">&#x27;#comment-container&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">appId</span>: <span class="string">&#x27;&lt;%- config.comment.appId %&gt;&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">appKey</span>: <span class="string">&#x27;&lt;%- config.comment.appKey %&gt;&#x27;</span></span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>中介者模式</title>
    <url>/2021/10/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>定义一个封装一组对象如何交互的对象；<br>通过使对象明确地相互引用来促进松散耦合，并允许独立的改变它们的交互；<br>行为型</p>
</blockquote>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li>系统对象之间存在复杂的引用关系，产生的相互依赖关系结构混乱且难以理解；</li>
<li>交互的公共行为，如果需要改变行为则可以增加新的中介类。</li>
</ul>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>将一对多转化成了一对一，降低程序复杂度</li>
<li>类之间的解耦</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>中介者过多，导致系统复杂</li>
</ul>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><ul>
<li><strong>抽象中介者角色</strong>：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。</li>
<li><strong>具体中介者角色</strong>：实现中介者接口，定义一个List来管理同事对象，协调各个同事之间的交互关系，因此它依赖于同事角色。</li>
<li><strong>抽象同事类角色</strong>：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。</li>
<li><strong>具体同事类角色</strong>：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>假设有一个中介小刘，做房产中介，有两个房东来找租客<br>抽象中介者角色，可以理解为中介这一个行业  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Colleague colleague)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">relay</span><span class="params">(Colleague cl)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体中介者角色<br>中介小刘，聚合了同事角色，也就是聚合了房东，保留房东的联系方式，两个方法，一个保存房东联系方式，一个给房东联系的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoLiuMediator</span> <span class="keyword">extends</span> <span class="title">Mediator</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Colleague&gt; colleagues = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Colleague colleague)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!colleagues.contains(colleague)) &#123;</span><br><span class="line">            colleagues.add(colleague);</span><br><span class="line">            colleague.setMedium(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">relay</span><span class="params">(Colleague cl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Colleague ob : colleagues) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ob.equals(cl)) &#123;</span><br><span class="line">                ob.receive();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抽象同事类角色<br>聚合了一个中介，有三个方法，一个是保存中介信息，一个是联系中介租房的，一个是讨价还价的  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Mediator mediator;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMedium</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体同事类角色1  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LandlordColleague1</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;2000少一分都不行。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我有房子要出租。&quot;</span>);</span><br><span class="line">        mediator.relay(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体同事类角色2  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LandlordColleague2</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1800一分都不能少。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我也有房子要出租。&quot;</span>);</span><br><span class="line">        mediator.relay(<span class="keyword">this</span>); <span class="comment">//请中介者转发</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端调用  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Mediator mediator = <span class="keyword">new</span> XiaoLiuMediator();</span><br><span class="line"></span><br><span class="line">        Colleague l1 = <span class="keyword">new</span> LandlordColleague1();</span><br><span class="line">        Colleague l2 = <span class="keyword">new</span> LandlordColleague2();</span><br><span class="line"></span><br><span class="line">        mediator.register(l1);</span><br><span class="line">        mediator.register(l2);</span><br><span class="line"></span><br><span class="line">        l1.send();</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------&quot;</span>);</span><br><span class="line">        l2.send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我有房子要出租。</span><br><span class="line">1800一分都不能少。</span><br><span class="line">-------------------</span><br><span class="line">我也有房子要出租。</span><br><span class="line">2000少一分都不行。</span><br></pre></td></tr></table></figure>

<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><img src="http://www.plantuml.com/plantuml/svg/bP9FQuCm6CRl-HJlCIjKsAxhXB6hEss7mTZXhRv883KbUNKhnUy-jJKnLXcx1Nt-_F8exXrRp1boZSx1AnKAsLWuYsEzroe770MDKGLOAfLZilB5Q4rOrWJvUBfxNFDeF4qDkbEsGbmQFnIQJDM-c7wOgYAGT21MDSW4MTUyyp5fA7Rm11LzmxErU1fKgGmmVtF3kPs9Ru1xIOUCyLf1qbCQffof21iUheSOnH7tYleWRuHT3RHh8-Qa6f9h8xjkD3dTDSEgqCOMdl7UJnjXH_U-Tim7kOGFSElv3__9X-M2IVuxEGv-nyYZ-82gacziLLL-VW7QqerEF-XccmOA4NXssut_F48iJ9GaQH0iN35wFmrEalcVBCHmXSZXdtZdBm00">




























<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>享元模式</title>
    <url>/2021/09/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>运用共享技术来有效地支持大量细粒度对象的复用；<br>它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率。</p>
</blockquote>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li>常常应用于系统底层的开发，以便解决系统的性能问题；  </li>
<li>系统有大量相似对象、需要缓冲池的场景。  </li>
</ul>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>减少对象的创建，降低内存中对象的数量，降低系统的内存，提高效率；  </li>
<li>减少内存之外的其他资源占用。  </li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>关注内/外部状态、关注线程安全问题</li>
<li>使系统、程序逻辑复杂化</li>
</ul>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>享元模式的定义提出了两个要求，细粒度和共享对象。因为要求细粒度，所以不可避免地会使对象数量多且性质相似，此时我们就将这些对象的信息分为两个部分：<strong>内部状态</strong>和<strong>外部状态</strong>  </p>
<ul>
<li><strong>内部状态</strong>： 指对象共享出来的信息，存储在享元信息内部，并且不会随环境的改变而改变。  </li>
<li><strong>外部状态</strong>： 指对象得以依赖的一个标记，随环境的改变而改变，不可共享。 </li>
</ul>
<p>主要角色：<br><strong>抽象享元角色</strong>： 是所有的具体享元类的基类，为具体享元规范要求实现的公共接口，非享元的外部状态以参数的形式通过方法传入；<br><strong>具体享元角色</strong>：实现抽象享元角色中所规定的接口；<br><strong>非享元角色</strong>： 是不可共享的外部状态，它以参数的形式注入具体享元的相关方法中；<br><strong>享元工厂角色</strong>： 负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检查系统中是否存在符合要求的享元对象，如果存在则提供给客户，如果不存在的话，则创建一个新的享元对象。  </p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>我们在工作中，经常有一些需求文档，设计文档，接口文档等等，其实每次的文档格式是基本一样的只是内容不同，所以我们可以把文档模板做成享元对象，只需要每次在里面填充不同的内容即可  </p>
<p>首先我们创建非享元角色，文档内容，就算模板相同，每个模板的具体内容也是不同，属于外部状态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DocContent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DocContent</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建抽象享元角色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Template</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createDoc</span><span class="params">(DocContent content)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体享元角色，其中的<code>templateName</code>字段就是内部状态，每个模板的模板名称是相同的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DocTemplate</span> <span class="keyword">implements</span> <span class="title">Template</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String templateName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DocTemplate</span><span class="params">(String templateName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.templateName = templateName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createDoc</span><span class="params">(DocContent content)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前模板是：&quot;</span>+templateName+<span class="string">&quot;  内容是：&quot;</span>+content.getContent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建享元工厂，这里是使用<code>HashMap</code>来做享元对象的存储，<code>HashMap</code>属于非线程安全的，所以如果是在并发的情况下，可能会有并发问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DocFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String,DocTemplate&gt; TEMPLATE_MAP = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Template <span class="title">getTemplate</span><span class="params">(String templateName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!TEMPLATE_MAP.containsKey(templateName))&#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;新建模板：&quot;</span>+templateName+<span class="string">&quot;   &quot;</span>);</span><br><span class="line">            TEMPLATE_MAP.put(templateName,<span class="keyword">new</span> DocTemplate(templateName));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> TEMPLATE_MAP.get(templateName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体调用，这里使用随机数连续10次调用来查看输出内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] templateNames = &#123;<span class="string">&quot;需求文档&quot;</span>,<span class="string">&quot;接口文档&quot;</span>,<span class="string">&quot;设计文档&quot;</span>,<span class="string">&quot;简历&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DocFactory factory = <span class="keyword">new</span> DocFactory();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            String templateName = templateNames[(<span class="keyword">int</span>) (Math.random() * templateNames.length)];</span><br><span class="line">            Template template = factory.getTemplate(templateName);</span><br><span class="line">            template.createDoc(<span class="keyword">new</span> DocContent(templateName+<span class="string">&quot;的内容是&quot;</span>+i+<span class="string">&quot;.....&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果，从结果中可以看出，每一种模板在第一次使用的时候会创建新的，但是后续再次调用的时候就不会再新创建对象，而模板的内容每次调用都是不一样的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">新建模板:  接口文档   当前模板是:  接口文档  内容是:  接口文档的内容是0.....</span><br><span class="line">新建模板:  设计文档   当前模板是:  设计文档  内容是:  设计文档的内容是1.....</span><br><span class="line">新建模板:  需求文档   当前模板是:  需求文档  内容是:  需求文档的内容是2.....</span><br><span class="line">当前模板是:  设计文档  内容是:  设计文档的内容是3.....</span><br><span class="line">当前模板是:  设计文档  内容是:  设计文档的内容是4.....</span><br><span class="line">当前模板是:  接口文档  内容是:  接口文档的内容是5.....</span><br><span class="line">新建模板:  简历   当前模板是:  简历  内容是:  简历的内容是6.....</span><br><span class="line">当前模板是:  接口文档  内容是:  接口文档的内容是7.....</span><br><span class="line">当前模板是:  设计文档  内容是:  设计文档的内容是8.....</span><br><span class="line">当前模板是:  设计文档  内容是:  设计文档的内容是9.....</span><br></pre></td></tr></table></figure>

<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><img src="http://www.plantuml.com/plantuml/svg/XKzB3e8m4Dtt5BC4eru0D25-ua8CYUnDhICsWK9AnHZYtQrIclgBgqxdpVkndDOrp4isAuL2eQ0bbUGDLGXR9Rd8W7L0G6w4S3tA8sK8AHPL_hXgILFo0p29-gTrF4VBKFqdb_LEbihrYuK-gAtSXxiom8OM693glCyvW_-EqDvUF9UKgL9UdNP7BcWECQt2pcde99j2keYJTPGkTd6Km0G4Nc15wzFZVEhvDeYjag7gP-zBSh-BumGDnsFBVjyxIGYn5WOnJPvYlx0NQ3GQEDWT">




<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>代理模式</title>
    <url>/2021/09/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>为其他对象提供一种代理，以控制对这个对象的访问<br>代理对象在客户端和目标对象之间起到中介的作用  </p>
</blockquote>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>代理模式能将代理对象与真实被调用的目标对象分离</li>
<li>一定程度上降低了系统的耦合度，扩展性好</li>
<li>保护目标对象</li>
<li>增强目标对象</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>代理模式会造成系统设计中类的数目增加   </li>
<li>在客户端和目标对象增加一个代理对象，会造成请求处理速度变慢  </li>
<li>增加系统的复杂度  </li>
</ul>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><blockquote>
<p>JDk的静态代理要求目标对象和代理对象都要实现相同的接口。然后提供给客户端使用。这个代理对客户端是可见的。</p>
</blockquote>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>假设一个场景，现在我们要保存一个用户信息，想要在保存用户之前或者之后做一些校验处理<br>建一个接口，里面是我们要实现的方法  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">saveUser</span><span class="params">(<span class="keyword">int</span> age,String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个接口的实现，也就是要被代理的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">saveUser</span><span class="params">(<span class="keyword">int</span> age, String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用户名：&quot;</span> + name + <span class="string">&quot;  用户年龄：&quot;</span> + age);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再创建一个接口的实现，这个就是我们的代理类，这里将被代理的类通过构造函数传入，如果集成了spring，可以通过注入的方式来做  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImplProxy</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceImplProxy</span><span class="params">(UserService userService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">saveUser</span><span class="params">(<span class="keyword">int</span> age, String name)</span> </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        <span class="keyword">int</span> saveUser = userService.saveUser(age, name);</span><br><span class="line">        after();</span><br><span class="line">        <span class="keyword">return</span> saveUser;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置处理&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;后置处理&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserService userService = <span class="keyword">new</span> UserServiceImplProxy(<span class="keyword">new</span> UserServiceImpl());</span><br><span class="line">        userService.saveUser(<span class="number">18</span>, <span class="string">&quot;小明&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果展示，可以在调用被代理的方法之前或者之后做一些处理</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">前置处理</span><br><span class="line">用户名: 小明  用户年龄: 18</span><br><span class="line">后置处理</span><br></pre></td></tr></table></figure>

<h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><img src="http://www.plantuml.com/plantuml/svg/bP1H2i8m343_UufyLd4dc1VmJnWU8AlP27JTIBkYZDtTJHXExGH_GfAIbvUo2oGL6eAB9ob88a_veDW5y1Xfxkgvm9eEHH1sDJXiQ9UhKIbZqVlrvAdfBF0Kg24N_0UqwqlB1f9iMCDX63VnPsblznyxX2E6ztFwLvul4YcgtXXw-lmblrZ4bgzGKjKAwUy7hARFrykrw-N7BDid5Hy0">


<h2 id="JDk动态代理"><a href="#JDk动态代理" class="headerlink" title="JDk动态代理"></a>JDk动态代理</h2><blockquote>
<p>JDk的动态代理要求目标对象必须实现接口，因为它创建代理对象的时候是根据接口创建的，如果不实现接口，jdk无法给目标对象创建代理对象，被代理对象可以实现多个接口，创建代理时指定创建某个接口的代理对象就可以调用该接口中定义的方法了。</p>
</blockquote>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>同样以上面的例子为例，我们要在保存用户信息之前以及之后做一些校验  </p>
<p>建一个接口，里面是我们要实现的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">saveUser</span><span class="params">(<span class="keyword">int</span> age,String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个接口的实现，也就是要被代理的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">saveUser</span><span class="params">(<span class="keyword">int</span> age, String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用户名：&quot;</span> + name + <span class="string">&quot;  用户年龄：&quot;</span> + age);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDk动态代理，需要代理类实现<code>InvocationHandler</code>接口，并实现里面的<code>invoke</code>方法，<code>invoke</code>方法里面有三个参数，分别是当前代理类对象，要代理的方法，方法的参数<br>通过<code>build()</code>方法获取当前的代理类，会通过<code>Proxy</code>的静态方法生成一个代理类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImplProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceImplProxy</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Class&lt;?&gt; aClass = target.getClass();</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(aClass.getClassLoader(), aClass.getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        before();</span><br><span class="line">        Object obj = method.invoke(target, args);</span><br><span class="line">        after();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置处理&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;后置处理&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">前置处理</span><br><span class="line">用户名: 小明  用户年龄: 18</span><br><span class="line">后置处理</span><br></pre></td></tr></table></figure>

<h2 id="CGLib动态代理"><a href="#CGLib动态代理" class="headerlink" title="CGLib动态代理"></a>CGLib动态代理</h2><blockquote>
<p>jdk给目标类提供动态代理要求目标类必须实现接口，当一个目标类不实现接口时，jdk是无法为其提供动态代理的，cglib却能给这样的类提供动态代理。Spring在给某个类提供动态代理时，会自动在jdk动态代理和cglib动态代理中动态选择。</p>
</blockquote>
<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>需要先添加maven依赖（如果直接导入jar包的话，可能会有一些关联的jar包无法引入从而引起一些错误）  </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><p>同样使用上述的例子，不过CGLIB代理主要用于被代理类没有实现接口的情况下，我们被代理类不再实现接口  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">saveUser</span><span class="params">(<span class="keyword">int</span> age, String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用户名：&quot;</span> + name + <span class="string">&quot;  用户年龄：&quot;</span> + age);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写代理类，实现<code>MethodInterceptor</code>接口，并重写里面的<code>intercept</code>方法  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImplProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceImplProxy</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">//设置父类，因为cglib是针对指定的类生成一个子类，所以需要指定父类</span></span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);<span class="comment">//设置回调</span></span><br><span class="line">        Object obj = enhancer.create();<span class="comment">//创建并返回代理对象</span></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置处理&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;后置处理&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        Object invoke = method.invoke(target, objects);</span><br><span class="line">        after();</span><br><span class="line">        <span class="keyword">return</span> invoke;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserServiceImpl userService = (UserServiceImpl) <span class="keyword">new</span> UserServiceImplProxy(<span class="keyword">new</span> UserServiceImpl()).build();</span><br><span class="line">        userService.saveUser(<span class="number">18</span>, <span class="string">&quot;小明&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">前置处理</span><br><span class="line">用户名: 小明  用户年龄: 18</span><br><span class="line">后置处理</span><br></pre></td></tr></table></figure>




















<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2021/07/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>单例模式是java中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。这种模式设计到一个单一的类，该类负责创建自己的对象，同时保证只有单个对象被创建，这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。  </p>
<ul>
<li>单例类只能有一个实例。</li>
<li>单例类必须自己创建自己的唯一实例。</li>
<li>单例类必须给所有其他对象提供这一实例。</li>
</ul>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>意图：</strong> 保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br><strong>主要解决：</strong> 一个全局使用的类频繁地创建与销毁。<br><strong>何时使用：</strong> 当你想控制实例数目，节省系统资源的时候。  </p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul>
<li>构造函数私有。  </li>
<li>判断系统是否已经有这个单例，如果有则返回，如果没有则创建。  </li>
</ul>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例；</li>
<li>避免对资源的多重占用。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</li>
</ul>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>创建一个Singleton类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个Singleton对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取唯一可以用对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//让构造函数私有化，这样改类就不能在外部实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从Singleton类中获取唯一对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//无法通过new调用</span></span><br><span class="line">        <span class="comment">//Singleton singleton = new Singleton();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取唯一可用对象</span></span><br><span class="line">        Singleton instance = Singleton.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><img src="http://www.plantuml.com/plantuml/svg/Iyv9B2vM2CxCIyz9BSdFg-PwshhYwSQ6frFMFzdHy7Bkp6SDZK_NpNkohrj1eQ0eioon95MXk2In93CPeKSXCmyeb9US2jIxvcdhHeYkPzDsFjiy5QYhD2a7g1f3KtfgYITKduOcr_FbZS_cT3wRr_AoOS7JzhtFfcv0s0VNew6fKArGorNBXJ15rmx9I2kuIm00">

<h3 id="单例模式的几种实现方式"><a href="#单例模式的几种实现方式" class="headerlink" title="单例模式的几种实现方式"></a>单例模式的几种实现方式</h3><h4 id="1-饿汉式（静态变量）"><a href="#1-饿汉式（静态变量）" class="headerlink" title="1.饿汉式（静态变量）"></a>1.饿汉式（静态变量）</h4><p><strong>是否懒加载：</strong> 否<br><strong>是否线程安全：</strong> 是<br><strong>描述：</strong> 这种方式比较常用，但是容易产生垃圾。<br><strong>优点：</strong> 没有加锁，执行效率会提高。<br><strong>缺点：</strong> 类加载时就初始化，浪费内存空间。<br>它基于classloader机制避免了多线程的同步问题，不过，instance在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用getInstance方法，但是也不能确定有其他的方式（或其他的静态方法）导致类装载，这时候初始化instance显然没有达到懒加载的效果。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-饿汉式（静态代码块）"><a href="#2-饿汉式（静态代码块）" class="headerlink" title="2.饿汉式（静态代码块）"></a>2.饿汉式（静态代码块）</h4><p><strong>是否懒加载：</strong> 否<br><strong>是否线程安全：</strong> 是<br><strong>描述：</strong> 这种方式比较常用，但是容易产生垃圾。<br><strong>优点：</strong> 没有加锁，执行效率会提高。<br><strong>缺点：</strong> 类加载时就初始化，浪费内存空间。<br>这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候就执行静态代码块中的代码，初始化类的实例。优点和缺点和上面也是一样的。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-懒汉式，线程不安全"><a href="#3-懒汉式，线程不安全" class="headerlink" title="3.懒汉式，线程不安全"></a>3.懒汉式，线程不安全</h4><p><strong>是否懒加载：</strong> 是<br><strong>是否线程安全：</strong> 否<br><strong>描述：</strong> 这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁synchronize，所以严格意义上它并不算单例模式。这种方式懒加载很明显，不要求线程安全，在多线程不能正常工作。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-懒汉式，线程安全"><a href="#4-懒汉式，线程安全" class="headerlink" title="4.懒汉式，线程安全"></a>4.懒汉式，线程安全</h4><p><strong>是否懒加载：</strong> 是<br><strong>是否多线程安全：</strong> 是<br><strong>描述：</strong> 这种方式具备很好的lazy loading，能够在多线程中很好的工作，但是效率很低，99%情况下不需要同步。<br><strong>优点：</strong> 第一次调用才初始化，避免内存浪费。<br><strong>缺点：</strong> 必须加锁synchronize才能保证单例，但加锁会影响效率。<br>getInstance()的性能对应用程序不是很关键（该方法使用不太频繁）。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-双重锁-双重校验锁"><a href="#5-双重锁-双重校验锁" class="headerlink" title="5.双重锁/双重校验锁"></a>5.双重锁/双重校验锁</h4><p>是否懒加载：是<br>是否多线程安全：是<br>描述：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。<br>getInstance()的性能对应用程序很关键，参数需要添加volatile关键字防止指令重排  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-登记式-静态内部类"><a href="#6-登记式-静态内部类" class="headerlink" title="6.登记式/静态内部类"></a>6.登记式/静态内部类</h4><p><strong>是够懒加载：</strong> 是<br><strong>是否多线程安全：</strong> 是<br><strong>描述：</strong> 这种方式能达到双检锁方式一样的效果，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式，这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。<br>这种方式利用了classloader机制来保证初始化instance时只有一个线程，它跟饿汉式不同的是：饿汉式只要类被装载了，那么instance就会被实例化（没有达到懒加载的效果），而这种方式是Singleton类被装载了，instance不一定被初始化，因为SingletonHolder类没有被主动使用，自由通过显式调用getInstance方法时，才会显式装载SingletonHolder类，从而实例化instance。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-枚举"><a href="#7-枚举" class="headerlink" title="7.枚举"></a>7.枚举</h4><p><strong>是否懒加载：</strong> 是<br><strong>是否多线程安全：</strong> 是<br><strong>描述：</strong> 这种方式还没有被广泛使用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。这种方式是Effective Java作者Josh Bloch提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    INSTANCE;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whateverMethod</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="通过反射或序列化破解单例"><a href="#通过反射或序列化破解单例" class="headerlink" title="通过反射或序列化破解单例"></a>通过反射或序列化破解单例</h3><h4 id="反射破解"><a href="#反射破解" class="headerlink" title="反射破解"></a>反射破解</h4><p>单例类（以双检锁为例）：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException, InvocationTargetException, NoSuchMethodException </span>&#123;</span><br><span class="line">        Singleton instance = Singleton.getInstance();</span><br><span class="line">        System.out.println(instance);</span><br><span class="line">        Class c1 = instance.getClass();</span><br><span class="line">        Constructor constructor1 = c1.getDeclaredConstructor(<span class="keyword">null</span>);</span><br><span class="line">        constructor1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        System.out.println(constructor1.newInstance());</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; c2 = Class.forName(<span class="string">&quot;com.Singleton&quot;</span>);</span><br><span class="line">        Constructor constructor2 = c2.getDeclaredConstructor(<span class="keyword">null</span>);</span><br><span class="line">        constructor2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        System.out.println(constructor2.newInstance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过<code>getClass()</code>或者<code>Class.forName()</code>获取class对象，然后通过无参构造创建对象。  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">com.Singleton@1b6d3586</span><br><span class="line">com.Singleton@4554617c</span><br><span class="line">com.Singleton@74a14482</span><br></pre></td></tr></table></figure>

<h4 id="反序列化破解"><a href="#反序列化破解" class="headerlink" title="反序列化破解"></a>反序列化破解</h4><p>如果单例类实现了<code>Serializable</code>接口进行序列化，可以通过反序列化破解。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先将对象序列化到文件，然后从文件中读取对象。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        Singleton instance = Singleton.getInstance();</span><br><span class="line">        System.out.println(instance);</span><br><span class="line">        ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;D:/test.txt&quot;</span>));</span><br><span class="line">        objectOutputStream.writeObject(instance);</span><br><span class="line"></span><br><span class="line">        ObjectInputStream ous = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:/test.txt&quot;</span>));</span><br><span class="line">        Object o = ous.readObject();</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">com.Singleton@1b6d3586</span><br><span class="line">com.Singleton@312b1dae</span><br></pre></td></tr></table></figure>

<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><blockquote>
<p>反射破解是通过调用构造方法进行实例化，只需要在构造方法中跑出异常即可。  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>反序列化方式可以通过增加<code>readResolve()</code>方法解决，这个方法是基于回调的，反序列化时，如果定义了<code>readResolve()</code>则直接返回此方法指定的对象，而不需要再创建新的对象。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用第六种枚举类型实现单例模式，可以避免反射和序列化破解。  </p>
</blockquote>
<ul>
<li>jdk在反射的底层代码中限制了枚举不能通过<code>newInstance()</code>方法获取对象，里面判断类型是否是枚举，如果是直接抛出异常。  </li>
<li>枚举类型在序列化时是将枚举值的name存放到文件中的，反序列化时通过调用<code>valueOf()</code>方法获取对象。  </li>
</ul>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>原型模式</title>
    <url>/2021/09/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。<br>不需要知道任何细节，不调用构造函数。  </p>
</blockquote>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li>类初始化消耗较多资源  </li>
<li>new产生的一个对象需要非常繁琐的过程，（数据准备，访问权限等）  </li>
<li>构造函数比较复杂  </li>
<li>循环体重生产大量对象  </li>
</ul>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>原型模式性能比直接new一个对象性能高  </li>
<li>简化创建过程  </li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>必须配备克隆方法  </li>
<li>对克隆复杂对象或对克隆出的对象进行复杂改造时，容易引入风险  </li>
<li>深拷贝、浅拷贝要运用得当    </li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>假设一个场景，我们要发送大量邮件，邮件的标题发送地址内容，都是不同的或者有部分相同，而创建一个邮件对象假如耗时比较长，我们就可以用克隆来实现   </p>
<p>只要对象类实现<code>Cloneable</code>接口，然后重写<code>clone</code>方法就可以实现简单的克隆</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mail</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line">    <span class="keyword">private</span> String mailAddress;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMailAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mailAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMailAddress</span><span class="params">(String mailAddress)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mailAddress = mailAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTitle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mail <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Mail) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>clone</code>方法中可以根据具体情况添加业务逻辑，具体调用如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Mail mail = <span class="keyword">new</span> Mail();</span><br><span class="line">        Mail clone = mail.clone();</span><br><span class="line">        System.out.println(mail);</span><br><span class="line">        System.out.println(clone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">com.ys.Mail@7f31245a</span><br><span class="line">com.ys.Mail@6d6f6e28</span><br></pre></td></tr></table></figure>

<p>原型模式的克隆是分深克隆和浅克隆的，需要注意使用场景；</p>
<ul>
<li><strong>浅克隆</strong> ：创建一个新的对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。</li>
<li><strong>深克隆</strong> ：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。</li>
</ul>
<p>假设我们给对象类增加一个发送日期的字段，并给日期设置值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Mail mail = <span class="keyword">new</span> Mail();</span><br><span class="line">        mail.setDate(<span class="keyword">new</span> Date(<span class="number">0L</span>));</span><br><span class="line">        Mail clone = mail.clone();</span><br><span class="line">        System.out.println(mail);</span><br><span class="line">        System.out.println(clone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Mail&#123;date=Thu Jan 01 08:00:00 CST 1970&#125;com.ys.Mail@330bedb4</span><br><span class="line">Mail&#123;date=Thu Jan 01 08:00:00 CST 1970&#125;com.ys.Mail@2503dbd3</span><br></pre></td></tr></table></figure>

<p>修改我们克隆出来的对象的日期</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Mail mail = <span class="keyword">new</span> Mail();</span><br><span class="line">        mail.setDate(<span class="keyword">new</span> Date(<span class="number">0L</span>));</span><br><span class="line">        Mail clone = mail.clone();</span><br><span class="line">        clone.getDate().setTime(<span class="number">1630809727754L</span>);</span><br><span class="line">        System.out.println(mail);</span><br><span class="line">        System.out.println(clone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Mail&#123;date=Sun Sep 05 10:42:07 CST 2021&#125;com.ys.Mail@330bedb4</span><br><span class="line">Mail&#123;date=Sun Sep 05 10:42:07 CST 2021&#125;com.ys.Mail@2503dbd3</span><br></pre></td></tr></table></figure>

<p>会发现两个对象依然是不同的对象，但是日期却同时都被修改了<br>在debug模式下可以看出原因，两个对象引用的日期对象依然是同一个对象，就导致两个对象同时被修改<br><img src="/2021/09/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8Fdubug%E5%9B%BE.png" alt="原型模式dubug图"></p>
<p>解决办法就可以使用深克隆</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mail</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line">    <span class="keyword">private</span> String mailAddress;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> Date date;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Mail&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;date=&quot;</span> + date +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>+<span class="keyword">super</span>.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDate</span><span class="params">(Date date)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.date = date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMailAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mailAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMailAddress</span><span class="params">(String mailAddress)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mailAddress = mailAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTitle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mail <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Mail clone = (Mail) <span class="keyword">super</span>.clone();</span><br><span class="line">            clone.date = (Date) date.clone();</span><br><span class="line">            <span class="keyword">return</span> clone;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点看<code>clone</code>方法中的修改，对日期类型也进行了克隆。<br><img src="/2021/09/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E6%B7%B1%E5%85%8B%E9%9A%86debug%E5%9B%BE.png" alt="原型模式深克隆debug图"><br>从图中可以看到，日期类型已经不是同一个对象了。</p>
<h4 id="使用序列化实现深克隆"><a href="#使用序列化实现深克隆" class="headerlink" title="使用序列化实现深克隆"></a>使用序列化实现深克隆</h4><p>上面所描述的深克隆方法，每次如果添加了对象属性都需要在<code>clone</code>方法中进行维护才能实现深克隆，通过序列化实现深克隆可以解决这种问题<br>对象类实现<code>Serializable</code>接口<br>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mail</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line">    <span class="keyword">private</span> String mailAddress;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> Date date;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Mail&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;date=&quot;</span> + date +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>+<span class="keyword">super</span>.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mail <span class="title">mailClone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建流对象</span></span><br><span class="line">        ByteArrayOutputStream bos = <span class="keyword">null</span>;</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayInputStream bis = <span class="keyword">null</span>;</span><br><span class="line">        ObjectInputStream ois= <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//序列化</span></span><br><span class="line">            bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line">            oos.writeObject(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//反序列化</span></span><br><span class="line">            bis = <span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">            ois = <span class="keyword">new</span> ObjectInputStream(bis);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (Mail) ois.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (bos != <span class="keyword">null</span>)</span><br><span class="line">                    bos.close();</span><br><span class="line">                <span class="keyword">if</span> (oos != <span class="keyword">null</span>)</span><br><span class="line">                    oos.close();</span><br><span class="line">                <span class="keyword">if</span> (bis != <span class="keyword">null</span>)</span><br><span class="line">                    bis.close();</span><br><span class="line">                <span class="keyword">if</span> (ois != <span class="keyword">null</span>)</span><br><span class="line">                    ois.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDate</span><span class="params">(Date date)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.date = date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMailAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mailAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMailAddress</span><span class="params">(String mailAddress)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mailAddress = mailAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTitle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义mailClone方法，通过对当前对象序列化然后反序列化的方法，来达到深克隆的目的，这种方法如果在对象类中新增了对象属性，不需要再进行刻意维护<br>调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Mail mail = <span class="keyword">new</span> Mail();</span><br><span class="line">        mail.setDate(<span class="keyword">new</span> Date(<span class="number">0L</span>));</span><br><span class="line">        Mail clone = mail.mailClone();</span><br><span class="line">        clone.getDate().setTime(<span class="keyword">new</span> Date().getTime());</span><br><span class="line">        System.out.println(mail);</span><br><span class="line">        System.out.println(clone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Mail&#123;date=Thu Jan 01 08:00:00 CST 1970&#125;com.ys.Mail@7ea987ac</span><br><span class="line">Mail&#123;date=Sat Sep 11 19:06:14 CST 2021&#125;com.ys.Mail@5b480cf9</span><br></pre></td></tr></table></figure>


<h2 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h2><img src="http://www.plantuml.com/plantuml/svg/oymhIIrAIqnELN3EoSzBJKpAIQskvU9ApaaiBbRmJSpCKSZCBSX9pKtDAob6KiBrTDsyvtqRu0BF-fO-xL_yihttQTlCP93WisaxdssUoWKs0IoWeQa0D1XkT4XgSKarLq5fKavcia9nIM89a2hBpqnHo4tCpDC8BYdAp4kFZbL8B4elXca4csMZfmVMomK0">

<h2 id="克隆模式破解单例"><a href="#克隆模式破解单例" class="headerlink" title="克隆模式破解单例"></a>克隆模式破解单例</h2><p>以最简单的饿汉式单例为例，当单例类实现了<code>Cloneable</code>接口，并实现了<code>clone</code>方法就可以克隆产生多个实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Singleton clone = (Singleton) <span class="keyword">super</span>.clone();</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> copy mutable state here, so the clone can&#x27;t change the internals of the original</span></span><br><span class="line">            <span class="keyword">return</span> clone;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton instance = Singleton.getInstance();</span><br><span class="line">        Singleton clone = instance.clone();</span><br><span class="line">        System.out.println(instance);</span><br><span class="line">        System.out.println(clone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">com.ys.Singleton@7f31245a</span><br><span class="line">com.ys.Singleton@6d6f6e28</span><br></pre></td></tr></table></figure>

<p>解决办法：第一，不实现Cloneable接口，第二，在clone方法中返回会getInstance()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">com.ys.Singleton@7f31245a</span><br><span class="line">com.ys.Singleton@7f31245a</span><br></pre></td></tr></table></figure>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>命令模式</title>
    <url>/2021/10/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>将”请求“封装成对象，以便于使用不同的请求。<br>命令模式解决了应用程序中对象的职责以及它们之间的通信方式<br>行为型</p>
</blockquote>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li>请求调用者和请求接收者需要解耦，使得调用者和接收者不直接交互</li>
<li>需要抽象出等待执行的行为</li>
</ul>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>降低耦合</li>
<li>容易扩展新命令或者一组命令</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>命令的无限扩展会增加类的数量，提高系统实现复杂度</li>
</ul>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><ul>
<li><strong>抽象命令类角色</strong>：声明执行命令的接口，拥有执行命令的抽象方法<code>execute()</code>。</li>
<li><strong>具体命令类角色</strong>：是抽象命令类的具体实现类，它拥有接收者对象，开通过调用接收者的功能来完成命令要执行的操作。</li>
<li><strong>实现者/接收者角色</strong>：执行命令功能的相关操作，是具体命令对象业务的真正实现者。</li>
<li><strong>调用者/请求者角色</strong>：是请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者。</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>假设我们有一台电脑，电脑接收命令，就是接收者，操作人员发送命令，就是调用者<br>创建 抽象命令类角色  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建电脑，也就是具体命令的实现，具体命令类角色  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Computer</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot;被打开了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot;被关闭了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建具体命令角色，开机  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OpenCommand</span> <span class="keyword">implements</span> <span class="title">Command</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Computer computer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OpenCommand</span><span class="params">(Computer computer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.computer = computer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        computer.open();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体命令角色，关机   </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloseCommand</span> <span class="keyword">implements</span> <span class="title">Command</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Computer computer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CloseCommand</span><span class="params">(Computer computer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.computer = computer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        computer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用者，收集命令并执行  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Operator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Command&gt; commands = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCommand</span><span class="params">(Command command)</span></span>&#123;</span><br><span class="line">        commands.add(command);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeCommand</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Command command : commands) &#123;</span><br><span class="line">            command.execute();</span><br><span class="line">        &#125;</span><br><span class="line">        commands.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Computer computer = <span class="keyword">new</span> Computer(<span class="string">&quot;编号为A的电脑 &quot;</span>);</span><br><span class="line">        OpenCommand openCommand = <span class="keyword">new</span> OpenCommand(computer);</span><br><span class="line">        CloseCommand closeCommand = <span class="keyword">new</span> CloseCommand(computer);</span><br><span class="line">        Operator operator = <span class="keyword">new</span> Operator();</span><br><span class="line">        operator.addCommand(openCommand);</span><br><span class="line">        operator.addCommand(closeCommand);</span><br><span class="line">        operator.executeCommand();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">编号为A的电脑 被打开了</span><br><span class="line">编号为A的电脑 被关闭了</span><br></pre></td></tr></table></figure>

<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><img src="http://www.plantuml.com/plantuml/svg/dP5BYiCm38RtEeMMII4dw0DAjeLPp0bSHos6-87jTgO4txrnY1ttiMbtGh_qwvFKQcakdYnkcgPPuOyXrMefcUgWVPJQNZjA6WWrAYV62USK3d3LeaFw9pvsLVKQ0W3lcNEOdGOmLboP9_prLgWpAYPf3UPox0NFPLKXrZY4f4_-UYIiwgSaZsnZ5iCoj5W5XJGzILBU9To59CFnESWyXKFrKlK2bXUFGe0qEj_LCgzjlaXnp2_fIelFyPOZJLp5Pmx2-Stikuj-CN2uHKL_kBUMtQQANVnmEO1rNK4pBJOtr-zHKdMKmnq0">













<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>备忘录模式</title>
    <url>/2021/10/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>保存一个对象的某个状态，以便于在适当的时候恢复对象。<br>“后悔药”<br>行为型</p>
</blockquote>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li>保存及恢复数据相关业务场景</li>
<li>后悔的时候，即像恢复到之前的状态</li>
</ul>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>为用户提供一种可恢复机制</li>
<li>存档信息的封装</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>资源占用。如果类的成员过多，势必会占用比较大大的资源，而且每一次保存都会消耗一定的内存。</li>
</ul>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><ul>
<li><strong>发起人角色</strong>：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里面的所有信息。</li>
<li><strong>备忘录角色</strong>：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。</li>
<li><strong>管理者角色</strong>：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内同进行访问与修改。</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>假设一个场景，我们有一个文档，需要保存不同的版本内容，方便进行回滚操作<br>创建发起人角色： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Word</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Word</span><span class="params">(String title, String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTitle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构建需要保存的备忘录对象，或者直接存数据库</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WordMemento <span class="title">saveToMemento</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WordMemento(<span class="keyword">this</span>.title,<span class="keyword">this</span>.content);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//回退</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undoFormMemento</span><span class="params">(WordMemento wordMemento)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.title = wordMemento.getTitle();</span><br><span class="line">        <span class="keyword">this</span>.content = wordMemento.getContent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Word&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;title=&#x27;&quot;</span> + title + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, content=&#x27;&quot;</span> + content + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建备忘录角色：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordMemento</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WordMemento</span><span class="params">(String title, String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTitle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;WordMemento&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;title=&#x27;&quot;</span> + title + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, content=&#x27;&quot;</span> + content + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建管理者角色：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordMementoManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Stack&lt;WordMemento&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回备忘录保存的上一个版本</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WordMemento <span class="title">getMemento</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMemento</span><span class="params">(WordMemento wordMemento)</span></span>&#123;</span><br><span class="line">        stack.push(wordMemento);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WordMementoManager wordMementoManager = <span class="keyword">new</span> WordMementoManager();</span><br><span class="line">        Word word = <span class="keyword">new</span> Word(<span class="string">&quot;java设计模式A&quot;</span>,<span class="string">&quot;设计模式内同A&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;创建文档，文档内容：&quot;</span>+word);</span><br><span class="line">        WordMemento wordMemento = word.saveToMemento();</span><br><span class="line">        wordMementoManager.addMemento(wordMemento);</span><br><span class="line">        System.out.println(<span class="string">&quot;保存第一版文档，文档内容：&quot;</span>+wordMemento);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;修改文档&quot;</span>);</span><br><span class="line"></span><br><span class="line">        word.setTitle(<span class="string">&quot;java设计模式B&quot;</span>);</span><br><span class="line">        word.setContent(<span class="string">&quot;设计模式内同B&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第二版文档，文档内容：&quot;</span>+word);</span><br><span class="line">        WordMemento wordMemento1 = word.saveToMemento();</span><br><span class="line">        wordMementoManager.addMemento(wordMemento1);</span><br><span class="line">        System.out.println(<span class="string">&quot;保存第二版文档，文档内容：&quot;</span>+wordMemento1);</span><br><span class="line"></span><br><span class="line">        word.setTitle(<span class="string">&quot;java设计模式C&quot;</span>);</span><br><span class="line">        word.setContent(<span class="string">&quot;设计模式内同C&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第三版文档，文档内容：&quot;</span>+word);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        WordMemento memento = wordMementoManager.getMemento();</span><br><span class="line">        word.undoFormMemento(memento);</span><br><span class="line">        System.out.println(<span class="string">&quot;文档回退，回退后内容：&quot;</span>+word);</span><br><span class="line"></span><br><span class="line">        WordMemento memento1 = wordMementoManager.getMemento();</span><br><span class="line">        word.undoFormMemento(memento1);</span><br><span class="line">        System.out.println(<span class="string">&quot;文档再次回退，回退后内容：&quot;</span>+word);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建文档，文档内容：Word&#123;title=&#x27;java设计模式A&#x27;, content=&#x27;设计模式内同A&#x27;&#125;</span><br><span class="line">保存第一版文档，文档内容：WordMemento&#123;title=&#x27;java设计模式A&#x27;, content=&#x27;设计模式内同A&#x27;&#125;</span><br><span class="line">修改文档</span><br><span class="line">第二版文档，文档内容：Word&#123;title=&#x27;java设计模式B&#x27;, content=&#x27;设计模式内同B&#x27;&#125;</span><br><span class="line">保存第二版文档，文档内容：WordMemento&#123;title=&#x27;java设计模式B&#x27;, content=&#x27;设计模式内同B&#x27;&#125;</span><br><span class="line">第三版文档，文档内容：Word&#123;title=&#x27;java设计模式C&#x27;, content=&#x27;设计模式内同C&#x27;&#125;</span><br><span class="line">----------------------------------</span><br><span class="line">文档回退，回退后内容：Word&#123;title=&#x27;java设计模式B&#x27;, content=&#x27;设计模式内同B&#x27;&#125;</span><br><span class="line">文档再次回退，回退后内容：Word&#123;title=&#x27;java设计模式A&#x27;, content=&#x27;设计模式内同A&#x27;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><img src="http://www.plantuml.com/plantuml/svg/Iyv9B2vM2CylIb6evYeeoYnBB4bL22ufoinBLoZ9BCb9jKONJSxFAqdDAm6AboRbP2Q3zMeWwz11KwcfK5sBhDWtDHSecgzGd5YM6f8FvMbe8XILvMUcA9JcfUIxvHVbmkIHTPOZs21jjLnSoN1lmDHGu1kObGGzXSrYtyIynFJK8YJxqpBp4dE0sXEJissG5Def58E456mLybBBeT9s6fhMNFhwB_PFUJfxtjCbxK_tptYwT-gJ_NEVhftnV5RBanrTJtOqFDcnwdbdnxCvQx05Qdfg2I945L23D34bXOZGHFWg9BMu1EGFY150rvR0JCfDpCo31azqh49YKNenE3n0Mi59IK_F3jbLNCZMsUZgQc49CAXE6pqziBrS809e36R80W00">





















<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂方法模式</title>
    <url>/2021/08/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>工厂方法模式属于类的创建型模式又被称为多态工厂模式。工厂方法模式的意义在于定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类中，核心工厂类不再负责产品的创建，仅负责声明具体工厂子类必须实现的接口。<br>这样进一步抽象画的好处是使得工厂方法模式可以使系统在不修改具体工厂角色的情况下引进新的产品。</p>
</blockquote>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><blockquote>
<p>1）创建对象需要大量重复的代码<br>2）客户端（应用层）不依赖于产品类实例如何被创建、实现等细节<br>3）一个类通过其子类来指定创建哪个对象  </p>
</blockquote>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>用户只需要关系所需产品对应的工厂，无须关心创建细节。  </li>
<li>加入新产品符合开闭原则，提高可扩展性。  </li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>类的个数容易过多，增加复杂度。  </li>
<li>增加了系统的抽象性和理解难度。  </li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="创建抽象产品类"><a href="#创建抽象产品类" class="headerlink" title="创建抽象产品类"></a>创建抽象产品类</h4><blockquote>
<p>我们创建一个电脑的抽象产品类，他有一个抽象方法用于启动电脑</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产品的抽象方法，由具体的产品类去实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建具体产品类"><a href="#创建具体产品类" class="headerlink" title="创建具体产品类"></a>创建具体产品类</h4><blockquote>
<p>接着我们创建各个品牌的电脑，他们都继承了他们的父类Computer，并实现了父类的start方法。</p>
</blockquote>
<p><strong>联想电脑</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LenovoComputer</span> <span class="keyword">extends</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;联想电脑启动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>惠普电脑</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HpComputer</span> <span class="keyword">extends</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;惠普电脑启动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>华硕电脑</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsusComputer</span> <span class="keyword">extends</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;华硕电脑启动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>创建一个工厂抽象类，具体创建产品的代码由工厂抽象类的子类去实现</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工厂方法创建产品接口抽象化，将具体创建产品的代码写到工厂方法子类中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Computer <span class="title">createComputer</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>创建联想电脑的工厂实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LenovoComputerFactory</span> <span class="keyword">extends</span> <span class="title">ComputerFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">createComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LenovoComputer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>创建惠普电脑的工厂实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HpComputerFactory</span> <span class="keyword">extends</span> <span class="title">ComputerFactory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">createComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HpComputer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>创建华硕电脑的工厂实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsusComputerFactory</span> <span class="keyword">extends</span> <span class="title">ComputerFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">createComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AsusComputer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>客户端调用</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过工厂方法的子类去创建对应的工厂类</span></span><br><span class="line">        <span class="comment">//每次增加新的产品，只需要新建一个抽象工厂方法的子类即可，不会对现有的产品产生影响</span></span><br><span class="line">        ComputerFactory computerFactory = <span class="keyword">new</span> HpComputerFactory();</span><br><span class="line">        Computer computer = computerFactory.createComputer();</span><br><span class="line">        computer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h2><img src="http://www.plantuml.com/plantuml/svg/IqmgBYbAJ2vHICv9B2vMSCxFBIWjIIsgvdewjUtfvCPdNNjVR5puRDhEPvkdlj_Jywn_mfDziv_ldlzaHmEor8jrAvzEQ7coOnL4rzDryvxtRU0gA4tAoKnMI8HPKPQVcQ9GN99OLAAXQSrLoyK5iTEnkBGOPgz2QaL9QbuAfaE0baDCXLZ-V5OBilrS3lvbgKL5cIcf2b1BaUsghaLOvfEQbr-MJpVhF0heO5KYzZXq0mhb5rKg02tQllHfNzFpZRiX9WCPHCKbMDVJjHE0wd74ADnpoKMfYIMfC2xEw8Kv2Jqi44w5k0JPQlpX0vBjcFrqzwvdyoU0P9VtGa8LvbISBiITA0Qf8n59QP0wC2IrkAGQfWEOG4jWYJKtCJDF8xYaA3ClFJfM8R4elLXJ0QAH2oNls-ZfOKijN6Xv5gGCQunn8UKsa2AC44Er3nPS8AKWjtDXJmPmQSm8W4a10000">
















































<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>外观模式</title>
    <url>/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>外观模式又叫门面模式，是一种通过为多个复杂子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体细节，这样会大大降低应用程序的复杂度，提高程序的可维护性。</p>
</blockquote>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>外观模式包含以下主要角色：  </p>
<ul>
<li>外观角色： 为多个子系统提供一个共同的接口。  </li>
<li>子系统角色： 实现系统的部分功能，客户可以通过外观角色访问它。  </li>
<li>客户角色： 通过一个外观角色访问各个子系统的功能。   </li>
</ul>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li>子系统越来越复杂，增加外观模式提供简单调用接口。  </li>
<li>构建多层系统结构，利用外观对象作为每层的入口，简化层间调用。  </li>
</ul>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>简化了调用过程，无需深入了解子系统，防止带来风险。  </li>
<li>减少系统依赖、松散耦合。  </li>
<li>更好的划分访问层次。  </li>
<li>符合迪米特法则，即最少知道原则。  </li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>增加子系统、扩展子系统行为容易引入风险。  </li>
<li>不符合开闭原则。  </li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>假设我们现在有三个系统，<code>SubSystem01</code>、<code>SubSystem02</code>、<code>SubSystem03</code>，每个系统里面都有各自的逻辑处理方法；<br>我们现在有一个需求，需要调用三个系统联合去处理一个业务，那么就需要分别创建出<code>SubSystem01</code>、<code>SubSystem02</code>、<code>SubSystem03</code>系统的实例，然后调用对应的方法执行业务逻辑，<br>如果对象的创建，或者需要调用的方法很繁琐，那么每次处理逻辑，都要进行这块调用的处理，就很麻烦；<br>所以我们可以将这几个系统作为子系统，然后以一个高层系统(外观角色)进行封装，对外暴露一个相对简单的接口。</p>
<p>子系统1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubSystem01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子系统01的method1方法被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子系统2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubSystem02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子系统02的method2方法被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子系统3：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubSystem03</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子系统03的method3方法被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>外观角色：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Facade</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    SubSystem01 obj1 = <span class="keyword">new</span> SubSystem01();</span><br><span class="line">    SubSystem02 obj2 = <span class="keyword">new</span> SubSystem02();</span><br><span class="line">    SubSystem03 obj3 = <span class="keyword">new</span> SubSystem03();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        obj1.method1();</span><br><span class="line">        obj2.method2();</span><br><span class="line">        obj3.method3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Facade facade = <span class="keyword">new</span> Facade();</span><br><span class="line">        facade.method();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">子系统01的method1方法被调用</span><br><span class="line">子系统02的method2方法被调用</span><br><span class="line">子系统03的method3方法被调用</span><br></pre></td></tr></table></figure>

<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><img src="http://www.plantuml.com/plantuml/svg/TT6n3e8m40RW_PxYHXWmqeugeo-0ct4eq60DK4ABnY3lhXL2ggKtzl-QtlKWhvXIU6GvApWE0FYfjC_IfzAytiOeirkC1spumpuEmjsV94OIHn9NKYEf8wcHNzhsMILol4jHOCtrLHP1E8mm0apDskqDuEhOnyag9pvELpdzvIUkzCAKPdhHJ3H1gZlHbESBigvK8KuNvy_Ulw8eiOVn1SGNK03pF6wIUO5l">


<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>创建者模式</title>
    <url>/2021/08/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。<br>它是将一个复杂的对象分解为多个简答的对象，然后一步一步构建而成。<br>它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。</p>
</blockquote>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>封装性号，构建和表示分离。</li>
<li>扩展性好，各个具体的建造者相互独立，有利于系统的解耦。</li>
<li>客户端不必知道产品内部组成的细节，建造者可以对创建过程逐步细化，而不对其他模块产生任何影响，便于控制细节风险。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>产品的组成部分必须相同，这限制了其使用范围。</li>
<li>如果产品的内部变化复杂，如果产品内部发生变化，则建造者也要同步修改，后期维护成本较大。</li>
</ul>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><blockquote>
<p>比如我们有一个计算机类，类里面有些属性是必填参数，有些是选填的，那么我们按照传统方式进行创建的话一般有两种方式：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String cpu;<span class="comment">//必须</span></span><br><span class="line">    <span class="keyword">private</span> String ram;<span class="comment">//必须</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> usbCount;<span class="comment">//可选</span></span><br><span class="line">    <span class="keyword">private</span> String keyboard;<span class="comment">//可选</span></span><br><span class="line">    <span class="keyword">private</span> String display;<span class="comment">//可选</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>第一种：折叠构造函数模式，通过重写含有不同参数的构造函数进行赋值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String cpu;<span class="comment">//必须</span></span><br><span class="line">    <span class="keyword">private</span> String ram;<span class="comment">//必须</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> usbCount;<span class="comment">//可选</span></span><br><span class="line">    <span class="keyword">private</span> String keyboard;<span class="comment">//可选</span></span><br><span class="line">    <span class="keyword">private</span> String display;<span class="comment">//可选</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Computer</span><span class="params">(String cpu, String ram)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(cpu,ram,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Computer</span><span class="params">(String cpu, String ram, <span class="keyword">int</span> usbCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(cpu,ram,usbCount,<span class="string">&quot;罗技键盘&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Computer</span><span class="params">(String cpu, String ram, <span class="keyword">int</span> usbCount, String keyboard)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(cpu,ram,usbCount,keyboard,<span class="string">&quot;三星显示器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Computer</span><span class="params">(String cpu, String ram, <span class="keyword">int</span> usbCount, String keyboard, String display)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cpu = cpu;</span><br><span class="line">        <span class="keyword">this</span>.ram = ram;</span><br><span class="line">        <span class="keyword">this</span>.usbCount = usbCount;</span><br><span class="line">        <span class="keyword">this</span>.keyboard = keyboard;</span><br><span class="line">        <span class="keyword">this</span>.display = display;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种：Javabean模式，通过使用set方法进行赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String cpu;<span class="comment">//必须</span></span><br><span class="line">    <span class="keyword">private</span> String ram;<span class="comment">//必须</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> usbCount;<span class="comment">//可选</span></span><br><span class="line">    <span class="keyword">private</span> String keyboard;<span class="comment">//可选</span></span><br><span class="line">    <span class="keyword">private</span> String display;<span class="comment">//可选</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCpu</span><span class="params">(String cpu)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cpu = cpu;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRam</span><span class="params">(String ram)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ram = ram;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsbCount</span><span class="params">(<span class="keyword">int</span> usbCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.usbCount = usbCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKeyboard</span><span class="params">(String keyboard)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.keyboard = keyboard;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDisplay</span><span class="params">(String display)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.display = display;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="弊端"><a href="#弊端" class="headerlink" title="弊端"></a>弊端</h3><blockquote>
<p>第一种主要是使用及阅读不方便，当你想要使用一个类的构造函数的时候，你首先要想清楚自己需要使用哪一个，然后还要搞清楚这个函数里面参数的含义，很容易混淆。<br>第二种主要是在构建类的过程中是分两步进行的，这个操作容易导致操作失误，出现问题。</p>
</blockquote>
<h2 id="建造者模式代码实现"><a href="#建造者模式代码实现" class="headerlink" title="建造者模式代码实现"></a>建造者模式代码实现</h2><h3 id="结构组成"><a href="#结构组成" class="headerlink" title="结构组成"></a>结构组成</h3><ul>
<li><strong>产品角色</strong>：它是包含多个组成部件的复杂对象，由具体创建者来创建其各个零部件。</li>
<li><strong>抽象建造者</strong>：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品方法的getResult()。</li>
<li><strong>具体建造者</strong>：实现Builder接口，完成复杂产品的各个部件的具体创建方法。</li>
<li><strong>指挥者</strong>：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。</li>
</ul>
<h3 id="第一种实现："><a href="#第一种实现：" class="headerlink" title="第一种实现："></a>第一种实现：</h3><p>首先创建目标类，也就是我们的产品角色，要实现的产品定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 产品角色</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String cpu;<span class="comment">//必须</span></span><br><span class="line">    <span class="keyword">private</span> String ram;<span class="comment">//必须</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> usbCount;<span class="comment">//可选</span></span><br><span class="line">    <span class="keyword">private</span> String keyboard;<span class="comment">//可选</span></span><br><span class="line">    <span class="keyword">private</span> String display;<span class="comment">//可选</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Computer</span><span class="params">(String cpu, String ram)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cpu = cpu;</span><br><span class="line">        <span class="keyword">this</span>.ram = ram;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsbCount</span><span class="params">(<span class="keyword">int</span> usbCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.usbCount = usbCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKeyboard</span><span class="params">(String keyboard)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.keyboard = keyboard;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDisplay</span><span class="params">(String display)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.display = display;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Computer&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;cpu=&#x27;&quot;</span> + cpu + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, ram=&#x27;&quot;</span> + ram + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, usbCount=&quot;</span> + usbCount +</span><br><span class="line">                <span class="string">&quot;, keyboard=&#x27;&quot;</span> + keyboard + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, display=&#x27;&quot;</span> + display + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后创建抽象建造者，对具体建造实现类的一个抽象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象创建者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">getUsbCount</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">getKeyboard</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">getDisplay</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Computer <span class="title">getComputer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>指挥者负责创建流程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指挥者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerDirector</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeComputer</span><span class="params">(ComputerBuilder builder)</span> </span>&#123;</span><br><span class="line">        builder.getKeyboard();</span><br><span class="line">        builder.getDisplay();</span><br><span class="line">        builder.getUsbCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体建造者，建造者的具体实现，创建产品对象，定义具体产品的创建规则，这已创建电脑举例</p>
<p>华硕电脑创建者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体创建者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsusComputerBuilder</span> <span class="keyword">extends</span> <span class="title">ComputerBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Computer computer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AsusComputerBuilder</span><span class="params">(String cpu, String ram)</span> </span>&#123;</span><br><span class="line">        computer = <span class="keyword">new</span> Computer(cpu, ram);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUsbCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        computer.setUsbCount(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getKeyboard</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        computer.setKeyboard(<span class="string">&quot;华硕键盘&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getDisplay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        computer.setDisplay(<span class="string">&quot;华硕显示器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">getComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> computer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>联想电脑建造者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体创建者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LenovoComputerBuilder</span> <span class="keyword">extends</span> <span class="title">ComputerBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Computer computer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LenovoComputerBuilder</span><span class="params">(String cpu, String ram)</span> </span>&#123;</span><br><span class="line">        computer = <span class="keyword">new</span> Computer(cpu, ram);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUsbCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        computer.setUsbCount(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getKeyboard</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        computer.setKeyboard(<span class="string">&quot;联想键盘&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getDisplay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        computer.setDisplay(<span class="string">&quot;联想显示器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">getComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> computer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ComputerDirector director = <span class="keyword">new</span> ComputerDirector();</span><br><span class="line"></span><br><span class="line">        ComputerBuilder asusBuilder = <span class="keyword">new</span> AsusComputerBuilder(<span class="string">&quot;英特尔i7&quot;</span>,<span class="string">&quot;金士顿&quot;</span>);</span><br><span class="line">        director.makeComputer(asusBuilder);</span><br><span class="line">        Computer asusComputer = asusBuilder.getComputer();</span><br><span class="line">        System.out.println(asusComputer);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ComputerBuilder lenovoBuilder = <span class="keyword">new</span> LenovoComputerBuilder(<span class="string">&quot;英特尔i8&quot;</span>,<span class="string">&quot;三星&quot;</span>);</span><br><span class="line">        director.makeComputer(lenovoBuilder);</span><br><span class="line">        Computer lenovoComputer = lenovoBuilder.getComputer();</span><br><span class="line">        System.out.println(lenovoComputer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第一种方法UML类图"><a href="#第一种方法UML类图" class="headerlink" title="第一种方法UML类图"></a>第一种方法UML类图</h3><img src="http://www.plantuml.com/plantuml/svg/pP8nJiCm68Ltdy9Z8z7s09KgGRl11ao8mN6io6fYH_RlYAggnCB0n1au0GTWu3GClGK9CNRYE4mCJ8dotl_olT-c1T4QRsHP6M0A7r2bU4s0uMjGNEIOLcQrN7v-F9rUtqDDaNAiSG7Ow7GZZO1MVNaxFJw7apksJoLHsQGXuxegoBwdcxJWr87EFDvP3oT1HuH8ga4H2fWEkbqONcHTnIxB-Mh9CvmpkBNOisGrwRcqvBzvjXrypE8MtTXSbyRNO7Uqvzhea9Wz01DPj8dTcekbziNzEP8tkJixCbv7gFWbX8gh7XxOiB3lUyM4hELVDeuc_glEFz-sN34AidSbloDBicDkBDn0sZtRj2xiXcbmyne8-1WkREsxUqnKhXDyEBOKiJicv_Er0qFnKnbwqAX6gmSp2BLyUB5OZrfx9SBZnIZA5m00">


<h3 id="第二种方法："><a href="#第二种方法：" class="headerlink" title="第二种方法："></a>第二种方法：</h3><p>在<code>Computer</code>类中创建一个静态内部类<code>ComputerBuilder</code>，<code>ComputerBuilder</code>类的属性和<code>Computer</code>类相同，在<code>ComputerBuilder</code>类中创建设置函数，函数的返回类型为<code>ComputerBuilder</code>类型，通过设置函数对可选参数进行赋值，也可以把必选参数也用设置函数赋值，不过这里使用了<br>有参构造进行赋值，创建一个<code>build()</code>方法用来在<code>ComputerBuilder</code>中构建<code>Computer</code>实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String cpu;<span class="comment">//必须</span></span><br><span class="line">    <span class="keyword">private</span> String ram;<span class="comment">//必须</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> usbCount;<span class="comment">//可选</span></span><br><span class="line">    <span class="keyword">private</span> String keyboard;<span class="comment">//可选</span></span><br><span class="line">    <span class="keyword">private</span> String display;<span class="comment">//可选</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Computer</span><span class="params">(ComputerBuilder computerBuilder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cpu = computerBuilder.cpu;</span><br><span class="line">        <span class="keyword">this</span>.ram = computerBuilder.ram;</span><br><span class="line">        <span class="keyword">this</span>.usbCount = computerBuilder.usbCount;</span><br><span class="line">        <span class="keyword">this</span>.keyboard = computerBuilder.keyboard;</span><br><span class="line">        <span class="keyword">this</span>.display = computerBuilder.display;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerBuilder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String cpu;</span><br><span class="line">        <span class="keyword">private</span> String ram;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> usbCount;</span><br><span class="line">        <span class="keyword">private</span> String keyboard;</span><br><span class="line">        <span class="keyword">private</span> String display;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ComputerBuilder</span><span class="params">(String cpu, String ram)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.cpu = cpu;</span><br><span class="line">            <span class="keyword">this</span>.ram = ram;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> ComputerBuilder <span class="title">setUsbCount</span><span class="params">(<span class="keyword">int</span> usbCount)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.usbCount = usbCount;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> ComputerBuilder <span class="title">setKeyboard</span><span class="params">(String keyboard)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.keyboard = keyboard;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> ComputerBuilder <span class="title">setDisplay</span><span class="params">(String display)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.display = display;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Computer <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> Computer(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Computer&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;cpu=&#x27;&quot;</span> + cpu + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, ram=&#x27;&quot;</span> + ram + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, usbCount=&quot;</span> + usbCount +</span><br><span class="line">                <span class="string">&quot;, keyboard=&#x27;&quot;</span> + keyboard + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, display=&#x27;&quot;</span> + display + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第二种方法UML类图"><a href="#第二种方法UML类图" class="headerlink" title="第二种方法UML类图"></a>第二种方法UML类图</h3><img src="http://www.plantuml.com/plantuml/svg/VP0z3i8m38Ntdi9ZAdvw09Y0ZH6O44EQHYYYVqeSfAf2Oc5WuWoSW0CmS1e6RW6506recUBe-TdVCmkfKZ1CebGZbv0xgHHhYXmcA4My19RgdkTTBxlRyMnhaaQ_ceWHjFA7YOwnK0-dstPlErSyynCgWyQ6GAWqf5b9rtues0UKl8k15c7m06VLl-ji75Q9PeJQW7N1wWCr1caAO8CR3FBTtYvjTHlQGN6S6GPI1lfd61isOh7-yunUsAIQuiS1Vc4XnPNDcQTSOVvkKqZnyQmJ4K14HMp6pHT0vLAva6yAusTOgzEnMHoRhT_jFdVS0G00">















































<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象工厂模式</title>
    <url>/2021/08/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>抽象工厂模式提供一个创建一系列相关或者相互依赖对象的接口<br>无须指定他们具体的类</p>
</blockquote>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><blockquote>
<p>1）客户端（应用层）不依赖于产品类实例如何被创建、实现等细节。<br>2）强调一系列相关的产品对象（属于同一产品族）一起使用创建对象需要大量重复的代码。<br>3）提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。  </p>
</blockquote>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>具体产品在应用层代码隔离，无须关心创建细节</li>
<li>将一个系列的产品族统一到一起创建</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂的接口。  </li>
<li>增加了系统的抽象性和理解难度。  </li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>假设有一个生产电脑的工厂，电脑是由显示器和主机组成，同一个品牌下的主机和显示器，被称为同一个产品族，如，惠普主机和惠普显示器；不同品牌下的同一商品，被称为同一产品等级结构，如，惠普显示器和华硕显示器。  </p>
<p>创建一个抽象工厂（或者接口都可以，这个看具体需要），里面包含电脑和主机两个方法。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ComputerFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//显示器</span></span><br><span class="line">    <span class="function">Displayer <span class="title">getDisplayer</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//主机</span></span><br><span class="line">    <span class="function">Mainframe <span class="title">getMainframe</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个显示器的抽象类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Displayer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个主机的抽象类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Mainframe</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个品牌的工厂实现，如惠普  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HpComputerFactory</span> <span class="keyword">implements</span> <span class="title">ComputerFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Displayer <span class="title">getDisplayer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HpDisplayer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mainframe <span class="title">getMainframe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HpMainframe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建品牌下的显示器实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HpDisplayer</span> <span class="keyword">extends</span> <span class="title">Displayer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;惠普电脑显示器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建品牌下的主机实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HpMainframe</span> <span class="keyword">extends</span> <span class="title">Mainframe</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;惠普电脑主机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一些其他的品牌，如华硕等<br>工厂实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsusComputerFactory</span> <span class="keyword">implements</span> <span class="title">ComputerFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Displayer <span class="title">getDisplayer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AsusDisplayer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mainframe <span class="title">getMainframe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AsusMainframe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显示器实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsusDisplayer</span> <span class="keyword">extends</span> <span class="title">Displayer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;华硕电脑显示器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主机实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsusDisplayer</span> <span class="keyword">extends</span> <span class="title">Displayer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;华硕电脑显示器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>具体调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过具体的某个工厂实现来获取这个工厂</span></span><br><span class="line">        ComputerFactory computerFactory = <span class="keyword">new</span> HpComputerFactory();</span><br><span class="line">        <span class="comment">//通过这个工厂获取这个工厂下的显示器</span></span><br><span class="line">        Displayer displayer = computerFactory.getDisplayer();</span><br><span class="line">        <span class="comment">//通过工厂获取工厂下的主机</span></span><br><span class="line">        Mainframe mainframe = computerFactory.getMainframe();</span><br><span class="line">        <span class="comment">//具体业务</span></span><br><span class="line">        displayer.start();</span><br><span class="line">        mainframe.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h2><img src="http://www.plantuml.com/plantuml/svg/hLAzRi8m4Dxz53VI9I_G2WcrGbsOoeOOZd14bcB7ybqGAEBT6nVYf25fAi5u-VxkEqTR8N_0bE2zCAwiXoMcKlWpLEf3iylnJ1uoaZZCNbxL2hKzU3GKa3W4vA8KxbXyRG9fZipGkbJAbRjSfn0PnqBlWGMz36lRd2bj45yrdwxVH1kNao4ht2yPNSUgGdKPBHkmJcfhGISXk-yqZp7TdNloDgMHno_JyWMN_EJMDyg_oeVuX-e7WuSEi2QMoAe9qf1DxJ7x4gzjjja2-emRuVr_aYJpxZkECk9UIWqTFf1-NUHFreJPMvByb1jOfe6-0G00">









<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>桥接模式</title>
    <url>/2021/09/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>将抽象部分与它的具体实现部分分离，使它们都可以独立的变化<br>通过组合的方式建立两个类之间联系，而不是继承  </p>
</blockquote>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li>抽象和具体实现之间增加更多的灵活性</li>
<li>一个类存在两个（或多个）独立变化的维度，且这两个（或多个）维度都需要独立进行扩展</li>
<li>不希望使用继承，或因为多层继承导致系统类的个数剧增</li>
</ul>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>分离抽象部分以及其具体实现部分  </li>
<li>提高了系统可扩展性  </li>
<li>符合开闭原则  </li>
<li>符合合成复用原则  </li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>增加了系统的理解与设计难度</li>
<li>需要正确的识别出系统中两个独立变化的维度</li>
</ul>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><strong>抽象化角色</strong>： 定义抽象类，并包含一个对实例化对象的引用<br><strong>扩展抽象化角色</strong>： 是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法<br><strong>实现化角色</strong>： 定义实现化角色的接口，供扩展抽象化角色调用<br><strong>具体实现化角色</strong>： 给出实现化角色接口的具体实现</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>有多个电脑品牌，每个品牌下有不同的电脑类型，比如迷你电脑、台式机、笔记本等，如果我们使用一个类去表示一个品牌下的一种电脑类型，那么类会非常多；<br>这里我们就可以使用桥接模式来实现，首先我们创建一个电脑的接口，定义电脑的行为操作，开机、玩游戏<br>实现化角色  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">games</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义电脑品牌抽象类，里面组合电脑接口(其中的行为方法可以与电脑接口一样，也可以不一样，这里演示使用，写成一样)<br>抽象化角色  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Brand</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Computer computer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Brand</span><span class="params">(Computer computer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.computer = computer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Computer <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建电脑类型的实现类（具体实现化角色）<br>迷你电脑主机：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiniComputer</span> <span class="keyword">implements</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;   迷你电脑开机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">games</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;   迷你电脑玩游戏&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>笔记本电脑： （具体实现化角色）  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotebookComputer</span> <span class="keyword">implements</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;   笔记本电脑开机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">games</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;   笔记本电脑玩游戏&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建厂商品牌的实现（扩展抽象化角色）<br>惠普电脑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HpBrand</span> <span class="keyword">extends</span> <span class="title">Brand</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HpBrand</span><span class="params">(Computer computer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(computer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;打开惠普电脑&quot;</span>);</span><br><span class="line">        computer.open();</span><br><span class="line">        <span class="keyword">return</span> computer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>联想电脑：  （扩展抽象化角色）  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LenovoBrand</span> <span class="keyword">extends</span> <span class="title">Brand</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LenovoBrand</span><span class="params">(Computer computer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(computer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;打开联想电脑&quot;</span>);</span><br><span class="line">        computer.open();</span><br><span class="line">        <span class="keyword">return</span> computer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Brand brand = <span class="keyword">new</span> HpBrand(<span class="keyword">new</span> MiniComputer());</span><br><span class="line">        Computer computer = brand.open();</span><br><span class="line">        computer.games();</span><br><span class="line"></span><br><span class="line">        Brand brand1 = <span class="keyword">new</span> LenovoBrand(<span class="keyword">new</span> NotebookComputer());</span><br><span class="line">        Computer computer1 = brand1.open();</span><br><span class="line">        computer1.games();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">打开惠普电脑   迷你电脑开机   迷你电脑玩游戏</span><br><span class="line">打开联想电脑   笔记本电脑开机   笔记本电脑玩游戏</span><br></pre></td></tr></table></figure>

<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><img src="http://www.plantuml.com/plantuml/svg/hL512i8m4Bpd5JbQmHSKFEZ5W_g7D5abs6H3aXOXzEzMqwv1eGVnjilCpWopeWdH2ncvR4K8VEU5LJmnvp62ZA3u7eth8dWkfw5chcjQBJDtzOLNF0qpHSpgn487TbNLR63QZlj5I7Y3YVMe5N5UorKO2Fc2vOm7brF2FO9LK-OqMqxeSgwFE4-4v8zWiSSbYuBnkyr9MqsuDgu50pO6kY6tef92kkmcwsRPy_Yt1l7sLscMsrXljlIh1m00">














<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>模板方法模式</title>
    <url>/2021/10/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>定义了一个算法的骨架，并允许子类为一个或多个步骤提供实现；<br>模板方法使得子类可以在不改变算法结构的情况下，重新定义算法的某些步骤。</p>
</blockquote>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li>一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现；</li>
<li>各个子类中公共的行为被提取出来并集中到一个公共父类中，从而避免代码重复。</li>
</ul>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类实现，而把可变部分算法由子类继承实现，便于子类继续扩展。</li>
<li>它在父类中提取了公共部分代码，便于代码复用；</li>
<li>部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>对每个不同的实现都需要定义一个子类，这会导致类的数量增加，系统更加庞大，设计也更加抽象，间接增加的系统实现的复杂度。</li>
<li>父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码的阅读难度。</li>
<li>由于继承关系自身的缺点，如果父类添加新的抽象方法，则所有子类都需要改一遍。</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>假设一个场景，我们要生产电脑，每个厂家生产电脑配置的东西不一样</p>
<p>首先创建抽象类，限制创建电脑的模板</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AComputer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模板方法，声明成final是不希望子类覆盖这个类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">assembleComputer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//限制方法的调用，不让子类重写</span></span><br><span class="line">        principal();</span><br><span class="line">        displayer();</span><br><span class="line">        keyboard();</span><br><span class="line">        <span class="keyword">if</span> (needMouse())&#123;</span><br><span class="line">            mouse();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产主机，每个电脑都必须的，所以也声明成final</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">principal</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产主机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显示器，每个电脑也都需要，所以也声明成final</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">displayer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产显示器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 键盘配置，由子类来实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">keyboard</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 鼠标为非必须品，可以通过钩子方法来判断是否需要</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">mouse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产鼠标&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 鼠标的钩子方法，默认返回false，如果子类需要，重写该方法即可</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">needMouse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建子类，继承抽象类，实现抽像方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsusComputer</span> <span class="keyword">extends</span> <span class="title">AComputer</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产键盘</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">keyboard</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;华硕机械键盘&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类重写钩子方法，控制父类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LenovoComputer</span> <span class="keyword">extends</span> <span class="title">AComputer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">keyboard</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;联想键盘&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 联想生产键盘，同时也生产鼠标，重写鼠标钩子方法，返回true即可</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">needMouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者通过入参来控制父类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HpComputer</span> <span class="keyword">extends</span> <span class="title">AComputer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> needMouseFlag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HpComputer</span><span class="params">(<span class="keyword">boolean</span> needMouseFlag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.needMouseFlag = needMouseFlag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 惠普生产键盘，但是鼠标可能生产可能不生产，可以将钩子的值作为变量通过构造函数设置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">keyboard</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;惠普键盘&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">needMouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.needMouseFlag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><img src="http://www.plantuml.com/plantuml/svg/fP31QiCm44Jl_eezEjzG2Ws1q4DAls4bJOBeMYiasSIO_7jCI5BNTN9eppFxTcROv9BO5hB2ETDweqri2n8DLKnQO0iSxNrWeKwzez64nWXklderd9QTCVbWVMHvR74-H-7-Ik5Rb8lsXTue9rUlNfQF6sqpPcoZAk100N0VT_rKLTTskSttWZWM13UfF5HldnrIyWxp23Ibx12qqpzpliMdkN-yV8_FterBTrpmcx8LFj0hxLaonXLR8zvEMFNYmIpaVnkS0G00">
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>状态模式</title>
    <url>/2021/10/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>允许一个对象在其内部状态改变时，改变它的行为；<br>行为型</p>
</blockquote>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li>一个对象存在多个状态（不同状态下行为不同），且状态可相互转换</li>
</ul>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>将不同的状态隔离</li>
<li>把各种状态的转换逻辑，分布到State子类中，减少相互间依赖</li>
<li>增加新的状态非常简单</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>状态对的业务场景等导致类数据增加，系统变复杂</li>
</ul>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><ul>
<li><strong>环境类角色</strong>：也称为上下文，它定义了客户端需要大的接口，内部维护一个当前状态，并负责具体的状态切换；</li>
<li><strong>抽象状态角色</strong>：定义一个接口，用以封装环境对象中大的特定状态所对应的行为，可以有一个或多个行为。</li>
<li><strong>具体状态角色</strong>：实现抽象状态所对应的行为，并且在需要的情况下进行状态切换。</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>假设我们播放一个视频，一共有四种状态，播放、快进、暂停、停止，这四种状态，有的可以相互切换，有的不行<br>环境类角色，上下文，缓存一个当前状态，并负责切换状态  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VideoContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> VideoState videoState;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> VideoState <span class="title">getVideoState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> videoState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVideoState</span><span class="params">(VideoState videoState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.videoState = videoState;</span><br><span class="line">        <span class="keyword">this</span>.videoState.setVideoContext(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.videoState.play();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.videoState.speed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.videoState.pause();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.videoState.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抽象状态角色，组合有上下文类，方便子类使用  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">VideoState</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> VideoContext videoContext;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVideoContext</span><span class="params">(VideoContext videoContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.videoContext = videoContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;<span class="comment">//播放</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">speed</span><span class="params">()</span></span>;<span class="comment">//快进</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span></span>;<span class="comment">//暂停</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;<span class="comment">//停止</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体状态角色<br>播放状态，可以和另外三种状态进行切换  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlayState</span> <span class="keyword">extends</span> <span class="title">VideoState</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正常播放视频状态&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.videoContext.setVideoState(<span class="keyword">new</span> SpeedState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.videoContext.setVideoState(<span class="keyword">new</span> PauseState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.videoContext.setVideoState(<span class="keyword">new</span> StopState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>快进状态，可以和另外三种状态切换  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpeedState</span> <span class="keyword">extends</span> <span class="title">VideoState</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.videoContext.setVideoState(<span class="keyword">new</span> PlayState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;快进播放视频状态&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.videoContext.setVideoState(<span class="keyword">new</span> PauseState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.videoContext.setVideoState(<span class="keyword">new</span> StopState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>暂停状态，可以和另外三种状态切换  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PauseState</span> <span class="keyword">extends</span> <span class="title">VideoState</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.videoContext.setVideoState(<span class="keyword">new</span> PlayState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.videoContext.setVideoState(<span class="keyword">new</span> SpeedState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;暂停播放视频状态&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.videoContext.setVideoState(<span class="keyword">new</span> StopState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>停止状态，只能和播放状态切换，停止的情况下不能快进和暂停  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopState</span> <span class="keyword">extends</span> <span class="title">VideoState</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.videoContext.setVideoState(<span class="keyword">new</span> PlayState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ERROR, 停止状态不能快进&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ERROR，停止状态不能暂停&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;停止播放视频状态&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试，视频开始是播放状态，我们有事需要离开一会，可以切换成暂停状态，回来想要快进看，由暂停直接切换到快进状态，看完之后切换到停止状态，从停止状态再切换到快进状态是不允许的。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        VideoContext videoContext = <span class="keyword">new</span> VideoContext();</span><br><span class="line">        videoContext.setVideoState(<span class="keyword">new</span> PlayState());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;当前状态：&quot;</span>+videoContext.getVideoState().getClass().getSimpleName());</span><br><span class="line"></span><br><span class="line">        videoContext.pause();</span><br><span class="line">        System.out.println(<span class="string">&quot;当前状态：&quot;</span>+videoContext.getVideoState().getClass().getSimpleName());</span><br><span class="line"></span><br><span class="line">        videoContext.speed();</span><br><span class="line">        System.out.println(<span class="string">&quot;当前状态：&quot;</span>+videoContext.getVideoState().getClass().getSimpleName());</span><br><span class="line"></span><br><span class="line">        videoContext.stop();</span><br><span class="line">        System.out.println(<span class="string">&quot;当前状态：&quot;</span>+videoContext.getVideoState().getClass().getSimpleName());</span><br><span class="line"></span><br><span class="line">        videoContext.speed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当前状态：PlayState</span><br><span class="line">当前状态：PauseState</span><br><span class="line">当前状态：SpeedState</span><br><span class="line">当前状态：StopState</span><br><span class="line">ERROR, 停止状态不能快进</span><br></pre></td></tr></table></figure>

<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><img src="http://www.plantuml.com/plantuml/svg/rLGnRi8m5Drz2ezf9U00OQZK0nGfg4l5O18hifGcbls9YX03FKBLgMNgMd65SXgY7gDsJ1A7s7lPxF_-Vtx_VTjnHgJ4ZooXnNsH0tq1l45Si980DU48zB9ibo7YgsN6OXjDANIxu0PljarIMR04onxiP1tKy8oi7KoSqcGOvcGbNUT2mKrqYn1PIX0a1XntBHiLkk42Q0mqwJjHMflGsT4P3BnbjgPMWTLWE9bKRuVg_SUTTEvNPPsEtx_7Jm-LQLzpVRoUTdiFL-s6fjhjgyENziHOCLDAZ1DACCsJ2tFk7aegX8fWztpSU3ifxCkmXkQXiCTdf4QQrQVrVqcTwPhha1gfq7KedLDPVr0cIog1JV8pONaGWM1v-hJ0HAIogUokztGqkkszS6JTfo5elG85NgBMV1syhQD33FK-Y-buN7Vr1m00"><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>策略模式</title>
    <url>/2021/10/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>定义了算法家族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化不会影响到使用算法的用户。<br>行为型</p>
</blockquote>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li>系统由很多类，而他们的区别仅仅在于他们的行为不同；</li>
<li>一个系统需要动态地在几种算法中选择一种。</li>
</ul>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>符合开闭原则</li>
<li>避免使用多重条件转移语句</li>
<li>提高算法的保密性和安全性</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。</li>
<li>会产生很多策略类。</li>
</ul>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><ul>
<li><strong>抽象策略类</strong>：定义了一个公共接口，各种不同的算法以不同的方法实现这个接口，环境角色使用这个接口调用不同的算法，一般使用接口或者抽象类实现。</li>
<li><strong>环境策略类</strong>：实现了抽象策略定义的接口，提供具体的算法实现。</li>
<li><strong>环境类</strong>：持有一个策略类的引用，最终给客户端调用。</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>假设有一个饭店，里面有许多中菜，都是由大厨来做的，根据不同的策略，大厨就可以做出来不同的菜<br>抽象策略类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span>  <span class="title">friedDish</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>菜肴1<br>具体策略类   </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bouilli</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">friedDish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;红烧肉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>菜肴2<br>具体策略类  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoastDuck</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">friedDish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;烤鸭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>菜肴3<br>具体策略类  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShreddedPotatoes</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">friedDish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;土豆丝&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>厨房<br>环境类：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Restaurant</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Restaurant</span><span class="params">(Strategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">friedDish</span><span class="params">()</span></span>&#123;</span><br><span class="line">        strategy.friedDish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Restaurant restaurant = <span class="keyword">new</span> Restaurant(<span class="keyword">new</span> Bouilli());</span><br><span class="line">        restaurant.friedDish();</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Restaurant restaurant1 = <span class="keyword">new</span> Restaurant(<span class="keyword">new</span> ShreddedPotatoes());</span><br><span class="line">        restaurant1.friedDish();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">红烧肉</span><br><span class="line">-------------------</span><br><span class="line">土豆丝</span><br></pre></td></tr></table></figure>

<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><img src="http://www.plantuml.com/plantuml/svg/fP112i9034NtSueiLV041HVI0uWzGPn9RN3QAPDCGKhlRcdL5jrfLe7yztyIRfHYYPQWq8XArplqfWli0Ch8v7AMQhFDp62CzIW2nv3OUmQkMqyrDIfliZTjkdYsCF4h7FfXCJW75CsJlVrkKLIHd2Dt2eeQIFvOXaGnHMnqF1l6QYDt8xzyGvvDDezdpmNRV0cdW9NsCt-ENmNlzeUNoGC0">






















<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>组合模式</title>
    <url>/2021/09/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>将对象组合成树形结构以表示“整体-部分”的层次结构<br>组合模式使客户端对单个对象和组合对象保持一致的方式处理  </p>
</blockquote>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li>希望客户端可以忽略组合对象与单个对象的差异时  </li>
<li>处理一个树形结构时   </li>
</ul>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>清楚地定义分层次的复杂对象，表示对象的全部或部分层次  </li>
<li>让客户端忽略了层次的差异，方便对整个层次结构进行控制  </li>
<li>简化客户端代码  </li>
<li>符合开闭原则  </li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>限制类型时会较为复杂  </li>
<li>使设计变得更加抽象  </li>
</ul>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>主要角色：<br><strong>抽象构件角色</strong>： 它的主要作用是为树叶构件和树枝构件声明公共接口，并实现他们的默认行为。在透明式的组合模式中抽象构件还声明访问和管理之类的接口；在安全式的组合模式中不声明访问和管理子类的接口，管理工作由树枝构件完成。（总的抽象类或接口，定义一些通用的方法，比如新增、删除）<br><strong>树叶构件角色</strong>： 是组合中的叶节点对象，它没有子节点，用于继承或实现抽象构件。<br><strong>树枝构件角色</strong>： 是组合中的分支节点对象，它有子节点，用户继承和实现抽象构件。它的主要作用是存储和管理子部件，通常包含<code>add()</code>、<code>remove()</code>、<code>getChild()</code>等方法。  </p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>假设我们现在有一个文件夹，里面有若干个文件，我们现在需要用对象来存储，需要表示清楚其中的层级关系<br>首先创建抽象构件角色，根据业务情况，来控制方法是否是必须需要重写的，也可以使用接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FileComponent</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(FileComponent fileComponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;无权操作添加方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(FileComponent fileComponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;无权操作删除方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;无权操作获取名称方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;无权操获取大小方法除方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建树叶构件角色，文件类，属于叶子节点，不存在删除或者添加的方法，所以我们只需要实现获取名称和大小的方法即可，另外文件本身是拥有名称和大小属性的，也可以根据实际情况将属性上提  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDoc</span> <span class="keyword">extends</span> <span class="title">FileComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileDoc</span><span class="params">(String name, Integer size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;文件的名称是：&quot;</span> + <span class="keyword">this</span>.name + <span class="string">&quot;   文件的大小是：&quot;</span> + <span class="keyword">this</span>.size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>树枝构件角色，文件夹类，可以存放或者删除文件，拥有名称和层级属性，文件夹本身是没有大小的，但是可以依托下面文件的大小来计算大小，所以文件夹类可以实现所有的方法  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FolderDoc</span> <span class="keyword">extends</span> <span class="title">FileComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;FileComponent&gt; components = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer level;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FolderDoc</span><span class="params">(String name, Integer level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> components.stream().mapToInt(FileComponent::getSize).sum();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(FileComponent fileComponent)</span> </span>&#123;</span><br><span class="line">        components.add(fileComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(FileComponent fileComponent)</span> </span>&#123;</span><br><span class="line">        components.remove(fileComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;  size=&quot;</span> + getSize());</span><br><span class="line">        <span class="keyword">for</span> (FileComponent component : components) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.level != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.level; i++) &#123;</span><br><span class="line">                    System.out.print(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            component.print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体调用，我们在<code>视频</code>文件夹下存放了两部电影，以及一个<code>火影忍者</code>文件夹，文件夹下又有三集电视剧</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FileComponent fileComponent = <span class="keyword">new</span> FileDoc(<span class="string">&quot;倩女幽魂&quot;</span>,<span class="number">400</span>);</span><br><span class="line">        FileComponent fileComponent1 = <span class="keyword">new</span> FileDoc(<span class="string">&quot;僵尸先生&quot;</span>,<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">        FileComponent fileComponent2 = <span class="keyword">new</span> FolderDoc(<span class="string">&quot;火影忍者&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        FileComponent fileComponent3 = <span class="keyword">new</span> FileDoc(<span class="string">&quot;火影忍者第一集&quot;</span>,<span class="number">45</span>);</span><br><span class="line">        FileComponent fileComponent4 = <span class="keyword">new</span> FileDoc(<span class="string">&quot;火影忍者第二集&quot;</span>,<span class="number">56</span>);</span><br><span class="line">        FileComponent fileComponent5 = <span class="keyword">new</span> FileDoc(<span class="string">&quot;火影忍者第三集&quot;</span>,<span class="number">47</span>);</span><br><span class="line"></span><br><span class="line">        fileComponent2.add(fileComponent3);</span><br><span class="line">        fileComponent2.add(fileComponent4);</span><br><span class="line">        fileComponent2.add(fileComponent5);</span><br><span class="line"></span><br><span class="line">        FileComponent folder = <span class="keyword">new</span> FolderDoc(<span class="string">&quot;视频&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        folder.add(fileComponent);</span><br><span class="line">        folder.add(fileComponent1);</span><br><span class="line">        folder.add(fileComponent2);</span><br><span class="line"></span><br><span class="line">        folder.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">视频  size=848</span><br><span class="line">  文件的名称是: 倩女幽魂   文件的大小是: 400</span><br><span class="line">  文件的名称是: 僵尸先生   文件的大小是: 300</span><br><span class="line">  火影忍者  size=148</span><br><span class="line">    文件的名称是: 火影忍者第一集   文件的大小是: 45</span><br><span class="line">    文件的名称是: 火影忍者第二集   文件的大小是: 56</span><br><span class="line">    文件的名称是: 火影忍者第三集   文件的大小是: 47</span><br></pre></td></tr></table></figure>

<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><img src="http://www.plantuml.com/plantuml/svg/lLBBJiCm4BpxA_QO8hK_a589WP2G49ToGnoszZQovDYHlOH7rN_7SJ1fGX55GfmSxyncPdQDcy0U9OCq609SQqENhcwS9Skm4urtJ999GUkq0bIg65EsXxSPxFRJ5a-rQ-aNNMlssbPG4TzXJSK4lR5C5VaENkktBp3cE4cxYN_YObQAlH13lYidWLwOh3gMLxV8b4tOwA3yB6Rj48LZzMbZj3nkjuT-y7feiKC6ayueygVOt6gB1cvruEM8iWAPFmESWwLdkF0UNnDprKtafA26MZBbN-tctrxGjuEzfv2crwydC78y4hj6ROi-tSCZeAz2xXpBBkVpis4_Kt2nI19YM60izPMFTvSfxm00">































<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>简单工厂模式</title>
    <url>/2021/07/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类中。<br>我们把被创建的对象称为”产品“，把创建产品的对象称为”工厂“，如果创建的产品不多，只要一个工厂类就可以完成，这种模式交”简单工厂模式“。<br>在简单工厂模式中，创建实例的方法通常为静态方法，因此简单工厂模式又叫做“静态工厂方法模式”。  </p>
</blockquote>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>工厂类包含必要的逻辑判断，可以决定在什么时候创建哪一个产品的实例，客户端可以免除直接创建产品对象的职责，很方便的创建出相应的产品，工厂和产品的区分明确。  </li>
<li>客户端无需知道所创建具体产品的类名，只需要知道参数即可。  </li>
<li>也可以引入配置文件，在不修改客户端代码的情况下，更换和添加新的具体产品类。  </li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>简单工厂模式的工厂类单一，负责所有产品的创建，职责过重，一旦异常，整个系统将受影响。且工厂类代码会非常臃肿，违背开闭原则。  </li>
<li>使用简单工厂模式会正价系统中；类的个数（引入新的工厂类），增加系统的复杂度和理解难度。  </li>
<li>系统扩展困难，一旦增加新产品不得不修改工厂逻辑，在产品类型较多时，可能造成逻辑过于复杂。  </li>
<li>简单工厂模式使用了static工厂方法，造成工厂角色无法形成基于继承的等级结构。  </li>
</ul>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>对于产品种类相对比较少的情况，考虑使用简单工厂模式，使用简单工厂模式的客户端只需要传入工厂类的参数，不需要关系如何创建对象的逻辑，可以很方便的创建所需产品。  </li>
</ul>
<h2 id="模式的结构与实现"><a href="#模式的结构与实现" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h2><h3 id="简单工厂模式的主要角色如下"><a href="#简单工厂模式的主要角色如下" class="headerlink" title="简单工厂模式的主要角色如下"></a>简单工厂模式的主要角色如下</h3><ul>
<li>简单工厂：是简单工厂模式的核心，负责实现创建所有实例的内部逻辑。工厂的创建产品类的方法可以被外界直接调用，创建所需的产品对象。  </li>
<li>抽象产品：是简单工厂创建的所有对象的父类，负责描述所有实例共有的公共接口。  </li>
<li>具体产品：是简单工厂模式的创建目标。  </li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="创建抽象产品类"><a href="#创建抽象产品类" class="headerlink" title="创建抽象产品类"></a>创建抽象产品类</h4><p>我们创建一个电脑的抽象产品类，他有一个抽象方法用于启动电脑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产品的抽象方法，由具体的产品类去实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建具体产品类"><a href="#创建具体产品类" class="headerlink" title="创建具体产品类"></a>创建具体产品类</h4><p>接着我们创建各个品牌的电脑，他们都继承了他们的父类Computer，并实现了父类的start方法。</p>
<p><strong>联想电脑</strong>  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LenovoComputer</span> <span class="keyword">extends</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;联想电脑启动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>惠普电脑</strong>  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HpComputer</span> <span class="keyword">extends</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;惠普电脑启动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>华硕电脑</strong>  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsusComputer</span> <span class="keyword">extends</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;华硕电脑启动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建工厂类"><a href="#创建工厂类" class="headerlink" title="创建工厂类"></a>创建工厂类</h4><p>接下来创建一个工厂类，它提供了一个静态方法createComputer用来生产电脑，你只需要传入你想生产的电脑品牌，它就会实例化对象品牌的电脑对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Computer <span class="title">createComputer</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        Computer computer = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (type)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;lenovo&quot;</span>:</span><br><span class="line">                computer = <span class="keyword">new</span> LenovoComputer();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;hp&quot;</span>:</span><br><span class="line">                computer = <span class="keyword">new</span> HpComputer();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;asus&quot;</span>:</span><br><span class="line">                computer = <span class="keyword">new</span> AsusComputer();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> computer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="客户端调用工厂类"><a href="#客户端调用工厂类" class="headerlink" title="客户端调用工厂类"></a>客户端调用工厂类</h4><p>客户端调用工厂类，传入“hp”生产出惠普电脑并调用该电脑的start对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ComputerFactory.createComputer(<span class="string">&quot;hp&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第二种实现方式"><a href="#第二种实现方式" class="headerlink" title="第二种实现方式"></a>第二种实现方式</h4><p>为了节省内存和创建的时间，我们可以将computer事先创建好缓存起来。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String,Computer&gt; COMPUTER_MAP = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        COMPUTER_MAP.put(<span class="string">&quot;lenovo&quot;</span>,<span class="keyword">new</span> LenovoComputer());</span><br><span class="line">        COMPUTER_MAP.put(<span class="string">&quot;hp&quot;</span>,<span class="keyword">new</span> HpComputer());</span><br><span class="line">        COMPUTER_MAP.put(<span class="string">&quot;asus&quot;</span>,<span class="keyword">new</span> AsusComputer());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Computer <span class="title">createComputer</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="keyword">null</span> || type.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//返回null或者抛异常看业务情况判断</span></span><br><span class="line">        &#125;</span><br><span class="line">        Computer computer = COMPUTER_MAP.get(type.toLowerCase());</span><br><span class="line">        <span class="keyword">return</span> computer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第三种实现"><a href="#第三种实现" class="headerlink" title="第三种实现"></a>第三种实现</h4><p>因为每次新增产品的实现之后，都需要修改工厂类里面实例创建的代码，所以简单工厂方法并不符合开闭原则，第三种方法在一定程度上解决了这个问题  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Computer <span class="title">createComputer</span><span class="params">(Class clazz)</span></span>&#123;</span><br><span class="line">        Computer computer = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            computer = (Computer)Class.forName(clazz.getName()).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException | ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> computer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体调用如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ComputerFactory3.createComputer(HpComputer.class).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="UML结构图"><a href="#UML结构图" class="headerlink" title="UML结构图"></a>UML结构图</h3><img src="http://www.plantuml.com/plantuml/svg/IqmgBYbAJ2vHICv9B2vMSCxFBIWjIIsgvdewjUtfvCPdNNjVR5puRDhEPvkdlj_Jywn_mfDziv_ldlzaHmEor8jrAvzEQ7coOnL4rzDryvxtRU0gA4tAoKnMI8HPKPQVcQ9GN99OLAAXQSrLomMnqh6uj1XchK9gHKbgNWgcEu1sGmo5sFryLWkozLmE_cMfHKMPAQaAK3kHhOBRv9EQbr-MJn-xF0heOm_CK3TW0ESNLIe03T--z6bVq_EDk-7nzRHrpTFMZI_dpdpMq0Wn_FcK-KzsBOSu0nPDG9DBW1JSsSb5gOabgJ2kHd19KMPUka99PK4go7Okb6YpqTD3TmaNMcXZKu8KI5Ya0G00">
















<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>装饰器模式</title>
    <url>/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>在不改变原有对象的基础之上，将功能附加到对象上；<br>提供了比继承更有弹性的替代方案（扩展原有对象功能）  </p>
</blockquote>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li>扩展一个类的功能或给一个类添加附加职责  </li>
<li>动态的给一个对象添加功能，这些功能可以再动态的撤销  </li>
</ul>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>继承的有力补充，比继承灵活，不改变原有对象的情况下给一个对象扩展功能；  </li>
<li>通过使用不同装饰类以及这些装饰类的排列组合，可以试想不同效果；  </li>
<li>符合开闭原则。  </li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>会出现更多的代码，更多的类，增加程序复杂性；  </li>
<li>动态装饰时，多层装饰时会更复杂。  </li>
</ul>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><ul>
<li>抽象构件角色： 定义一个抽象接口以规范准备接收附加责任的对象。  </li>
<li>具体构件角色： 实现抽象构件，通过装饰角色为其添加一些职责。  </li>
<li>抽象装饰角色： 继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。  </li>
<li>具体装饰角色： 实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。  </li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>假设我们去买煎饼，一个煎饼8元钱，可以加鸡蛋和香肠，以传统方式来实现，如果用户只是买一个煎饼，我们建一个煎饼类即可实现，如果用户想要加一个鸡蛋，可以新建一个类继承煎饼类来实现，但是如果用户想再加香肠呢？再鸡蛋呢？两个、三个…<br>很明显，如果再以简单的继承来去实现，我们的类会爆炸式的增加，所以我们可以引入装饰者模式，把鸡蛋和香肠作为装饰，可以动态添加。</p>
<p>首先创建一个抽象构件角色：(煎饼以及作为装饰的抽象类)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">APancakes</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> String <span class="title">getDesc</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">cost</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体构件角色：(具体煎饼类，可以有多种煎饼)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pancakes</span> <span class="keyword">extends</span> <span class="title">APancakes</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;煎饼&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象装饰角色：(具体装饰角色的抽象类，也可以使用对象类，具体根据业务情况决定)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractDecorator</span> <span class="keyword">extends</span> <span class="title">APancakes</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> APancakes aPancakes;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractDecorator</span><span class="params">(APancakes aPancakes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.aPancakes = aPancakes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> aPancakes.getDesc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> aPancakes.cost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>具体装饰角色：(装饰角色的具体实现)<br>鸡蛋实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EggDecorator</span> <span class="keyword">extends</span> <span class="title">AbstractDecorator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EggDecorator</span><span class="params">(APancakes aPancakes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(aPancakes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getDesc() + <span class="string">&quot;  加一个鸡蛋&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.cost() + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>香肠实现：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SausageDecorator</span> <span class="keyword">extends</span> <span class="title">AbstractDecorator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SausageDecorator</span><span class="params">(APancakes aPancakes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(aPancakes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getDesc() + <span class="string">&quot;  加一根香肠&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.cost() + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        APancakes aPancakes = <span class="keyword">new</span> Pancakes();</span><br><span class="line">        aPancakes = <span class="keyword">new</span> EggDecorator(aPancakes);</span><br><span class="line">        aPancakes = <span class="keyword">new</span> EggDecorator(aPancakes);</span><br><span class="line">        aPancakes = <span class="keyword">new</span> SausageDecorator(aPancakes);</span><br><span class="line"></span><br><span class="line">        System.out.println(aPancakes.getDesc()+aPancakes.cost());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如代码所示，想要加几个鸡蛋或者香肠，可以动态的去实现</p>
<p>结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">煎饼  加一个鸡蛋  加一个鸡蛋  加一根香肠 12</span><br></pre></td></tr></table></figure>

<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><img src="http://www.plantuml.com/plantuml/svg/hP8n3u8m48Nt_eeRTI6HLHSItKrmCmv7kJIDM4pl82R4_ow820eBqQdjlTntxrsA2Oj7BQ0pP8PeZqxZcHWgXPqKYxVEW27P4kl5SjrBrjMTEKjJl2lLGZh62kWcvD81jbBVCAZkggSqhn4d_94JlTnkIUSU9VTJlAkt9GeDDe3TRJrdsCwOYJaZ1xC2n5Wm6lexzq0iTV8YoQm65fJwA7ERmWMjMxIWumdG6-uQF-9jWk39K2E3RwN_2wDI-2uz0000">










<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>观察者模式</title>
    <url>/2021/10/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>定义了对象之间的一对多依赖，让多个观察者对象同时监听某一个主题对象，当主题对象发生变化时，它的所有依赖者（观察者）都会收到通知并更新。<br>行为型</p>
</blockquote>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立的改变和复用。</li>
<li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间大的耦合度。</li>
<li>一个对象必须通知其他对象，而并不知道这些对象是谁。</li>
<li>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为影响C对象….，可以适用观察者模式创建一种链式触发机制。</li>
</ul>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>观察者和被观察者之间建立一个抽象的耦合</li>
<li>观察者模式支持广播通信</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>观察者时间有过多的细节依赖、提高时间消耗及程序复杂度</li>
<li>使用要得当，要避免循环调用</li>
</ul>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><ul>
<li><strong>抽象主题角色</strong>：也叫重选ing目标类，它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法。</li>
<li><strong>具体主题角色</strong>：也叫具体目标类，它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。</li>
<li><strong>抽象观察者角色</strong>：它是一个抽象类或者接口，它包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。</li>
<li><strong>具体观察者角色</strong>：实现首相观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="自定义抽象类实现观察者"><a href="#自定义抽象类实现观察者" class="headerlink" title="自定义抽象类实现观察者"></a>自定义抽象类实现观察者</h3><p>抽象目标  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line">    <span class="comment">//增加观察者方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除观察者方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span></span>; <span class="comment">//通知观察者方法</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体目标：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">extends</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体目标发生改变...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object obs : observers) &#123;</span><br><span class="line">            ((Observer) obs).response();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抽象观察者  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">response</span><span class="params">()</span></span>; <span class="comment">//反应</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体观察者1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver1</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">response</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体观察者1作出反应！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体观察者2  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver2</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">response</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体观察者2作出反应！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">具体目标发生改变...</span><br><span class="line">--------------</span><br><span class="line">具体观察者1作出反应！</span><br><span class="line">具体观察者2作出反应！</span><br></pre></td></tr></table></figure>

<h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><img src="http://www.plantuml.com/plantuml/svg/dL0zJyD03DtlLtXCaHg9hWGan8h4KBQAuN9ngqF9NMIxALNK_qvIuYXf2mCt-UptuMURiv1r0gwqpB3Uvv_O_LfJKvIkmW9UFKlsbZDIW_G4SQWO7Y7W0Pw9x76EIHOFfjxdfNVGH5-0BOf4XoD_0UrfXYAiOeD_0wskUsQ4A7vxL4BlUZBc9yXB38vGK0FXbs0ePW4drfT2lMCdvOCWRQr369TgpR0hrp4mtlHKy3tugYwnmY0yLPY7Lg71yxRKwlzIxyXzN0FT6-0iLfHLMH-IjP0Fkyq7MDgnqaURRBcyqyDDkcawDcVTz6nfzDAPDgxFy-jeTJswbFi6">

<h3 id="使用jdk提供类实现观察者"><a href="#使用jdk提供类实现观察者" class="headerlink" title="使用jdk提供类实现观察者"></a>使用jdk提供类实现观察者</h3><p>假设一个场景，学生向老师提问问题，那么老师就是观察者，需要观察学生是否有问题并及时做出回应，学生就是被观察者<br>创建学生类，被观察者，继承jdk的<code>Observable</code>类  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produceQuestion</span><span class="params">(String question)</span></span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot; 同生提出了一个问题：&quot;</span>+question);</span><br><span class="line">        setChanged();</span><br><span class="line">        notifyObservers(question);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察者老师，继承jdk的<code>Observer</code>类  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Teacher</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span> </span>&#123;</span><br><span class="line">        Student student = (Student) o;</span><br><span class="line">        String question = (String) arg;</span><br><span class="line">        System.out.println(name+<span class="string">&quot; 老师收到了一个 &quot;</span>+student.getName()+<span class="string">&quot;同学提出的问题：&quot;</span>+question);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体调用测试：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student(<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">        Teacher teacher = <span class="keyword">new</span> Teacher(<span class="string">&quot;王老师&quot;</span>);</span><br><span class="line">        Teacher teacher1 = <span class="keyword">new</span> Teacher(<span class="string">&quot;刘老师&quot;</span>);</span><br><span class="line">        student.addObserver(teacher);</span><br><span class="line">        student.addObserver(teacher1);</span><br><span class="line">        student.produceQuestion(<span class="string">&quot;天为什么是蓝的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">小明 同生提出了一个问题：天为什么是蓝的</span><br><span class="line">刘老师 老师收到了一个 小明同学提出的问题：天为什么是蓝的</span><br><span class="line">王老师 老师收到了一个 小明同学提出的问题：天为什么是蓝的</span><br></pre></td></tr></table></figure>
<h3 id="UML类图-1"><a href="#UML类图-1" class="headerlink" title="UML类图"></a>UML类图</h3><img src="http://www.plantuml.com/plantuml/svg/XL5BRi8m4Dtx5BCCgC01u0ojgdQ7M4piQMgQEAuzZf0Y3iMQ0t4Dd3HEtKfLbtw_UJEMDNeFJwKdrs5PKoys6pYgZzlbAiv2QCFatb3I927tIo17_mi7HOQ1Jan6vNdG2-jqXqnHvBIfm613Ms53MMkPZ4N6BQ0_VzCZN14_HgR8gQxL2gnhLP3q7CYpRasA-PpUYoYVExuIodToe1jRKnE7-dcdVqfEphzAZas2LT5UP8kt3p7_I981NHNryAEBvs7eLu1dv9JJe4vhx0-3qu-ZedCkkrkjbjc5CsAzpd6HbHceOQX8LvY1z7K9k0C0">























<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>解释器模式</title>
    <url>/2021/10/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>给定一个语言，定义它的文法大的一种表示，并定义一个解释器，这个解释器使用该表示类解释语言中的句子。<br>为了解释一种语言，而为语言创建的解释器。<br>类型：行为型</p>
</blockquote>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li>某个特定类型问题发生频率足够高</li>
</ul>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>扩展性好。由于在解释器模式中适用类来表示语言的文法规则，因此可以通过继承等机制类改变或者扩展文法。</li>
<li>容易实现。在语法树中的每个表达式节点都是类似的，所以实现其文法较为容易。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>执行效率较低。解释器模式中通常适用大量的循环和递归调用，担当要解释大的句子较复杂时，其运行速度很慢，且代码的调试过程也比较麻烦。</li>
<li>会引起类膨胀。解释器模式中的每条规则至少定义一个类，担当包含的文法规则很多时，类的个数将急剧增加，导致系统难以管理和维护。</li>
<li>可应用大的场景比较少。在软件开发中，需要定义语言文法大的应用实力非常少，所以这种模式很少被适用到。 </li>
</ul>
<h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><ul>
<li><strong>抽象表达式角色</strong>：定义解释器的接口，约定解释器的解释操作，主要包含解释方法<code>interpret()</code>。</li>
<li><strong>终结符表达式角色</strong>：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。</li>
<li><strong>非终结符表示式角色</strong>：也是抽象表达式的子类，用来表现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符 表达式。</li>
<li><strong>环境角色</strong>：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。</li>
<li><strong>客户端</strong>：主要任务是将需要分析的句子表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>比如我们创建一个对<code>6 100 11 + *</code>这个式子的解释器，解释规则是如果是数字就入栈，如果是符号就将入栈的后两个数字（先进后出）进行计算<br>抽象表达式类  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interpreter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">interpret</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非终结符号表达式类<br>加法解释器类  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddInterpreter</span> <span class="keyword">implements</span> <span class="title">Interpreter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Interpreter firstExpression, secondExpression;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AddInterpreter</span><span class="params">(Interpreter firstExpression, Interpreter secondExpression)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.firstExpression = firstExpression;</span><br><span class="line">        <span class="keyword">this</span>.secondExpression = secondExpression;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interpret</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.firstExpression.interpret() + <span class="keyword">this</span>.secondExpression.interpret();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;+&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非终结符号表达式类<br>乘法解释器类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiInterpreter</span> <span class="keyword">implements</span> <span class="title">Interpreter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Interpreter firstExpression, secondExpression;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MultiInterpreter</span><span class="params">(Interpreter firstExpression, Interpreter secondExpression)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.firstExpression = firstExpression;</span><br><span class="line">        <span class="keyword">this</span>.secondExpression = secondExpression;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interpret</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.firstExpression.interpret() * <span class="keyword">this</span>.secondExpression.interpret();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;*&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>终结符号表达式类  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberInterpreter</span> <span class="keyword">implements</span> <span class="title">Interpreter</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumberInterpreter</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumberInterpreter</span><span class="params">(String number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = Integer.parseInt(number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interpret</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>环境类  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExpressionParser</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Interpreter&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">parse</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        String[] strItemArray = str.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String symbol : strItemArray) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isOperator(symbol)) &#123;</span><br><span class="line">                Interpreter numberInterpreter = <span class="keyword">new</span> NumberInterpreter(symbol);</span><br><span class="line">                stack.push(numberInterpreter);</span><br><span class="line">                System.out.printf(<span class="string">&quot;入栈：%d%n&quot;</span>, numberInterpreter.interpret());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Interpreter firstExpression = stack.pop();</span><br><span class="line">                Interpreter secondExpression = stack.pop();</span><br><span class="line">                System.out.printf(<span class="string">&quot;出栈：%d 和 %d%n&quot;</span>, firstExpression.interpret(), secondExpression.interpret());</span><br><span class="line">                Interpreter expressionObject = getExpressionObject(firstExpression, secondExpression, symbol);</span><br><span class="line">                System.out.printf(<span class="string">&quot;应用运算符：%s%n&quot;</span>, expressionObject.toString());</span><br><span class="line">                <span class="keyword">int</span> result = expressionObject.interpret();</span><br><span class="line">                NumberInterpreter resultExpression = <span class="keyword">new</span> NumberInterpreter(result);</span><br><span class="line">                stack.push(resultExpression);</span><br><span class="line">                System.out.println(String.format(<span class="string">&quot;阶段结果入栈： %d&quot;</span>,resultExpression.interpret()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = stack.pop().interpret();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOperator</span><span class="params">(String symbol)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (symbol.equals(<span class="string">&quot;+&quot;</span>) || symbol.equals(<span class="string">&quot;*&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Interpreter <span class="title">getExpressionObject</span><span class="params">(Interpreter firstExpression, Interpreter secondExpression, String symbol)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (symbol.equals(<span class="string">&quot;+&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AddInterpreter(firstExpression, secondExpression);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (symbol.equals(<span class="string">&quot;*&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MultiInterpreter(firstExpression, secondExpression);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>客户端  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String inputStr = <span class="string">&quot;6 100 11 + *&quot;</span>;</span><br><span class="line">        ExpressionParser expressionParser = <span class="keyword">new</span> ExpressionParser();</span><br><span class="line">        <span class="keyword">int</span> result = expressionParser.parse(inputStr);</span><br><span class="line">        System.out.println(<span class="string">&quot;解释器计算结果：&quot;</span> + result);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">入栈：6</span><br><span class="line">入栈：100</span><br><span class="line">入栈：11</span><br><span class="line">出栈：11 和 100</span><br><span class="line">应用运算符：+</span><br><span class="line">阶段结果入栈： 111</span><br><span class="line">出栈：111 和 6</span><br><span class="line">应用运算符：*</span><br><span class="line">阶段结果入栈： 666</span><br><span class="line">解释器计算结果：666</span><br></pre></td></tr></table></figure>

<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><img src="http://www.plantuml.com/plantuml/svg/lLEnJiCm4Dtz5JUcYEO76YenC30K8PKDCRY9Mvr87CjtAKXL_vqOcjgnep0WiJZEtRlt_CvdrApiNfOA7jtEMDMlS1Ae6N28P8kLE0jHrf88xgigX69ZQjKepHGn68j7oMFUFLhYXy_-ZmXRVGkaobPNFh8IfjlLM4OgsIn9c8m95t0w3voH9vUvkjfqDUC_-8fr_kGCvgnvRqzTirFsTtFUcwFJtrNNWoSacGU5JKvnMxQe3nFGkVlmFf-bfL7ZjopBzo9GM0Ev4Do1LX-NzDhDRA1Z7Cjm568xLdjHn4xX1z-pSVyvjbX18r5VobxVGDe33PLXFulbyYQvsXGn7kg88i_pnBL8nhAOGaLFSXAJ3i4aJ2IDTp3Ndoy0"><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2021/07/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><strong>设计模式：</strong> 是一套被反复使用、多人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦一块块砖石一样。项目中合理的运用设计模式可以完美的解决很多问题，每种模式在现在中都有相应的原理来与之对应，每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是他能被广泛应用的原因。  </p>
<h2 id="设计模式的目的"><a href="#设计模式的目的" class="headerlink" title="设计模式的目的"></a>设计模式的目的</h2><p>编写软件过程中，程序员面临着来自耦合性、内聚性以及可维护性、可扩展性、重用性、灵活性等多方面额挑战，设计模式是为了让<strong>程序（软件）</strong>，具有更好的：<br>1）代码重用性（相同的代码不用多次编写）<br>2）可读性（编程规范性，便有其他程序员的阅读和理解）<br>3）可扩展性（当需要增加新的功能时，非常方便）<br>4）可靠性（当我们增加新的功能后，对原本的功能没有影响）<br>5）使程序呈现高内聚，低耦合懂得特性  </p>
<h2 id="设计模式七大原则"><a href="#设计模式七大原则" class="headerlink" title="设计模式七大原则"></a>设计模式七大原则</h2><p>设计模式的原则其实就是程序员在编程时，应该准守的原则，也是各种设计模式的基础（即：设计模式为什么这样设计的依据）<br><strong>1）单一职责原则</strong>      </p>
<blockquote>
<p>1）降低类的复杂度，一个类只负责一项职责<br>2）提高类的可读性，可维护性<br>3）降低变更引起的风险<br>4）通常情况下，我们应该准守单一职责原则，只有在逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法层面保持单一职责原则  </p>
</blockquote>
<p><strong>2）接口隔离原则</strong>    </p>
<blockquote>
<p>客户端不应该依赖他不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上</p>
</blockquote>
<p><strong>3）依赖倒转（倒置）原则</strong>    </p>
<blockquote>
<p>1）高层模块不应该依赖底层模块，二者都应该依赖其抽象<br>2）抽象不应该依赖细节，细节应该依赖抽象<br>3）依赖倒转（倒置）的中心思想是面向接口编程<br>4）依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础搭建懂得架构要稳定的多。在java中，抽象指的是接口或者抽象类，细节就是具体的实现类<br>5）使用接口或抽象类的目的是制定好规范，而不涉及任何具体操作，把展示细节的任务交给他们的实现类去完成。  </p>
</blockquote>
<p><strong>4）里氏替换原则</strong>    </p>
<blockquote>
<p>1）如果每个类型T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。换句话说，所有引用基类的地方必须能透明的使用其子类对象。<br>2）在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法。<br>3）里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过聚合，组合，依赖来解决问题。  </p>
</blockquote>
<p><strong>5）开闭原则</strong>    </p>
<blockquote>
<p>1）开闭原则是编程中最基础、最重要的设计原则。<br>2）一个软件实体，如类、模块和函数应该对扩展开放（对提供方），对修改关闭（对使用方）。用抽象构建框架，用实现扩展细节。<br>3）当软件需要变化时，尽量通过快照软件实体的行为类实现变化，而不是通过修改已有的代码来实现变化。<br>4）编程中遵循其他原则，以及使用设计模式的目的就是遵循开闭原则。  </p>
</blockquote>
<p><strong>6）迪米特原则</strong>    </p>
<blockquote>
<p>1）一个对象应该对其他对象保持最少的了解。<br>2）类与类关系越密切，耦合度越大。<br>3）迪米特法则，又叫最少知道原则，即一个类对自己依赖的类知道的越少越好，也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的public方法不对外泄露任何信息。<br>4）迪米特法则还有个更简单的定义：只与直接朋友通信。<br>5）直接朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式有很多，依赖、关联、组合、聚合等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。  </p>
</blockquote>
<p><strong>7）合成复用原则</strong>    </p>
<blockquote>
<p>尽量使用合成、聚合的方式，而不是使用继承。</p>
</blockquote>
<h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><blockquote>
<p>对象实例化的模式，创建型模式用于解耦对象的实例化过程。<br>这些设计模式提供一种在创建对象的同时隐藏创建逻辑的方式，而不是使用new运算符直接实例化对象，这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。  </p>
</blockquote>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><ul>
<li>某个类只能有一个实例，提供一个全局的访问点。<br><a href="https://ysymj.gitee.io/2021/07/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">点击阅读&gt;&gt;</a></li>
</ul>
<h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><ul>
<li>一个工厂类根据传入的参量决定创建出那一种产品类的实例。<br><a href="https://ysymj.gitee.io/2021/07/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/">点击阅读&gt;&gt;</a></li>
</ul>
<h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><ul>
<li>定义一个创建对象的接口，让子类决定实例化那个类。<br><a href="https://ysymj.gitee.io/2021/08/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/">点击阅读&gt;&gt;</a></li>
</ul>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><ul>
<li>创建相关或依赖对象的家族，而无需明确指定具体类。<br><a href="https://ysymj.gitee.io/2021/08/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/">点击阅读&gt;&gt;</a></li>
</ul>
<h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><ul>
<li>封装一个复杂对象的构建过程，并可以按步骤构造。<br><a href="https://ysymj.gitee.io/2021/08/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/">点击阅读&gt;&gt;</a></li>
</ul>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><ul>
<li>通过复制现有的实例来创建新的实例。<br><a href="https://ysymj.gitee.io/2021/09/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/">点击阅读&gt;&gt;</a></li>
</ul>
<h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><blockquote>
<p>把类或对象结合在一起形成一个更大的结构。<br>这些设计模式关注类和对象等的结合，继承的概念被用来组合接口和定义组合对象获得新功能的方式。  </p>
</blockquote>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><ul>
<li>将一个类的方法接口转换成客户希望的另外一个接口。<br><a href="https://ysymj.gitee.io/2021/09/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/">点击阅读&gt;&gt;</a></li>
</ul>
<h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><ul>
<li>将抽象部分和它的实现部分分离，使它们都可以独立的变化。<br><a href="https://ysymj.gitee.io/2021/09/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/">点击阅读&gt;&gt;</a></li>
</ul>
<h3 id="过滤器模式"><a href="#过滤器模式" class="headerlink" title="过滤器模式"></a>过滤器模式</h3><ul>
<li>这种设计模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来。  </li>
</ul>
<h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><ul>
<li>将对象组合成树形结构以表示“部分-整体”的层次结构。<br><a href="https://ysymj.gitee.io/2021/09/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/">点击阅读&gt;&gt;</a></li>
</ul>
<h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><ul>
<li>动态的给对象添加新的功能。<br><a href="https://ysymj.gitee.io/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/">点击阅读&gt;&gt;</a></li>
</ul>
<h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><ul>
<li>对外提供一个统一的方法，来访问子系统中的一群接口。<br><a href="https://ysymj.gitee.io/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/">点击阅读&gt;&gt;</a></li>
</ul>
<h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><ul>
<li>通过共享技术来有效的支持大量细粒度的对象。<br><a href="https://ysymj.gitee.io/2021/09/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/">点击阅读&gt;&gt;</a></li>
</ul>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><ul>
<li>为其他对象提供一个代理以便控制整个对象的访问。<br><a href="https://ysymj.gitee.io/2021/09/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/">点击阅读&gt;&gt;</a></li>
</ul>
<h2 id="行为模式"><a href="#行为模式" class="headerlink" title="行为模式"></a>行为模式</h2><blockquote>
<p>类和对象如何交互，及划分责任和算法。<br>这些设计模式特别关注对象之间的通信。  </p>
</blockquote>
<h3 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h3><ul>
<li>在不改变数据结构的前提下，增加作用于一组对象元素的新功能。<br><a href="https://ysymj.gitee.io/2021/10/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/">点击阅读&gt;&gt;</a></li>
</ul>
<h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><ul>
<li>定义一个算法结构，而将一些步骤延迟到子类实现。<br><a href="https://ysymj.gitee.io/2021/10/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/">点击阅读&gt;&gt;</a></li>
</ul>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><ul>
<li>定义一系列算法，把他们封装起来，并且使他们可以互相替换。<br><a href="https://ysymj.gitee.io/2021/10/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/">点击阅读&gt;&gt;</a></li>
</ul>
<h3 id="空对象模式"><a href="#空对象模式" class="headerlink" title="空对象模式"></a>空对象模式</h3><ul>
<li>一个空对象取代NULL对象实例的检查。  </li>
</ul>
<h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><ul>
<li>允许一个对象在其对象内部状态改变时改变它的行为。<br><a href="https://ysymj.gitee.io/2021/10/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/">点击阅读&gt;&gt;</a></li>
</ul>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><ul>
<li>对象间的一对多的依赖关系。<br><a href="https://ysymj.gitee.io/2021/10/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/">点击阅读&gt;&gt;</a></li>
</ul>
<h3 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h3><ul>
<li>在不破坏封装的前提下，保持对象的内部状态。<br><a href="https://ysymj.gitee.io/2021/10/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/">点击阅读&gt;&gt;</a></li>
</ul>
<h3 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h3><ul>
<li>用一个中介对象来封装一系列的对象交互。<br><a href="https://ysymj.gitee.io/2021/10/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/">点击阅读&gt;&gt;</a></li>
</ul>
<h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><ul>
<li>一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。<br><a href="https://ysymj.gitee.io/2021/10/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/">点击阅读&gt;&gt;</a></li>
</ul>
<h3 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h3><ul>
<li>给定一个语言，定义它的文法的一种表示，并定义一个解释器。<br><a href="https://ysymj.gitee.io/2021/10/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/">点击阅读&gt;&gt;</a></li>
</ul>
<h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><ul>
<li>将命令请求封装为一个对象，使得可以用不同的请求来进行参数化。<br><a href="https://ysymj.gitee.io/2021/10/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/">点击阅读&gt;&gt;</a></li>
</ul>
<h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><ul>
<li>将请求的发送者和接收者解耦，使的多个对象都有处理这个请求的机会。<br><a href="https://ysymj.gitee.io/2021/10/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/">点击阅读&gt;&gt;</a></li>
</ul>
<h2 id="J2EE模式"><a href="#J2EE模式" class="headerlink" title="J2EE模式"></a>J2EE模式</h2><blockquote>
<p>这些设计模式特别关注表示层，这些模式是由Sun Java Center鉴定的。</p>
</blockquote>
<h3 id="MVC模式"><a href="#MVC模式" class="headerlink" title="MVC模式"></a>MVC模式</h3><ul>
<li>MVC模式代表Model-View-Controller(模型-视图-控制器)模式。这种模式用于应用程序的分层开发。  </li>
</ul>
<h3 id="业务代表模式"><a href="#业务代表模式" class="headerlink" title="业务代表模式"></a>业务代表模式</h3><ul>
<li>用于对表示层和业务层解耦。  </li>
</ul>
<h3 id="组合实体模式"><a href="#组合实体模式" class="headerlink" title="组合实体模式"></a>组合实体模式</h3><ul>
<li>用在EJB持久化机制中，一个组合实体是一个EJB实体bean，代表了对象的图解。  </li>
</ul>
<h3 id="数据访问对象模式"><a href="#数据访问对象模式" class="headerlink" title="数据访问对象模式"></a>数据访问对象模式</h3><ul>
<li>用于把低级的数据访问API或操作从高级的业务服务中分离出来。  </li>
</ul>
<h3 id="前端控制器模式"><a href="#前端控制器模式" class="headerlink" title="前端控制器模式"></a>前端控制器模式</h3><ul>
<li>用来提供一个集中的请求处理机制，所有的请求都将由一个单一的处理程序处理。  </li>
</ul>
<h3 id="拦截过滤器模式"><a href="#拦截过滤器模式" class="headerlink" title="拦截过滤器模式"></a>拦截过滤器模式</h3><ul>
<li>用于对应用程序的请求或响应做一些预处理/后处理。  </li>
</ul>
<h3 id="服务定位器模式"><a href="#服务定位器模式" class="headerlink" title="服务定位器模式"></a>服务定位器模式</h3><ul>
<li>用在我们想使用JNDI查询定位各种服务的时候。  </li>
</ul>
<h3 id="传输对象模式"><a href="#传输对象模式" class="headerlink" title="传输对象模式"></a>传输对象模式</h3><ul>
<li>用于从客户端向服务器一次性传递带有多个属性的数据。  </li>
</ul>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>访问者模式</title>
    <url>/2021/10/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>封装作用于某数据结构（如List/Set/Map等）中的各元素的操作；<br>可以在不改变各元素的类的前提下，定义作用于这些元素的操作；<br>行为型</p>
</blockquote>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li>一个数据结构（如List/Set/Map等）包含很多类型对象</li>
<li>数据结构与数据操作分离</li>
</ul>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>增加新的操作很容易，即增加一个新的访问者</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>增加新的数据结构困难</li>
<li>具体元素变更比较麻烦</li>
</ul>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><ul>
<li><strong>抽象访问者角色</strong>：定义一个访问具体元素的接口，为每个具体元素类对应一个访问操作visit()，该操作中的参数类型标识了被访问的具体元素；</li>
<li><strong>具体访问者角色</strong>：实现抽象访问者角色中声明的各个访问操作，确定访问者访问一个元素时该做什么；</li>
<li><strong>抽象元素角色</strong>：声明一个包含接受操作accept()的接口，被接受的访问者对象作为accept()方法的参数；</li>
<li><strong>具体元素角色</strong>：实现抽象元素角色提供的accept()操作，其方法通常都是visitor.visit(this)，另外具体元素中可能还包含本身业务逻辑的相关操作。</li>
<li><strong>对象结构角色</strong>：是一个包含元素角色的容器，提供让访问者对象遍历容器中的多有元素的方法，通常由List/Set/Map等聚合类实现。</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>假设一个场景，双十一购物，有几个小伙伴买了商品，有的想给差评，有的想给好评<br>抽象访问者角色<br>想要做出的评论的抽象，比如好评、差评  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementA element)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementB element)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体访问者角色<br>具体的评论，比如好评差评  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteVisitorA</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementA element)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体访问者A访问--&gt;&quot;</span> + element.operationA());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementB element)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体访问者A访问--&gt;&quot;</span> + element.operationB());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体访问者  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteVisitorB</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementA element)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体访问者B访问--&gt;&quot;</span> + element.operationA());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementB element)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体访问者B访问--&gt;&quot;</span> + element.operationB());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抽象元素角色<br>用户的抽象，里面有一个评论的方法  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体元素<br>用户实现具体的评论，并记录有用户的名称</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteElementA</span> <span class="keyword">implements</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">operationA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;具体元素A的操作。&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteElementB</span> <span class="keyword">implements</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">operationB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;具体元素B的操作。&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对象结构角色<br>记录有所有的购买用户，只有这些用户可以进行评价  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectStructure</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Element&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        Iterator&lt;Element&gt; i = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">            ((Element) i.next()).accept(visitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Element element)</span> </span>&#123;</span><br><span class="line">        list.add(element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Element element)</span> </span>&#123;</span><br><span class="line">        list.remove(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ObjectStructure os = <span class="keyword">new</span> ObjectStructure();</span><br><span class="line">        os.add(<span class="keyword">new</span> ConcreteElementA());</span><br><span class="line">        os.add(<span class="keyword">new</span> ConcreteElementB());</span><br><span class="line">        Visitor visitor = <span class="keyword">new</span> ConcreteVisitorA();</span><br><span class="line">        os.accept(visitor);</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------&quot;</span>);</span><br><span class="line">        visitor = <span class="keyword">new</span> ConcreteVisitorB();</span><br><span class="line">        os.accept(visitor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">具体访问者A访问--&gt;具体元素A的操作。</span><br><span class="line">具体访问者A访问--&gt;具体元素B的操作。</span><br><span class="line">------------------------</span><br><span class="line">具体访问者B访问--&gt;具体元素A的操作。</span><br><span class="line">具体访问者B访问--&gt;具体元素B的操作。</span><br></pre></td></tr></table></figure>

<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><img src="http://www.plantuml.com/plantuml/svg/nPBDJeGm4CVlFCKSws5v0P44Z3SJ3nelnaEtZ9inq99sg36RVNVPXRALW1y7umdQ_Zh_3o3DQ5-aGdWaHsmix1Dlg09_N8fhevL5nfiQ6zHS00ul5vTVK6L47P94rT8v2CmeKm0rxK2vIBhjjZKf-8a3s1--nyjF-9gPyf_Cq5J-I8JofLBOiWXM_F1SgdDo4YKu3uijhSoCdD-p9Rq3qwALJ4ONOhcrASuVQ9OppRljAohkgKvnP_4utvANZ71BZhDHDeUwNy4LQ7o3mbhvVZhDHL_Px_mCM5M946Zj2rjiZCT5R3B_W2vgn76VSBpTID9YoFxq3DBkNBWPl6Lf7afDvYMOpUPyU1B9qXaJjjFmFty0">







<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>责任链模式</title>
    <url>/2021/10/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>为请求创建一个接收此次请求对象的链；<br>行为型</p>
</blockquote>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li>一个请求的处理需要多个对象当中的一个或几个协同处理；</li>
</ul>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>请求的发送者和接收者（请求的处理）解耦</li>
<li>责任链可以动态组合</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>责任链太长或者处理时间过长，影响性能；</li>
<li>责任链有可能过多。</li>
</ul>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><ul>
<li><strong>抽象处理者角色</strong>：定义一个处理请求的接口，包含抽象处理方法和一个后续连接。</li>
<li><strong>具体处理者角色</strong>：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。</li>
<li><strong>客户类角色</strong>：创建处理链，并向链头的具体处理对象提交请求，它不关心处理细节和请求的传递过程。</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>假设我们有一个文档，需要审核标题和内容，先审核标题，后审核内容，标题不合格直接结束<br>文档实体：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Word</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTitle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抽象处理者角色：<br>里面保存了下一级审核的对象指向，以及审核的具体逻辑实现方法  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Handler handler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(Handler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">examine</span><span class="params">(Word word)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体处理者角色：<br>标题审核，如果通过进行下一步审核，如果不通过，直接结束  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TitleHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">examine</span><span class="params">(Word word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (word.getTitle() != <span class="keyword">null</span> &amp;&amp; !<span class="string">&quot;&quot;</span>.equals(word.getTitle()))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;标题合格，通用审核&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="keyword">null</span>)&#123;</span><br><span class="line">                handler.examine(word);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;标题不合格，不通过审核&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体处理者角色：<br>内容审核，如果通过进行下一步，如果不通过，结束  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContentHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">examine</span><span class="params">(Word word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (word.getContent() != <span class="keyword">null</span> &amp;&amp; !<span class="string">&quot;&quot;</span>.equals(word.getContent()))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;内容合格，通用审核&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="keyword">null</span>)&#123;</span><br><span class="line">                handler.examine(word);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;内容不合格，不通过审核&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户角色类：<br>组装具体的责任链，设置审核先后层级  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TitleHandler titleHandler = <span class="keyword">new</span> TitleHandler();</span><br><span class="line">        ContentHandler contentHandler = <span class="keyword">new</span> ContentHandler();</span><br><span class="line">        titleHandler.setNext(contentHandler);</span><br><span class="line"></span><br><span class="line">        Word word = <span class="keyword">new</span> Word();</span><br><span class="line">        word.setTitle(<span class="string">&quot;责任链模式&quot;</span>);</span><br><span class="line"><span class="comment">//        word.setContent(&quot;责任链模式内容&quot;);</span></span><br><span class="line"></span><br><span class="line">        titleHandler.examine(word);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">标题合格，通用审核</span><br><span class="line">内容不合格，不通过审核</span><br></pre></td></tr></table></figure>
<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><img src="http://www.plantuml.com/plantuml/svg/fP2n3e8m48RtFiMDiF02kBaukKZYO1oEze9Di9ZsH1B2kqlRK974oQLD_zvzz_ydMtGEpfrLC8g7rJqomOcjDWsmvfRAhIexmsIu59CGM3ksA1bam1pGg9Pi87LCaaabxHRl6VUiMosXxxG2HtoaWRDDKGxZz667IXhmhWrbmUbhFl9W8CwjlD65CVF8g6Hc53_w_On4sCTGVp4gSkoZntoEaPUOTzGcY-kxN05juvREWDeLnJ8f2SN6qkfZdLQ8ZNFFyaR4rqwIkgBCppS0">


<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代器模式</title>
    <url>/2021/10/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>提供一种方法，顺序访问一个集合对象中的各个元素，而又不暴露该的对象的内部表示。<br>行为型</p>
</blockquote>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li>访问一个集合对象的内容而无需暴露它的内部表示</li>
<li>为遍历不同的集合结构提供一个统一的接口</li>
</ul>
<p>##优点和缺点</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>分离了集合对象的遍历行为</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>类的个数成对增加</li>
</ul>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><ul>
<li>*<em>抽象聚合角色</em> ：定义存储、添加、删除、集合对象以及创建迭代器对象的接口</li>
<li><strong>具体聚合角色</strong> ：实现抽象集合，返回一个具体迭代器的实例</li>
<li><strong>抽象迭代器角色</strong> ：定义访问和遍历聚合元素的接口，通常包括hasNext()，first()，next()等方法</li>
<li><strong>具体迭代器角色</strong> ：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>创建抽象聚合接口，定义方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Aggregate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object obj)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Object obj)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">getIterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现抽象聚合接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteAggregate</span> <span class="keyword">implements</span> <span class="title">Aggregate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        list.add(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        list.remove(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">getIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">new</span> ConcreteIterator(list));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建迭代器接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">first</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Object <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建迭代器接口具体实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; list = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteIterator</span><span class="params">(List&lt;Object&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; list.size() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">first</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        Object obj = list.get(index);</span><br><span class="line">        ;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object obj = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.hasNext()) &#123;</span><br><span class="line">            obj = list.get(++index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用迭代器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Aggregate ag = <span class="keyword">new</span> ConcreteAggregate();</span><br><span class="line">        ag.add(<span class="string">&quot;中山大学&quot;</span>);</span><br><span class="line">        ag.add(<span class="string">&quot;华南理工&quot;</span>);</span><br><span class="line">        ag.add(<span class="string">&quot;韶关学院&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;聚合的内容有：&quot;</span>);</span><br><span class="line">        Iterator it = ag.getIterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            Object ob = it.next();</span><br><span class="line">            System.out.println(ob.toString() + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">聚合的内容有:</span><br><span class="line">中山大学	</span><br><span class="line">华南理工	</span><br><span class="line">韶关学院	</span><br></pre></td></tr></table></figure>

<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><img src="http://www.plantuml.com/plantuml/svg/XL7BZi8m3BptAtmi1v3sp4D2Urff1T-GfgORb2R8CGLKyU-aK4BQ8FOGoSuuuvc9Ceoq4n9XNLM4bM24DZiS2wqaD5QL8CeotnPxb0oss4_c0v2mjWs-nNyyiM1BK24_wzp3rooJMZW7tzP8GiRNObKVDDPes0tLa6gwwbSvNZnMhK3x1fPWy0Hh8d69mNoaScG1ski_9gA9zpQw0Mz4XVJ2M9lrF3j5ZZibVM_mV6yBQpKA0t_2RVgh99B05YKIRVWOo57hUPZm0lqfyUoHwLT8PRmdJvZY21B54JOqcm8cFF0cqn-VhH8jDm00">

































<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>适配器模式</title>
    <url>/2021/09/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口兼容而不能一起工作的那些类能一起工作。<br>适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。  </p>
</blockquote>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li>已经存在的类，它的方法和需求不匹配时（方法结果相似或相同）；  </li>
<li>不是软件设计阶段考虑的设计模式，是随着软件维护，由于不同产品、不同厂家造成功能类似而接口不相同情况下的解决方案。  </li>
</ul>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>客户端通过适配器可以透明地调用目标接口；  </li>
<li>复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类；  </li>
<li>将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题；  </li>
<li>符合开闭原则。  </li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>适配器编写过程需要全面考虑，可能会增加系统的复杂性；  </li>
<li>增加系统代码可读的难度。  </li>
</ul>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><ul>
<li><strong>目标接口：</strong> 当前系统业务所期待的接口，它可以是抽象类或者接口；  </li>
<li><strong>适配者类：</strong> 它是被访问和适配的现存组件库中的组件接口；  </li>
<li><strong>适配器类：</strong> 它是一个转换器，通过继承或者引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。   </li>
</ul>
<h2 id="类结构型模式"><a href="#类结构型模式" class="headerlink" title="类结构型模式"></a>类结构型模式</h2><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>我们生活中经常会给手机充电，但是标准电压是交流电220V，但是我们的手机一般是使用直流电5V的，我们可以用代码来演示一下这个过程的实现。  </p>
<p>首先我们创建一个适配者类，也就是我们220V交流电</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AC220</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">outputAC220V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> output = <span class="number">220</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;输出交流电&quot;</span> + output + <span class="string">&quot;V&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们创建目标接口，也就是我们需要的5V直流电  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DC5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">outputDC5V</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建适配器类，也就是实现我们交流200V转换直流5V的类，可以理解为手机充电器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PowerAdapter</span> <span class="keyword">extends</span> <span class="title">AC220</span> <span class="keyword">implements</span> <span class="title">DC5</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">outputDC5V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> adapterInput = <span class="keyword">super</span>.outputAC220V();</span><br><span class="line">        <span class="comment">//业务处理</span></span><br><span class="line">        <span class="keyword">int</span> adapterOutput = adapterInput / <span class="number">44</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用PowerAdapter输入AC: &quot;</span> + adapterInput + <span class="string">&quot;V；输出DC: &quot;</span> + adapterOutput + <span class="string">&quot;V&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> adapterOutput;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DC5 dc5 = <span class="keyword">new</span> PowerAdapter();</span><br><span class="line">        dc5.outputDC5V();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">输出交流电220V</span><br><span class="line">使用PowerAdapter输入AC: 220V; 输出DC: 5V</span><br></pre></td></tr></table></figure>

<h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><img src="http://www.plantuml.com/plantuml/svg/POwn2i8m48RtFCMDTIbISDAbr0SG51TnYCbP3jea95SLIj_Tj6afudJaxlk_FwgH8K1P5SKMUk6wHqCAo33OZbt7q-6QRQ0Vn214FA1_IeLmh7QHNy7uZjX-XDIaFDat-b9B5nE07qQZbnvgNOCj6WwpvgyssURIvBjWu1KDB3cEboKDhIIJdTcJgMztaBuEItAq7_8yPK7yV6dPYoy0">


<h2 id="对象结构型模式"><a href="#对象结构型模式" class="headerlink" title="对象结构型模式"></a>对象结构型模式</h2><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>同样以上述实例做演示，代码实现只有适配器类中有所不同</p>
<p>首先我们创建一个适配者类，也就是我们220V交流电</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AC220</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">outputAC220V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> output = <span class="number">220</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;输出交流电&quot;</span> + output + <span class="string">&quot;V&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们创建目标接口，也就是我们需要的5V直流电</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DC5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">outputDC5V</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建适配器类，也就是实现我们交流200V转换直流5V的类，可以理解为手机充电器<br><code>类结构型模式</code>是通过继承<code>AC220</code>类来调用方法的，<code>对象结构模式则</code>是通过组合来做的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PowerAdapter</span> <span class="keyword">implements</span> <span class="title">DC5</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AC220 ac220 = <span class="keyword">new</span> AC220();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">outputDC5V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> adapterInput = ac220.outputAC220V();</span><br><span class="line">        <span class="comment">//业务处理</span></span><br><span class="line">        <span class="keyword">int</span> adapterOutput = adapterInput / <span class="number">44</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用PowerAdapter输入AC: &quot;</span> + adapterInput + <span class="string">&quot;V；输出DC: &quot;</span> + adapterOutput + <span class="string">&quot;V&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> adapterOutput;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DC5 dc5 = <span class="keyword">new</span> PowerAdapter();</span><br><span class="line">        dc5.outputDC5V();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">输出交流电220V</span><br><span class="line">使用PowerAdapter输入AC: 220V; 输出DC: 5V</span><br></pre></td></tr></table></figure>

<h3 id="UML类图-1"><a href="#UML类图-1" class="headerlink" title="UML类图"></a>UML类图</h3><img src="http://www.plantuml.com/plantuml/svg/POwz2eCm4CVtFCMDRK4fGgVQGUm355gwb0xNc4f0OqXE7SHtRs8KaIuvSlV_-F4AhOKiJv8Z34otdqfoa8gWQKctD1sUkpqC8niPSmTXliW5NFEJqwz2ztUoinVnAVBMzC9a1Mhd05dhIjH2aPsDsiWEISp5oFrx0INwiF59VooXOYO99GzXQSMsXEH6ryW2QfHgToSZLVbw0vhIBivGcKRHOSF8c2TButWAPHlyPVi3">


<h2 id="接口适配器"><a href="#接口适配器" class="headerlink" title="接口适配器"></a>接口适配器</h2><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><p>接口适配器和上面两种略有不同<br>假设我们现在有一个接口，里面有多个方法，但是我们只想使用其中的一个方法，那么就可以使用一个抽象类，来继承这个接口，并实现这个接口的所有方法，不做任何业务逻辑处理，<br>我们具体想要实现逻辑的类，就可以继承这个抽象类，然后去重写自己想要使用的方法即可。</p>
<p>首先有一个接口，里面有多个方法  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interface1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m4</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m5</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们只想用其中的<code>m1</code>方法，如果直接实现接口的话，需要实现所有的方法<br>我们就可以先创建一个抽象类，去实现这个接口，然后空实现所有的方法  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAdapter</span> <span class="keyword">implements</span> <span class="title">Interface1</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们具体的业务类就可以继承这个抽象类，实现自己需要的方法就可以了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">AbstractAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//业务逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h3><img src="http://www.plantuml.com/plantuml/svg/ROwz3i8m30RtF8L76FitCNLavmNSn4YHaX3L1Y5LUVUsQajKaUryWx-pGMXyeYQu7rHDwlEo1dnrkTvsh3Cs6TkCtOf9AHnOHjG2sY4pzFlP6upBUx0-El8KX4zxyJqug-4t2rCwkxhWce9h2wxRt1AtDJs81UWh5Cn_OBabpG00">




<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发成神之路-精通JUC并发工具十八般武艺——CAS和不变性(五)</title>
    <url>/2021/12/04/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94CAS%E5%92%8C%E4%B8%8D%E5%8F%98%E6%80%A7/</url>
    <content><![CDATA[<h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><h2 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h2><ul>
<li>应用于并发场合，是一种思想一种算法，主要用于并发编程中，实现不可被打断的数据交换操作，从而避免多线程情况下由于线程顺序执行不能缺点而引起的问题</li>
<li>我认为V的值应该是A，如果是的话那我就把它改成B，如果不是A（说明被别人修改过了），那我就不修改了，避免多人同时修改导致出错</li>
<li>CAS有三个操作数：内存值V，预期值A，要修改的值B，当且仅当预期值A和内存值V相同时，才将内存值修改为B，否则什么都不做，最后返回现在的V值</li>
<li>CPU的特殊指令（CAS会先进行比较，然后更新，由CPU保证原子性）<blockquote>
<p>CAS的等价代码如下所示，compareAndSwap方法发是由synchronized锁来保证原子性，而对于CAS来说，是由CPU保证的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimulatedCAS</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">compareAndSwap</span><span class="params">(<span class="keyword">int</span> expectedValue,<span class="keyword">int</span> newValue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> oldValue = value;</span><br><span class="line">        <span class="keyword">if</span> (oldValue == expectedValue) &#123;</span><br><span class="line">            value = newValue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li>乐观锁</li>
<li>并发容器</li>
<li>原子类</li>
</ul>
<h2 id="分析在Java中是如何利用CAS实现原子操作的"><a href="#分析在Java中是如何利用CAS实现原子操作的" class="headerlink" title="分析在Java中是如何利用CAS实现原子操作的"></a>分析在Java中是如何利用CAS实现原子操作的</h2><ul>
<li><code>AtomicInteger</code>加载<code>Unsafe</code>工具，用来直接操作内存数据</li>
<li>用<code>Unsafe</code>来实现底层操作</li>
<li>用<code>volatile</code>修饰<code>value</code>字段，保证可见性</li>
<li>Unsafe类中的compareAndSwapInt方法<ul>
<li>方法中先想办法拿到变量value在内存中的地址</li>
<li>通过Atomic::cmpxchg实现原子性的比较和替换，其中参数x是即将更新的值，参数e是原内存的值，至此，最终完成CAS的全过程</li>
</ul>
</li>
</ul>
<h3 id="Unsafe类"><a href="#Unsafe类" class="headerlink" title="Unsafe类"></a>Unsafe类</h3><ul>
<li><code>Unsafe</code>是CAS的核心类，Java无法直接访问底层操作系统，而是通过本地(native)方法来访问。不过尽管如此，JVM还是开了一个后门，JDK中有一个<code>Unsafe</code>，它提供了硬件级别的原子操作</li>
<li><code>valueOffset</code>表示的是变量值在内存中的偏移地址，因为<code>Unsafe</code>就是根据内存偏移地址获取数据的原值的，这样我们就能通过<code>Unsafe</code>来实现CAS了</li>
</ul>
<h3 id="CAS缺点"><a href="#CAS缺点" class="headerlink" title="CAS缺点"></a>CAS缺点</h3><ul>
<li>ABA问题(CAS只会判断当前值是否是期待的值，并不会去判断中间是都有过更改，假设当前期待的是5，之前是5，被一个线程改成了7，然后又被一个线程改成5，此时已经被改了两次，无法判断)</li>
<li>自旋时间过长(如果一直拿不到锁，就会一直自旋，可能会占用比较多的CPU)</li>
</ul>
<h1 id="以不变应万变（不可变性）"><a href="#以不变应万变（不可变性）" class="headerlink" title="以不变应万变（不可变性）"></a>以不变应万变（不可变性）</h1><h2 id="什么是不变性"><a href="#什么是不变性" class="headerlink" title="什么是不变性"></a>什么是不变性</h2><ul>
<li>如果对象在被创建后，状态就不能被修改，那么它就是不可变的</li>
<li>具有不变性的对象一定是线程安全的，我们不需要对其采取任何额外的安全措施，也能保证线程安全</li>
</ul>
<h2 id="final的作用"><a href="#final的作用" class="headerlink" title="final的作用"></a>final的作用</h2><ul>
<li>类防止被继承、方法防止被重写、变量防止被修改</li>
<li>天生是线程安全的，而不需要额外的同步开销</li>
</ul>
<h2 id="3中用法：修饰变量、方法、类"><a href="#3中用法：修饰变量、方法、类" class="headerlink" title="3中用法：修饰变量、方法、类"></a>3中用法：修饰变量、方法、类</h2><p>###final修饰变量</p>
<ul>
<li>被final修饰的变量，意味着值不能被修改，如果变量是对象，那么对象的引用不能变，但是对象自身的内容依然可以变化</li>
<li>属性被声明为final后，该变量则只能被赋值一次，且一旦被赋值，final的变量就不能再被改变，无论如何也不会变化</li>
<li>类中的final属性<ul>
<li>第一种是在声明变量的等号右边直接赋值</li>
<li>第二种就是构造函数中赋值</li>
<li>第三种就是在类的初始代码块中赋值（不常用）</li>
<li>如果不采用第一种赋值方法，那么就必须在2和3中挑一个来赋值，而不能不赋值，这是final的语法所规定的</li>
</ul>
</li>
<li>类中的static final属性<ul>
<li>第一种是在声明变量的等号右边直接赋值</li>
<li>第二种是在static初始代码块中赋值，但是不能使用普通代码块赋值</li>
</ul>
</li>
<li>方法中final变量<ul>
<li>和前面两种不同，由于这里的变量是在方法里面的，所以没有构造函数，也不存在初始代码块</li>
<li>不规定赋值时机，只要求在使用前必须赋值，这和方法中的非final变量的要求也是一样的</li>
</ul>
</li>
</ul>
<h4 id="为什么要规定赋值时机"><a href="#为什么要规定赋值时机" class="headerlink" title="为什么要规定赋值时机"></a>为什么要规定赋值时机</h4><ul>
<li>如果初始化不赋值，后续赋值，就是从null变成你的赋值，这就违反了final不变原则了</li>
</ul>
<h3 id="final修饰方法"><a href="#final修饰方法" class="headerlink" title="final修饰方法"></a>final修饰方法</h3><ul>
<li>构造方法不允许final修饰</li>
<li>不可被重写，也就是不能被override，即便子类有同样名字的方法发，那也不是override，这个和static方法是一个道理</li>
<li>引申：静态方法不能被重写（但是可以写重名的方法）</li>
</ul>
<p>###final修饰类</p>
<ul>
<li>不可被继承</li>
<li>例如典型的String类就是final的，我们从没见过那个类是继承String</li>
</ul>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ul>
<li>final修饰对象的时候，只是对象的引用不变，而对象本身的属性是可以变化的</li>
<li>final使用原则：良好的编程习惯</li>
</ul>
<h2 id="不变性和final的关系"><a href="#不变性和final的关系" class="headerlink" title="不变性和final的关系"></a>不变性和final的关系</h2><ul>
<li>不变性并不意味着，简单地用final修饰就是不可变<ul>
<li>对于基本数据类型，确实被final修饰后就具有不可变性</li>
<li>但是对于对象类型，需要该对象保证自身被创建后，状态永远不会变才可以</li>
</ul>
</li>
<li>满足一下条件时，对象才是不可变的<ul>
<li>对象创建后，其状态就不能修改</li>
<li>所有属性都是final修饰的</li>
<li>对象创建过程中没有发发生逸出</li>
</ul>
</li>
</ul>
<h2 id="把变量写在线程内部——栈封闭"><a href="#把变量写在线程内部——栈封闭" class="headerlink" title="把变量写在线程内部——栈封闭"></a>把变量写在线程内部——栈封闭</h2><ul>
<li>在方法里面新建的局部变量，实际上是存储在每个线程私有的栈空间，而每个栈的占用空间是不能被其他线程所访问到的，所以不会有线程安全问题，这就是著名的“栈封闭”技术，是“线程封闭”技术的一种情况</li>
<li>方法内部的变量是不会有并发问题的（栈封闭）</li>
</ul>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发成神之路-精通JUC并发工具十八般武艺——ThreadLocal(二)</title>
    <url>/2021/11/28/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94ThreadLocal/</url>
    <content><![CDATA[<h1 id="两大使用场景——ThreadLocal的用途"><a href="#两大使用场景——ThreadLocal的用途" class="headerlink" title="两大使用场景——ThreadLocal的用途"></a>两大使用场景——ThreadLocal的用途</h1><ul>
<li>场景1：每个线程需要一个独享的对象（通常是工具类，典型需要使用的类有SimpleDateFormat和Random）<blockquote>
<p>SimpleDateFormat为线程不安全的，如果在方法中每次都创建一个SimpleDateFormat对象<br>如果访问量较高，会导致格式化出来的时间有部分是重复的<br>可以通过使用ThreadLocal，针对每一个线程创建一个SimpleDateFormat对象，这样同一个线程的不同任务是排队进行的，不同线程使用的是不同的对象，就可以解决并发问题  </p>
</blockquote>
</li>
<li>场景2：每个线程内需要保存全局变量（例如在拦截器中获取用户信息，可以让不同方法直接使用，避免参数传递的麻烦）<blockquote>
<p>假设当前用户信息需要被线程内所有方法共享，一个比较繁琐的解决发难就是把user作为阐述层层传递，从方法1到方法2到方法3，以次类推，但是这样做代码冗余，且不利于维护<br>使用ThreadLocal，当前线程中公共变量，可以在当前线程中的任何一个方法中调用获取相应的变量值</p>
</blockquote>
</li>
</ul>
<h2 id="ThreadLocal的两个作用"><a href="#ThreadLocal的两个作用" class="headerlink" title="ThreadLocal的两个作用"></a>ThreadLocal的两个作用</h2><ul>
<li>让某个需要用到的对象在线程间隔离（每个线程都有自己的独立的对象）</li>
<li>在任何方法中都可以轻松的获取到对象</li>
</ul>
<h2 id="根据共享对象的生产时机不同，选择initialValue或set来保存对象"><a href="#根据共享对象的生产时机不同，选择initialValue或set来保存对象" class="headerlink" title="根据共享对象的生产时机不同，选择initialValue或set来保存对象"></a>根据共享对象的生产时机不同，选择<code>initialValue</code>或<code>set</code>来保存对象</h2><ul>
<li>场景一：<code>initialValue</code><blockquote>
<p>在ThreadLocal第一个get的时候，把对象给初始化出来，对象的初始化时机可以由我们控制</p>
</blockquote>
</li>
<li>场景二：<code>set</code><blockquote>
<p>如果需要保存到ThreadLocal里面的对象的生产时机不由我们随意控制，例如拦截器生成的用户信息，用ThreadLocal.set()直接放到我们的ThreadLocal中去，以便后续使用</p>
</blockquote>
</li>
</ul>
<h1 id="使用ThreadLocal带来的好处"><a href="#使用ThreadLocal带来的好处" class="headerlink" title="使用ThreadLocal带来的好处"></a>使用ThreadLocal带来的好处</h1><ul>
<li>达到线程安全的目的</li>
<li>不需要加锁，提高执行效率</li>
<li>更高效的利用内存、节省开销：相比于每一个任务都新建一个SimpleDateFormat，显然用ThreadLocal可以节省内存和开销</li>
<li>免去传参的繁琐：无论是场景一的工具类，还是场景二的用户名，都可以在任何地方直接通过ThreadLocal拿到，再也不需要每次都传同样的参数，ThreadLocal使得代码耦合度更低，更优雅</li>
</ul>
<h1 id="主要方法介绍"><a href="#主要方法介绍" class="headerlink" title="主要方法介绍"></a>主要方法介绍</h1><ul>
<li><p><code>T initialValue()</code></p>
<blockquote>
<p>该方法会返回当前线程对应的”初始值“，这是一个延迟加载的方法，只有再调用<code>get()</code>的时候，才会触发<br>当线程第一个吃用<code>get()</code>方法访问变量时，将调用此方法，除非线程先调用了<code>set()</code>方法，在这种情况下，不会为线程调用本<code>initialValue()</code>方法<br>通常每个线程最调用一次此方法，但如果已经调用了<code>remove()</code>，再调用<code>get()</code>，则可以再次调用此方法<br>如果不重写本方法，这个放回就会返回null，一般使用匿名内部类的方法来重写<code>initialValue()</code>方法，以便再后续使用中，可以初始化副本对象<br>该方法没有默认实现，如果我们需要到该方法，需要自己实现，通常使用匿名内部类的方式</p>
</blockquote>
</li>
<li><p><code>void set(T t)</code></p>
<blockquote>
<p>为这个线程设置一个新值</p>
</blockquote>
</li>
<li><p><code>T get()</code></p>
<blockquote>
<p>得到这个线程对应的value，如果是首次调用<code>get()</code>（没有调用<code>set()</code>方法直接调用<code>get()</code>），则会调用<code>initialValue()</code>方法获取这个值<br><code>get()</code>方法是先取出当前线程的<code>ThreadLocalMap</code>，然后调用<code>map.getEntry</code>方法，把本<code>ThreadLocal</code>的引用作为参数传进去，取出map中属于本<code>ThreadLocal</code>的value<br>注意，这个map以及map中的key和value都是保存再线程中的，而不是保存再ThreadLocal中的</p>
</blockquote>
</li>
<li><p><code>void remove()</code></p>
<blockquote>
<p>删除对应这个线程的值</p>
</blockquote>
</li>
</ul>
<h1 id="ThreadLocalMap类"><a href="#ThreadLocalMap类" class="headerlink" title="ThreadLocalMap类"></a>ThreadLocalMap类</h1><ul>
<li>ThreadLocalMap类是每个线程Thread类里面的变量，里面最重要的是一个键值对数组<code>Entry[] table</code>，可以认为是一个map，键值对：<ul>
<li>键：这个ThreadLocal</li>
<li>值：实际需要的成员变量，比如user或者SimpleDateFormat对象</li>
</ul>
</li>
<li>当发现hash冲突的时候，ThreadLocalMap采用的是线性探测法，也就是如果发生冲突，就继续找下一个空位置，而不是采用链表拉链</li>
</ul>
<h1 id="ThreadLocal注意点"><a href="#ThreadLocal注意点" class="headerlink" title="ThreadLocal注意点"></a>ThreadLocal注意点</h1><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><ul>
<li>什么是内存泄漏：某个对象不再有用，但是占用的内存却不能被回收</li>
<li>key的泄漏：ThreadLocalMap中的Entry继承自WeakReference，是弱引用<ul>
<li>弱引用的特点是，如果这个对象只被弱引用关联（没有任何强引用关联），那么这个对象就可以被回收，所以弱引用不会阻止GC</li>
</ul>
</li>
<li>value的泄漏<ul>
<li>ThreadLocalMap的每个Entry都是一个对key的弱引用，同时，每个Entry都包含了一个对value的强引用</li>
<li>正常情况下，当线程终止，保存再ThreadLocal里面的value会被垃圾回收，因为没有任何强引用了</li>
<li>但是如果线程不终止（比如线程需要保持很久，使用线程池的场景，线程一直被重复使用），那么key对应的value就不能被回收，因为又以下的调用链：<ul>
<li>Thread -&gt; ThreadLocalMap -&gt; Entry(key为null) -&gt; value</li>
</ul>
</li>
<li>因为value和Thread之间还存在这个强引用链路，所以导致value无法回收，就可能出现OOM</li>
<li>JDK已经考虑到了这个问题，多以在set，remove，rehash方法中会扫描key为null的Entry，并把相应的value设置成null，这样value对象就可以被回收</li>
<li>但是如果一个ThreadLocal不被使用，那么实际上set,remove,rehash方法也不会被调用到，如果同时线程又不停止，那么调用链就一直存在，那么就导致了value的内存泄漏</li>
</ul>
</li>
</ul>
<h2 id="如何避免内存泄漏（阿里规约）"><a href="#如何避免内存泄漏（阿里规约）" class="headerlink" title="如何避免内存泄漏（阿里规约）"></a>如何避免内存泄漏（阿里规约）</h2><ul>
<li>调用remove方法，就会删除相应的Entry对象，可以避免内存泄漏，所以使用完ThreadLocal之后，应该调用remove方法</li>
</ul>
<h2 id="控制针问题"><a href="#控制针问题" class="headerlink" title="控制针问题"></a>控制针问题</h2><ul>
<li>当ThreadLocal.get()方法出来的值，直接被基本类型接受的时候，如果值是空，那么在转为基本类型的时候会抛出控制在异常</li>
</ul>
<h2 id="共享对象"><a href="#共享对象" class="headerlink" title="共享对象"></a>共享对象</h2><ul>
<li>如果每个线程中ThreadLocal.set()进去的东西本来就是多个线程共享的同一个对象，比如static对象，那么多个线程的ThreadLocal.get()取的还是这个共享对象本身，还是会有并发访问的问题</li>
</ul>
<h2 id="如果使用ThreadLocal就可以解决问题，那么不要强制使用"><a href="#如果使用ThreadLocal就可以解决问题，那么不要强制使用" class="headerlink" title="如果使用ThreadLocal就可以解决问题，那么不要强制使用"></a>如果使用ThreadLocal就可以解决问题，那么不要强制使用</h2><ul>
<li>例如在任务数很少的时候，在局部变量中可以新建对象就可以解决问题，那么就不需要使用到ThreadLocal</li>
</ul>
<h2 id="优先使用框架的支持，而不是自己创造"><a href="#优先使用框架的支持，而不是自己创造" class="headerlink" title="优先使用框架的支持，而不是自己创造"></a>优先使用框架的支持，而不是自己创造</h2><ul>
<li>例如spring中，如果可以使用RequestContextHolder，那么就不需要自己维护ThreadLocal，因为自己可能会忘记调用remove()方法，造成内存泄漏</li>
</ul>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发成神之路-精通JUC并发工具十八般武艺——原子类(四)</title>
    <url>/2021/12/04/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94%E5%8E%9F%E5%AD%90%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="什么是原子类，有什么作用？"><a href="#什么是原子类，有什么作用？" class="headerlink" title="什么是原子类，有什么作用？"></a>什么是原子类，有什么作用？</h1><ul>
<li>不可分割</li>
<li>一个操作是不可中断的，即便是多线程的情况下也可以保证</li>
<li>java.util.concurrent.atomic</li>
<li>原子类的作用和锁类似，是为了保证并发情况下线程安全。不过原子类相比于锁，有一定的优势：<ul>
<li>粒度更细：原子变量可以把竞争范围缩小到变量级别，这是我们可以获得的最细粒度的情况了，通常锁的粒度都要大于原子变量的粒度</li>
<li>效率更高：通常，使用原子类的效率会比使用锁的效率更高，除了高度竞争的情况</li>
</ul>
</li>
</ul>
<h1 id="6类原子类纵览"><a href="#6类原子类纵览" class="headerlink" title="6类原子类纵览"></a>6类原子类纵览</h1><table>
<thead>
<tr>
<th align="left">类型描述</th>
<th align="left">原子类</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Atomic*基本类型原子类</td>
<td align="left">AtomicInteger<br>AtomicLong<br>AtomicBoolean</td>
</tr>
<tr>
<td align="left">Atomic*array数组类型原子类</td>
<td align="left">AtomicIntegerArray<br>AtomicLongArray<br>AtomicReferenceArray</td>
</tr>
<tr>
<td align="left">Atomic*Reference引用类型原子类</td>
<td align="left">AtomicReference<br>AtomicStampedReference<br>AtomicMarkableReference</td>
</tr>
<tr>
<td align="left">Atomic*FieldUpdater升级类型原子类</td>
<td align="left">AtomicIntegerFieldUpdater<br>AtomicLongFieldUpdater<br>AtomicReferenceFieldUpdater</td>
</tr>
<tr>
<td align="left">Adder累加器</td>
<td align="left">LongAdder<br>DoubleAdder</td>
</tr>
<tr>
<td align="left">Accumulator累加器</td>
<td align="left">LongAccumulator<br>DoubleAccumulator</td>
</tr>
</tbody></table>
<h1 id="Atomic-基本类型原子类，以AtomicInteger为例"><a href="#Atomic-基本类型原子类，以AtomicInteger为例" class="headerlink" title="Atomic*基本类型原子类，以AtomicInteger为例"></a>Atomic*基本类型原子类，以AtomicInteger为例</h1><h2 id="AtomicInteger常用方法"><a href="#AtomicInteger常用方法" class="headerlink" title="AtomicInteger常用方法"></a>AtomicInteger常用方法</h2><ul>
<li>public final int get()//获取当前的值</li>
<li>public final int getAndSet()//获取当前的值，并设置新值</li>
<li>public final int getAndIncrement()//获取当前的值，并自增</li>
<li>public final int getAndDecrement()//获取当前值，并自减</li>
<li>public final int getAndAdd(int delta)//获取当前值，并加上预期的值</li>
<li>boolean compareAndSet(int expect,int update)//如果输入的数组等于预期值，则以原子方式将该值设置为输入值(先判断当前值是否是expect，如果是则修改为update的值，不是返回false)</li>
</ul>
<h1 id="Atomic-Array数组类型原子类"><a href="#Atomic-Array数组类型原子类" class="headerlink" title="Atomic*Array数组类型原子类"></a>Atomic*Array数组类型原子类</h1><ul>
<li>里面的每个元素都是原子类，都是线程安全的</li>
</ul>
<h1 id="Atomic-Reference引用类型原子类"><a href="#Atomic-Reference引用类型原子类" class="headerlink" title="Atomic*Reference引用类型原子类"></a>Atomic*Reference引用类型原子类</h1><ul>
<li>AtomicReference：AtomicReference类的作用，和AtomicInteger并没有本质区别，AtomicInteger可以让一个整数保证原子性，而AtomicReference可以让一个对象保证原子性，当然AtomicReference的功能明显比AtomicInteger强，因为一个对象里面可以包含很多属性。</li>
<li>用法和AtomicInteger类似<blockquote>
<p>代码如下所示：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Thread&gt; sign = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        <span class="keyword">while</span> (!sign.compareAndSet(<span class="keyword">null</span>, thread)) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        sign.compareAndSet(thread, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpinLock spinLock = <span class="keyword">new</span> SpinLock();</span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始尝试获取自旋锁&quot;</span>);</span><br><span class="line">                spinLock.lock();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获得自旋锁&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">300</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    spinLock.unlock();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;释放了自旋锁&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(runnable).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(runnable).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="把普通变量升级为原子类：用AtomicIntegerFieldUpdater升级原有变量"><a href="#把普通变量升级为原子类：用AtomicIntegerFieldUpdater升级原有变量" class="headerlink" title="把普通变量升级为原子类：用AtomicIntegerFieldUpdater升级原有变量"></a>把普通变量升级为原子类：用<code>AtomicIntegerFieldUpdater</code>升级原有变量</h1></li>
<li><code>AtomicIntegerFieldUpdater</code>对普通变量进行升级</li>
<li>使用场景：偶尔需要一个原子get-set操作（大多数情况的时候不会有并发情况，只有在某一时间段，或者某一个操作的时候才会有）<blockquote>
<p>代码如下所示，在使用的时候使用<code>AtomicIntegerFieldUpdater</code>处理即可</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerFieldUpdaterDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Candidate tom;</span><br><span class="line">    <span class="keyword">static</span> Candidate peter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AtomicIntegerFieldUpdater&lt;Candidate&gt; sourceUpdater =</span><br><span class="line">            AtomicIntegerFieldUpdater.newUpdater(Candidate.class, <span class="string">&quot;score&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            peter.score++;</span><br><span class="line">            sourceUpdater.getAndIncrement(tom);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Candidate</span> </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        tom = <span class="keyword">new</span> Candidate();</span><br><span class="line">        peter = <span class="keyword">new</span> Candidate();</span><br><span class="line">        AtomicIntegerFieldUpdaterDemo a = <span class="keyword">new</span> AtomicIntegerFieldUpdaterDemo();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(a);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(a);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;普通变量：&quot;</span>+peter.score);</span><br><span class="line">        System.out.println(<span class="string">&quot;升级后的记过：&quot;</span>+tom.score);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="AtomicIntegerFieldUpdater的注意点"><a href="#AtomicIntegerFieldUpdater的注意点" class="headerlink" title="AtomicIntegerFieldUpdater的注意点"></a>AtomicIntegerFieldUpdater的注意点</h2></li>
<li>可见范围（如果变量是不可见的就不能操作）</li>
<li>不支持static</li>
</ul>
<h1 id="Adder累加器"><a href="#Adder累加器" class="headerlink" title="Adder累加器"></a>Adder累加器</h1><ul>
<li>是Java8中引入的，相对是比较新的一个类</li>
<li>高并发下LongAdder比AtomicLong效率高，不过本质是空间换时间</li>
<li>竞争激烈的时候，LongAdder把不同的线程对应到不同的Cell上进行修改，降低了冲突的概率，是多段锁的概念，提高了并发性<blockquote>
<p>使用<code>AtomicLong</code>和<code>LongAdder</code>进行自增操作，如下代码所示<br>使用20个线程执行10000个任务，每个任务里面是自增一万次，总计一亿次<br><code>LongAdder</code>的耗时要远远低于<code>AtomicLong</code><br><code>AtomicLong</code>每次执行加1之后，都需要把结果刷到主内存中，以保证其他线程可见<br><code>LongAdder</code>则不需要，只是每个线程单独计数，之后在进行汇总</p>
</blockquote>
</li>
</ul>
<p>AtomicLong  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicLongDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        AtomicLong counter = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            executorService.submit(<span class="keyword">new</span> Task(counter));</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        <span class="keyword">while</span> (!executorService.isTerminated())&#123;&#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(counter.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;AtomicLong耗时：&quot;</span>+(end-start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> AtomicLong count;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(AtomicLong count)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.count = count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                count.getAndIncrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">100000000</span><br><span class="line">AtomicLong耗时：1773</span><br></pre></td></tr></table></figure>
<p>LongAdder  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongAdderDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        LongAdder counter = <span class="keyword">new</span> LongAdder();</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            executorService.submit(<span class="keyword">new</span> Task(counter));</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        <span class="keyword">while</span> (!executorService.isTerminated())&#123;&#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(counter.sum());</span><br><span class="line">        System.out.println(<span class="string">&quot;LongAdder 耗时：&quot;</span>+(end-start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> LongAdder count;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(LongAdder count)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.count = count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                count.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">100000000</span><br><span class="line">LongAdder 耗时：172</span><br></pre></td></tr></table></figure>

<h2 id="LongAdder带来的改进和原理"><a href="#LongAdder带来的改进和原理" class="headerlink" title="LongAdder带来的改进和原理"></a>LongAdder带来的改进和原理</h2><ul>
<li>在内部，这个<code>LongAdder</code>的实现原理和刚才的<code>AtomicLong</code>是有不同的，刚才的<code>AtomicLong</code>的实现原理是每一次加法都需要做同步，所以在高并发的时候会导致冲突比较多，也就降低了效率</li>
<li>而此时的<code>LongAdder</code>，每个线程会有自己的一个计数器，仅用来在自己线程内计数，这样一来就不会有其他线程的计数器干扰</li>
<li>第一线程的计数器数值为1的时候，可能线程2的计数器的值已经是3了，他们之间并不存在竞争关系，所以在加和的过程中，根本不需要同步机制，也不需要刚才的flush和refresh，这里也没有一个公共的counter来给所有线程统一计数</li>
<li><code>LongAdder</code>引入分段累加的概念，内部有一个<code>base</code>变量和一个<code>Cell[]</code>数组共同参与计数：<ul>
<li><code>base</code>变量：竞争不激烈，直接累加到该变量上</li>
<li><code>Cell[]</code>数组：竞争激烈，各个线程分散累加到自己的槽<code>Cell[i]</code>中</li>
</ul>
</li>
<li><code>sum()</code>方法源码<blockquote>
<p>如下图所示，方法注释中也有讲解，由于是将Cell[]数组和base中的所有值相加，当循环Cell[]数组的时候，如果里面的值又有变动，最终获得结果就可能不精确，循环过的对象在发生改变，无法将值再累计到结果上<br>如果调用方法的时候Cell[]数组不会再发生改变，得到的值就是精确结果<br><img src="/2021/12/04/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94%E5%8E%9F%E5%AD%90%E7%B1%BB/LongAdder%E7%B1%BBsum%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81.png" alt="LongAdder类sum方法源码"></p>
</blockquote>
</li>
</ul>
<h2 id="对比AtomicLong和LongAdder"><a href="#对比AtomicLong和LongAdder" class="headerlink" title="对比AtomicLong和LongAdder"></a>对比<code>AtomicLong</code>和<code>LongAdder</code></h2><ul>
<li>在低争用下，<code>AtomicLong</code>和<code>LongAdder</code>这两个类具有相似的特征，但是在竞争激烈的情况下，<code>LongAdder</code>的预期吞吐量要高的多，但要消耗更多的空间</li>
<li><code>LongAdder</code>适合的场景是统计求和和计数的场景，而且<code>LongAdder</code>基本只提供了add方法，而<code>AtomicLong</code>还具有cas方法</li>
</ul>
<h1 id="Accumulator累加器"><a href="#Accumulator累加器" class="headerlink" title="Accumulator累加器"></a>Accumulator累加器</h1><ul>
<li><code>Accumulator</code>和<code>Adder</code>非常相似，<code>Accumulator</code>就是一个更通用版本的<code>Adder</code><blockquote>
<p>具体代码实现如下所示，可以实现1-9的叠加，构造函数中的表达式里面的算法可以根据需要进行更该</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongAccumulatorDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LongAccumulator accumulator = <span class="keyword">new</span> LongAccumulator((x, y) -&gt; x + y, <span class="number">0</span>);</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">8</span>);</span><br><span class="line">        IntStream.range(<span class="number">1</span>,<span class="number">10</span>).forEach(i-&gt;executorService.submit(()-&gt;accumulator.accumulate(i)));</span><br><span class="line">        System.out.println(accumulator.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2></li>
<li>适用于需要大量计算，并且可以并行计算的场景</li>
<li>不保证计算的顺序（如上代码，使用了线程池，不能保证那个线程先执行，也许是1+3+4+2…）</li>
</ul>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发成神之路-精通JUC并发工具十八般武艺——并发容器(六)</title>
    <url>/2021/12/04/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h1 id="并发容器概念"><a href="#并发容器概念" class="headerlink" title="并发容器概念"></a>并发容器概念</h1><ul>
<li><code>ConcurrentHashMap</code>：线程安全的HashMap</li>
<li><code>CopyOnWriteArrayList</code>：线程安全的List</li>
<li><code>BlockingQueue</code>：这是一个接口，表示阻塞队列，非常适合用于作为数据共享的通道</li>
<li><code>ConcurrentLinkedQueue</code>：高效的非阻塞队列，使用链表实现。可以看作一个线程安全的LinkedList</li>
<li><code>ConcurrentSkipListMap</code>：是一个Map，使用跳表的数据结构进行快速查找</li>
</ul>
<h1 id="趣说集合类的历史——古老和过时的同步容器"><a href="#趣说集合类的历史——古老和过时的同步容器" class="headerlink" title="趣说集合类的历史——古老和过时的同步容器"></a>趣说集合类的历史——古老和过时的同步容器</h1><ul>
<li>Vector和Hashtable<ul>
<li>主要通过在方法上面添加<code>synchronized</code>关键字，来实现线程安全，效率很差  </li>
</ul>
</li>
<li>HashMap和ArrayList<ul>
<li>HashMap和ArrayList是线程不安全的，不过可以通过<code>Collections.synchronizedList(new ArrayList&lt;E&gt;())</code>和<code>Collections.synchronizedMap(new HashMap&lt;K,V&gt;())</code>使之变成线程安全的</li>
<li>使用这两个方法包装之后，其实也是使用的<code>synchronized</code>，只不过锁的是同步代码块，效率并不会有所提升</li>
</ul>
</li>
<li><code>ConcurrentHashMap</code>和<code>CopyOnWriteArrayList</code><ul>
<li>取代同步的HashMap和同步的ArrayList</li>
</ul>
</li>
</ul>
<h1 id="ConcurrentHashMap-重点、面试常考"><a href="#ConcurrentHashMap-重点、面试常考" class="headerlink" title="ConcurrentHashMap(重点、面试常考)"></a>ConcurrentHashMap(重点、面试常考)</h1><h2 id="Map简介"><a href="#Map简介" class="headerlink" title="Map简介"></a>Map简介</h2><img src="http://www.plantuml.com/plantuml/svg/POv13a0m44NtJj7ZM6331OP-J5H9En69k3iMcghb_7b_vh4Lk9uwg9BMuymwGzwhdFnupuhdrM265VzP5smdw1V2Bh0wb6wAmz5wSG8TKobHqSO3jGOn56hXPUE0n2XkVipb2N_k5m00">

<ul>
<li>HashMap：是根据key的hashCode进行存储的，键允许一个null值，value不做限制，线程非安全</li>
<li>Hashtable：功能和HashMap一致，线程安全，不过性能比较差</li>
<li>LinkedHashMap：保存记录的插入顺序</li>
<li>TreeMap：根据key进行排序，有默认排序规则，也可以自动逸排序规则</li>
</ul>
<h2 id="为什么HashMap是线程不安全的？"><a href="#为什么HashMap是线程不安全的？" class="headerlink" title="为什么HashMap是线程不安全的？"></a>为什么HashMap是线程不安全的？</h2><ul>
<li>同时put碰撞导致数据丢失<ul>
<li>如果两个线程同时存储，key的hashCode相同，会导致有一个的值丢失，只会存储一个</li>
</ul>
</li>
<li>同时put扩容导致数据丢失<ul>
<li>如果两个线程同时对hashMap进行了扩容，那么扩容只会的数组只有一个能被保存下来，导致另外一个的数据丢失</li>
</ul>
</li>
<li>死循环造成CPU 100%<ul>
<li>多线程的情况下会照成循环链表最终导致死循环</li>
<li>原因分析: <a href="https://coolshell.cn/articles/9606.html">点击查看</a><blockquote>
<p>死循环的实现代码如下所示:<br>具体复现方式: 首先需要将JDk切换成1.7版本,然后按下图所示打上断点,并将断点设置为线程级别,当两个线程都走到第二各断点的时候,放过所有断点,就会复现循环链表的情况<br><img src="/2021/12/04/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/HashMap%E6%AD%BB%E5%BE%AA%E7%8E%AF%E5%A4%8D%E7%8E%B0%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="HashMap死循环复现示意图"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapEndlessloop</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;Integer,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span>,<span class="number">1.5f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        map.put(<span class="number">5</span>,<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        map.put(<span class="number">7</span>,<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>,<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                map.put(<span class="number">15</span>,<span class="string">&quot;D&quot;</span>);</span><br><span class="line">                System.out.println(map);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;Thread 1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                map.put(<span class="number">1</span>,<span class="string">&quot;E&quot;</span>);</span><br><span class="line">                System.out.println(map);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;Thread 2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="HashMap分析"><a href="#HashMap分析" class="headerlink" title="HashMap分析"></a>HashMap分析</h2></li>
</ul>
</li>
<li>在1.7版本的JDK中,底层数据结构是数组加链表</li>
<li>在1.8中,当链表的长度达到一定的阈值之后,就会转变成红黑树<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3></li>
<li>每个节点要么是红色,要么是黑色,但是根节点永远是黑色</li>
<li>红色节点不能连续(也即是,红色节点的孩子和父亲都不能是红色)</li>
<li>从任意节点到其子树中每个叶子节点的路径都包含了数量相同的黑色节点</li>
<li>所有的叶子节点都是黑色的</li>
</ul>
<h3 id="HashMap关于并发的特点"><a href="#HashMap关于并发的特点" class="headerlink" title="HashMap关于并发的特点"></a>HashMap关于并发的特点</h3><ul>
<li>非线程安全</li>
<li>迭代时不允许修改内容</li>
<li>只读的并发是安全的</li>
<li>如果一定要把HashMap用在并发环境,用Collection.synchronizedMap(new HashMap&lt;K,V&gt;())</li>
</ul>
<h2 id="JDK1-7的ConcurrentHashMap实现和分析"><a href="#JDK1-7的ConcurrentHashMap实现和分析" class="headerlink" title="JDK1.7的ConcurrentHashMap实现和分析"></a>JDK1.7的ConcurrentHashMap实现和分析</h2><ul>
<li>Java7中的ConcurrentHashMap最外层是多个segment,每个segment的底层数据结构与HashMap类似,仍然是数组和链表组成的拉链法</li>
<li>每个segment独立上ReentrantLock锁,每个segment之间互不影响,提高了并发效率</li>
<li>ConcurrentHashMap默认有16各segment,所以最多可以同时支持16个线程并发写(从中分别分布在不同segment上).这个默认值可以在初始化的时候设置为其他值,但是一旦初始化以后,是不可以扩容的</li>
</ul>
<h2 id="JDK1-8的ConcurrentHashMap实现和分析"><a href="#JDK1-8的ConcurrentHashMap实现和分析" class="headerlink" title="JDK1.8的ConcurrentHashMap实现和分析"></a>JDK1.8的ConcurrentHashMap实现和分析</h2><h3 id="putValue流程"><a href="#putValue流程" class="headerlink" title="putValue流程"></a>putValue流程</h3><ul>
<li>判断key  value不为空</li>
<li>计算Hash值</li>
<li>根据对应位置节点的类型,来赋值,或者helpTransfer,或者增长链表,或者给红黑树增加节点</li>
<li>检查满足阈值就”红黑树化”</li>
<li>返回oldVal</li>
</ul>
<h3 id="get流程"><a href="#get流程" class="headerlink" title="get流程"></a>get流程</h3><ul>
<li>计算hash值</li>
<li>找到对应的位置,根据情况进行:<ul>
<li>直接取值</li>
<li>红黑树里找值</li>
<li>遍历链表找值</li>
<li>返回找到的结果</li>
</ul>
</li>
</ul>
<h3 id="为什么要把1-7的结构改成了1-8的结构"><a href="#为什么要把1-7的结构改成了1-8的结构" class="headerlink" title="为什么要把1.7的结构改成了1.8的结构"></a>为什么要把1.7的结构改成了1.8的结构</h3><ul>
<li>数据结构(7是segment加链表的结构,8是数组加链表,链表长度达到8之后,会转为红黑树,7的并发度是根据segment的个数决定的,8是每个Node都是独立的)</li>
<li>Hash碰撞(7是直接使用链表,8是先使用链表,数量达到8之后,会转成红黑树)</li>
<li>保证并发安全(7是使用分段锁,继承于Lock,8中是使用CAS加synchronized来保证的)</li>
<li>查询复杂度(7查询链表是O(n),8为链表的是相同,为红黑树的时候降为O(logn))</li>
<li>为什么超过8的时候转成红黑树?<ul>
<li>没有最开始就使用红黑树而是要后面转,是因为红黑树占用空间比链表大两倍</li>
<li>作者有在注释中描述,链表最终的长度能达到8个概率只有千万分之一,这种概率已经很小了,为了应对这种极端情况,才会转成红黑树,但是一般链表长度根本不会到8</li>
</ul>
</li>
</ul>
<h2 id="组合操作"><a href="#组合操作" class="headerlink" title="组合操作"></a>组合操作</h2><ul>
<li><code>replace</code> (把一个值根据当前值的情况判断是否要替换)</li>
<li><code>putIfAbsent</code> (如果当前key不存在值,就放进去,否则就取出来)</li>
</ul>
<h1 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h1><h2 id="诞生的历史和原因"><a href="#诞生的历史和原因" class="headerlink" title="诞生的历史和原因"></a>诞生的历史和原因</h2><ul>
<li>代替<code>Vector</code>和<code>SynchronizedList</code>,就和<code>ConcurrentHashMap</code>代替<code>SynchronizedMap</code>的原因一样</li>
<li><code>Vector</code>和<code>SynchronizedList</code>的锁粒度太大,并发效率相对比较低,并且迭代时无法编辑</li>
<li>Copy-On-Write并发容器还包括<code>CopyOnWriteArraySet</code>,用来代替同步<code>Set</code></li>
</ul>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li>读操作可以尽可能地块,而写即使慢一些也没有太大关系</li>
<li>读多写少: 黑名单,每日更新;监听器: 迭代操作远多余修改操作</li>
</ul>
<h2 id="读写规则"><a href="#读写规则" class="headerlink" title="读写规则"></a>读写规则</h2><ul>
<li>读写锁规则的升级: 读取是完全不用加锁的,并且更厉害的是写入也不会阻塞读取操作,只有写入和写入之间需要进行同步等待</li>
<li><code>ArrayList</code>在迭代的时候是不允许修改的,检测到修改会直接异常</li>
<li><code>CopyOnWriteArrayList</code>可以在迭代中修改,不过迭代的依然是未修改时的内容</li>
</ul>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><ul>
<li>CopyOnWrite的含义<ul>
<li>每次修改或者添加数据都会创建一个新的容器,之后再把变量的引用指向新的容器,旧的就可以回收,旧的容器也不会改变</li>
</ul>
</li>
<li>创建新副本,读写分离<br>+在写入的时候,会将原本的数组整个复制,然后将修改写入原本的数组中,最后再替换回去</li>
<li>“不可变”原理<ul>
<li>因为每次修改都是一个新的容器,所以对旧的容器来说就是不可变的</li>
</ul>
</li>
<li>迭代的时候<ul>
<li>在迭代的时候,如果原本的数组已经被修改过了,但是迭代器是不知道的,它使用的依然是最开始的时候的旧数组(可能会出现数据过期的问题)</li>
</ul>
</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>数据一致性问题: CopyOnWrite容器只能保证数据的最终一致性,不能保证数据的实时一直性,所以如果你希望写入的数据,马上就能读到,请不要使用CopyOnWrite容器</li>
<li>内存占用问题: 因为CopyOnWrite的写是复制机制,所以在进行写操作的时候,内存里会同时驻扎两个对象的内存</li>
</ul>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><ul>
<li>底层是基于数组实现的</li>
<li>添加数据的时候,如下图所示,使用Lock锁进行上锁,然后将新建一个比原本数组长1的数组,然后将原本数组的内容全部复制进去,然后将新数据保存到数据的最后一位<br><img src="/2021/12/04/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/CopyOnWriteArrayList%E7%9A%84add%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="CopyOnWriteArrayList的add方法源码示意图"></li>
</ul>
<h1 id="并发队列Queue-阻塞队列、非阻塞队列"><a href="#并发队列Queue-阻塞队列、非阻塞队列" class="headerlink" title="并发队列Queue(阻塞队列、非阻塞队列)"></a>并发队列Queue(阻塞队列、非阻塞队列)</h1><h2 id="为什么要使用队列"><a href="#为什么要使用队列" class="headerlink" title="为什么要使用队列"></a>为什么要使用队列</h2><ul>
<li>用队列可以在线程间传递数据: 生产者消费者模式,银行转账</li>
<li>考虑锁等线程安全问题的重任从”你”转移到了”队列”上</li>
</ul>
<h2 id="各并发队列关系图"><a href="#各并发队列关系图" class="headerlink" title="各并发队列关系图"></a>各并发队列关系图</h2><img src="http://www.plantuml.com/plantuml/svg/bOrB3i8m34Jtd29NuRDa0Ue98dS0gwaDTY9HLTmTn2TIrKtPphmtmv9XfqW8nuA2yR7YccoIKiToVZS1zmnflNAKedjOcyLX2d9_JUWXsQSBrJaOgt7-LzkpT6X_tGwt9L8p25rCHOillDcgK35x4P_3cVR5dm00">

<h2 id="阻塞队列BlockingQueue"><a href="#阻塞队列BlockingQueue" class="headerlink" title="阻塞队列BlockingQueue"></a>阻塞队列<code>BlockingQueue</code></h2><h3 id="什么是阻塞队列"><a href="#什么是阻塞队列" class="headerlink" title="什么是阻塞队列"></a>什么是阻塞队列</h3><ul>
<li>阻塞队列是具有阻塞功能的队列,所以它首先是一个队列,其次是具有阻塞功能</li>
<li>通常,阻塞队列的一端是给生产者方数据用,另一端给消费者拿数据用,阻塞队列是线程安全的,所以生产者和消费者都可以是多线程的</li>
<li>阻塞功能: 最具有特色的两个带有阻塞功能的方法:<ul>
<li><code>take()</code>方法: 获取并移除队列的头结点,一旦如果执行take的时候,队列里无数据,则阻塞,直到队列里有数据</li>
<li><code>put()</code>方法: 插入元素,但是如果队列已满,那么就无法继续插入,则阻塞,直到队列里有了空闲空间</li>
</ul>
</li>
<li>是否有界(容量有多大): 这是一个非常重要的属性,无界队列意味着里面可以容纳非常多(<code>Integer.MAX_VALUE</code>,约为2的31次方,是一个非常大的数,可以近似认为是无限容量)</li>
<li>阻塞队列和线程池的关系: 阻塞队列是线程池的重要组成部分</li>
</ul>
<h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a><code>ArrayBlockingQueue</code></h3><ul>
<li>有界</li>
<li>指定容量</li>
<li>公平：还可以指定是否需要保证公平，如果想要保证公平的话，那么等待了最长时间的线程会被优先处理，不过这会同时带来一定的性能损耗</li>
<li>示例代码如下所示：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueueDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayBlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        Interviewer interviewer = <span class="keyword">new</span> Interviewer(queue);</span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer(queue);</span><br><span class="line">        <span class="keyword">new</span> Thread(interviewer).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(consumer).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interviewer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    BlockingQueue&lt;String&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Interviewer</span><span class="params">(BlockingQueue&lt;String&gt; queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;10个候选人都来了&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                String candidate = <span class="string">&quot;Candidate &quot;</span> + i;</span><br><span class="line">                queue.put(candidate);</span><br><span class="line">                System.out.println(candidate + <span class="string">&quot; 安排好了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            queue.put(<span class="string">&quot;stop&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    BlockingQueue&lt;String&gt; queue;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(BlockingQueue&lt;String&gt; queue)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.queue = queue;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">             String msg;</span><br><span class="line">             <span class="keyword">while</span> (!(msg = queue.take()).equals(<span class="string">&quot;stop&quot;</span>))&#123;</span><br><span class="line">                 System.out.println(msg+<span class="string">&quot;面试结束----&quot;</span>);</span><br><span class="line">             &#125;</span><br><span class="line">             System.out.println(<span class="string">&quot;所有候选人面试结束&quot;</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>ArrayBlockingQueue</code>的put方法源码如下，首先判断值是否为空，然后获取锁，之后判断队列是否满了，如果满了就进行等待，如果没满就把值放进去<br><img src="/2021/12/04/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/ArrayBlockingQueue%E7%9A%84put%E6%BA%90%E7%A0%81%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="ArrayBlockingQueue的put源码示意图"></p>
</blockquote>
</li>
</ul>
<h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a><code>LinkedBlockingQueue</code></h3><ul>
<li>无界</li>
<li>容量<code>Integer.MAX_VALUE</code></li>
<li>内部结构：<code>Node</code>、两把锁</li>
<li>由下图中可以看出，<code>LinkedBlockingQueue</code>中是有两把锁的，所以存放和获取是互不干扰的<br><img src="/2021/12/04/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/LinkedBlockingQueue%E4%B8%A4%E6%8A%8A%E9%94%81%E6%BA%90%E7%A0%81%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="LinkedBlockingQueue两把锁源码示意图"></li>
<li>从图中可以看出，存值的时候首先会判断值是否为空，然后将其封装成一个node，然后获取putLock锁</li>
<li>再然后判断当前长度是否等于最大长度，是就进行等待，不是就开始存值操作，然后再判断存值之后的长度是否小于最大长度，是的话就唤醒其他的线程继续运行<br><img src="/2021/12/04/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/LinkedBlockingQueue%E7%9A%84put%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="LinkedBlockingQueue的put方法源码示意图"></li>
</ul>
<h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a><code>PriorityBlockingQueue</code></h3><ul>
<li>支持优先级</li>
<li>自然排序（而不是先进先出）</li>
<li>无界队列</li>
<li><code>PriorityQueue</code>的线程安全版本</li>
</ul>
<h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a><code>SynchronousQueue</code></h3><ul>
<li>它的容量为0</li>
<li>需要注意的是，<code>SynchronousQueue</code>的容量不是1而是0，因为<code>SynchronousQueue</code>不需要去持有元素，它所作的就是直接传递</li>
<li>效率很高</li>
<li><code>SynchronousQueue</code>没有peek等函数，因为peek的含义是取出头结点，但是<code>SynchronousQueue</code>的容量是0，所以连头结点都没有，也就没有peek方法，同理，也没有iterate相关方法</li>
<li>是一个极好用的直接传递的并发数据结构</li>
<li><code>SynchronousQueue</code>是线程池<code>Executors.newCachedThreadPool()</code>使用的阻塞队列</li>
</ul>
<h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><ul>
<li>无界</li>
<li>延迟队列，根据延迟时间排序</li>
<li>元素需要实现Delayed接口，规定排序规则</li>
</ul>
<h2 id="非阻塞队列"><a href="#非阻塞队列" class="headerlink" title="非阻塞队列"></a>非阻塞队列</h2><ul>
<li>并发包中的非阻塞队列只有ConcurrentLinkedQueue这一种，顾名思义ConcurrentLinkedQueue是使用链表作为其数据结构的，使用CAS非阻塞算法来实现线程安全（不具备阻塞功能），适合用在对性能要求较高的并发场景，用的相对比较少一些</li>
<li>看源码的offer方法的CAS思想，内有p.casNext方法，用了UNSAFE.compareAndSwapObject</li>
</ul>
<h2 id="如何选择适合自己的队列"><a href="#如何选择适合自己的队列" class="headerlink" title="如何选择适合自己的队列"></a>如何选择适合自己的队列</h2><ul>
<li>边界（根据业务情况判断需要的队列的大小）</li>
<li>空间</li>
<li>吞吐量</li>
</ul>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>synchronized关键字</title>
    <url>/2021/11/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h1 id="synchronized的作用"><a href="#synchronized的作用" class="headerlink" title="synchronized的作用"></a>synchronized的作用</h1><ul>
<li><p>官网解释翻译</p>
<blockquote>
<p>同步方法支持一种简单的策略来防止线程干扰和内存一致性错误：如果一个对象对多个线程可见，则对该对象变量的所有读取或写入都是通过同步方法完成的。</p>
</blockquote>
</li>
<li><p>通俗解释</p>
<blockquote>
<p>能够保证在同一时刻最多只有一个线程执行该段代码，以达到保证并发安全的效果。</p>
</blockquote>
</li>
</ul>
<h1 id="synchronized的地位"><a href="#synchronized的地位" class="headerlink" title="synchronized的地位"></a>synchronized的地位</h1><ul>
<li>synchronized的java的关键字，被java语言原生支持  </li>
<li>是最基本的互斥同步手段  </li>
<li>是并发编程种的元老级角色，是并发编程的必学内容 </li>
</ul>
<h1 id="synchronized的两种用法"><a href="#synchronized的两种用法" class="headerlink" title="synchronized的两种用法"></a>synchronized的两种用法</h1><h2 id="对象锁"><a href="#对象锁" class="headerlink" title="对象锁"></a>对象锁</h2><ul>
<li>包括方法锁（默认锁对象为this当前实例对象）和同步代码块锁（自己指定锁对象）</li>
</ul>
<h3 id="代码块形式"><a href="#代码块形式" class="headerlink" title="代码块形式"></a>代码块形式</h3><ul>
<li>手动指定锁对象<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedObjectCodeBlock2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        SynchronizedObjectCodeBlock2 s = <span class="keyword">new</span> SynchronizedObjectCodeBlock2();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(s);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(s);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;运行结束&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="方法锁形式"><a href="#方法锁形式" class="headerlink" title="方法锁形式"></a>方法锁形式</h3><ul>
<li>synchronized修饰普通方法，锁对象默认为this<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedObjectCodeBlock2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        SynchronizedObjectCodeBlock2 s = <span class="keyword">new</span> SynchronizedObjectCodeBlock2();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(s);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(s);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;运行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="类锁"><a href="#类锁" class="headerlink" title="类锁"></a>类锁</h2><ul>
<li>指synchronized修饰静态的方法或指定锁为class对象  </li>
</ul>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li>Java类可能有很多实例对象，但只有1个class对象</li>
<li>所谓的类锁，不过是class对象的锁而已  </li>
<li>类锁只能在同一时间被一个对象拥有  </li>
</ul>
<ul>
<li>synchronized加在static方法上<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedObjectCodeBlock2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        SynchronizedObjectCodeBlock2 s1 = <span class="keyword">new</span> SynchronizedObjectCodeBlock2();</span><br><span class="line">        SynchronizedObjectCodeBlock2 s2 = <span class="keyword">new</span> SynchronizedObjectCodeBlock2();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(s1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(s2);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;运行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>synchronized（*.class）代码块<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedObjectCodeBlock2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SynchronizedObjectCodeBlock2 s1 = <span class="keyword">new</span> SynchronizedObjectCodeBlock2();</span><br><span class="line">        SynchronizedObjectCodeBlock2 s2 = <span class="keyword">new</span> SynchronizedObjectCodeBlock2();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(s1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(s2);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedObjectCodeBlock2.class) &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;运行结束&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="多线程访问同步方法的7种情况"><a href="#多线程访问同步方法的7种情况" class="headerlink" title="多线程访问同步方法的7种情况"></a>多线程访问同步方法的7种情况</h1><h2 id="两个线程同时访问一个对象的同步方法"><a href="#两个线程同时访问一个对象的同步方法" class="headerlink" title="两个线程同时访问一个对象的同步方法"></a>两个线程同时访问一个对象的同步方法</h2><ul>
<li>会串行执行</li>
<li>同步方法默认锁的是this，也就是当前对象，每次只能有一个线程获取到锁</li>
</ul>
<h2 id="两个线程访问的是两个对象的同步方法"><a href="#两个线程访问的是两个对象的同步方法" class="headerlink" title="两个线程访问的是两个对象的同步方法"></a>两个线程访问的是两个对象的同步方法</h2><ul>
<li>会并行执行</li>
<li>默认锁的是this，也就是当前对象，由于是来个对象，也就是不同的锁，所以两个线程会同时执行</li>
</ul>
<h2 id="两个线程访问的是synchronized的静态方法"><a href="#两个线程访问的是synchronized的静态方法" class="headerlink" title="两个线程访问的是synchronized的静态方法"></a>两个线程访问的是synchronized的静态方法</h2><ul>
<li>会串行执行</li>
<li>静态方法锁的是class对象，class对象只有一个，所以两个线程是同一把锁  </li>
</ul>
<h2 id="两个线程同时访问同步方法与非同步方法"><a href="#两个线程同时访问同步方法与非同步方法" class="headerlink" title="两个线程同时访问同步方法与非同步方法"></a>两个线程同时访问同步方法与非同步方法</h2><ul>
<li>会并行执行</li>
<li>同步方法会受到保护，非同步方法不会上锁，所以会并行执行</li>
</ul>
<h2 id="访问同一个对象的不同的普通同步方法"><a href="#访问同一个对象的不同的普通同步方法" class="headerlink" title="访问同一个对象的不同的普通同步方法"></a>访问同一个对象的不同的普通同步方法</h2><ul>
<li>会串行执行</li>
<li>同步方法锁的是this当前对象，即便是不同的方法，锁的也是同一个对象，所以会串行执行</li>
</ul>
<h2 id="同时访问静态synchronized和非静态synchronized方法"><a href="#同时访问静态synchronized和非静态synchronized方法" class="headerlink" title="同时访问静态synchronized和非静态synchronized方法"></a>同时访问静态synchronized和非静态synchronized方法</h2><ul>
<li>并行执行</li>
<li>静态方法锁的class类，非静态方锁的是当前对象，两个方法并不是同一个锁，所以会并行执行</li>
</ul>
<h2 id="方法抛异常后，会释放锁"><a href="#方法抛异常后，会释放锁" class="headerlink" title="方法抛异常后，会释放锁"></a>方法抛异常后，会释放锁</h2><ul>
<li>异常之后会释放锁，不会影响后续的执行</li>
<li>先抛出异常，后面才能进入同步方法</li>
</ul>
<h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><h2 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h2><ul>
<li>什么是可重入：指的是同一个线程的外层函数获得锁之后，内层函数可以直接再次获取该锁  </li>
<li>好处：避免死锁，提升封装性  <blockquote>
<p>比如方法1被synchronized修饰，在方法里面递归调用该方法，也是可以重入的<br>方法1和方法2都被synchronized修饰，那么在方法1中也是可以调用方法2的  </p>
</blockquote>
</li>
</ul>
<h2 id="不可中断"><a href="#不可中断" class="headerlink" title="不可中断"></a>不可中断</h2><ul>
<li>一旦这个锁已经被别人获得了，如果我还想获得，我只能选择等待或者阻塞，直到别人的线程释放这个锁，如果别人永远不释放锁，那么我只能永远地等待下去。</li>
</ul>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="加锁和释放锁的原理"><a href="#加锁和释放锁的原理" class="headerlink" title="加锁和释放锁的原理"></a>加锁和释放锁的原理</h2><ul>
<li>获取呵呵释放锁的时机：进入和退出同步代码块（运行完毕或者抛出异常）</li>
<li>等价代码（使用lock锁必须要显示的上锁解锁，并且需要考虑异常情况，synchronized则不需要考虑这些）</li>
<li>看字节码：monitor相关指令<br>使用<code>javac xxx.java</code>将java文件编译成class文件<br>再使用<code>java -v xxx.class</code>反编译class文件<br>具体代码如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decompilation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Thread thread)</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
反编译后，insert方法如下：<br><img src="/2021/11/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/Decompilation%E5%8F%8D%E7%BC%96%E8%AF%91%E5%86%85%E5%AE%B9.png" alt="Decompilation反编译内容"><br>从图中可以看出，第6行monitorenter指令，上锁<br>第8行monitorexit指令，释放锁<br>第14行monitorexit指令，则是在抛出异常的情况下释放锁</li>
</ul>
<h2 id="可重入原理：加锁次数计数器"><a href="#可重入原理：加锁次数计数器" class="headerlink" title="可重入原理：加锁次数计数器"></a>可重入原理：加锁次数计数器</h2><ul>
<li>JVN会记录被加锁大的次数</li>
<li>第一次加锁时，次数从0变为1，之后如果再次加锁，就从1变成2，以次类推</li>
<li>退出一层同步代码块时，计数减一，当计数为0的时候表示锁释放  </li>
</ul>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><ul>
<li>一个线程执行的结果，另一个线程不一定可见</li>
<li>线程1操作x=5，之后线程2可能读取到之前的数据x=3</li>
<li>synchronized可以保证可见性  </li>
</ul>
<h1 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h1><ul>
<li>效率低：锁的释放情况少，试图获得锁时不能设定超时、不能中断一个正在试图获得锁的线程。  </li>
<li>不够灵活（读写锁更灵活）：加锁和释放的时机单一，每个锁仅有单一的条件（某个对象），可能是不够的。 </li>
<li>无法知道是否成功获取到锁</li>
</ul>
<p>#常见面试题</p>
<ul>
<li>使用注意点：锁的范围不宜过大、避免锁的嵌套</li>
<li>如何选择Look和synchronized关键字？<blockquote>
<p>如果synchronized能够满足需求的话，优先使用synchronized，无法满足再使用Lock锁</p>
</blockquote>
</li>
<li>多线程访问同步方法的各种具体情况<blockquote>
<p>上面所述的七种情况  </p>
</blockquote>
</li>
</ul>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java字节码指令大全</title>
    <url>/2021/11/16/Java%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<h1 id="二进制指令表"><a href="#二进制指令表" class="headerlink" title="二进制指令表"></a>二进制指令表</h1><h2 id="常量入栈指令"><a href="#常量入栈指令" class="headerlink" title="常量入栈指令"></a>常量入栈指令</h2><table>
<thead>
<tr>
<th align="center">指令码</th>
<th align="center">操作码（助记符）</th>
<th align="center">操作数</th>
<th align="left">描述（栈指操作数栈）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0x01</td>
<td align="center">aconst_null</td>
<td align="center"></td>
<td align="left">null值入栈</td>
</tr>
<tr>
<td align="center">0x02</td>
<td align="center">iconst_m1</td>
<td align="center"></td>
<td align="left">-1(int)值入栈</td>
</tr>
<tr>
<td align="center">0x03</td>
<td align="center">iconst_0</td>
<td align="center"></td>
<td align="left">0(int)值入栈</td>
</tr>
<tr>
<td align="center">0x04</td>
<td align="center">iconst_1</td>
<td align="center"></td>
<td align="left">1(int)值入栈</td>
</tr>
<tr>
<td align="center">0x05</td>
<td align="center">iconst_2</td>
<td align="center"></td>
<td align="left">2(int)值入栈</td>
</tr>
<tr>
<td align="center">0x06</td>
<td align="center">iconst_3</td>
<td align="center"></td>
<td align="left">3(int)值入栈</td>
</tr>
<tr>
<td align="center">0x07</td>
<td align="center">iconst_4</td>
<td align="center"></td>
<td align="left">4(int)值入栈</td>
</tr>
<tr>
<td align="center">0x08</td>
<td align="center">iconst_5</td>
<td align="center"></td>
<td align="left">5(int)值入栈</td>
</tr>
<tr>
<td align="center">0x09</td>
<td align="center">lconst_0</td>
<td align="center"></td>
<td align="left">0(long)值入栈</td>
</tr>
<tr>
<td align="center">0x0a</td>
<td align="center">lconst_1</td>
<td align="center"></td>
<td align="left">1(long)值入栈</td>
</tr>
<tr>
<td align="center">0x0b</td>
<td align="center">fconst_0</td>
<td align="center"></td>
<td align="left">0(float)值入栈</td>
</tr>
<tr>
<td align="center">0x0c</td>
<td align="center">fconst_1</td>
<td align="center"></td>
<td align="left">1(float)值入栈</td>
</tr>
<tr>
<td align="center">0x0d</td>
<td align="center">fconst_2</td>
<td align="center"></td>
<td align="left">2(float)值入栈</td>
</tr>
<tr>
<td align="center">0x0e</td>
<td align="center">dconst_0</td>
<td align="center"></td>
<td align="left">0(double)值入栈</td>
</tr>
<tr>
<td align="center">0x0f</td>
<td align="center">dconst_1</td>
<td align="center"></td>
<td align="left">1(double)值入栈</td>
</tr>
<tr>
<td align="center">0x10</td>
<td align="center">bipush</td>
<td align="center">valuebyte</td>
<td align="left">valuebyte值带符号扩展成int值入栈</td>
</tr>
<tr>
<td align="center">0x11</td>
<td align="center">sipush</td>
<td align="center">valuebyte1 <br> valuebyte2</td>
<td align="left">(valuebyte1&lt;&lt;8) &#124; valuebyte2值带符合扩展成int值入栈</td>
</tr>
<tr>
<td align="center">0x12</td>
<td align="center">ldc</td>
<td align="center">indexbyte1</td>
<td align="left">常量池中的常量值（int、float、string、reference、object reference）入栈</td>
</tr>
<tr>
<td align="center">0x13</td>
<td align="center">ldc_w</td>
<td align="center">indexbyte1 <br> indexByte2</td>
<td align="left">常量池中的常量（int、float、string、reference、object reference）入栈</td>
</tr>
<tr>
<td align="center">0x14</td>
<td align="center">ldc2_w</td>
<td align="center">indexbyte1 <br> indexbyte2</td>
<td align="left">常量池中常量（long、double）入栈</td>
</tr>
</tbody></table>
<blockquote>
<p>int类型在-1<del>5，使用iconst_x指令<br>int类型在-128</del>127，使用bipush指令<br>int类型在-32768~32767，使用sipush指令<br>在其他范围，使用ldc指令</p>
</blockquote>
<h2 id="局部变量值转载到栈中指令"><a href="#局部变量值转载到栈中指令" class="headerlink" title="局部变量值转载到栈中指令"></a>局部变量值转载到栈中指令</h2><table>
<thead>
<tr>
<th align="center">指令码</th>
<th align="center">操作码（助记符）</th>
<th align="center">操作数</th>
<th align="left">描述（栈指操作数栈）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0x19</td>
<td align="center">(wide)aload</td>
<td align="center">indexbyte</td>
<td align="left">从局部变量indexbyte中装载引用类型值入栈</td>
</tr>
<tr>
<td align="center">0x2a</td>
<td align="center">aload_0</td>
<td align="center"></td>
<td align="left">从局部变量0中装载引用类型值入栈</td>
</tr>
<tr>
<td align="center">0x2b</td>
<td align="center">aload_1</td>
<td align="center"></td>
<td align="left">从局部变量1中装载引用类型值入栈</td>
</tr>
<tr>
<td align="center">0x2c</td>
<td align="center">aload_2</td>
<td align="center"></td>
<td align="left">从局部变量2中装载引用类型值入栈</td>
</tr>
<tr>
<td align="center">0x2d</td>
<td align="center">aload_3</td>
<td align="center"></td>
<td align="left">从局部变量3中装载引用类型值入栈</td>
</tr>
<tr>
<td align="center">0x15</td>
<td align="center">(wide)iload</td>
<td align="center">indexbyte</td>
<td align="left">从局部变量indexbyte中装载int类型入栈</td>
</tr>
<tr>
<td align="center">0x1a</td>
<td align="center">iload_0</td>
<td align="center"></td>
<td align="left">从局部变量0中装载int类型值入栈</td>
</tr>
<tr>
<td align="center">0x1b</td>
<td align="center">iload_1</td>
<td align="center"></td>
<td align="left">从局部变量1中装载int类型值入栈</td>
</tr>
<tr>
<td align="center">0x1c</td>
<td align="center">iload_2</td>
<td align="center"></td>
<td align="left">从局部变量2中装载int类型值入栈</td>
</tr>
<tr>
<td align="center">0x1d</td>
<td align="center">iload_3</td>
<td align="center"></td>
<td align="left">从局部变量3中装载int类型值入栈</td>
</tr>
<tr>
<td align="center">0x16</td>
<td align="center">(wide)lload</td>
<td align="center">indexbyte</td>
<td align="left">从局部变量indexbyte中装载long类型值入栈</td>
</tr>
<tr>
<td align="center">0x1e</td>
<td align="center">lload_0</td>
<td align="center"></td>
<td align="left">从局部变量0中装载long类型值入栈</td>
</tr>
<tr>
<td align="center">0x1f</td>
<td align="center">lload_1</td>
<td align="center"></td>
<td align="left">从局部变量1中装载long类型值入栈</td>
</tr>
<tr>
<td align="center">0x20</td>
<td align="center">lload_2</td>
<td align="center"></td>
<td align="left">从局部变量2中装载long类型值入栈</td>
</tr>
<tr>
<td align="center">0x21</td>
<td align="center">lload_3</td>
<td align="center"></td>
<td align="left">从局部变量3中装载long类型值入栈</td>
</tr>
<tr>
<td align="center">0x17</td>
<td align="center">(wide)fload</td>
<td align="center">indexbyte</td>
<td align="left">从局部变量indexbyte中装载float类型值入栈</td>
</tr>
<tr>
<td align="center">0x22</td>
<td align="center">fload_0</td>
<td align="center"></td>
<td align="left">从局部变量0中装载float类型值入栈</td>
</tr>
<tr>
<td align="center">0x23</td>
<td align="center">fload_1</td>
<td align="center"></td>
<td align="left">从局部变量1中装载float类型值入栈</td>
</tr>
<tr>
<td align="center">0x24</td>
<td align="center">fload_2</td>
<td align="center"></td>
<td align="left">从局部变量2中装载float类型值入栈</td>
</tr>
<tr>
<td align="center">0x25</td>
<td align="center">fload_3</td>
<td align="center"></td>
<td align="left">从局部变量3中装载float类型值入栈</td>
</tr>
<tr>
<td align="center">0x18</td>
<td align="center">(wide)dload</td>
<td align="center">indexbyte</td>
<td align="left">从局部变量indexbyte中装载double类型值入栈</td>
</tr>
<tr>
<td align="center">0x26</td>
<td align="center">dload_0</td>
<td align="center"></td>
<td align="left">从局部变量0中装载double类型值入栈</td>
</tr>
<tr>
<td align="center">0x27</td>
<td align="center">dload_1</td>
<td align="center"></td>
<td align="left">从局部变量1中装载double类型值入栈</td>
</tr>
<tr>
<td align="center">0x28</td>
<td align="center">dload_2</td>
<td align="center"></td>
<td align="left">从局部变量2中装载double类型值入栈</td>
</tr>
<tr>
<td align="center">0x29</td>
<td align="center">dload_3</td>
<td align="center"></td>
<td align="left">从局部变量3中装载double类型值入栈</td>
</tr>
<tr>
<td align="center">0x32</td>
<td align="center">aaload</td>
<td align="center"></td>
<td align="left">从引用类型数组中装载指定项的值</td>
</tr>
<tr>
<td align="center">0x2e</td>
<td align="center">iaload</td>
<td align="center"></td>
<td align="left">从int类型数组中装载指定项的值</td>
</tr>
<tr>
<td align="center">0x2f</td>
<td align="center">laload</td>
<td align="center"></td>
<td align="left">从long类型数组中装载指定项的值</td>
</tr>
<tr>
<td align="center">0x30</td>
<td align="center">faload</td>
<td align="center"></td>
<td align="left">从float类型数组中装载指定项的值</td>
</tr>
<tr>
<td align="center">0x31</td>
<td align="center">daload</td>
<td align="center"></td>
<td align="left">从double类型数组中装载指定项的值</td>
</tr>
<tr>
<td align="center">0x33</td>
<td align="center">baload</td>
<td align="center"></td>
<td align="left">从boolean类型数组或byte类型数组中装载指定项的值（先转为int类型的值，后压栈）</td>
</tr>
<tr>
<td align="center">0x34</td>
<td align="center">caload</td>
<td align="center"></td>
<td align="left">从char类型数组中装载指定项的值（先转为int类型的值，后压栈）</td>
</tr>
<tr>
<td align="center">0x35</td>
<td align="center">saload</td>
<td align="center"></td>
<td align="left">从short类型数组中装载指定项的值（先转为int类型的值，后压栈）</td>
</tr>
</tbody></table>
<blockquote>
<p>如果是静态方法，局部变量指令编号从0开始如：aload_0<br>如果是普通方法，局部变量指令编号从1开始如：aload_1<br>构造函数中为调用指令aload_0，代表this<br>double和long类型的局部变量会使用两个编号<br>局部变量表的容量以变量槽(Variable Slot)为最小单位。每个变量槽都可以存储32位长度的内存空间，例如boolean、byte、char、short、int、float、reference。<br>对于64位长度的数据类型（long，double），虚拟机会以高位对齐方式为其分配两个连续的Slot空间，也就是相当于把一次long和double数据类型读写分割成为两次32位读写。</p>
</blockquote>
<h2 id="将栈顶值保存到局部变量中指令"><a href="#将栈顶值保存到局部变量中指令" class="headerlink" title="将栈顶值保存到局部变量中指令"></a>将栈顶值保存到局部变量中指令</h2><table>
<thead>
<tr>
<th align="center">指令码</th>
<th align="center">操作码（助记符）</th>
<th align="center">操作数</th>
<th align="left">描述（栈指操作数栈）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0x3a</td>
<td align="center">(wide)astore</td>
<td align="center">indexbyte</td>
<td align="left">将栈顶引用类型值保存到局部变量indexbyte中</td>
</tr>
<tr>
<td align="center">0x4b</td>
<td align="center">astore_0</td>
<td align="center"></td>
<td align="left">将栈顶引用类型值保存到局部变量0中</td>
</tr>
<tr>
<td align="center">0x4c</td>
<td align="center">astore_1</td>
<td align="center"></td>
<td align="left">将栈顶引用类型值保存到局部变量1中</td>
</tr>
<tr>
<td align="center">0x4d</td>
<td align="center">astore_2</td>
<td align="center"></td>
<td align="left">将栈顶引用类型值保存到局部变量2中</td>
</tr>
<tr>
<td align="center">0x4e</td>
<td align="center">astore_3</td>
<td align="center"></td>
<td align="left">将栈顶引用类型值保存到局部变量3中</td>
</tr>
<tr>
<td align="center">0x36</td>
<td align="center">(wide)istore</td>
<td align="center">indexbyte</td>
<td align="left">将栈顶int类型值保存到局部变量indexbyte中</td>
</tr>
<tr>
<td align="center">0x3b</td>
<td align="center">istore_0</td>
<td align="center"></td>
<td align="left">将栈顶int类型值保存到局部变量0中</td>
</tr>
<tr>
<td align="center">0x3c</td>
<td align="center">istore_1</td>
<td align="center"></td>
<td align="left">将栈顶int类型值保存到局部变量1中</td>
</tr>
<tr>
<td align="center">0x3d</td>
<td align="center">istore_2</td>
<td align="center"></td>
<td align="left">将栈顶int类型值保存到局部变量2中</td>
</tr>
<tr>
<td align="center">0x3e</td>
<td align="center">istore_3</td>
<td align="center"></td>
<td align="left">将栈顶int类型值保存到局部变量3中</td>
</tr>
<tr>
<td align="center">0x37</td>
<td align="center">(wide)lstore</td>
<td align="center">indexbyte</td>
<td align="left">将栈顶long类型值保存到局部变量indexbyte中</td>
</tr>
<tr>
<td align="center">0x3f</td>
<td align="center">lstore_0</td>
<td align="center"></td>
<td align="left">将栈顶long类型值保存到局部变量0中</td>
</tr>
<tr>
<td align="center">0x40</td>
<td align="center">lstore_1</td>
<td align="center"></td>
<td align="left">将栈顶long类型值保存到局部变量1中</td>
</tr>
<tr>
<td align="center">0x41</td>
<td align="center">lstore_2</td>
<td align="center"></td>
<td align="left">将栈顶long类型值保存到局部变量2中</td>
</tr>
<tr>
<td align="center">0x42</td>
<td align="center">lstore_3</td>
<td align="center"></td>
<td align="left">将栈顶long类型值保存到局部变量3中</td>
</tr>
<tr>
<td align="center">0x38</td>
<td align="center">(wide)fstore</td>
<td align="center">indexbyte</td>
<td align="left">将栈顶float类型值保存到局部变量indexbyte中</td>
</tr>
<tr>
<td align="center">0x43</td>
<td align="center">fstore_0</td>
<td align="center"></td>
<td align="left">将栈顶float类型值保存到局部变量0中</td>
</tr>
<tr>
<td align="center">0x44</td>
<td align="center">fstore_1</td>
<td align="center"></td>
<td align="left">将栈顶float类型值保存到局部变量1中</td>
</tr>
<tr>
<td align="center">0x45</td>
<td align="center">fstore_2</td>
<td align="center"></td>
<td align="left">将栈顶float类型值保存到局部变量2中</td>
</tr>
<tr>
<td align="center">0x46</td>
<td align="center">fstore_3</td>
<td align="center"></td>
<td align="left">将栈顶float类型值保存到局部变量3中</td>
</tr>
<tr>
<td align="center">0x37</td>
<td align="center">(wide)dstore</td>
<td align="center">indexbyte</td>
<td align="left">将栈顶double类型值保存到局部变量indexbyte中</td>
</tr>
<tr>
<td align="center">0x3f</td>
<td align="center">dstore_0</td>
<td align="center"></td>
<td align="left">将栈顶double类型值保存到局部变量0中</td>
</tr>
<tr>
<td align="center">0x40</td>
<td align="center">dstore_1</td>
<td align="center"></td>
<td align="left">将栈顶double类型值保存到局部变量1中</td>
</tr>
<tr>
<td align="center">0x41</td>
<td align="center">dstore_2</td>
<td align="center"></td>
<td align="left">将栈顶double类型值保存到局部变量2中</td>
</tr>
<tr>
<td align="center">0x42</td>
<td align="center">dstore_3</td>
<td align="center"></td>
<td align="left">将栈顶double类型值保存到局部变量3中</td>
</tr>
<tr>
<td align="center">0x53</td>
<td align="center">aastore</td>
<td align="center"></td>
<td align="left">将栈顶引用类型值保存到指定引用类型数组的指定项</td>
</tr>
<tr>
<td align="center">0x4f</td>
<td align="center">iastore</td>
<td align="center"></td>
<td align="left">将栈顶int类型值保存到指定int类型数组的指定项</td>
</tr>
<tr>
<td align="center">0x50</td>
<td align="center">lastore</td>
<td align="center"></td>
<td align="left">将栈顶long类型值保存到指定long类型数组的指定项</td>
</tr>
<tr>
<td align="center">0x51</td>
<td align="center">fastore</td>
<td align="center"></td>
<td align="left">将栈顶float类型值保存到指定float类型数组的指定项</td>
</tr>
<tr>
<td align="center">0x52</td>
<td align="center">dastore</td>
<td align="center"></td>
<td align="left">将栈顶double类型值保存到指定double类型数组的指定项</td>
</tr>
<tr>
<td align="center">0x54</td>
<td align="center">bastore</td>
<td align="center"></td>
<td align="left">将栈顶boolean类型值或byte类型值保存到指定boolean类型数组或byte类型数组的指定项</td>
</tr>
<tr>
<td align="center">0x55</td>
<td align="center">castore</td>
<td align="center"></td>
<td align="left">将栈顶char类型值保存到指定char类型数组的指定项</td>
</tr>
<tr>
<td align="center">0x56</td>
<td align="center">sastore</td>
<td align="center"></td>
<td align="left">将栈顶short类型值保存到指定short类型数组的指定项</td>
</tr>
</tbody></table>
<h2 id="wide指令"><a href="#wide指令" class="headerlink" title="wide指令"></a>wide指令</h2><table>
<thead>
<tr>
<th align="center">指令码</th>
<th align="center">操作码（助记符）</th>
<th align="center">操作数</th>
<th align="left">描述（栈指操作数栈）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0xc4</td>
<td align="center">wide</td>
<td align="center"></td>
<td align="left">使用附加字节扩展局部变量索引（linc指令特殊）</td>
</tr>
</tbody></table>
<h2 id="通用（无类型）栈操作指令"><a href="#通用（无类型）栈操作指令" class="headerlink" title="通用（无类型）栈操作指令"></a>通用（无类型）栈操作指令</h2><table>
<thead>
<tr>
<th align="center">指令码</th>
<th align="center">操作码（助记符）</th>
<th align="center">操作数</th>
<th align="left">描述（栈指操作数栈）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0x00</td>
<td align="center">nop</td>
<td align="center"></td>
<td align="left">空操作</td>
</tr>
<tr>
<td align="center">0x57</td>
<td align="center">pop</td>
<td align="center"></td>
<td align="left">从栈顶弹出一个字长的数据</td>
</tr>
<tr>
<td align="center">0x58</td>
<td align="center">pop2</td>
<td align="center"></td>
<td align="left">从栈顶弹出两个字长的数据</td>
</tr>
<tr>
<td align="center">0x59</td>
<td align="center">dup</td>
<td align="center"></td>
<td align="left">复制栈顶一个字长的数据，将复制后的数据压栈</td>
</tr>
<tr>
<td align="center">0x5a</td>
<td align="center">dup_x1</td>
<td align="center"></td>
<td align="left">复制栈顶一个字长的数据，弹出栈顶两个字长的数据，将复制后的数据压栈，再将弹出的两个字长数据压栈</td>
</tr>
<tr>
<td align="center">0x5b</td>
<td align="center">dup_x2</td>
<td align="center"></td>
<td align="left">复制栈顶一个字长的数据，弹出栈顶三个字长的数据，将复制后的数据压栈，再将弹出的三个字长数据压栈</td>
</tr>
<tr>
<td align="center">0x5c</td>
<td align="center">dup2</td>
<td align="center"></td>
<td align="left">复制栈顶两个字长的数据，将复制后的数据压栈</td>
</tr>
<tr>
<td align="center">0x5d</td>
<td align="center">dup2_x1</td>
<td align="center"></td>
<td align="left">复制栈顶两个字长的数据，弹出栈顶三个字长的数据，将复制后的数据压栈，再将弹出的三个字长数据压栈</td>
</tr>
<tr>
<td align="center">0x5e</td>
<td align="center">dup2_x2</td>
<td align="center"></td>
<td align="left">复制栈顶两个字长的数据，弹出栈顶四个字长的数据，将复制后的数据压栈，再将弹出的四个字长数据压栈</td>
</tr>
<tr>
<td align="center">0x5f</td>
<td align="center">swap</td>
<td align="center"></td>
<td align="left">交换栈顶两个字长的数据的位置，Java指令中没有提供以两个字节长为单位的交换指令</td>
</tr>
</tbody></table>
<h2 id="类型转换指令"><a href="#类型转换指令" class="headerlink" title="类型转换指令"></a>类型转换指令</h2><table>
<thead>
<tr>
<th align="center">指令码</th>
<th align="center">操作码（助记符）</th>
<th align="center">操作数</th>
<th align="left">描述（栈指操作数栈）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0x86</td>
<td align="center">i2f</td>
<td align="center"></td>
<td align="left">将栈顶int类型值转换成float类型值</td>
</tr>
<tr>
<td align="center">0x85</td>
<td align="center">i2l</td>
<td align="center"></td>
<td align="left">将栈顶int类型值转换成long类型值</td>
</tr>
<tr>
<td align="center">0x87</td>
<td align="center">i2d</td>
<td align="center"></td>
<td align="left">将栈顶int类型值转换成double类型值</td>
</tr>
<tr>
<td align="center">0x8b</td>
<td align="center">f2i</td>
<td align="center"></td>
<td align="left">将栈顶float类型值转换成int类型值</td>
</tr>
<tr>
<td align="center">0x8c</td>
<td align="center">f2l</td>
<td align="center"></td>
<td align="left">将栈顶float类型值转换成long类型值</td>
</tr>
<tr>
<td align="center">0x8d</td>
<td align="center">f2d</td>
<td align="center"></td>
<td align="left">将栈顶float类型值转换成double类型值</td>
</tr>
<tr>
<td align="center">0x88</td>
<td align="center">l2i</td>
<td align="center"></td>
<td align="left">将栈顶long类型值转换成int类型值</td>
</tr>
<tr>
<td align="center">0x89</td>
<td align="center">l2f</td>
<td align="center"></td>
<td align="left">将栈顶long类型值转换成float类型值</td>
</tr>
<tr>
<td align="center">0x8a</td>
<td align="center">l2d</td>
<td align="center"></td>
<td align="left">将栈顶long类型值转换成double类型值</td>
</tr>
<tr>
<td align="center">0x8e</td>
<td align="center">d2i</td>
<td align="center"></td>
<td align="left">将栈顶double类型值转换成int类型值</td>
</tr>
<tr>
<td align="center">0x90</td>
<td align="center">d2f</td>
<td align="center"></td>
<td align="left">将栈顶double类型值转换成float类型值</td>
</tr>
<tr>
<td align="center">0x8f</td>
<td align="center">d2l</td>
<td align="center"></td>
<td align="left">将栈顶double类型值转换成long类型值</td>
</tr>
<tr>
<td align="center">0x91</td>
<td align="center">i2b</td>
<td align="center"></td>
<td align="left">将栈顶int类型值截断成byte类型，后带符合扩展成int类型值入栈</td>
</tr>
<tr>
<td align="center">0x92</td>
<td align="center">i2c</td>
<td align="center"></td>
<td align="left">将栈顶int类型值截断成char类型值，后带符号扩展成int类型值入栈</td>
</tr>
<tr>
<td align="center">0x93</td>
<td align="center">i2s</td>
<td align="center"></td>
<td align="left">将栈顶int类型值截断成short类型值，后带符号扩展成int类型值入栈</td>
</tr>
</tbody></table>
<h2 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h2><table>
<thead>
<tr>
<th align="center">指令码</th>
<th align="center">操作码（助记符）</th>
<th align="center">操作数</th>
<th align="left">描述（栈指操作数栈）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0x60</td>
<td align="center">iadd</td>
<td align="center"></td>
<td align="left">将栈顶两int类型整数相加，结果入栈</td>
</tr>
<tr>
<td align="center">0x64</td>
<td align="center">isub</td>
<td align="center"></td>
<td align="left">将栈顶两int类型整数相减，结果入栈</td>
</tr>
<tr>
<td align="center">0x68</td>
<td align="center">imul</td>
<td align="center"></td>
<td align="left">将栈顶两int类型整数相乘，结果入栈</td>
</tr>
<tr>
<td align="center">0x6c</td>
<td align="center">idiv</td>
<td align="center"></td>
<td align="left">将栈顶两int类型整数相除，结果入栈</td>
</tr>
<tr>
<td align="center">0x70</td>
<td align="center">irem</td>
<td align="center"></td>
<td align="left">将栈顶两int类型整数取模，结果入栈</td>
</tr>
<tr>
<td align="center">0x74</td>
<td align="center">ineg</td>
<td align="center"></td>
<td align="left">将栈顶两int类型值取负，结果入栈</td>
</tr>
<tr>
<td align="center">0x61</td>
<td align="center">ladd</td>
<td align="center"></td>
<td align="left">将栈顶两long类型整数相加，结果入栈</td>
</tr>
<tr>
<td align="center">0x65</td>
<td align="center">lsub</td>
<td align="center"></td>
<td align="left">将栈顶两long类型整数相减，结果入栈</td>
</tr>
<tr>
<td align="center">0x69</td>
<td align="center">lmul</td>
<td align="center"></td>
<td align="left">将栈顶两long类型整数相乘，结果入栈</td>
</tr>
<tr>
<td align="center">0x6d</td>
<td align="center">ldiv</td>
<td align="center"></td>
<td align="left">将栈顶两long类型整数相除，结果入栈</td>
</tr>
<tr>
<td align="center">0x71</td>
<td align="center">lrem</td>
<td align="center"></td>
<td align="left">将栈顶两long类型整数取模，结果入栈</td>
</tr>
<tr>
<td align="center">0x75</td>
<td align="center">lneg</td>
<td align="center"></td>
<td align="left">将栈顶long类型值取负，结果入栈</td>
</tr>
<tr>
<td align="center">0x84</td>
<td align="center">(wide)iinc</td>
<td align="center">indexbyte<br>constbyte</td>
<td align="left">将整数值constbyte加到indexbyte指定的int类型的局部变量中</td>
</tr>
</tbody></table>
<h2 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h2><table>
<thead>
<tr>
<th align="center">指令码</th>
<th align="center">操作码（助记符）</th>
<th align="center">操作数</th>
<th align="left">描述（栈指操作数栈）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0x62</td>
<td align="center">fadd</td>
<td align="center"></td>
<td align="left">将栈顶两float类型数相加，结果入栈</td>
</tr>
<tr>
<td align="center">0x66</td>
<td align="center">fsub</td>
<td align="center"></td>
<td align="left">将栈顶两float类型数相减，结果入栈</td>
</tr>
<tr>
<td align="center">0x6a</td>
<td align="center">fmul</td>
<td align="center"></td>
<td align="left">将栈顶两float类型数相乘，结果入栈</td>
</tr>
<tr>
<td align="center">0x6e</td>
<td align="center">fdiv</td>
<td align="center"></td>
<td align="left">将栈顶两float类型数相除，结果入栈</td>
</tr>
<tr>
<td align="center">0x72</td>
<td align="center">frem</td>
<td align="center"></td>
<td align="left">将栈顶两float类型数取模，结果入栈</td>
</tr>
<tr>
<td align="center">0x76</td>
<td align="center">fneg</td>
<td align="center"></td>
<td align="left">将栈顶float类型值取反，结果入栈</td>
</tr>
<tr>
<td align="center">0x63</td>
<td align="center">dadd</td>
<td align="center"></td>
<td align="left">将栈顶两double类型数相加，结果入栈</td>
</tr>
<tr>
<td align="center">0x67</td>
<td align="center">dsub</td>
<td align="center"></td>
<td align="left">将栈顶两double类型数相减，结果入栈</td>
</tr>
<tr>
<td align="center">0x6b</td>
<td align="center">dmul</td>
<td align="center"></td>
<td align="left">将栈顶两double类型数相乘，结果入栈</td>
</tr>
<tr>
<td align="center">0x6f</td>
<td align="center">ddiv</td>
<td align="center"></td>
<td align="left">将栈顶两double类型数相除，结果入栈</td>
</tr>
<tr>
<td align="center">0x73</td>
<td align="center">drem</td>
<td align="center"></td>
<td align="left">将栈顶两double类型数取模，结果入栈</td>
</tr>
<tr>
<td align="center">0x77</td>
<td align="center">dneg</td>
<td align="center"></td>
<td align="left">将栈顶double类型值取反，结果入栈</td>
</tr>
</tbody></table>
<h2 id="逻辑运算——位移运算"><a href="#逻辑运算——位移运算" class="headerlink" title="逻辑运算——位移运算"></a>逻辑运算——位移运算</h2><table>
<thead>
<tr>
<th align="center">指令码</th>
<th align="center">操作码（助记符）</th>
<th align="center">操作数</th>
<th align="left">描述（栈指操作数栈）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0x78</td>
<td align="center">ishl</td>
<td align="center"></td>
<td align="left">左移int类型值</td>
</tr>
<tr>
<td align="center">0x79</td>
<td align="center">lshl</td>
<td align="center"></td>
<td align="left">左移long类型值</td>
</tr>
<tr>
<td align="center">0x7a</td>
<td align="center">ishr</td>
<td align="center"></td>
<td align="left">算术右移int类型值</td>
</tr>
<tr>
<td align="center">0x7b</td>
<td align="center">lshr</td>
<td align="center"></td>
<td align="left">算术右移long类型值</td>
</tr>
<tr>
<td align="center">0x7c</td>
<td align="center">iushr</td>
<td align="center"></td>
<td align="left">逻辑右移int类型值</td>
</tr>
<tr>
<td align="center">0x7d</td>
<td align="center">lushr</td>
<td align="center"></td>
<td align="left">逻辑右移long类型值</td>
</tr>
</tbody></table>
<h2 id="逻辑运算——按位布尔运算"><a href="#逻辑运算——按位布尔运算" class="headerlink" title="逻辑运算——按位布尔运算"></a>逻辑运算——按位布尔运算</h2><table>
<thead>
<tr>
<th align="center">指令码</th>
<th align="center">操作码（助记符）</th>
<th align="center">操作数</th>
<th align="left">描述（栈指操作数栈）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0x73</td>
<td align="center">iand</td>
<td align="center"></td>
<td align="left">对int类型的按位与运算</td>
</tr>
<tr>
<td align="center">0x7f</td>
<td align="center">land</td>
<td align="center"></td>
<td align="left">对long类型的按位与运算</td>
</tr>
<tr>
<td align="center">0x80</td>
<td align="center">ior</td>
<td align="center"></td>
<td align="left">对int类型的按位或运算</td>
</tr>
<tr>
<td align="center">0x81</td>
<td align="center">lor</td>
<td align="center"></td>
<td align="left">对long类型的按位或运算</td>
</tr>
<tr>
<td align="center">0x82</td>
<td align="center">ixor</td>
<td align="center"></td>
<td align="left">对int类型的按位异或运算</td>
</tr>
<tr>
<td align="center">0x83</td>
<td align="center">lxor</td>
<td align="center"></td>
<td align="left">对long类型的按位异或运算</td>
</tr>
</tbody></table>
<h2 id="控制流指令——条件跳转指令"><a href="#控制流指令——条件跳转指令" class="headerlink" title="控制流指令——条件跳转指令"></a>控制流指令——条件跳转指令</h2><table>
<thead>
<tr>
<th align="center">指令码</th>
<th align="center">操作码（助记符）</th>
<th align="center">操作数</th>
<th align="left">描述（栈指操作数栈）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0x99</td>
<td align="center">ifeq</td>
<td align="center">branchbyte1<br>branchbyte2</td>
<td align="left">若栈顶int类型值为0则跳转</td>
</tr>
<tr>
<td align="center">0x9a</td>
<td align="center">ifne</td>
<td align="center">branchbyte1<br>branchbyte2</td>
<td align="left">若栈顶int类型值不为0则跳转</td>
</tr>
<tr>
<td align="center">0x9b</td>
<td align="center">iflt</td>
<td align="center">branchbyte1<br>branchbyte2</td>
<td align="left">若栈顶int类型值小于0则跳转</td>
</tr>
<tr>
<td align="center">0x9e</td>
<td align="center">ifle</td>
<td align="center">branchbyte1<br>branchbyte2</td>
<td align="left">若栈顶int类型值小于等于0则跳转</td>
</tr>
<tr>
<td align="center">0x9d</td>
<td align="center">ifgt</td>
<td align="center">branchbyte1<br>branchbyte2</td>
<td align="left">若栈顶int类型值大于0则跳转</td>
</tr>
<tr>
<td align="center">0x9c</td>
<td align="center">ifge</td>
<td align="center">branchbyte1<br>branchbyte2</td>
<td align="left">若栈顶int类型值大于等于0则跳转</td>
</tr>
<tr>
<td align="center">0x9f</td>
<td align="center">if_icmpeq</td>
<td align="center">branchbyte1<br>branchbyte2</td>
<td align="left">若栈顶两int类型值相等则跳转</td>
</tr>
<tr>
<td align="center">0xa0</td>
<td align="center">if_icmpne</td>
<td align="center">branchbyte1<br>branchbyte2</td>
<td align="left">若栈顶两int类型值不相等则跳转</td>
</tr>
<tr>
<td align="center">0xa1</td>
<td align="center">if_icmplt</td>
<td align="center">branchbyte1<br>branchbyte2</td>
<td align="left">若栈顶两int类型值前小于后则跳转</td>
</tr>
<tr>
<td align="center">0xa4</td>
<td align="center">if_icmple</td>
<td align="center">branchbyte1<br>branchbyte2</td>
<td align="left">若栈顶两int类型值前小于等于后则跳转</td>
</tr>
<tr>
<td align="center">0xa3</td>
<td align="center">if_icmpgt</td>
<td align="center">branchbyte1<br>branchbyte2</td>
<td align="left">若栈顶两int类型值前大于后则跳转</td>
</tr>
<tr>
<td align="center">0xa2</td>
<td align="center">if_icmpge</td>
<td align="center">branchbyte1<br>branchbyte2</td>
<td align="left">若栈顶两int类型值前大于等于后则跳转</td>
</tr>
<tr>
<td align="center">0xc6</td>
<td align="center">ifnull</td>
<td align="center">branchbyte1<br>branchbyte2</td>
<td align="left">若栈顶引用值为null则跳转</td>
</tr>
<tr>
<td align="center">0xc7</td>
<td align="center">ifnonnull</td>
<td align="center">branchbyte1<br>branchbyte2</td>
<td align="left">若栈顶引用值不为null则跳转</td>
</tr>
<tr>
<td align="center">0xa5</td>
<td align="center">if_acmpeq</td>
<td align="center">branchbyte1<br>branchbyte2</td>
<td align="left">若栈顶两引用类型值相等则跳转</td>
</tr>
<tr>
<td align="center">0xa6</td>
<td align="center">if_acmpne</td>
<td align="center">branchbyte1<br>branchbyte2</td>
<td align="left">若栈顶两引用类型值不相等则跳转</td>
</tr>
</tbody></table>
<h2 id="控制流指令——比较指令"><a href="#控制流指令——比较指令" class="headerlink" title="控制流指令——比较指令"></a>控制流指令——比较指令</h2><table>
<thead>
<tr>
<th align="center">指令码</th>
<th align="center">操作码（助记符）</th>
<th align="center">操作数</th>
<th align="left">描述（栈指操作数栈）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0x94</td>
<td align="center">lcmp</td>
<td align="center"></td>
<td align="left">比较栈顶两long类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈</td>
</tr>
<tr>
<td align="center">0x95</td>
<td align="center">fcmpl</td>
<td align="center"></td>
<td align="left">比较栈顶两float类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈；有NaN存在，-1入栈</td>
</tr>
<tr>
<td align="center">0x96</td>
<td align="center">fcmpg</td>
<td align="center"></td>
<td align="left">比较栈顶两float类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈；有NaN存在，-1入栈</td>
</tr>
<tr>
<td align="center">0x97</td>
<td align="center">dcmpl</td>
<td align="center"></td>
<td align="left">比较栈顶两double类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈；有NaN存在，-1入栈</td>
</tr>
<tr>
<td align="center">0x98</td>
<td align="center">dcmpg</td>
<td align="center"></td>
<td align="left">比较栈顶两float类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈；有NaN存在，-1入栈</td>
</tr>
</tbody></table>
<h2 id="控制流指令——无条件跳转指令"><a href="#控制流指令——无条件跳转指令" class="headerlink" title="控制流指令——无条件跳转指令"></a>控制流指令——无条件跳转指令</h2><table>
<thead>
<tr>
<th align="center">指令码</th>
<th align="center">操作码（助记符）</th>
<th align="center">操作数</th>
<th align="left">描述（栈指操作数栈）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0xa7</td>
<td align="center">goto</td>
<td align="center">branchbyte1<br>branchbyte2</td>
<td align="left">无条件跳转到指定位置</td>
</tr>
<tr>
<td align="center">0xc8</td>
<td align="center">goto_w</td>
<td align="center">branchbyte1<br>branchbyte2<br>branchbyte3<br>branchbyte4</td>
<td align="left">无条件跳转到执行位置（宽索引）</td>
</tr>
</tbody></table>
<h2 id="控制流指令——表跳转指令"><a href="#控制流指令——表跳转指令" class="headerlink" title="控制流指令——表跳转指令"></a>控制流指令——表跳转指令</h2><table>
<thead>
<tr>
<th align="center">指令码</th>
<th align="center">操作码（助记符）</th>
<th align="center">操作数</th>
<th align="left">描述（栈指操作数栈）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0xaa</td>
<td align="center">tablewitch</td>
<td align="center">&lt;0-3bytepad&gt;<br>defaultbyte1<br>defaultbyte2<br>defaultbyte3<br>defaultbyte4<br>lowbyte1<br>lowbyte2<br>lowbyte3<br>lowbyte4<br>highbyte1<br>highbyte2<br>highbyte3<br>highbyte4<br>jump offsets…</td>
<td align="left">通过索引访问跳转表，并跳转</td>
</tr>
<tr>
<td align="center">0xab</td>
<td align="center">lookupswitch</td>
<td align="center">&lt;0-3bytepad&gt;<br>defaultbyte1<br>defaultbyte2<br>defaultbyte3<br>defaultbyte4<br>npairs1<br>npairs2<br>npairs3<br>npairs4<br>match offsets</td>
<td align="left">通过键值访问跳转表，并跳转</td>
</tr>
</tbody></table>
<h2 id="控制流指令——异常和finally"><a href="#控制流指令——异常和finally" class="headerlink" title="控制流指令——异常和finally"></a>控制流指令——异常和finally</h2><table>
<thead>
<tr>
<th align="center">指令码</th>
<th align="center">操作码（助记符）</th>
<th align="center">操作数</th>
<th align="left">描述（栈指操作数栈）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0xbf</td>
<td align="center">athrow</td>
<td align="center"></td>
<td align="left">抛出异常</td>
</tr>
<tr>
<td align="center">0xa8</td>
<td align="center">jsr</td>
<td align="center">branchbyte1<br>branchbyte2</td>
<td align="left">跳转到子例程序</td>
</tr>
<tr>
<td align="center">0xc9</td>
<td align="center">jsr_w</td>
<td align="center">branchbyte1<br>branchbyte2<br>branchbyte3<br>branchbyte4</td>
<td align="left">跳转都子例程序（宽索引）</td>
</tr>
<tr>
<td align="center">oxa9</td>
<td align="center">(widde)ret</td>
<td align="center">indexbyte</td>
<td align="left">返回子例程序</td>
</tr>
</tbody></table>
<h2 id="对象操作指令"><a href="#对象操作指令" class="headerlink" title="对象操作指令"></a>对象操作指令</h2><table>
<thead>
<tr>
<th align="center">指令码</th>
<th align="center">操作码（助记符）</th>
<th align="center">操作数</th>
<th align="left">描述（栈指操作数栈）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0xbb</td>
<td align="center">new</td>
<td align="center">indexbyte1<br>indexbyte2</td>
<td align="left">创建新的实例对象</td>
</tr>
<tr>
<td align="center">0xc0</td>
<td align="center">checkcast</td>
<td align="center">indexbyte1<br>indexbyte</td>
<td align="left">类型强转</td>
</tr>
<tr>
<td align="center">0xc1</td>
<td align="center">instanceof</td>
<td align="center">indexbyte1<br>indexbyte2</td>
<td align="left">判断类型</td>
</tr>
<tr>
<td align="center">0xb4</td>
<td align="center">getfield</td>
<td align="center">indexbyte1<br>indexbyte2</td>
<td align="left">获取对象字段的值</td>
</tr>
<tr>
<td align="center">0xb5</td>
<td align="center">putfield</td>
<td align="center">indexbyte1<br>indexbyte2</td>
<td align="left">给对象字段赋值</td>
</tr>
<tr>
<td align="center">0xb2</td>
<td align="center">getstatic</td>
<td align="center">indexbyte1<br>indexbyte2</td>
<td align="left">获取静态字段的值</td>
</tr>
<tr>
<td align="center">0xb3</td>
<td align="center">putstatic</td>
<td align="center">indexbyte1<br>indexbyte2</td>
<td align="left">给静态字段赋值</td>
</tr>
</tbody></table>
<h2 id="数组操作指令"><a href="#数组操作指令" class="headerlink" title="数组操作指令"></a>数组操作指令</h2><table>
<thead>
<tr>
<th align="center">指令码</th>
<th align="center">操作码（助记符）</th>
<th align="center">操作数</th>
<th align="left">描述（栈指操作数栈）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0xbc</td>
<td align="center">newarray</td>
<td align="center">atype</td>
<td align="left">创建type类型的数组</td>
</tr>
<tr>
<td align="center">0xbd</td>
<td align="center">anewarray</td>
<td align="center">indexbyte1<br>indexbyte2</td>
<td align="left">创建引用类型的数组</td>
</tr>
<tr>
<td align="center">0xbe</td>
<td align="center">arraylength</td>
<td align="center"></td>
<td align="left">获取一维数组的长度</td>
</tr>
<tr>
<td align="center">0xc5</td>
<td align="center">multianewarray</td>
<td align="center">indexbyte1<br>indexbyte2<br>dimension</td>
<td align="left">创建dimension维度的数组</td>
</tr>
</tbody></table>
<h2 id="方法调用指令"><a href="#方法调用指令" class="headerlink" title="方法调用指令"></a>方法调用指令</h2><table>
<thead>
<tr>
<th align="center">指令码</th>
<th align="center">操作码（助记符）</th>
<th align="center">操作数</th>
<th align="left">描述（栈指操作数栈）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0xb7</td>
<td align="center">invokespecial</td>
<td align="center">indexbyte1<br>indexbyte2</td>
<td align="left">编译时方法绑定调用方法</td>
</tr>
<tr>
<td align="center">0xb6</td>
<td align="center">invokvirtual</td>
<td align="center">indexbyte1<br>indexbyte2</td>
<td align="left">运行时方法绑定调用方法</td>
</tr>
<tr>
<td align="center">0xb8</td>
<td align="center">invokestatic</td>
<td align="center">indexbyte1<br>indexbyte2</td>
<td align="left">调用静态方法</td>
</tr>
<tr>
<td align="center">0xb9</td>
<td align="center">invokeinterface</td>
<td align="center">indexbyte1<br>indexbyte2<br>count<br>0</td>
<td align="left">调用接口方法</td>
</tr>
</tbody></table>
<h2 id="方法返回指令"><a href="#方法返回指令" class="headerlink" title="方法返回指令"></a>方法返回指令</h2><table>
<thead>
<tr>
<th align="center">指令码</th>
<th align="center">操作码（助记符）</th>
<th align="center">操作数</th>
<th align="left">描述（栈指操作数栈）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0xac</td>
<td align="center">ireturn</td>
<td align="center"></td>
<td align="left">返回int类型值</td>
</tr>
<tr>
<td align="center">0xad</td>
<td align="center">lreturn</td>
<td align="center"></td>
<td align="left">返回long类型值</td>
</tr>
<tr>
<td align="center">0xae</td>
<td align="center">freturn</td>
<td align="center"></td>
<td align="left">返回float类型值</td>
</tr>
<tr>
<td align="center">0xaf</td>
<td align="center">dreturn</td>
<td align="center"></td>
<td align="left">返回double类型值</td>
</tr>
<tr>
<td align="center">0xb0</td>
<td align="center">areturn</td>
<td align="center"></td>
<td align="left">返回引用类型值</td>
</tr>
<tr>
<td align="center">0xb1</td>
<td align="center">return</td>
<td align="center"></td>
<td align="left">viod函数返回</td>
</tr>
</tbody></table>
<h2 id="线程同步指令"><a href="#线程同步指令" class="headerlink" title="线程同步指令"></a>线程同步指令</h2><table>
<thead>
<tr>
<th align="center">指令码</th>
<th align="center">操作码（助记符）</th>
<th align="center">操作数</th>
<th align="left">描述（栈指操作数栈）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0xc2</td>
<td align="center">monitorenter</td>
<td align="center"></td>
<td align="left">进入并获得对象监视器</td>
</tr>
<tr>
<td align="center">0xc3</td>
<td align="center">monitorexit</td>
<td align="center"></td>
<td align="left">释放并退出对象监视器</td>
</tr>
</tbody></table>
<p>摘录: <a href="https://www.cnblogs.com/longjee/p/8675771.html">https://www.cnblogs.com/longjee/p/8675771.html</a></p>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发成神之路-精通JUC并发工具十八般武艺——Lock锁(三)</title>
    <url>/2021/11/28/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94Lock%E9%94%81/</url>
    <content><![CDATA[<h1 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h1><h2 id="简介、地位、作用"><a href="#简介、地位、作用" class="headerlink" title="简介、地位、作用"></a>简介、地位、作用</h2><ul>
<li>锁是一种工具，用于控制对共享资源的访问</li>
<li>Lock和synchronized，这两个是最常见的锁，它们都可以达到线程安全的目的，但是在使用上和功能上又有较大的不同</li>
<li>Lock并不是用来代替synchronized的，而是当使用synchronized不合适或不满足要求的时候，来提供高级功能</li>
<li>Lock接口最常见的实现类就是ReentrantLock</li>
<li>通常情况下，Lock只允许一个线程来访问这个共享资源，不过有的时候，一些特殊的实现也可以运行并发访问，比如ReadWriteLock里面的ReadLock</li>
</ul>
<h2 id="为什么synchronized不够用？为什么需要Lock锁？"><a href="#为什么synchronized不够用？为什么需要Lock锁？" class="headerlink" title="为什么synchronized不够用？为什么需要Lock锁？"></a>为什么synchronized不够用？为什么需要Lock锁？</h2><ul>
<li>效率低：锁的释放情况少，试图获得锁时不能设定超时、不能中断一个正在试图获得锁的过程</li>
<li>不够灵活（读写锁更灵活）：加锁和释放的时机单一，每个锁仅有单一的条件（某个对象），可能是不够的</li>
<li>无法知道是否成功获取到锁</li>
</ul>
<h2 id="方法介绍"><a href="#方法介绍" class="headerlink" title="方法介绍"></a>方法介绍</h2><ul>
<li>在Lock中声明了四个方法来获取锁</li>
<li><code>lock()</code>、<code>tryLock()</code>、<code>tryLock(long time,TimeUnit unit)</code>和<code>lockInterruptibly()</code></li>
</ul>
<h3 id="四个方法的区别"><a href="#四个方法的区别" class="headerlink" title="四个方法的区别"></a>四个方法的区别</h3><h4 id="lock"><a href="#lock" class="headerlink" title="lock()"></a><code>lock()</code></h4><ul>
<li><code>lock()</code>就是最普通的获取锁，如果锁已经被其他线程获取，则进行等待</li>
<li>Lock不会想synchronized一样在异常时自动释放锁</li>
<li>因此最佳实践是，在finally中释放锁，以保证发生异常时锁一定被释放</li>
<li><code>lock()</code>方法不能被中断，这会带来很大隐患：一旦陷入死锁，<code>lock()</code>就会陷入永远等待</li>
</ul>
<h4 id="tryLock"><a href="#tryLock" class="headerlink" title="tryLock()"></a><code>tryLock()</code></h4><ul>
<li>tryLock()用来尝试获取锁，如果当前锁没有被其他线程占用，则获取成功，则返回true，否则返回false，代表获取锁失败</li>
<li>相比与<code>lock()</code>，这样的方法显然功能更强大了，我们可以根据是否能获取到锁来决定后续程序的行为</li>
<li>该方法会立即返回，即便在拿不到锁时不会一直在那等</li>
</ul>
<h4 id="tryLock-long-time-TimeUnit-unit"><a href="#tryLock-long-time-TimeUnit-unit" class="headerlink" title="tryLock(long time,TimeUnit unit)"></a><code>tryLock(long time,TimeUnit unit)</code></h4><ul>
<li>相比与tryLock()方法，增加了超时时间，和时间类型两个参数</li>
<li>尝试获取锁，并不会立即返回，而是会等待指定时间，如果超时了就会返回，或者拿到锁了也会返回</li>
</ul>
<h4 id="lockInterruptibly"><a href="#lockInterruptibly" class="headerlink" title="lockInterruptibly()"></a><code>lockInterruptibly()</code></h4><ul>
<li>相当于<code>TryLock(long time,TimeUnit unit)</code>把超时时间设置为无限，在等待锁的过程中线程可以被中断</li>
</ul>
<h4 id="unlock"><a href="#unlock" class="headerlink" title="unlock()"></a><code>unlock()</code></h4><ul>
<li>解锁</li>
</ul>
<h1 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h1><ul>
<li>这些分类，是从各种不同角度出发去看的</li>
<li>这些分类并不是互斥的，也就是多个类型可以并存：有可能一个锁，同时属于两种类型</li>
<li>比如ReentrantLock即是互斥锁，又是可重入锁<br><img src="/2021/11/28/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94Lock%E9%94%81/Java%E4%B8%AD%E9%94%81%E5%88%86%E7%B1%BB%E5%9B%BE.png" alt="Java中锁分类图">+ </li>
</ul>
<h1 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h1><h2 id="为什么还会诞生非互斥同步锁（乐观锁）——互斥同步锁（悲观锁）"><a href="#为什么还会诞生非互斥同步锁（乐观锁）——互斥同步锁（悲观锁）" class="headerlink" title="为什么还会诞生非互斥同步锁（乐观锁）——互斥同步锁（悲观锁）"></a>为什么还会诞生非互斥同步锁（乐观锁）——互斥同步锁（悲观锁）</h2><h3 id="互斥同步锁的劣势"><a href="#互斥同步锁的劣势" class="headerlink" title="互斥同步锁的劣势"></a>互斥同步锁的劣势</h3><ul>
<li>阻塞和唤醒带来的性能劣势（线程状态切换，上下文切换，检查是否有被阻塞线程等，都会带来性能损耗）</li>
<li>永久阻塞：如果持有锁的线程被永久阻塞，比如遇到了无限循环、死锁等活跃性问题，那么等待该线程释放锁的那几个悲催的线程，将永远也得不到执行</li>
<li>优先级反转（低优先级的线程先拿到了锁，高优先级的线程也只能等待它完成之后才能拿到锁）</li>
</ul>
<h2 id="什么是乐观锁和悲观锁"><a href="#什么是乐观锁和悲观锁" class="headerlink" title="什么是乐观锁和悲观锁"></a>什么是乐观锁和悲观锁</h2><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><ul>
<li>如果我不锁柱这个资源，别人就会来争抢，就会造成数据结果错误，所以悲观锁为了确保结果正确性，会在每次获取并修改数据时，把数据锁住，让别人无法访问该数据，这样就可以确保数据内容万无一失</li>
<li>Java中悲观锁的实现就是synchronized和Lock相关类</li>
</ul>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><ul>
<li>认为自己在操作的时候不会有其他线程来干扰，所以并不会锁住被操作对象</li>
<li>在更新的时候，去对比在我修改期间数据有没有被其他人改过：如果没被改变过，就说明真的是只有我自己在操作，那我就正常去执行修改数据</li>
<li>如果数据和我一开始拿到的不一样了，说明其他人在这段时间内修改过数据，那我就不能继续刚才的更新数据过程了，我会选择放弃修改、报错、重试等策略</li>
<li>乐观锁的实现一般都是利用CAS算法来实现的</li>
</ul>
<h2 id="典型例子"><a href="#典型例子" class="headerlink" title="典型例子"></a>典型例子</h2><ul>
<li>乐观锁的典型例子就是原子类、并发容器等</li>
<li>悲观锁的典型例子就是synchronized和Lock相关类</li>
<li>Git：Git就是乐观锁的典型例子，当我们往远程仓库push的时候，git会检查远程仓库的版本是不是领先于我们现在大的版本，如果远程仓库的版本号和本地的不一样，就表示有其他人修改了远程代码了，我们的这次提交就失败，如果远端和本地版本号一致，我们就可以顺利提交版本到远端仓库</li>
<li>数据库<ul>
<li>select for update就是悲观锁</li>
<li>用version控制数据就是乐观锁<ul>
<li>添加一个字段lock_version</li>
<li>先查询这个更新语句的version：select * from table</li>
<li>然后update set num = 2,version = version+1 where version = 1 and id = 5</li>
<li>如果version被更新等于2，不一样就会出现更新错误，这就是乐观锁的原理</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="开销对比"><a href="#开销对比" class="headerlink" title="开销对比"></a>开销对比</h2><ul>
<li>悲观锁的原始开销要高于乐观锁，但是特点是一劳永逸，临界区持锁时间就算越来越差，也不会对互斥锁的开销造成影响</li>
<li>相反，虽然乐观锁一开始的开销比悲观锁小，但是如果自旋时间很长或者不停重试，那么消耗的资源也会越来越多</li>
</ul>
<h2 id="两种锁的使用场景"><a href="#两种锁的使用场景" class="headerlink" title="两种锁的使用场景"></a>两种锁的使用场景</h2><ul>
<li>悲观锁：适合并发写入多的情况，适用于临界区持锁时间比较长的情况，悲观锁可以避免大量的无用自旋等消耗，典型情况：<ul>
<li>临界区有IO操作</li>
<li>临界区代码复杂或者循环量大</li>
<li>临界区竞争非常激烈</li>
</ul>
</li>
<li>乐观锁：适合并发写入少，大部分是读取的场景，不加锁能让读取性能大幅度提高</li>
</ul>
<h1 id="可重入锁和非可重入锁，以ReentrantLock为例（重点）"><a href="#可重入锁和非可重入锁，以ReentrantLock为例（重点）" class="headerlink" title="可重入锁和非可重入锁，以ReentrantLock为例（重点）"></a>可重入锁和非可重入锁，以<code>ReentrantLock</code>为例（重点）</h1><h2 id="可重入性质"><a href="#可重入性质" class="headerlink" title="可重入性质"></a>可重入性质</h2><h3 id="什么是可重入"><a href="#什么是可重入" class="headerlink" title="什么是可重入"></a>什么是可重入</h3><ul>
<li>当一个线程获取到一把锁之后，可以再次获取这把锁，甚至多次获得这把锁，递归获取</li>
<li>ReentrantLock和synchronized都是可重入锁</li>
<li>好处：可以避免死锁，比如需要多次获取当前锁的时候，不可能放弃再重新获取</li>
<li>代码示例如下，递归进行调用，每次不需要重新获取锁<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursionDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        accessResource();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">accessResource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;已经对资源进行了处理&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (lock.getHoldCount() &lt; <span class="number">5</span>)</span><br><span class="line">                accessResource();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
可重入锁和不可重入锁源码对比：<blockquote>
<p>如图所示，可重入锁，在线程再次获取锁的时候，会判断当前线程是否持有锁，如果有，就在标记上加1<br>解锁的时候同理，标记减一，最后判断是否等于0，等于0表示彻底解锁<br>不可重入锁则是直接判断锁的状态，已被持有直接返回<br><img src="/2021/11/28/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94Lock%E9%94%81/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E5%92%8C%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E6%BA%90%E7%A0%81%E5%AF%B9%E6%AF%94.png" alt="可重入锁和不可重入锁源码对比"></p>
</blockquote>
</li>
</ul>
<h2 id="ReentrantLock的其他方法介绍"><a href="#ReentrantLock的其他方法介绍" class="headerlink" title="ReentrantLock的其他方法介绍"></a>ReentrantLock的其他方法介绍</h2><ul>
<li><code>isHeldByCurrentThread</code>可以看出锁是否被当前线程持有</li>
<li>getQueueLength可以返回当前正在等待这把锁的队列有多长，一般这两个方法是开发和调试的时候使用，上线后不会使用</li>
</ul>
<h1 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h1><h2 id="什么是公平和非公平"><a href="#什么是公平和非公平" class="headerlink" title="什么是公平和非公平"></a>什么是公平和非公平</h2><ul>
<li>公平值得是按照线程请求的顺序，来分配锁</li>
<li>非公平指的是，不完全按照请求的顺序，在一定情况下可以插队（并不是完全打乱顺序）</li>
<li>注意：非公平也同样不提倡“插队”行为，这里的非公平，指的是“在合适的时机”插队，而不是盲目插队</li>
<li>合适的时机：在被唤醒的空档期，有一个完全清醒的线程来获取锁，可以直接拿到</li>
</ul>
<h2 id="为什么要有非公平"><a href="#为什么要有非公平" class="headerlink" title="为什么要有非公平"></a>为什么要有非公平</h2><ul>
<li>提高效率</li>
<li>避免唤醒带来的空档期</li>
</ul>
<h2 id="公平情况（以ReentrantLock为例）"><a href="#公平情况（以ReentrantLock为例）" class="headerlink" title="公平情况（以ReentrantLock为例）"></a>公平情况（以<code>ReentrantLock</code>为例）</h2><ul>
<li>如果创建ReentrantLock对象时，参数填写为true，那么这就是一个公平锁</li>
<li>假设有1234，四个线程去获取锁，1拿到了锁，234就在队列里面等待，2完就是3，然后4</li>
</ul>
<h2 id="不公平情况（以ReentrantLock为例）"><a href="#不公平情况（以ReentrantLock为例）" class="headerlink" title="不公平情况（以ReentrantLock为例）"></a>不公平情况（以<code>ReentrantLock</code>为例）</h2><ul>
<li>还是上面的例子，假如在1释放锁的时候，线程5恰好去执行<code>lock()</code></li>
<li>由于<code>ReentrantLock</code>发现此时并没有线程持有lock这把锁（线程2还没有来得及获取，因为唤醒和获取需要时间）</li>
<li>线程5可以插队，直接拿到这把锁，这也是<code>ReentrantLock</code>默认的公平策略，也就是“不公平”</li>
</ul>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><blockquote>
<p>如下面代码所示，当ReentrantLock参数为true，设置为公平锁的时候<br>线程1打印完毕第一次之后，想要再次获取到锁，就会排队到线程10的后面，需要1到10挨个打印完第一伦之后，才会打印第二轮<br>当ReentrantLock参数为false，设置为非公平锁的时候<br>线程1打印完之后，就会尝试第二次获取锁，而这个时候线程2唤醒还需要时间，就会出现，线程1连着两次打印，线程2连着打印的情况</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FairLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        PrintQueue printQueue = <span class="keyword">new</span> PrintQueue();</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Job(printQueue));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            threads[i].start();</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Job</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    PrintQueue printQueue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Job</span><span class="params">(PrintQueue printQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.printQueue = printQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;开始打印&quot;</span>);</span><br><span class="line">        printQueue.printJob(<span class="keyword">new</span> Object());</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;打印完毕&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintQueue</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock queueLock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">false</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printJob</span><span class="params">(Object document)</span></span>&#123;</span><br><span class="line">        queueLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> duration = <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>)+<span class="number">1</span>;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;正在打印，需要&quot;</span>+duration);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(duration*<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            queueLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        queueLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> duration = (<span class="keyword">long</span>) (Math.random() * <span class="number">10000</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;正在打印，需要&quot;</span>+duration/<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(duration);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            queueLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="特例"><a href="#特例" class="headerlink" title="特例"></a>特例</h2><ul>
<li>针对<code>tryLock()</code>方法，它不遵守设定的公平规则（无论公平还是非公平）</li>
<li>例如，当有线程在执行<code>tryLock()</code>的时候，一旦有线程释放了锁，那么这个正在tryLock的线程就能获取到锁，即使在它之前已经有其他线程等待在队列里面了</li>
</ul>
<h2 id="对比公平和非公平的有缺点"><a href="#对比公平和非公平的有缺点" class="headerlink" title="对比公平和非公平的有缺点"></a>对比公平和非公平的有缺点</h2><table>
<thead>
<tr>
<th align="left"></th>
<th align="left">优势</th>
<th align="left">劣势</th>
</tr>
</thead>
<tbody><tr>
<td align="left">公平</td>
<td align="left">各线程公平平等，每个线程在等待一段时间后，总有执行的机会</td>
<td align="left">更慢，吞吐量更小</td>
</tr>
<tr>
<td align="left">不公平</td>
<td align="left">更快，吞吐量更大</td>
<td align="left">有可能产生线程饥饿，也就是某些线程在长时间内，始终得不到执行</td>
</tr>
</tbody></table>
<h2 id="源码对比"><a href="#源码对比" class="headerlink" title="源码对比"></a>源码对比</h2><blockquote>
<p>公平锁和非公平锁的源码对比如下<br>可以看出，公平锁在线程获取锁的时候会先判断，队列中是否有任务，非公平锁则不会判断，直接就去获取锁<br><img src="/2021/11/28/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94Lock%E9%94%81/%E5%85%AC%E5%B9%B3%E9%94%81%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E6%BA%90%E7%A0%81%E5%AF%B9%E6%AF%94.png" alt="公平锁非公平锁源码对比"></p>
</blockquote>
<h1 id="共享锁和排它锁：以ReentrantReadWriteLock读写锁为例（重点）"><a href="#共享锁和排它锁：以ReentrantReadWriteLock读写锁为例（重点）" class="headerlink" title="共享锁和排它锁：以ReentrantReadWriteLock读写锁为例（重点）"></a>共享锁和排它锁：以<code>ReentrantReadWriteLock</code>读写锁为例（重点）</h1><h2 id="什么是共享锁和排他锁"><a href="#什么是共享锁和排他锁" class="headerlink" title="什么是共享锁和排他锁"></a>什么是共享锁和排他锁</h2><ul>
<li>排它锁：又较独占锁、独享锁</li>
<li>共享锁：又称为读锁，获取共享锁之后，可以查看但无法修改和删除数据，其他线程此时也可以获取到共享锁，也可以查看但无法修改和删除数据</li>
<li>共享锁和排他锁的典型就是读写锁<code>ReentrantReadWriteLock</code>，其中读锁是共享锁，写锁是独享锁</li>
</ul>
<h2 id="读写锁的作用"><a href="#读写锁的作用" class="headerlink" title="读写锁的作用"></a>读写锁的作用</h2><ul>
<li>在没有读写锁之前，我们假设使用ReentrantLock，那么虽然我们保证了线程安全，但是也浪费了一定的资源：多个读操作同时进行，并没有线程安全问题</li>
<li>在读的地方使用读锁，在写的地方是哦那个写锁，灵活控制，如果没有写锁的情况下，读是没有阻塞的，提高了程序的执行效率</li>
</ul>
<h2 id="读写锁的规则"><a href="#读写锁的规则" class="headerlink" title="读写锁的规则"></a>读写锁的规则</h2><ul>
<li>多个线程只申请读锁，都可以申请到</li>
<li>如果又一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁</li>
<li>如果又一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁</li>
<li>总结：要么是一个或者多个线程同时读锁，要么是一个线程又写锁，但是两者不会同时出现（要么多读，要么一写）</li>
<li>换一种理解思路：读写锁只是一把锁，可以通过两种方式锁定：<ul>
<li>读锁定和写锁定</li>
<li>读写锁可以同时被一个或多个线程锁定，也可以被单一线程写锁定</li>
<li>但是永远不能同时对这把锁进行读锁定和写锁定<blockquote>
<p>读写锁代码实现如下所示</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CinemaReadWrite</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantReadWriteLock reentrantReadWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantReadWriteLock.ReadLock readLock = reentrantReadWriteLock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantReadWriteLock.WriteLock writeLock = reentrantReadWriteLock.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;得到了读锁，正在读取&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;释放了读锁&quot;</span>);</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>&#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;得到了写锁，正在写入&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;释放了写锁&quot;</span>);</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;read(),<span class="string">&quot;Thread1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;read(),<span class="string">&quot;Thread2&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;write(),<span class="string">&quot;Thread3&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;write(),<span class="string">&quot;Thread4&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thread1得到了读锁，正在读取</span><br><span class="line">Thread2得到了读锁，正在读取</span><br><span class="line">Thread2释放了读锁</span><br><span class="line">Thread1释放了读锁</span><br><span class="line">Thread3得到了写锁，正在写入</span><br><span class="line">Thread3释放了写锁</span><br><span class="line">Thread4得到了写锁，正在写入</span><br><span class="line">Thread4释放了写锁</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="读写锁插队策略"><a href="#读写锁插队策略" class="headerlink" title="读写锁插队策略"></a>读写锁插队策略</h2><ul>
<li>公平锁：不允许插队</li>
<li>非公平锁：<ul>
<li>写锁可以随时插队</li>
<li>读锁仅在队列头节点不是想获取写锁的线程的时候可以插队</li>
<li>(如果读锁可以随意插队，那么可能会造成写锁饥饿，读取需要时间，假如刚好一个结束，另一个开始，这样会导致写锁一直得不到执行)<blockquote>
<p>根据<code>ReentrantReadWriteLock</code>中的源码可以看出来，公平锁读写锁每次都会判断队列，在决定是否去获取锁<br>非公平锁，写锁直接返回false，可以去进行插队，读锁会判断队列第一位是不是排它锁，也就是写锁<br><img src="/2021/11/28/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94Lock%E9%94%81/ReentrantReadWriteLock%E5%85%AC%E5%B9%B3%E9%94%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0.png" alt="ReentrantReadWriteLock公平锁代码实现"><br><img src="/2021/11/28/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94Lock%E9%94%81/ReentrantReadWriteLock%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0.png" alt="ReentrantReadWriteLock非公平锁代码实现"></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairBargeDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantReadWriteLock reentrantReadWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantReadWriteLock.ReadLock readLock = reentrantReadWriteLock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantReadWriteLock.WriteLock writeLock = reentrantReadWriteLock.writeLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        list.add(Thread.currentThread().getName() + <span class="string">&quot;开始尝试获取读锁&quot;</span>);</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            list.add(Thread.currentThread().getName() + <span class="string">&quot;得到了读锁，正在读取&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            list.add(Thread.currentThread().getName() + <span class="string">&quot;释放了读锁&quot;</span>);</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        list.add(Thread.currentThread().getName() + <span class="string">&quot;开始尝试获取写锁&quot;</span>);</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            list.add(Thread.currentThread().getName() + <span class="string">&quot;得到了写锁，正在写入&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">20</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            list.add(Thread.currentThread().getName() + <span class="string">&quot;释放了写锁&quot;</span>);</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; write(), <span class="string">&quot;Thread1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; read(), <span class="string">&quot;Thread2&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; read(), <span class="string">&quot;Thread3&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; read(), <span class="string">&quot;Thread4&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; read(), <span class="string">&quot;Thread5&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; write(), <span class="string">&quot;Thread6&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; read(), <span class="string">&quot;Thread7&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Thread[] threads = <span class="keyword">new</span> Thread[<span class="number">1000</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                    threads[i] = <span class="keyword">new</span> Thread(() -&gt; read(), <span class="string">&quot;子线程创建的Thread&quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                    threads[i].start();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        list.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>插队演示代码如上所示，先将锁设置为非公平锁<br>读锁插队：我们先将创建线程获取到一个写锁，写锁完毕之后，会唤醒后面的读锁，后面跟了多个读锁，按照顺序唤醒，需要时间去执行，而这个时候，插队线程会不停的发出插队请求<br>具体结果如下图<br>线程1释放读锁之后，线程2被唤醒，然后线程158开始插队并插队成功，之后线程3和4拿到了读锁，然后线程159插队成功，线程5拿到读锁之后，线程5后面的线程6拿的是写锁<br>队列第一位为写锁的时候读锁不允许插队，所以后面的插队读请求全部插队失败<br><img src="/2021/11/28/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94Lock%E9%94%81/%E8%AF%BB%E9%94%81%E6%8F%92%E9%98%9F%E7%BB%93%E6%9E%9C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="读锁插队结果示意图"><br>如下图所示，当之前的读锁任务执行完毕之后，并没有其他线程来抢锁，直接由线程7写锁抢锁成功，之后的所有尝试获取读锁的线程都进行等待<br><img src="/2021/11/28/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94Lock%E9%94%81/%E5%86%99%E9%94%81%E6%8F%92%E9%98%9F%E7%BB%93%E6%9E%9C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="写锁插队结果示意图"></p>
</blockquote>
<blockquote>
<p>如果是公平锁，结果如下两图所示，线程1执行完毕之后，线程2、3、4、5开始执行，期间又线程进行尝试，但都在获取锁的时候进行等待<br>当线程2、3、4、5执行完毕，线程6开始执行，线程6释放锁之后，线程7才开始和其他线程一起执行读锁<br><img src="/2021/11/28/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94Lock%E9%94%81/%E5%85%AC%E5%B9%B3%E9%94%81%E6%8A%A2%E9%94%81%E7%BB%93%E6%9E%9C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="公平锁抢锁结果示意图"><br><img src="/2021/11/28/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94Lock%E9%94%81/%E5%85%AC%E5%B9%B3%E9%94%81%E6%8A%A2%E9%94%81%E7%BB%93%E6%9E%9C%E7%A4%BA%E6%84%8F%E5%9B%BE2.png" alt="公平锁抢锁结果示意图2"></p>
</blockquote>
<h2 id="锁的升降级"><a href="#锁的升降级" class="headerlink" title="锁的升降级"></a>锁的升降级</h2><ul>
<li>支持降级，不支持升级</li>
<li>假设又两个线程同时持有读锁，其中一个想要进行升级，那么等另外一个线程执行完毕就可以进行升级，但是如果两个线程都想要升级，那么就会互相等待，陷入死锁（锁可以支持升级，只不过<code>ReentrantReadWriteLock</code>为了避免死锁不支持升级，可以自己实现锁支持升级，但是需要保证升级的时候只有一个线程进行升级，不然就容易陷入死锁）<blockquote>
<p>锁升降级代码如下所示<br>在获取到了写锁的情况下可以直接去拿读锁进行降级，可以成功<br>在拿到读锁的情况下，再去尝试获取写锁进行升级，会陷入阻塞中</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Upgrading</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantReadWriteLock reentrantReadWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantReadWriteLock.ReadLock readLock = reentrantReadWriteLock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantReadWriteLock.WriteLock writeLock = reentrantReadWriteLock.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readUpgrading</span><span class="params">()</span></span>&#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;得到了读锁，正在读取&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;升级会带来堵塞&quot;</span>);</span><br><span class="line">            writeLock.lock();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;成功获取到了写锁，升级成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;释放了读锁&quot;</span>);</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeUpgrading</span><span class="params">()</span></span>&#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;得到了写锁，正在写入&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            readLock.lock();</span><br><span class="line">            System.out.println(<span class="string">&quot;在不释放写锁的情况下直接获取读锁成功，锁降级成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.lock();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;释放了写锁&quot;</span>);</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; writeUpgrading(), <span class="string">&quot;Thread1&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        thread.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;readUpgrading(),<span class="string">&quot;Thread2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><code>ReentrantReadWriteLock</code>实现了<code>ReadWriteLock</code>接口，最主要的有来给两个方法：<code>readLock()</code>和<code>writeLock()</code>用来获取读锁和写锁</li>
<li>锁的申请和释放策略<ul>
<li>多个线程只申请读锁，都可以申请到</li>
<li>如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请的线程会一直等待释放读锁</li>
<li>如果有一个线程已经占用了写锁，则此时其他线程如果要申请读锁，则申请的线程会一直等待释放写锁</li>
<li>要么是一个或者多个线程同时持有读锁，要么是一个线程持有写锁，但是两者不会同时出现</li>
</ul>
</li>
<li>插队策略：为了防止饥饿，读锁不能插队</li>
<li>升降级策略：只能降级，不能升级</li>
<li>使用场景：相比于<code>ReentrantLock</code>适用于一般场合，<code>ReentrantReadWriteLock</code>适用于读多写少的情况，合理适用可以进一步提高并发效率</li>
</ul>
<h1 id="自旋锁和阻塞锁"><a href="#自旋锁和阻塞锁" class="headerlink" title="自旋锁和阻塞锁"></a>自旋锁和阻塞锁</h1><ul>
<li>阻塞或唤醒一个Java线程需要操作系统切换CPU的状态来完成，这种状态转换需要耗费处理器时间</li>
<li>如果同步代码块中的内容过于简单，状态切换消耗的时间有可能比用户代码执行的时间还要长</li>
<li>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失</li>
<li>如果物理机有多核处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快会释放锁</li>
<li>而为了让当前线程“稍微等一下”，我们需要让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销，这就是自旋锁</li>
<li>阻塞锁和自旋锁相反，阻塞锁如果遇到没拿到锁的情况，会直接把线程阻塞，直到被唤醒</li>
</ul>
<h2 id="自旋锁的缺点"><a href="#自旋锁的缺点" class="headerlink" title="自旋锁的缺点"></a>自旋锁的缺点</h2><ul>
<li>如果锁被占用的时间很长，那么自旋的线程只会浪费处理器资源</li>
<li>在自旋的过程中，一直消耗CPU，所以虽然自旋锁的起始开销低于悲观锁，但是随着自旋时间的增长，开销也是线性增长的</li>
</ul>
<h2 id="原理和源码分析"><a href="#原理和源码分析" class="headerlink" title="原理和源码分析"></a>原理和源码分析</h2><ul>
<li>在Java1.5版本及以上的并发框架<code>java.util.concurrent</code>的atomic包下的类基本都是自旋锁的实现</li>
<li><code>AtomicInteger</code>的实现：自旋锁的实现原理CAS，<code>AtomicInteger</code>中调用<code>unsafe</code>进行自增操作的源码中的<code>do-while</code>循环就是一个自旋操作，如果修改过程中遇到其他线程竞争导致没修改成功，就在while里死循环，直至修改成功<blockquote>
<p>如图所示<br><img src="/2021/11/28/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94Lock%E9%94%81/%E8%87%AA%E6%97%8B%E9%94%81%E6%BA%90%E7%A0%81%E5%9B%BE%E7%A4%BA.png" alt="自旋锁源码图示"><br>自旋锁实现代码如下所示  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Thread&gt; sign = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        <span class="keyword">while</span> (!sign.compareAndSet(<span class="keyword">null</span>, thread)) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        sign.compareAndSet(thread, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpinLock spinLock = <span class="keyword">new</span> SpinLock();</span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始尝试获取自旋锁&quot;</span>);</span><br><span class="line">                spinLock.lock();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获得自旋锁&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">300</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    spinLock.unlock();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;释放了自旋锁&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(runnable).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(runnable).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="自旋锁的适用场景"><a href="#自旋锁的适用场景" class="headerlink" title="自旋锁的适用场景"></a>自旋锁的适用场景</h2><ul>
<li>自旋锁一般用于多核服务器，在并发度不是特别高的情况下，比阻塞锁的效率高</li>
<li>另外，自旋锁适用于临界区比较短小的情况，否则如果临界区很大（线程一旦拿到锁，很久之后才会释放），那也是不合适的</li>
</ul>
<h1 id="可中断锁：顾名思义，就是可以相应中断的锁"><a href="#可中断锁：顾名思义，就是可以相应中断的锁" class="headerlink" title="可中断锁：顾名思义，就是可以相应中断的锁"></a>可中断锁：顾名思义，就是可以相应中断的锁</h1><ul>
<li>在Java中<code>synchronized</code>就是不可中断锁，而<code>Lock</code>是可中断锁，因为<code>tryLock(time)</code>和<code>lockInterruptibly</code>都能响应中断</li>
<li>如果某一线程A正在执行锁中的代码，另一个线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以中断它，这种就是可中断锁</li>
</ul>
<h1 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h1><h2 id="Java虚拟机对锁的优化"><a href="#Java虚拟机对锁的优化" class="headerlink" title="Java虚拟机对锁的优化"></a>Java虚拟机对锁的优化</h2><ul>
<li>自旋锁和自适应(在自旋的时候会自动判断自旋的时间，也许自旋几次之后就会转为阻塞，会根据上次获取锁的情况进行判断)</li>
<li>锁消除(jvm会判断对锁的使用，假设是在一个方法内部，根本不会出现并发情况，JVM会自动帮忙消除锁)</li>
<li>锁粗化(虚拟机检测到在很短的代码内对同一个多不停的加锁解锁，就会将锁的范围粗化，减少加锁解锁的次数)</li>
</ul>
<h2 id="我们在写代码时如何优化锁和提高并发性能"><a href="#我们在写代码时如何优化锁和提高并发性能" class="headerlink" title="我们在写代码时如何优化锁和提高并发性能"></a>我们在写代码时如何优化锁和提高并发性能</h2><ul>
<li>缩小同步代码块</li>
<li>尽量不要锁着方法</li>
<li>减少请求锁的次数</li>
<li>避免认为制造“热点”</li>
<li>锁中尽量不要再包含锁</li>
<li>选择合适的锁类型或合适的工具类</li>
</ul>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发成神之路-精通JUC并发工具十八般武艺——控制并发流程(七)</title>
    <url>/2021/12/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94%E6%8E%A7%E5%88%B6%E5%B9%B6%E5%8F%91%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="什么是控制并发流程"><a href="#什么是控制并发流程" class="headerlink" title="什么是控制并发流程"></a>什么是控制并发流程</h1><ul>
<li>控制并发流程的工具类，作用就是帮助我们程序员更容易的让线程之间合作</li>
<li>让线程之间相互配合，来满足业务逻辑</li>
<li>比如让线程A等待线程B执行完毕后再执行等合作策略</li>
</ul>
<h2 id="有那些控制并发流程的工具类"><a href="#有那些控制并发流程的工具类" class="headerlink" title="有那些控制并发流程的工具类"></a>有那些控制并发流程的工具类</h2><table>
<thead>
<tr>
<th align="center">类</th>
<th align="left">作用</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>Semaphore</code></td>
<td align="left">信号量，可以通过控制”许可证“的数量，来保证线程之间的配合</td>
<td align="left">线程只有在拿到”许可证“后才能继续运行，相比于其他同步器，更灵活</td>
</tr>
<tr>
<td align="center"><code>CyclicBarrier</code></td>
<td align="left">线程会等待，直到足够多线程达到了事先规定的数目，一旦达到触发条件，就可以进行下一步的动作。</td>
<td align="left">适用于线程之间相互等待处理结果就绪的场景</td>
</tr>
<tr>
<td align="center"><code>Phaser</code></td>
<td align="left">和CyclicBarrier类似，但是计数可变</td>
<td align="left">Java7加入的</td>
</tr>
<tr>
<td align="center"><code>CountDownLatch</code></td>
<td align="left">和CyclicBarrier类似，数量递减到0时，触发动作</td>
<td align="left">不可重复使用</td>
</tr>
<tr>
<td align="center"><code>Exchanger</code></td>
<td align="left">让两个线程在合适的适合交换对象</td>
<td align="left">适用场景：当两个线程工作在同一个类的不同示例上时，用于交换数据</td>
</tr>
<tr>
<td align="center"><code>Condition</code></td>
<td align="left">可以控制线程的”等待“和”唤醒“</td>
<td align="left">是Object.wait()的升级版</td>
</tr>
</tbody></table>
<h1 id="CountDownLatch倒计时门闩"><a href="#CountDownLatch倒计时门闩" class="headerlink" title="CountDownLatch倒计时门闩"></a>CountDownLatch倒计时门闩</h1><h2 id="CountDownLatch类的作用"><a href="#CountDownLatch类的作用" class="headerlink" title="CountDownLatch类的作用"></a>CountDownLatch类的作用</h2><ul>
<li>倒数门闩</li>
<li>流程：倒数结束之前，一直处于等待状态，直到倒计时结束了，此线程才继续工作</li>
<li>开始 -&gt; 进入等待 -&gt; 倒数结束 -&gt; 继续工作</li>
</ul>
<h2 id="CountDownLatch类的主要方法"><a href="#CountDownLatch类的主要方法" class="headerlink" title="CountDownLatch类的主要方法"></a>CountDownLatch类的主要方法</h2><ul>
<li><code>CountDownLatch(int count)</code>：仅有一个构造函数，参数count为需要倒数的数值</li>
<li><code>await()</code>：调用<code>await()</code>方法的线程会被挂起，它会等待直到count值为0才继续执行</li>
<li><code>countDown()</code>：将count值减1，直到为0时，等待的线程会被唤起</li>
</ul>
<h2 id="CountDownLatch类的主要用法"><a href="#CountDownLatch类的主要用法" class="headerlink" title="CountDownLatch类的主要用法"></a>CountDownLatch类的主要用法</h2><ul>
<li><p>用法一：一个线程等待多个线程都执行完毕，再继续自己的工作</p>
</li>
<li><p>代码如下所示：假设一个产品需要经过5道质检程序，全部检查之后通过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">5</span>);</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> no = i+<span class="number">1</span>;</span><br><span class="line">            Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep((<span class="keyword">long</span>) (Math.random()*<span class="number">10000</span>));</span><br><span class="line">                        System.out.println(<span class="string">&quot;No.&quot;</span>+no+<span class="string">&quot;完成了检查&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                        latch.countDown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            executorService.submit(runnable);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;等待5个人检查完毕~~~~&quot;</span>);</span><br><span class="line">        latch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;所有人都检查完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>用法二：多个线程等待某一个线程的信号，同时开始执行</p>
</li>
<li><p>代码如下所示：假设有5个人进行跑步比赛，裁判枪响之后，同时开始比赛</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> no = i+<span class="number">1</span>;</span><br><span class="line">            Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;NO.&quot;</span> + no + <span class="string">&quot;准备完毕，等待发令枪&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        latch.await();</span><br><span class="line">                        System.out.println(<span class="string">&quot;NO.&quot;</span> + no + <span class="string">&quot;开始跑步&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            executorService.submit(runnable);</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;发令抢响，比赛开始&quot;</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ul>
<li>扩展用法：多个线程等多个线程完成执行后，再同时执行</li>
<li><code>CountDownLatch</code>是不能够重用的，如果需要重新计数，可以考虑适用<code>CyclicBarrier</code>或创建新的<code>CountDownLatch</code></li>
</ul>
<h1 id="Semaphore信号量"><a href="#Semaphore信号量" class="headerlink" title="Semaphore信号量"></a>Semaphore信号量</h1><ul>
<li><code>Semaphore</code>可以用来限制或者管理数量有限的资源的适用情况</li>
<li>信号量的作用是维护一个”许可证“的计数，线程可以”获取“许可证，那信号量剩余的许可证就减一，线程也可以”释放“一个许可证，那么信号量剩余的许可证就加一，当信号量所拥有的许可证数量为0，那么下一个还想要获取许可证的线程，就需要等待，直到有另外的线程释放了许可证</li>
</ul>
<h2 id="信号量的使用流程"><a href="#信号量的使用流程" class="headerlink" title="信号量的使用流程"></a>信号量的使用流程</h2><ul>
<li>初始化<code>Semaphore</code>并指定许可证的数量</li>
<li>在需要被限制的代码前加<code>acquire()</code>或者<code>acquireUninterruptibly()</code>方法</li>
<li>在任务执行结束后，调用<code>release()</code>来释放许可证</li>
</ul>
<h2 id="信号量的主要方法介绍"><a href="#信号量的主要方法介绍" class="headerlink" title="信号量的主要方法介绍"></a>信号量的主要方法介绍</h2><ul>
<li><code>new Semaphore(int permits,boolean fair)</code>：这里可以设置是否使用公平策略，如果传入true，那么<code>Semaphore</code>会把之前等待的线程放到FIFO的队列里，以便于当有了新的许可证，可以分发给之前等待了最长时间的线程</li>
<li><code>acquire()</code>：获取许可证，可以响应中断</li>
<li><code>acquireUninterruptibly()</code>：获取许可证，不能响应中断</li>
<li><code>tryAcquire()</code>：看看现在有没有空闲的许可证，如果有的话就获取，如果没有的话也没有关系，我不必陷入阻塞，我可以去做别的事，过一会再来看许可证的空闲情况</li>
<li><code>tryAcquire(timeout)</code>：和<code>tryAcquire()</code>方法一样，但是多了一个超时时间，如果没有许可证，会等待一定的时间，然后再退出</li>
<li><code>release()</code>：归还许可证</li>
</ul>
<h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><p>使用方法如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>,<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">50</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            executorService.submit(<span class="keyword">new</span> Task());</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.isShutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;拿到了许可证&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;释放了许可证-----&quot;</span>);</span><br><span class="line">                semaphore.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="信号量特殊用法"><a href="#信号量特殊用法" class="headerlink" title="信号量特殊用法"></a>信号量特殊用法</h2><ul>
<li>一次性获取或释放多个许可证<ul>
<li>比如任务A会调用很多消耗资源的方法，而任务B调用的不是太消耗资源的方法，假设我们一共有5个许可证，那么我们就可以要求任务A获取5个许可证才能执行，而任务B只需要获取到一个许可证就能执行，这样就避免了两个任务同时运行的情况，我们可以根据自己的需求合理分配资源</li>
</ul>
</li>
</ul>
<h2 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h2><ul>
<li>获取和释放的许可证数量必须一致，否则比如每次获取到2个许可证，但是只释放1个，随着时间的推移，到最后许可证数量不够用，会导致城西卡死，（虽然信号量类并不对释放和获取的数量做规定，但是这是我们的编程规范，否则容易出错）</li>
<li>注意在初始化Semaphore的时候设置公平性，一般设置为true更合理（因为使用Semaphore的地方一般都是因为处理太慢，如果使用非公平策略，可能会导致饥饿的情况）</li>
<li>并不是必须由获取许可证的线程释放那个许可证，事实上，获取和释放许可证对线程并无要求，也许A获取了，然后B释放，只要逻辑合理即可</li>
<li>信号量的作用，除了控制临界 区最多同时有N个线程访问外，另一个作用是可以实现“条件等待”，例如线程1需要在线程2完成准备工作后才能开始工作，那么就线程1<code>acquire()</code>，而线程2完成任务后<code>release()</code>，这样的话就相当于轻量级<code>CountDownLatch</code></li>
</ul>
<h1 id="Condition接口（又称条件对象）"><a href="#Condition接口（又称条件对象）" class="headerlink" title="Condition接口（又称条件对象）"></a>Condition接口（又称条件对象）</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul>
<li>当线程1需要等待某个条件的时候，它就会去执行<code>condition.await()</code>方法，一旦执行了<code>await()</code>方法，线程就会进入阻塞状态</li>
<li>然后通常会有另外一个线程，假设是线程2，去执行对应的条件，直到这个条件达成的时候，线程2就会去执行<code>condition.signal()</code>方法，这是JVM就会从被阻塞的线程里找到那些等待该condition的线程，当线程1就会收到可执行的信号的时候，它的线程状态就会变成Runnable可执行状态</li>
</ul>
<h2 id="signalAll-和signal-方法的区别"><a href="#signalAll-和signal-方法的区别" class="headerlink" title="signalAll()和signal()方法的区别"></a><code>signalAll()</code>和<code>signal()</code>方法的区别</h2><ul>
<li>signalAll()会唤起所有正在等待的线程</li>
<li>但是signal()是公平的，只会唤起那个等待时间最长的线程</li>
</ul>
<h2 id="代码演示-1"><a href="#代码演示-1" class="headerlink" title="代码演示"></a>代码演示</h2><p>代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionDemo1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConditionDemo1 conditionDemo1 = <span class="keyword">new</span> ConditionDemo1();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    conditionDemo1.method2();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        conditionDemo1.method1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;条件不满足，开始等待&quot;</span>);</span><br><span class="line">            condition.await();</span><br><span class="line">            System.out.println(<span class="string">&quot;添加满足了，继续处理任务&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;准备工作完成，开始唤醒其他线程&quot;</span>);</span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>Condition</code>来实现生产者和消费者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionDemo2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> queueSize = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(queueSize);</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition notFull = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition notEmpty = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConditionDemo2 conditionDemo2 = <span class="keyword">new</span> ConditionDemo2();</span><br><span class="line">        Consumer consumer = conditionDemo2.<span class="function">new <span class="title">Consumer</span><span class="params">()</span></span>;</span><br><span class="line">        Producer producer = conditionDemo2.n<span class="function">ew <span class="title">Producer</span><span class="params">()</span></span>;</span><br><span class="line">        consumer.start();</span><br><span class="line">        producer.start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            consume();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (queue.size() == <span class="number">0</span>)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;队列为空，等待数据&quot;</span>);</span><br><span class="line">                        notEmpty.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                    queue.poll();</span><br><span class="line">                    notFull.signalAll();</span><br><span class="line">                    System.out.println(<span class="string">&quot;从队列里取走了一个数据，队列里剩余: &quot;</span>+queue.size());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            produce();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (queue.size() == queueSize)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;队列已满，等待空余&quot;</span>);</span><br><span class="line">                        notFull.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                    queue.offer(<span class="number">1</span>);</span><br><span class="line">                    notEmpty.signalAll();</span><br><span class="line">                    System.out.println(<span class="string">&quot;向队列插入一个元素，队列剩余空间: &quot;</span>+(queueSize-queue.size())+<span class="string">&quot;-----&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注意点-2"><a href="#注意点-2" class="headerlink" title="注意点"></a>注意点</h2><ul>
<li>实际上，如果说<code>Lock</code>用来代替<code>synchronized</code>，那么<code>Condition</code>就是用来代替相对应的<code>Object.wait/notify</code>的，所以在用法和性质上，几乎都一样</li>
<li><code>await</code>方法会自动释放持有的<code>Lock</code>锁，和<code>Object.wait</code>一样，不需要自己手动先释放锁</li>
<li>调用<code>await</code>的时候，必须持有锁，否则会抛出异常，和<code>Object.wait</code>一样</li>
</ul>
<h1 id="CyclicBarrier循环栅栏"><a href="#CyclicBarrier循环栅栏" class="headerlink" title="CyclicBarrier循环栅栏"></a><code>CyclicBarrier</code>循环栅栏</h1><ul>
<li><code>CyclicBarrier</code>循环栅栏和<code>CountDownLatch</code>很类似，都能阻塞一组线程</li>
<li>当有大量线程相互配合，分别计算不同任务，并且需要最后统一汇总的时候，我们可以使用<code>CyclicBarrier</code>，<code>CyclicBarrier</code>可以构造一个集结点，当某一个线程执行完毕，它就会到集结点等待，直到所有线程都到了集结点，那么该栅栏就被撤销，所有线程再统一出发，继续执行剩下的任务</li>
</ul>
<h2 id="代码演示-2"><a href="#代码演示-2" class="headerlink" title="代码演示"></a>代码演示</h2><p>代码如下所示，<code>CyclicBarrier</code>是可重用的，假设是同时执行了10个线程，也是可以，只不过会5个一起出发 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;所有都到了，大家一起出发吧&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task(i,cyclicBarrier)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(<span class="keyword">int</span> id, CyclicBarrier cyclicBarrier)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">            <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程&quot;</span>+id+<span class="string">&quot;现在前往集合地点&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep((<span class="keyword">long</span>) (Math.random()*<span class="number">10000</span>));</span><br><span class="line">                System.out.println(<span class="string">&quot;线程&quot;</span>+id+<span class="string">&quot;到了集合地点，开始等待其他人&quot;</span>);</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">                System.out.println(<span class="string">&quot;线程&quot;</span>+id+<span class="string">&quot;出发了&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CyclicBarrier和CountDownLatch的区别"><a href="#CyclicBarrier和CountDownLatch的区别" class="headerlink" title="CyclicBarrier和CountDownLatch的区别"></a><code>CyclicBarrier</code>和<code>CountDownLatch</code>的区别</h2><ul>
<li>作用不同：<code>CyclicBarrier</code>要等固定数量的线程都到达了栅栏位置才能继续执行，而<code>CountDownLatch</code>只需要等待数字到0，也就是说<code>CountDownLatch</code>用于事件，但是<code>CyclicBarrier</code>是用于线程（<code>CountDownLatch</code>同一个任务用一个线程执行多次，只要计算为0就可以，<code>CyclicBarrier</code>则必须要指定数量的线程才行）</li>
<li>可重用性不同：<code>CountDownLatch</code>在倒数到0并触发门闩打开后，就不能再次使用了，除非创建新的实例，而<code>CyclicBarrier</code>可以重复使用</li>
<li><code>CyclicBarrier</code>在所有线程都到达只会，可以再去运行一个Runnable方法</li>
</ul>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发成神之路-精通JUC并发工具十八般武艺——线程池(一)</title>
    <url>/2021/11/26/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF-%E7%B2%BE%E9%80%9AJUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h1 id="并发工具类——分类"><a href="#并发工具类——分类" class="headerlink" title="并发工具类——分类"></a>并发工具类——分类</h1><ul>
<li>为了并发安全：互斥同步、非互斥同步、无同步方案</li>
<li>管理线程、提高效率</li>
<li>线程协作<blockquote class="pullquote mindmap mindmap-md"><ul>
<li>并发工具类的分类<ul>
<li>为了线程安全（从底层原理来看）<ul>
<li>互斥同步<ul>
<li>使用各种互斥同步的锁<ul>
<li>synchronized</li>
<li>ReentrantLock</li>
<li>ReadWriteLock</li>
<li>…</li>
</ul>
</li>
<li>使用同步的工具类<ul>
<li>Collections.synchronizedList(new ArrayList&lt;&gt;())等</li>
<li>Vector等</li>
</ul>
</li>
</ul>
</li>
<li>非互斥同步<ul>
<li>atomic包，原子类<ul>
<li>Atomic*基本类型原子类<ul>
<li>AtomicInteger：整型原子类</li>
<li>AtomicLong：长整型原子类</li>
<li>AtomicBoolean：布尔型原子类</li>
</ul>
</li>
<li>Atomic*Array数组类型原子类(数组里面的元素，都可以保证原子性)<ul>
<li>AtomicIntegerArray：整型数组原子类</li>
<li>AtomicLongArray：长整型数组原子类</li>
<li>AtomicReferenceArray：引用类型数组原子类</li>
</ul>
</li>
<li>Atomic*Reference引用类型子类<ul>
<li>AtomicReference：引用类型原子类</li>
<li>AtomicStampedReference：引用类型原子类的升级，带时间戳，可以解决ABA问题</li>
<li>AtomicMarkableReference</li>
</ul>
</li>
<li>Atomic*FieldUpdater升级原子类<ul>
<li>用Atomic*FieldUpdater等升级自己的变量</li>
<li>AtomicIntegerFieldUpdater：原子更新整型字段的更新器</li>
<li>AtomicLongFieldUpdater：原子更新长整型字段的更新器</li>
</ul>
</li>
<li>Adder加法器<ul>
<li>LongAdder</li>
<li>DoubleAdder</li>
</ul>
</li>
<li>Accumulator累加器<ul>
<li>LongAccumulator</li>
<li>DoubleAccumulator</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>结合互斥和非互斥同步<ul>
<li>线程安全的并发容器<ul>
<li>ConcurrentHashMap</li>
<li>CopyOnWriteArrayList</li>
<li>并发队列<ul>
<li>阻塞队列<ul>
<li>ArrayBlockingQueue</li>
<li>LinkedBlockingQueue</li>
<li>PriorityBlockingQueue</li>
<li>SynchronousQueue</li>
<li>DelayedQueue</li>
<li>TransferQueue</li>
<li>…</li>
</ul>
</li>
<li>非阻塞队列<ul>
<li>ConcurrentLinkedQueue</li>
</ul>
</li>
</ul>
</li>
<li>ConcurrentSkipListMap和ConcurrentSkipListSet</li>
</ul>
</li>
</ul>
</li>
<li>无同步方、不可变<ul>
<li>final关键字</li>
<li>线程封闭<ul>
<li>ThreadLocal</li>
<li>栈封闭</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>为了线程安全（从使用者角度来看）<ul>
<li>避免共享变量<ul>
<li>线程封闭<ul>
<li>ThreadLocal</li>
<li>栈封闭</li>
</ul>
</li>
</ul>
</li>
<li>共享变量，但是可以限制和处理<ul>
<li>互斥同步<ul>
<li>使用各种互斥同步的锁<ul>
<li>synchronized</li>
<li>Lock接口相关的类</li>
</ul>
</li>
</ul>
</li>
<li>final关键字</li>
</ul>
</li>
<li>使用成熟工具类<ul>
<li>线程安全的并发容器<ul>
<li>ConcurrentHashMap</li>
<li>CopyOnWriteArrayList</li>
<li>并发队列<ul>
<li>阻塞队列<ul>
<li>ArrayBlockingQueue</li>
<li>LinkedBlockingQueue</li>
<li>PriorityBlockingQueue</li>
<li>SynchronousQueue</li>
<li>DelayedQueue</li>
<li>TransferQueue</li>
<li>…</li>
</ul>
</li>
<li>非阻塞队列<ul>
<li>ConcurrentLinkedQueue</li>
</ul>
</li>
</ul>
</li>
<li>ConcurrentSkipListMap和ConcurrentSkipListSet</li>
<li>使用同步的工具类<ul>
<li>Collections.synchronizedList(new ArrayList&lt;&gt;())等</li>
<li>Vector等</li>
</ul>
</li>
</ul>
</li>
<li>atomic包，原子类<ul>
<li>Atomic*基本类型原子类<ul>
<li>AtomicInteger：整型原子类</li>
<li>AtomicLong：长整型原子类</li>
<li>AtomicBoolean：布尔型原子类</li>
</ul>
</li>
<li>Atomic*Array数组类型原子类(数组里面的元素，都可以保证原子性)<ul>
<li>AtomicIntegerArray：整型数组原子类</li>
<li>AtomicLongArray：长整型数组原子类</li>
<li>AtomicReferenceArray：引用类型数组原子类</li>
</ul>
</li>
<li>Atomic*Reference引用类型子类<ul>
<li>AtomicReference：引用类型原子类</li>
<li>AtomicStampedReference：引用类型原子类的升级，带时间戳，可以解决ABA问题</li>
<li>AtomicMarkableReference</li>
</ul>
</li>
<li>Atomic*FieldUpdater升级原子类<ul>
<li>用Atomic*FieldUpdater等升级自己的变量</li>
<li>AtomicIntegerFieldUpdater：原子更新整型字段的更新器</li>
<li>AtomicLongFieldUpdater：原子更新长整型字段的更新器</li>
</ul>
</li>
<li>Adder加法器<ul>
<li>LongAdder</li>
<li>DoubleAdder</li>
</ul>
</li>
<li>Accumulator累加器<ul>
<li>LongAccumulator</li>
<li>DoubleAccumulator</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>为了方便管理线程、提高效率<ul>
<li>线程池相关<ul>
<li>Executor</li>
<li>Executors</li>
<li>ExecutorService</li>
<li>常见线程池<ul>
<li>FixedThreadPool</li>
<li>CachedThreadPool</li>
<li>ScheduledThreadPool</li>
<li>SingleThreadExecutor</li>
<li>ForkJoinPool</li>
<li>…</li>
</ul>
</li>
</ul>
</li>
<li>能获取子线程的运行结果<ul>
<li>Callable</li>
<li>Future</li>
<li>FutureTask</li>
<li>…</li>
</ul>
</li>
</ul>
</li>
<li>为了线程之间配合，来满足业务逻辑<ul>
<li>CountDownLath</li>
<li>CyclicBarrier</li>
<li>Semaphore</li>
<li>Condition</li>
<li>Exchanger</li>
<li>Phaser</li>
<li>…</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote></li>
</ul>
<h1 id="线程池的自我介绍"><a href="#线程池的自我介绍" class="headerlink" title="线程池的自我介绍"></a>线程池的自我介绍</h1><h2 id="线程池的重要性"><a href="#线程池的重要性" class="headerlink" title="线程池的重要性"></a>线程池的重要性</h2><ul>
<li>如果不使用线程池，每个任务都需要新开一个线程处理<ul>
<li>一个线程还好，如果是几千的任务，每次都创建线程</li>
</ul>
</li>
<li>这样开销太大，我们希望有固定的数量的线程，来执行这几千个任务，这样就避免了反复创建并销毁线程所带来的开销问题</li>
</ul>
<h2 id="为什么要使用线程池"><a href="#为什么要使用线程池" class="headerlink" title="为什么要使用线程池"></a>为什么要使用线程池</h2><ul>
<li>问题一：反复创建线程开销大</li>
<li>问题二：过多的线程会占用太多内存</li>
<li>解决以上两个问题的思路<ul>
<li>用少量的线程——避免内存占用过多</li>
<li>让这部分线程都保持工作，且可以反复执行任务——避免生命周期的损耗</li>
</ul>
</li>
</ul>
<h2 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h2><ul>
<li>加快相应速度</li>
<li>合理利用CPU和内存</li>
<li>统一管理</li>
</ul>
<h2 id="线程池适合应用的场景"><a href="#线程池适合应用的场景" class="headerlink" title="线程池适合应用的场景"></a>线程池适合应用的场景</h2><ul>
<li>服务器接受到大量请求时，使用线程池技术是非常合适的，它可以大大减少线程的创建和销毁次数，提高服务器的工作效率</li>
<li>实际上，在开发中，如果需要创建5个以上的线程，那么就可以使用线程池来管理</li>
</ul>
<h1 id="创建和停止线程池"><a href="#创建和停止线程池" class="headerlink" title="创建和停止线程池"></a>创建和停止线程池</h1><h2 id="线程池构造函数的参数"><a href="#线程池构造函数的参数" class="headerlink" title="线程池构造函数的参数"></a>线程池构造函数的参数</h2><table>
<thead>
<tr>
<th align="center">参数名</th>
<th align="center">类型</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">corePoolSize</td>
<td align="center">int</td>
<td align="center">核心线程数，详解见下文</td>
</tr>
<tr>
<td align="center">maximumPoolSize</td>
<td align="center">int</td>
<td align="center">最大线程数，详解见下文</td>
</tr>
<tr>
<td align="center">keepAliveTime</td>
<td align="center">long</td>
<td align="center">保持存活时间</td>
</tr>
<tr>
<td align="center">unit</td>
<td align="center">TimeUnit</td>
<td align="center">保持存活时间的单位</td>
</tr>
<tr>
<td align="center">workQueue</td>
<td align="center">BlockingQueue</td>
<td align="center">任务存储队列</td>
</tr>
<tr>
<td align="center">threadFactory</td>
<td align="center">ThreadFactory</td>
<td align="center">当线程池需要新的线程的时候，会使用threadFactory来生成新的线程</td>
</tr>
<tr>
<td align="center">Handler</td>
<td align="center">RejectedExecutionHandler</td>
<td align="center">由于线程池也无法接受你所提交的任务的拒绝策略</td>
</tr>
</tbody></table>
<h3 id="参数中corePoolSize和macPoolSize"><a href="#参数中corePoolSize和macPoolSize" class="headerlink" title="参数中corePoolSize和macPoolSize"></a>参数中<code>corePoolSize</code>和<code>macPoolSize</code></h3><ul>
<li><code>corePoolSize</code>指的是核心线程数：线程池在完成初始化后，默认情况下，线程池中并没有任何线程，线程池会等待有任务到来时，再创建新线程去执行任务</li>
<li>线程池有可能会在核心线程数的基础上，额外增加一些线程，但是这些增加的线程数有一个上限，这就是最大量<code>maximumPoolSize</code></li>
</ul>
<h3 id="添加线程规则"><a href="#添加线程规则" class="headerlink" title="添加线程规则"></a>添加线程规则</h3><ul>
<li>如果线程数小于<code>corePoolSize</code>，即使其他工作线程处于空闲状态，也会创建一个新的线程来运行新任务</li>
<li>如果线程数等于（或大于）<code>corePoolSize</code>但少于<code>maximumPoolSize</code>，则将任务放入队列</li>
<li>如果队列已满，并且线程数小于<code>maximumPoolSize</code>，则创建一个新的线程来运任务</li>
<li>如果队列已满，并且线程数大于或等于<code>maximumPoolSize</code>，则拒绝该任务</li>
<li>是否需要增加线程的判断顺序是：<ul>
<li><code>corePoolSize</code></li>
<li><code>workQueue</code></li>
<li><code>maximumPoolSize</code></li>
</ul>
</li>
</ul>
<div id="flowchart-0" class="flow-chart"></div>

<h3 id="增减线程的特点"><a href="#增减线程的特点" class="headerlink" title="增减线程的特点"></a>增减线程的特点</h3><ul>
<li>通过设置<code>corePoolSize</code>和<code>maximumPoolSize</code>相同，就可以创建一个固定大小的线程池</li>
<li>线程池希望保持较少的线程数，并且只有在负载变得很大的时候才增加它</li>
<li>通过设置<code>maximumPoolSize</code>为很高的值，例如Integer.MAX_VALUE，可以允许线程池容纳任意数量的并发任务</li>
<li>是只有队列填满的时候才会创建对于<code>corePoolSize</code>的线程，所以如果你使用的是无界队列（例如<code>LinkedBockingQueue</code>），那么线程数就不会超过<code>corePoolSize</code></li>
</ul>
<h3 id="keepAliveTime"><a href="#keepAliveTime" class="headerlink" title="keepAliveTime"></a><code>keepAliveTime</code></h3><ul>
<li>如果线程池当前的线程数对于<code>corePoolSize</code>，那么如果多余的线程空闲时间超过<code>keepAliveTime</code>，它们就会被终止</li>
</ul>
<h3 id="ThreadFactory用来创建线程"><a href="#ThreadFactory用来创建线程" class="headerlink" title="ThreadFactory用来创建线程"></a><code>ThreadFactory</code>用来创建线程</h3><ul>
<li>新的线程是由<code>ThreadFactory</code>创建的，默认使用<code>Executors.defaultThreadFactory()</code>，创建出来的线程都在同一个线程组，拥有同样的NORM_PRIORITY优先级并且都不是守护线程，如果自己指定ThreadFactory，那么就可以改变线程名、线程组、优先级、是否是守护线程等。</li>
<li>通常情况下我们使用默认的<code>ThreadFactory</code>就可以了</li>
</ul>
<h3 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h3><ul>
<li>有3中最常见的队列类型：<ul>
<li>直接交接：<code>SynchronousQueue</code>(没有队列，里面不存任务，直接交给线程执行)</li>
<li>无界队列：<code>LinkedBlockingQueue</code>(队列没有界限，永远不会被塞满，但是可能会内存溢出)</li>
<li>有界队列：<code>ArrayBlockingQueue</code>(可以设置队列大小)</li>
</ul>
</li>
</ul>
<h2 id="线程池应该手动创建还是自动创建"><a href="#线程池应该手动创建还是自动创建" class="headerlink" title="线程池应该手动创建还是自动创建"></a>线程池应该手动创建还是自动创建</h2><ul>
<li>手动创建更好，因为这样可以让我们更加明确线程池的运行规则，避免资源耗尽的风险</li>
<li>让我们来看看自动创建线程池（也就是直接调用JDK封装好的构造函数）可能带来那些问题</li>
</ul>
<h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a><code>newFixedThreadPool</code></h3><ul>
<li>创建一个定长的线程池</li>
<li>由于传进去的LinkedBlockQueue是没有容量上限的，所以当请求数越来越多，并且无法及时处理完毕的时候，也就是请求堆积的时候，会容易造成占用大量的内存，可能会导致OOM。<blockquote>
<p>OOM的代码如下，任务数调到最大，每个线程都直接休眠，任务一直无法完成，就会全部堆积在队列中，最终导致队列OOM</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FixedThreadPoolOOM</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i++) &#123;</span><br><span class="line">            executorService.execute(<span class="keyword">new</span> SubThread());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a><code>newSingleThreadExecutor</code></h3></li>
<li>创建一个单线程的线程池</li>
<li>可以看出，这里和刚才的<code>newFixedThreadPool</code>的原理基本是一样的，只不过是把线程数直接设置成了1，所以这也会导致同样的问题，也就是当请求堆积的时候，可能会占用大量内存</li>
</ul>
<h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a><code>newCachedThreadPool</code></h3><ul>
<li>可以缓存的线程池</li>
<li>这里的弊端在于第二个参数<code>maximumPoolSize</code>被设置为了<code>Integer.MAX_VALUE</code>，这可能会创建数量非常多的线程，甚至导致OOM</li>
</ul>
<h3 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a><code>newScheduledThreadPool</code></h3><ul>
<li>支持定时及周期性任务执行的线程池</li>
<li>可以在指定时间后执行任务，也可以在指定时间后每隔多久执行一次任务</li>
</ul>
<h3 id="workStealingPool是JDK8加入的"><a href="#workStealingPool是JDK8加入的" class="headerlink" title="workStealingPool是JDK8加入的"></a>workStealingPool是JDK8加入的</h3><ul>
<li>子任务：适合有子任务的场景（比如遍历二叉树，一个任务会创建多个子任务）</li>
<li>窃取：当其他的线程执行完任务之后，如果某一个线程的子任务还没有执行完毕，其他线程就会帮他执行，任务执行是没有顺序的</li>
</ul>
<h3 id="正确的创建线程池的方法"><a href="#正确的创建线程池的方法" class="headerlink" title="正确的创建线程池的方法"></a>正确的创建线程池的方法</h3><ul>
<li>根据不同的业务场景，自己设置线程池参数，比如我们的内存有多大，我们想给线程取什么名字等待</li>
</ul>
<h2 id="线程池里的线程数量设定为多少比较合适"><a href="#线程池里的线程数量设定为多少比较合适" class="headerlink" title="线程池里的线程数量设定为多少比较合适"></a>线程池里的线程数量设定为多少比较合适</h2><ul>
<li>CPU密集性（加密、计算hash等）：最佳线程数为CPU核心数的1-2倍左右。</li>
<li>耗时IO型（读写数据库、文件、网络读写等）：最佳线程数一般会大于CPU核心数很多倍，以JVM线程监控显示繁忙情况为依据，保证线程空闲可以衔接上</li>
<li>参考Brain Goetz推荐的计算方法：<ul>
<li>线程数 = CPU核心数 * （1 + 平均等待时间 / 平均工作时间）</li>
</ul>
</li>
</ul>
<h1 id="停止线程池的正确方法"><a href="#停止线程池的正确方法" class="headerlink" title="停止线程池的正确方法"></a>停止线程池的正确方法</h1><ul>
<li><code>shutdown()</code><ul>
<li>并不会立即停止线程池，而是通知线程池进行停止</li>
<li>线程池会将正在等待的以及正在执行的任务执行完毕之后再停止</li>
<li>但是再执行该方法之后，就无法再向线程池提交任务</li>
</ul>
</li>
<li><code>isShutdown()</code><ul>
<li>判断线程池是否已经执行过了<code>shutdown</code></li>
<li>并不是返回true就是线程池已经结束，而是开始准备结束</li>
</ul>
</li>
<li><code>isTerminated()</code><ul>
<li>判断线程池是否真的结束</li>
</ul>
</li>
<li><code>awaitTermination(long timeout, TimeUnit unit)</code><ul>
<li>会阻塞线程，阻塞时间根据参数指定</li>
<li>然后返回一个布尔类型的结果</li>
<li>结果是判断线程池是否关闭</li>
<li>阻塞一定的时间，然后判断线程池是否已经关闭</li>
</ul>
</li>
<li><code>shutdownNow</code><ul>
<li>立即关闭线程池</li>
<li>会多所有正在执行任务发出中断指令</li>
<li>有一个List的返回值，返回的是所有正在等待中的任务的集合</li>
</ul>
</li>
</ul>
<h1 id="任务太多，怎么拒绝？"><a href="#任务太多，怎么拒绝？" class="headerlink" title="任务太多，怎么拒绝？"></a>任务太多，怎么拒绝？</h1><h2 id="决绝时机"><a href="#决绝时机" class="headerlink" title="决绝时机"></a>决绝时机</h2><ul>
<li>当线程池关闭时，提交新任务会被拒绝</li>
<li>当线程池对最大线程和工作队列容量使用有限制边界并且已经饱和的时候会拒绝任务</li>
</ul>
<h2 id="4中决绝策略"><a href="#4中决绝策略" class="headerlink" title="4中决绝策略"></a>4中决绝策略</h2><ul>
<li>AbortPolicy<ul>
<li>直接抛出异常</li>
</ul>
</li>
<li>DiscardPolicy<ul>
<li>直接丢弃任务，并且不会通知</li>
</ul>
</li>
<li>DiscardOldestPolicy<ul>
<li>丢弃最老的任务，将新的放进队列</li>
</ul>
</li>
<li>CallerRunPolicy<ul>
<li>让提交任务的线程去执行任务（同步执行）</li>
</ul>
</li>
</ul>
<h1 id="钩子方法，给线程池加点料"><a href="#钩子方法，给线程池加点料" class="headerlink" title="钩子方法，给线程池加点料"></a>钩子方法，给线程池加点料</h1><blockquote>
<p>具体实现如以下代码所示，代码的功能是实现一个可以暂停的线程池，等待一定时间后还能被唤醒<br>继承<code>ThreadPoolExecutor</code>类，并重写<code>beforeExecute</code>方法，这个方法会在线程执行每一个任务之前执行<br>通过标记位，实现对线程的暂停和恢复</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PauseableThreadPool</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isPaused;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition unpaused = lock.newCondition();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        PauseableThreadPool pauseableThreadPool = <span class="keyword">new</span> PauseableThreadPool(<span class="number">10</span>,<span class="number">20</span>,<span class="number">10L</span>,TimeUnit.SECONDS,<span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;());</span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我被执行了&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            pauseableThreadPool.execute(runnable);</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">        pauseableThreadPool.pause();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程池被暂停了&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">        pauseableThreadPool.resume();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程池被恢复了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.beforeExecute(t, r);</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isPaused) &#123;</span><br><span class="line">                unpaused.await();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            isPaused = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resume</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            isPaused = <span class="keyword">false</span>;</span><br><span class="line">            unpaused.signalAll();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PauseableThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="实现原理，源码分析"><a href="#实现原理，源码分析" class="headerlink" title="实现原理，源码分析"></a>实现原理，源码分析</h1><h2 id="线程池组成部分"><a href="#线程池组成部分" class="headerlink" title="线程池组成部分"></a>线程池组成部分</h2><ul>
<li>线程池管理器</li>
<li>工作线程</li>
<li>任务队列</li>
<li>任务接口（Task）</li>
</ul>
<h2 id="Executor家族"><a href="#Executor家族" class="headerlink" title="Executor家族"></a>Executor家族</h2><ul>
<li>线程池、<code>ThreadPoolExecutor</code>、<code>ExecutorService</code>、<code>Executor</code>、<code>Executors</code>等这么多和线程池相关的类，大家都是什么关系呢？<img src="http://www.plantuml.com/plantuml/svg/oymhIIrAIqnELN2jI4qkBSalggxboiGG34ujAii4ybChIbBpKegH5ISc5PSK9IQNA2Jd91ONApX2kUWwCtCBSb9pK_DAYj4D1Pe1qHgIKPIQc1AGdvy3Km6t3uUfrRK0"></li>
<li><code>Executor</code><blockquote>
<p>线程池的最顶级接口，只提供了执行线程的方法</p>
</blockquote>
</li>
<li><code>ExecutorService</code><blockquote>
<p>对<code>Executor</code>接口的继承，同时添加了一些其他的方法，比如停止线程池的方法等</p>
</blockquote>
</li>
<li><code>ThreadPoolExecutor</code><blockquote>
<p>线程池的最终实现类</p>
</blockquote>
</li>
<li><code>Executors</code><blockquote>
<p>一个工具类，提供了一些创建线程池的方法</p>
</blockquote>
</li>
</ul>
<h2 id="线程池实现线程复用的原理"><a href="#线程池实现线程复用的原理" class="headerlink" title="线程池实现线程复用的原理"></a>线程池实现线程复用的原理</h2><ul>
<li>相同线程执行不同任务<blockquote>
<p>下面代码是从<code>ThreadPoolExecutor</code>类中摘取的启动任务的方法<br>从代码中可以看出来，主要是通过while循环，判断当前任务不为空，或者能取到下一个任务<br>而任务的类型就是<code>Runnable</code>类型的，之后就直接执行它的<code>run()</code>方法运行任务</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final void runWorker(Worker w) &#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = null;</span><br><span class="line">    w.unlock(); // allow interrupts</span><br><span class="line">    boolean completedAbruptly = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        while (task != null || (task = getTask()) != null) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            // If pool is stopping, ensure thread is interrupted;</span><br><span class="line">            // if not, ensure thread is not interrupted.  This</span><br><span class="line">            // requires a recheck in second case to deal with</span><br><span class="line">            // shutdownNow race while clearing interrupt</span><br><span class="line">            if ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            try &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; catch (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; throw x;</span><br><span class="line">                &#125; catch (Error x) &#123;</span><br><span class="line">                    thrown = x; throw x;</span><br><span class="line">                &#125; catch (Throwable x) &#123;</span><br><span class="line">                    thrown = x; throw new Error(x);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                task = null;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = false;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h2><ul>
<li>RUNNING：接受新任务并且处理排队任务</li>
<li>SHUTDOWN：不接受新的任务，但是处理排队中的任务</li>
<li>STOP：不接受新的任务，也不处理排队中的任务，并且中断正在进行中的任务</li>
<li>TIDYING，中文是整洁，理解了中文就容易理解这个状态了：所有任务都已经终止，<code>workerCount</code>为0时，线程会转换到<code>TIDYING</code>状态，并将运行<code>terminate()</code>钩子方法</li>
<li>TERMINATED：<code>terminate()</code>运行完成</li>
</ul>
<h1 id="使用线程池的注意点"><a href="#使用线程池的注意点" class="headerlink" title="使用线程池的注意点"></a>使用线程池的注意点</h1><ul>
<li>避免任务堆积</li>
<li>避免线程数过度增加</li>
<li>排查线程泄漏（线程一直无法回收）</li>
</ul>
<script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: 开始
o1=>operation: 提交任务
c1=>condition: 核心线程池是否已满？
c2=>condition: 队列是否已满？
c3=>condition: 线程池是否已满？
o2=>operation: 按照策略处理无法执行的任务
o3=>operation: 创建核心线程执行任务
o4=>operation: 任务添加到队列
o5=>operation: 创建非核心线程执行任务
st->o1
o1->c1
c1(yes)->c2
c1(no)->o3
c2(yes)->c3
c2(no)->o4
c3(yes)->o2
c3(no)->o5
e=>end: 结束
o2->e
o3->e
o4->e
o5->e</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发核心知识体系精讲——Java内存模型(二)</title>
    <url>/2021/11/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2%E2%80%94%E2%80%94Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2>Java内存模型——底层原理</h2>

<h2 id="自顶向下（学习方法）"><a href="#自顶向下（学习方法）" class="headerlink" title="自顶向下（学习方法）"></a>自顶向下（学习方法）</h2><ul>
<li>先将试用场景，再讲用法，最后讲原理</li>
<li>直观的了解、具体而感性的认识、有助于加深理解、最后分析源码</li>
<li>兴趣：连这个原理有什么作用都不知道的话，我们肯定是没有兴趣的，而没有兴趣就意味着我们学不好</li>
</ul>
<h2 id="到底什么叫“底层原理”？本章研究的内容是什么？"><a href="#到底什么叫“底层原理”？本章研究的内容是什么？" class="headerlink" title="到底什么叫“底层原理”？本章研究的内容是什么？"></a>到底什么叫“底层原理”？本章研究的内容是什么？</h2><h3 id="从Java代码到CPU指令"><a href="#从Java代码到CPU指令" class="headerlink" title="从Java代码到CPU指令"></a>从Java代码到CPU指令</h3><ul>
<li>最开始，我们编写的Java代码，是*.java文件</li>
<li>在编译（javac命令）后，从刚刚的*.java文件会编译出一个新的java字节码文件（*.class）</li>
<li>JVM会执行刚才生成的字节码文件（*.class），并把字节码文件转化为机器指令</li>
<li>机器指令可以直接在CPU上执行，也就是最终的程序执行</li>
</ul>
<blockquote>
<p>JVM实现会带来不同的”翻译“，不同的CPU平台的机器指令又千差万别，无法保证并发实现的效果一致（如果只是做一份编译，直接进行运行，不同的机器，对相同的编译内容理解也是不一样的，最终会导致运行结果不一致）<br>中断开始向下转移：转化过程的规范、原则（进行约束，以保证相同的代码最终能拿到相同的结果）</p>
</blockquote>
<h2 id="三兄弟：JVM内存结构-VS-Java内存模型-VS-Java对象模式"><a href="#三兄弟：JVM内存结构-VS-Java内存模型-VS-Java对象模式" class="headerlink" title="三兄弟：JVM内存结构 VS Java内存模型 VS Java对象模式"></a>三兄弟：JVM内存结构 VS Java内存模型 VS Java对象模式</h2><ul>
<li>JVM内存结构：和Java虚拟机的运行时区域有关</li>
<li>Java内存模型：和Java的并发编程有关</li>
<li>Java对象模型：和Java对象在虚拟机中的表现形式有关</li>
</ul>
<h3 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h3><ul>
<li>堆：整个运行区域最大的一块，主要存储实例对象，包括数组，如果这些对象不再有引用会被垃圾回收</li>
<li>虚拟机栈：保存基本数据类型，以及对对象的引用</li>
<li>方法区：已经加载的静态变量类信息以及常量信息包括永久引用</li>
<li>本地方法栈：主要是Native方法</li>
<li>程序计数器：主要存储当前线程所执行的字节码的行号数<br><img src="/2021/11/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2%E2%80%94%E2%80%94Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="JVM内存结构图"></li>
</ul>
<h3 id="Java对象模型"><a href="#Java对象模型" class="headerlink" title="Java对象模型"></a>Java对象模型</h3><ul>
<li>Java对象自身的存储模型</li>
<li>JVM会给整个类创建一个instanceKlass，保存再方法区，用来再JVM层表示该Java类</li>
<li>当我们再Java代码中，使用new创建一个对象的时候，JVM会创建一个instanceOopDesc对象，这个对象中包含了对象头以及实例数据<br><img src="/2021/11/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2%E2%80%94%E2%80%94Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/Java%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E5%9B%BE%E7%A4%BA.png" alt="Java对象模型图示"></li>
</ul>
<h2 id="JMM是什么？"><a href="#JMM是什么？" class="headerlink" title="JMM是什么？"></a>JMM是什么？</h2><h3 id="为什么需要JMM"><a href="#为什么需要JMM" class="headerlink" title="为什么需要JMM"></a>为什么需要JMM</h3><ul>
<li>C语言不存在内存模型的概念</li>
<li>依赖处理器，不同处理器结果不一样</li>
<li>无法保证并发安全</li>
<li>需要一个标准，让多线程运行的结果可预期</li>
</ul>
<h3 id="JMM是规范"><a href="#JMM是规范" class="headerlink" title="JMM是规范"></a>JMM是规范</h3><ul>
<li>Java Memory Model</li>
<li>是一组规范，需要各个JVM的实现来遵守JMM规范，以便于开发者可以利用这些规范，更方便地开发多线程程序</li>
<li>如果没有这样的一个JMM内存模型来规范，那么很可能经过了不同JVM的不同规则的重排序之后，导致不同的虚拟机上运行的结果不一样，那是很大的问题</li>
<li>volatile、synchronized、Lock等的原理都是JMM</li>
<li>如果没有JMM，那就需要我们自己指定什么时候使用内存栅栏等，那是相当麻烦的，幸好有了JMM，让我们只需要用同步工具和关键字就可以开发并发程序</li>
<li><h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2></li>
</ul>
<h3 id="重排序的代码案例、什么是重排序"><a href="#重排序的代码案例、什么是重排序" class="headerlink" title="重排序的代码案例、什么是重排序"></a>重排序的代码案例、什么是重排序</h3><ul>
<li><p>代码演示如下</p>
</li>
<li><p>4行赋值代码的执行顺序决定了最终x和y的结果，一共有3种情况：</p>
<ul>
<li>a=1;x=b(0);b=1;y=a(1)，最终结果是x=0，y=1</li>
<li>b=1;y=a(0);a=1;x=b(1)，最终结果是x=1，y=0</li>
<li>b=1;a=1;x=b(1);y=a(1)，最终结果是x=1，y=1<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutOfOrderExecution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread one = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                a = <span class="number">1</span>;</span><br><span class="line">                x = b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread tow = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                b = <span class="number">1</span>;</span><br><span class="line">                y = a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        one.start();</span><br><span class="line">        tow.start();</span><br><span class="line">        one.join();</span><br><span class="line">        tow.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;x = &quot;</span> + x + <span class="string">&quot;, y = &quot;</span> + y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>根据上面的代码可以看出，一般意义来说，是不可能出现x=0和y=0的情况的，但是这种结果却又出现了</p>
</li>
<li><p>只有执行顺序为  y=a;a=1;x=b;b=1;  的时候才会出现x=0，y=0<br><img src="/2021/11/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2%E2%80%94%E2%80%94Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F%E7%8E%B0%E8%B1%A1%E7%BB%93%E6%9E%9C%E5%9B%BE.png" alt="指令重排序现象结果图"></p>
</li>
<li><p><strong>什么是重排序</strong>：在线程1内部的两行代码的实际执行顺序和代码在Java文件中的顺序不一致，代码指令并不是严格按照代码语句顺序执行的，它们的顺序被改变了，这就是重排序，这里被颠倒的是y=a和b=1这两行语句</p>
</li>
</ul>
<h3 id="重排序的好处：提高处理速度"><a href="#重排序的好处：提高处理速度" class="headerlink" title="重排序的好处：提高处理速度"></a>重排序的好处：提高处理速度</h3><blockquote>
<p>如下图所示，左边三行代码，对应三段指令，当指令重拍之后，就会对应到右边的顺序，对a来说少了一次读和写操作<br><img src="/2021/11/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2%E2%80%94%E2%80%94Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F%E7%9A%84%E5%A5%BD%E5%A4%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="指令重排序的好处示意图"></p>
</blockquote>
<h3 id="重排序的3种情况：编译器优化、CPU指令重拍、内存的”重排序“"><a href="#重排序的3种情况：编译器优化、CPU指令重拍、内存的”重排序“" class="headerlink" title="重排序的3种情况：编译器优化、CPU指令重拍、内存的”重排序“"></a>重排序的3种情况：编译器优化、CPU指令重拍、内存的”重排序“</h3><ul>
<li>编译器优化：包括JVM，JIT编译器等</li>
<li>CPU指令重排：就算编译器不发生重拍，CPU也可能对指令进行重排</li>
<li>内存的“重排序”：线程A的修改线程B看不到（表面看起来像重排，实质是并发问题），引出可见性的问题</li>
</ul>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><h3 id="案例：演示什么是可见性"><a href="#案例：演示什么是可见性" class="headerlink" title="案例：演示什么是可见性"></a>案例：演示什么是可见性</h3><ul>
<li>具体演示代码如下所示，开启两个线程，同时操作变量a和b</li>
<li>一共会出现如下四种结果：</li>
<li>a=3;b=2;(线程1刚修改了a，还未修改b，线程2进行打印)</li>
<li>a=1;b=2;(线程2先于线程1运行)</li>
<li>a=3;b=3;(线程1运行完毕，线程2打印运行)</li>
<li>a=1;b=3;(从代码上看，这种情况几乎是不可能的，但是却真实出现了，线程1的操作对线程2来说，并不是完全可见的，线程2无法或者只能看到部分线程1的操作)<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldVisibility</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FieldVisibility test = <span class="keyword">new</span> FieldVisibility();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                test.change();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                test.print();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;b = &quot;</span> + b + <span class="string">&quot; a = &quot;</span> + a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">3</span>;</span><br><span class="line">        b = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="为什么会有可见性问题"><a href="#为什么会有可见性问题" class="headerlink" title="为什么会有可见性问题"></a>为什么会有可见性问题</h3><ul>
<li>CPU有多级缓存，导致读的数据过期<ul>
<li>高速缓存的容量比主内存小，但是速度仅次于寄存器，所以再CPU和主内存之间多了cache层</li>
<li>线程间的对于共享变量的可见性问题不是直接由多个引起的，而是由多缓存引起的</li>
<li>如果多有核心都只用一个缓存，那么也就不存在内存可见性问题了</li>
<li>每个核心都会将自己需要的数据读到独占缓存中，数据修改后也是写入到缓存中，然后等待刷入到主存中，多以会导致有些核心读取的值是一个过期的值</li>
</ul>
</li>
</ul>
<h3 id="JMM的抽象：主内存和本地内存"><a href="#JMM的抽象：主内存和本地内存" class="headerlink" title="JMM的抽象：主内存和本地内存"></a>JMM的抽象：主内存和本地内存</h3><h4 id="什么是主内存和本地内存"><a href="#什么是主内存和本地内存" class="headerlink" title="什么是主内存和本地内存"></a>什么是主内存和本地内存</h4><ul>
<li>Java作为高级语言，屏蔽了这些底层细节，用JMM定义了一套读写内存数据的规范，虽然我们不再需要关心一级缓存和二级缓存的问题，但是，JMM抽象了主内存和本地内存的概念。</li>
<li>这里说的本地内存并不是真的一块给每个线程分配的内存，而是JMM的一个抽象，是对于寄存器、一级缓存、二级缓存等的抽象</li>
</ul>
<h4 id="主内存和本地内存的关系"><a href="#主内存和本地内存的关系" class="headerlink" title="主内存和本地内存的关系"></a>主内存和本地内存的关系</h4><ul>
<li>JMM有一些规定<ul>
<li>所有的变量都是存储再主内存中，同时每个线程也有自己独立的工作内存，工作内存中的变量内容是主内存中的拷贝</li>
<li>线程不能直接读写主内存中的变量，而是只能操作自己工作内存中的变量，然后同步到主内存中</li>
<li>主内存是多个线程共享的，但线程间不共享工作内存，如果线程间=需要通信，必须借助主内存中转来完成</li>
</ul>
</li>
<li>所有的共享变量存在于主内存中，每个线程有自己的本地内存，而且线程读写共享数据也是通过本地内存交换的，所以才导致了可见性问题</li>
</ul>
<h3 id="Happens-Before原则"><a href="#Happens-Before原则" class="headerlink" title="Happens-Before原则"></a>Happens-Before原则</h3><ul>
<li>单线程原则<ul>
<li>排在后面的语句一定能看到前面的语句的操作</li>
<li>不影响重排序，如果重排序了，那么排在后面的也是能看到前面的语句的操作的</li>
</ul>
</li>
<li>锁操作（synchronized和Lock）<ul>
<li>如果一个线程对某把锁进行了解锁，另一个线程对这把锁进行了加锁，那么后面的线程一定能看到前面线程解锁前的所有操作</li>
</ul>
</li>
<li>volatile变量<ul>
<li>如果变量被volatile变量修饰，只要写入了就一定能被其他线程获取到</li>
</ul>
</li>
<li>线程启动<ul>
<li>子线程在启动的时候，能看到之前主线程的所有操作</li>
</ul>
</li>
<li>线程join<ul>
<li>一旦针对某个线程进行了join，那么后面的语句一定能看到这个线程join之前的所有操作</li>
</ul>
</li>
<li>传递<ul>
<li>一份代码中有很多行，原则上第一行执行完第二行一定能看到第一行的操作，第三行也一定能看到第二行的操作，所以第三行也可以看到第一行的操作</li>
</ul>
</li>
<li>中断<ul>
<li>一个线程被其他线程中断(interrupt)时，那么检测中断(isInterrupted)或者抛出InterruptedException一定能看到</li>
</ul>
</li>
<li>构造方法<ul>
<li>finalize()方法一定能看到构造方法中的最后一行语句（不做重点）</li>
</ul>
</li>
<li>工具类的happens-Before原则<ul>
<li>线程安全的容器get一定能看到在此之前的put等存入动作</li>
<li>CountDownLath</li>
<li>Semaphore</li>
<li>Future</li>
<li>线程池</li>
<li>CyclicBarrier</li>
</ul>
</li>
</ul>
<blockquote>
<p>近朱者赤：给b加了volatile，不仅b被影响，也可以实现轻量级同步<br>b之前的写入操作（对应代码b = a）对读取b后面的代码（print b）都可见，所以在writerThread里面对a的赋值，一定会对readerThread里面的读取可见，所以这里面的a即使不加volatile，只要b读到3，就可以由happens-before原则保证读取到的都是3，而不可能读取到1<br>（因为a对b进行了赋值，所以该语句的上一句，也就是对a的赋值操作，也必须完成之后，并且可见a之后，才能对b进行赋值操作）</p>
</blockquote>
<h3 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h3><h4 id="volatile是什么？"><a href="#volatile是什么？" class="headerlink" title="volatile是什么？"></a>volatile是什么？</h4><ul>
<li>volatile是一种同步机制，比synchronized或者Lock相关类更轻量，因为使用volatile并不会发生上下文切换等开销很大的行为</li>
<li>如果一个变量被修饰成volatile，那么JVM就知道了这个变量可能会被并发修改</li>
<li>但是开销小，相应的能力也小，虽然说volatile是用来同步的保证线程安全的，但是volatile做不到synchronized那样的原子保护，volatile仅在很有限的场景下才能发挥作用</li>
</ul>
<h4 id="volatile的适用场景"><a href="#volatile的适用场景" class="headerlink" title="volatile的适用场景"></a>volatile的适用场景</h4><ul>
<li>不适用：a++</li>
<li>适用场景1：boolean flag，如果一个共享变量自始至终只被各个线程赋值，而没有其他操作，那么就可以用volatile来代替synchronized或者代替原子变量，因为赋值自身是有原子性的，而volatile又保证了可见性，所以就足以保证线程安全</li>
<li>适用场景2：作为刷新之前变量的触发器</li>
</ul>
<h4 id="volatile的两点作用"><a href="#volatile的两点作用" class="headerlink" title="volatile的两点作用"></a>volatile的两点作用</h4><ul>
<li>可见性：读一个volatile变量之前，需要先使相应的本地缓存失效，这样就必须到主内存读取最新值，写一个volatile属性会立即刷入到主内存</li>
<li>禁止指令重排序优化：解决单例双重锁乱序问题</li>
</ul>
<h4 id="volatile和synchronized的关系"><a href="#volatile和synchronized的关系" class="headerlink" title="volatile和synchronized的关系"></a>volatile和synchronized的关系</h4><ul>
<li>volatile在这方面可以看做是轻量版的synchronized：如果一个共享变量自始至终只被各个线程赋值，而没有其他的操作，那么就可以用volatile来代替synchronized或者代替原子变量，因为赋值操作自身是有原子性的，而volatile又保证了可见性，所以就足以保证线程安全</li>
</ul>
<h4 id="volatile小结"><a href="#volatile小结" class="headerlink" title="volatile小结"></a>volatile小结</h4><ul>
<li>volatile修饰符适用于一下场景：某个属性被多个线程共享，其中有一个线程修改了此属性，其他线程可以立即得到修改后的值，比如boolean flag，或者作为触发器，实现轻量级同步</li>
<li>volatile属性的读写操作都是无锁的，它不能替代synchronized因为它没有提供原子性和互斥性，因为无锁，不需要花费时间在获取锁和释放锁上，所以说它是低成本的</li>
<li>volatile只能作用于属性，我们用volatile修饰属性，这样compilers就不会对这个属性做指令重排序</li>
<li>volatile提供了可见性，任何一个线程对其的修改将立马对其他线程可见。volatile属性不会被线程缓存，始终从主内存中读取</li>
<li>volatile提供了happens-before保证，对volatile变量v的写入happens-before所有其他线程后续对v的读操作</li>
<li>volatile可以使得long和double的赋值是原子的，后面马上会讲long和double的原子性</li>
</ul>
<h3 id="能保证可见性的措施"><a href="#能保证可见性的措施" class="headerlink" title="能保证可见性的措施"></a>能保证可见性的措施</h3><ul>
<li>除了volatile可以保证可见性之外，synchronized、Lock、并发集合、Thread.join()和Thread.start()等都可以保证可见性</li>
<li>具体看happens-before原则的规定</li>
</ul>
<h3 id="升华：对synchronized可见性的正确理解"><a href="#升华：对synchronized可见性的正确理解" class="headerlink" title="升华：对synchronized可见性的正确理解"></a>升华：对synchronized可见性的正确理解</h3><ul>
<li>synchronized不仅保证了原子性，还保证了可见性</li>
<li>synchronized不仅让被保护的代码安全，还近朱者赤（synchronized加锁时可以看到所有加锁前的操作，所以另一个线程在加锁的时候，也可以看到这个线程加锁前的操作）</li>
</ul>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><h3 id="什么是原子性"><a href="#什么是原子性" class="headerlink" title="什么是原子性"></a>什么是原子性</h3><ul>
<li>一系列的操作，要么全部执行成功，要么全部不执行，不会出现执行一半的情况，整个操作是不可分割的（ATM即取钱）</li>
<li>i++不是原子性的（首先会先读取i的值，然后执行加1操作，然后写回去，这三步操作，两个线程完全是可能交替执行的）</li>
<li>用synchronized实现原子性</li>
</ul>
<h3 id="Java中的原子操作有那些？"><a href="#Java中的原子操作有那些？" class="headerlink" title="Java中的原子操作有那些？"></a>Java中的原子操作有那些？</h3><ul>
<li>除了long和double之外的基本类型（int,byte,boolean,short,char,float）的赋值操作</li>
<li>所有引用referebce的赋值操作，不管是32位机器还是64位的机器</li>
<li>java.concurrent.Atomic.* 包中所有类都是原子类</li>
</ul>
<h3 id="long和double的原子性"><a href="#long和double的原子性" class="headerlink" title="long和double的原子性"></a>long和double的原子性</h3><ul>
<li>问题描述：官方文档、对于64位值的写入，可以分为两个32位的操作进行写入，读取错误、使用volatile解决</li>
<li>结论：在32位的JVM上，long和double的操作不是原子性的，但是在64位的JVM上是原子性的</li>
<li>实际开发中：商用Java虚拟机中不会出现这种问题</li>
</ul>
<h3 id="原子操作-原子操作-！-原子操作"><a href="#原子操作-原子操作-！-原子操作" class="headerlink" title="原子操作 + 原子操作 ！= 原子操作"></a>原子操作 + 原子操作 ！= 原子操作</h3><ul>
<li>简单的把原子操作组合在一起，并不能保证整体依然具有原子性</li>
<li>比如去ATM取两次钱是独立的原子操作，但是期间可能把银行卡借给其他人，也就是被其他线程打断或修改。</li>
<li>全同步的HashMap也不完全安全（比如先从中取出一个值，进行判断然后修改，然后再put，这一系列操作并不是原子性的，所以可能会出现问题，类似i++）</li>
</ul>
<h2 id="常见面试问题"><a href="#常见面试问题" class="headerlink" title="常见面试问题"></a>常见面试问题</h2><ul>
<li><p>JMM应用实例：单例模式8中写法、单例和并发编程的关系</p>
<ul>
<li><p>单例模式的作用（为什么要使用单例模式）</p>
<blockquote>
<p>节省内存和计算（假如某一资源在获取后就不会经常变动，而获取的过程又很耗费cpu或内存，可以使用单例）<br>保证结果正确（有时候可能会做一些统计，为了速度，可以使用多线程进行统计，但是最终还是要有一个全局的单例计数器）<br>方便管理（比如一些工具类）</p>
</blockquote>
</li>
<li><p>单例模式适用场景</p>
<blockquote>
<p>无状态的工具类：比如日志工具类，不管是在哪里使用，我们需要的只是他帮我们记录日志信息，除此之外，并不需要在它的实例对象上存储任何状态，这时候我们就只需要一个实例对象即可<br>全局信息类：比如我们在一个类上记录网站的访问次数，我们不希望有的访问记录在对象A上，有的却在对象B上，这个时候我们就让这个类成为单例</p>
</blockquote>
</li>
</ul>
</li>
<li><p>讲一讲Java内存模型</p>
</li>
<li><p>volatile和synchronized的异同</p>
</li>
<li><p>什么是原子操作？Java中有那些原子操作？生产对象的过程是不是原子操作？</p>
</li>
<li><p>什么是内存可见性</p>
</li>
<li><p>64位的double和long写入的时候是原子的吗？</p>
</li>
</ul>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发核心知识体系精讲——死锁(三)</title>
    <url>/2021/11/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2%E2%80%94%E2%80%94%E6%AD%BB%E9%94%81/</url>
    <content><![CDATA[<h2>死锁——从生产到消除</h2>


<h2 id="死锁是什么？有什么危害？"><a href="#死锁是什么？有什么危害？" class="headerlink" title="死锁是什么？有什么危害？"></a>死锁是什么？有什么危害？</h2><h3 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h3><ul>
<li>发生在并发中</li>
<li>互不相让：当两个（或更多）线程（或进程）相互持有对方所需要的资源，又不主动释放，导致所有人都无法继续前进，导致程序陷入无尽阻塞，这就是死锁</li>
<li>多个线程造成死锁的情况<ul>
<li>如果多个线程之间的依赖关系是环形，存在环路的锁的依赖关系，那么也可能会发生死锁</li>
</ul>
</li>
</ul>
<h3 id="死锁的影响"><a href="#死锁的影响" class="headerlink" title="死锁的影响"></a>死锁的影响</h3><ul>
<li>死锁的影响不同系统中是不一样的，这取决于系统对死锁的处理能力<ul>
<li>数据库中：检测并放弃事务</li>
<li>JVM中：无法自动处理</li>
</ul>
</li>
</ul>
<h3 id="几率不高但危害大"><a href="#几率不高但危害大" class="headerlink" title="几率不高但危害大"></a>几率不高但危害大</h3><ul>
<li>不一定发生，但是遵守“墨菲定律”</li>
<li>一旦发生，多是高并发场景，影响用户多</li>
<li>整个系统崩溃、子系统崩溃、性能降低</li>
<li>压力测试无法找出所有潜在的死锁</li>
</ul>
<h2 id="发生死锁的例子"><a href="#发生死锁的例子" class="headerlink" title="发生死锁的例子"></a>发生死锁的例子</h2><h3 id="最简单的情况"><a href="#最简单的情况" class="headerlink" title="最简单的情况"></a>最简单的情况</h3><blockquote>
<p>代码如下所示<br>当类的对象flag=1时(T1)，先锁定o1，睡眠500毫秒，然后锁定o2<br>而T1在睡眠的时候，另一个flag=0的对象(T2)线程启动，先锁定o2，睡眠500毫秒，等待T1释放o1<br>T1睡眠结束后，需要锁定o2才能继续执行，而此时o2已经被T2锁定<br>T2睡眠结束后，需要锁定o1才能继续执行，而此时o1已经被T1锁定<br>T1、T2相互等待，都需要对方锁定的资源才能继续执行，从而死锁</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MustDeadLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> Object o2 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MustDeadLock r1 = <span class="keyword">new</span> MustDeadLock();</span><br><span class="line">        MustDeadLock r2 = <span class="keyword">new</span> MustDeadLock();</span><br><span class="line">        r1.flag = <span class="number">1</span>;</span><br><span class="line">        r2.flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">new</span> Thread(r1).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(r2).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o1)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (o2)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程1拿到了锁&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o2)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (o1)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程2拿到了锁&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实际生产中的例子：转账"><a href="#实际生产中的例子：转账" class="headerlink" title="实际生产中的例子：转账"></a>实际生产中的例子：转账</h3><ul>
<li>需要两把锁（A向B转钱，需要把A的账户锁定，也需要把B的账户锁定）</li>
<li>获取两把锁成功，且余额大于0，则扣除转出人，增加收款人的余额，是原子操作</li>
<li>顺序相反导致死锁（A向B转钱，B同时向A转钱）</li>
</ul>
<h2 id="死锁的4个必要条件"><a href="#死锁的4个必要条件" class="headerlink" title="死锁的4个必要条件"></a>死锁的4个必要条件</h2><ul>
<li>互斥条件（某一个资源只能同时被一个线程拥有）</li>
<li>请求与保持条件（请求另外一把锁，但是保持自身已有的锁）</li>
<li>不剥夺条件（不会剥夺其中的一个锁给另外一个）</li>
<li>循环等待条件（互相等待）</li>
</ul>
<h2 id="如何定位死锁？"><a href="#如何定位死锁？" class="headerlink" title="如何定位死锁？"></a>如何定位死锁？</h2><ul>
<li>jstack<ul>
<li>使用工具查看到运行的java项目的pid</li>
<li>执行jstack pid （查看线程信息）</li>
</ul>
</li>
<li>ThreadMXBean代码演示<ul>
<li>代码如下所示，在程序进入死锁后，运行如下代码，可以获取死锁的线程信息<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();</span><br><span class="line">long[] deadlockedThreads = threadMXBean.findDeadlockedThreads();</span><br><span class="line">if (deadlockedThreads != null &amp;&amp; deadlockedThreads.length &gt; 0)&#123;</span><br><span class="line">    for (int i = 0; i &lt; deadlockedThreads.length; i++) &#123;</span><br><span class="line">        ThreadInfo threadInfo = threadMXBean.getThreadInfo(deadlockedThreads[i]);</span><br><span class="line">        System.out.println(threadInfo.getThreadName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="修复死锁的策略"><a href="#修复死锁的策略" class="headerlink" title="修复死锁的策略"></a>修复死锁的策略</h2><h3 id="线上发生了死锁应该怎么办？"><a href="#线上发生了死锁应该怎么办？" class="headerlink" title="线上发生了死锁应该怎么办？"></a>线上发生了死锁应该怎么办？</h3><ul>
<li>线上问题都需要防范于未然，不造成损失的扑灭几乎已经是不可能</li>
<li>保存案发现场然后立刻重启服务器</li>
<li>暂时保证线上服务的安全，然后再利用刚才保存的信息，排查死锁，修改代码，重新发版</li>
</ul>
<h3 id="常见的修复策略"><a href="#常见的修复策略" class="headerlink" title="常见的修复策略"></a>常见的修复策略</h3><h4 id="避免测试"><a href="#避免测试" class="headerlink" title="避免测试"></a>避免测试</h4><ul>
<li>避免相反的获取锁的顺序</li>
<li>实际上不在乎获取锁的顺序<h5 id="转账换序方案"><a href="#转账换序方案" class="headerlink" title="转账换序方案"></a>转账换序方案</h5></li>
<li>将获取锁的顺序固定，不允许有的线程先拿到锁一，有的线程先拿到锁二</li>
<li>比如可以根据主键进行排序，无论是你给我转账还是我给你转账，那么获取多的时候都先获取主键值小的那把锁，再获取主键值大的<blockquote>
<p>代码如下所示<br>转账时，获取锁的顺序按照hashCode进行排序，如果hashCode相同，那么就同时尝试获取第三把锁</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferMoney1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Account a = <span class="keyword">new</span> Account(<span class="number">500</span>);</span><br><span class="line">    <span class="keyword">static</span> Account b = <span class="keyword">new</span> Account(<span class="number">500</span>);</span><br><span class="line">    <span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        TransferMoney1 r1 = <span class="keyword">new</span> TransferMoney1();</span><br><span class="line">        TransferMoney1 r2 = <span class="keyword">new</span> TransferMoney1();</span><br><span class="line">        r1.flag = <span class="number">1</span>;</span><br><span class="line">        r2.flag = <span class="number">0</span>;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(r1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(r2);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;a的余额：&quot;</span> + a.balance);</span><br><span class="line">        System.out.println(<span class="string">&quot;b的余额：&quot;</span> + b.balance);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">            transferMoney(a, b, <span class="number">200</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">            transferMoney(b, a, <span class="number">200</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">transferMoney</span><span class="params">(Account from, Account to, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Helper</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (from.balance - amount &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;余额不足，转账失败。&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                from.balance -= amount;</span><br><span class="line">                to.balance += amount;</span><br><span class="line">                System.out.println(<span class="string">&quot;成功转账&quot;</span> + amount + <span class="string">&quot;元&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> fromHash = System.identityHashCode(from);</span><br><span class="line">        <span class="keyword">int</span> toHash = System.identityHashCode(to);</span><br><span class="line">        <span class="keyword">if</span> (fromHash &lt; toHash) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (from) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (to) &#123;</span><br><span class="line">                    <span class="keyword">new</span> Helper().transfer();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (fromHash &gt; toHash)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (to) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (from) &#123;</span><br><span class="line">                    <span class="keyword">new</span> Helper().transfer();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (to) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (from) &#123;</span><br><span class="line">                        <span class="keyword">new</span> Helper().transfer();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> balance;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(<span class="keyword">int</span> balance)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.balance = balance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="哲学家就餐的换手方案"><a href="#哲学家就餐的换手方案" class="headerlink" title="哲学家就餐的换手方案"></a>哲学家就餐的换手方案</h5><p>问题描述：如下图，五个哲学家围着圆桌吃饭，但是只有五根筷子如下分布，每次开始吃饭，哲学家们就会先拿起左边的筷子，再拿起右边的筷子，然后吃饭，如果右边的筷子被人拿了就等着别人放下再获取</p>
<ul>
<li>假设每个人都拿起了左边的筷子，然后等待右边的，这样就会陷入无尽等待（死锁）<br><img src="/2021/11/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2%E2%80%94%E2%80%94%E6%AD%BB%E9%94%81/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98%E5%9B%BE%E7%A4%BA.png" alt="哲学家就餐问题图示"><blockquote>
<p>死锁代码如下所示：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiningPhilosophers</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Philosophers</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        Object leftChopstick = <span class="keyword">new</span> Object();</span><br><span class="line">        Object rightChopstick = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Philosophers</span><span class="params">(Object leftChopstick, Object rightChopstick)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.leftChopstick = leftChopstick;</span><br><span class="line">            <span class="keyword">this</span>.rightChopstick = rightChopstick;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    doAction(<span class="string">&quot;Thinking&quot;</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (leftChopstick) &#123;</span><br><span class="line">                        doAction(<span class="string">&quot;拿起左边筷子&quot;</span>);</span><br><span class="line">                        <span class="keyword">synchronized</span> (rightChopstick) &#123;</span><br><span class="line">                            doAction(<span class="string">&quot;拿起右边筷子&quot;</span>);</span><br><span class="line">                            doAction(<span class="string">&quot;放下右边筷子&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        doAction(<span class="string">&quot;放下左边筷子&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">(String action)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;  &quot;</span> + action);</span><br><span class="line">            Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">10</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Philosophers[] philosophers = <span class="keyword">new</span> Philosophers[<span class="number">5</span>];</span><br><span class="line">        Object[] chopsticks = <span class="keyword">new</span> Object[philosophers.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chopsticks.length; i++) &#123;</span><br><span class="line">            chopsticks[i] = <span class="keyword">new</span> Object();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; philosophers.length; i++) &#123;</span><br><span class="line">            Object leftChopstick = chopsticks[i];</span><br><span class="line">            Object rightChopstick = chopsticks[(i + <span class="number">1</span>) % chopsticks.length];</span><br><span class="line">            philosophers[i] = <span class="keyword">new</span> Philosophers(leftChopstick, rightChopstick);</span><br><span class="line">            <span class="keyword">new</span> Thread(philosophers[i], <span class="string">&quot;哲学家&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot;号&quot;</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="多种解决方案"><a href="#多种解决方案" class="headerlink" title="多种解决方案"></a>多种解决方案</h6></li>
<li>服务员检测（避免策略）<blockquote>
<p>每次拿筷子找服务员拿，由服务员去协调</p>
</blockquote>
</li>
<li>改变一个哲学家拿筷子的顺序（避免策略）<blockquote>
<p>其中一个哲学家先拿起右边的筷子，再拿左边的<br>代码更改如下</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (int i = 0; i &lt; philosophers.length; i++) &#123;</span><br><span class="line">    Object leftChopstick = chopsticks[i];</span><br><span class="line">    Object rightChopstick = chopsticks[(i + 1) % chopsticks.length];</span><br><span class="line">    if (i == philosophers.length-1)</span><br><span class="line">        philosophers[i] = new Philosophers(rightChopstick,leftChopstick);</span><br><span class="line">    else</span><br><span class="line">        philosophers[i] = new Philosophers(leftChopstick, rightChopstick);</span><br><span class="line">    new Thread(philosophers[i], &quot;哲学家&quot; + (i + 1) + &quot;号&quot;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>餐票（避免策略）<blockquote>
<p>想要吃饭需要先拿到餐票，餐票只有四张</p>
</blockquote>
</li>
<li>领导调节（检测与恢复策略）<blockquote>
<p>发现死锁之后，使其中一个哲学家放下筷子</p>
</blockquote>
</li>
</ul>
<h4 id="检测与恢复策略"><a href="#检测与恢复策略" class="headerlink" title="检测与恢复策略"></a>检测与恢复策略</h4><p>一段时间检测是否有死锁，如果有就剥夺某一个资源，来打开死锁</p>
<ul>
<li>检测算法：锁的调用链路图<ul>
<li>允许发生死锁</li>
<li>每次调用锁都记录</li>
<li>定期检测“锁的调用链路图”中是否存在环路</li>
</ul>
</li>
<li>恢复方法1：进程终止<ul>
<li>逐个终止线程，直到死锁消除</li>
<li>终止顺序<ul>
<li>优先级（是前台交互还是后台处理）</li>
<li>已占用资源、还需要的资源（还需要一点资源就可以完成）</li>
<li>已经运行时间</li>
</ul>
</li>
</ul>
</li>
<li>恢复方法2：资源抢占<ul>
<li>把已经分发出去的锁给收回来</li>
<li>让线程回退几步，这样就不用结束整个线程，成本比较低</li>
<li>缺点：可能同一个线程一直被抢占，那就会造成饥饿</li>
</ul>
</li>
</ul>
<h4 id="鸵鸟策略"><a href="#鸵鸟策略" class="headerlink" title="鸵鸟策略"></a>鸵鸟策略</h4><ul>
<li>鸵鸟这种动物在遇到危险的时间，通常就会把头埋在地上，这样一来它就看不到危险了。而鸵鸟策略的意思就是说，如果我们发生了死锁的概率极其低，那么我们就直接忽略它，直到死锁发生的时候，再人工修复</li>
</ul>
<h3 id="实际工程中如何避免死锁"><a href="#实际工程中如何避免死锁" class="headerlink" title="实际工程中如何避免死锁"></a>实际工程中如何避免死锁</h3><ul>
<li>设置超时时间<ul>
<li>Lock的tryLock(long timeout,TimeUnit unit)</li>
<li>synchronized不具备尝试锁的能力</li>
<li>造成超时的可能性很多：发生了死锁、线程陷入了死循环、线程执行很慢</li>
<li>超时时间到了就认为获取锁失败<br>具体代码演示如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TryLockDeadlock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Lock lock1 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">static</span> Lock lock2 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TryLockDeadlock r1 = <span class="keyword">new</span> TryLockDeadlock();</span><br><span class="line">        TryLockDeadlock r2 = <span class="keyword">new</span> TryLockDeadlock();</span><br><span class="line">        r1.flag = <span class="number">1</span>;</span><br><span class="line">        r2.flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">new</span> Thread(r1).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(r2).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (lock1.tryLock(<span class="number">800</span>, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                        Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">                        <span class="keyword">if</span> (lock2.tryLock(<span class="number">800</span>, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;线程1已经成功获取了两把锁&quot;</span>);</span><br><span class="line">                            lock2.unlock();</span><br><span class="line">                            lock1.unlock();</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;线程1获取锁2失败，已重试&quot;</span>);</span><br><span class="line">                            lock1.unlock();</span><br><span class="line">                            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程1获取第一把所失败，已重实&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (lock2.tryLock(<span class="number">3000</span>, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                        Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">                        <span class="keyword">if</span> (lock1.tryLock(<span class="number">3000</span>, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;线程2已经成功获取了两把锁&quot;</span>);</span><br><span class="line">                            lock1.unlock();</span><br><span class="line">                            lock2.unlock();</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;线程2获取锁1失败，已重试&quot;</span>);</span><br><span class="line">                            lock2.unlock();</span><br><span class="line">                            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程1获取第2把所失败，已重实&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>多使用并发类而不是自己设计锁<ul>
<li><code>ConcurrentHashMap</code>、<code>ConcurrentLinkedQueue</code>、<code>AtomicBoolean</code>等</li>
<li>实际应用中<code>java.util.concurrent.atomic</code>十分有用，简单方便且效率比使用Lock更高</li>
<li>多用并发集合少使用同步集合，并发集合比同步集合的可扩展性更好</li>
<li>并发场景需要用到map，首先想到使用<code>ConcurrentHashMap</code></li>
</ul>
</li>
<li>尽量降低锁的使用粒度：用不同的锁而不是一个锁</li>
<li>如果能使用同步代码块，就不使用同步方法：自己指定锁对象</li>
<li>给你的线程起一个有意义的名字：debug和排查时事半功倍，框架和JDK都遵守这个最佳实践</li>
<li>避免锁的嵌套：锁嵌套非常容易造成死锁</li>
<li>分配资源前先看能不能收回来：银行家算法</li>
<li>尽量不要几个功能使用同一把锁：专锁专用</li>
</ul>
<h2 id="其他活性故障"><a href="#其他活性故障" class="headerlink" title="其他活性故障"></a>其他活性故障</h2><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul>
<li>死锁是最常见的活跃性问题，不过除了刚才的死锁之外，还有一些类似的问题，会导致程序无法顺序执行，统称为活跃性问题</li>
</ul>
<h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><p>比如哲学家就餐问题：在完全相同的时刻进入餐厅，并同时拿起左手边的筷子，拿不到右手边的筷子，那么这些哲学家就会等待五分钟，<br>同时放下手中的筷子，然后再等待五分钟，又同时拿起这些筷子（相同的时间拿起，相同的时间放下，等待相同的时间那么同样无法完成就餐）</p>
<h4 id="什么是活锁"><a href="#什么是活锁" class="headerlink" title="什么是活锁"></a>什么是活锁</h4><ul>
<li>虽然线程并没有阻塞，也始终再运行（所以叫做“活”锁，线程是“活”的），但是程序却得不到进展，因为线程始终重复做同样的事</li>
<li>如果这里是死锁，那么就是这里两个人始终一动不动，直到对方先抬头，他们之间不再说话，只是等待</li>
<li>如果发生活锁，那么这里的情况就是双方都不停的对对方说”你先起来吧，你先起来吧”，双方都一直再说话，在运行</li>
<li>活锁和死锁的结果是一样的，就是谁都不能先抬头<blockquote>
<p>假设有一对夫妻，只有一套餐具<br>吃饭的时候会去检查对方是不是处于饥饿状态，如果对方处于饥饿状态，就会把餐具让给对方<br>程序将处于一直谦让的状态无法完成</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LiveLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Spoon</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Diner diner;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%s has eaten!&quot;</span>, diner.name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Spoon</span><span class="params">(Diner diner)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.diner = diner;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Diner <span class="title">getDiner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> diner;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDiner</span><span class="params">(Diner diner)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.diner = diner;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Diner</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> idHungry = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Diner</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eatWith</span><span class="params">(Spoon spoon, Diner spouse)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (idHungry) &#123;</span><br><span class="line">                <span class="keyword">if</span> (spoon.diner != <span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (spouse.idHungry) &#123;</span><br><span class="line">                    System.out.println(name + <span class="string">&quot;亲爱的&quot;</span> + spouse.name + <span class="string">&quot;你先吃吧&quot;</span>);</span><br><span class="line">                    spoon.setDiner(spouse);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                spoon.use();</span><br><span class="line">                idHungry = <span class="keyword">false</span>;</span><br><span class="line">                System.out.println(name + <span class="string">&quot; 我已经吃完了&quot;</span>);</span><br><span class="line">                spoon.setDiner(spouse);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Diner husband = <span class="keyword">new</span> Diner(<span class="string">&quot;牛郎&quot;</span>);</span><br><span class="line">        Diner wife = <span class="keyword">new</span> Diner(<span class="string">&quot;织女&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Spoon spoon = <span class="keyword">new</span> Spoon(husband);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                husband.eatWith(spoon, wife);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                wife.eatWith(spoon, husband);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="如何解决活锁问题"><a href="#如何解决活锁问题" class="headerlink" title="如何解决活锁问题"></a>如何解决活锁问题</h4></li>
<li>原因：重试机制不变，消息队列始终重试，吃饭始终谦让</li>
<li>以太网的指数避退算法</li>
<li>加入随机因素(在进行谦让的时候加入随机因素，比如随机数，某一种情况下不进行谦让)</li>
</ul>
<h4 id="工程中的活锁实例：消息队列"><a href="#工程中的活锁实例：消息队列" class="headerlink" title="工程中的活锁实例：消息队列"></a>工程中的活锁实例：消息队列</h4><ul>
<li>策略：消息如果处理失败，就放在队列开头重试</li>
<li>由于依赖服务出了问题，处理该消息一直失败（由于依赖服务出现异常，把失败的消息放在队列头部，一直进行重试，一直都不会成功）</li>
<li>没有阻塞，但是程序无法继续</li>
<li>解决：放到队列尾部、重试次数限制</li>
</ul>
<h3 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h3><ul>
<li>当线程需要某些资源（列如CPU），但是始终得不到</li>
<li>线程的优先级设置的过于低，或者有某线程持有锁同时又无限循环从而不释放锁，或者某些程序始终占用某些文件的写锁</li>
<li>饥饿可能会导致相应性差：比如，我们的浏览器有一个线程负责下载图片和文件、计算渲染等，在这种情况下，如果后台线程把CPU资源都占用，那么前台线程将无法得到很好的执行，这会导致用户的体验很差</li>
</ul>
<h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><ul>
<li><p>写一个必然死锁大的例子（上面已经写过了），生产中什么场景下会发生死锁？</p>
<blockquote>
<p>需要获取两把锁的时候，都有可能发生死锁</p>
</blockquote>
</li>
<li><p>发生死锁必须满足那些条件</p>
<blockquote>
<p>互斥条件<br>请求保持条件<br>不剥夺条件<br>循环等待条件</p>
</blockquote>
</li>
<li><p>如何定位死锁？</p>
<blockquote>
<p>jstack<br>ThreadMXBean</p>
</blockquote>
</li>
<li><p>有那些解决死锁问题的策略？</p>
<blockquote>
<p>避免策略<br>检查与恢复策略<br>鸵鸟策略</p>
</blockquote>
</li>
<li><p>讲一讲哲学家就餐问题</p>
<blockquote>
<p>上面已经有描述</p>
</blockquote>
</li>
<li><p>实际工程中如何避免死锁？</p>
<blockquote>
<p>设置超时时间<br>多使用并发类而不是自己设计锁<br>尽量降低锁的使用粒度：用不同的锁而不是一个锁<br>如果能使用同步代码块，就不适用同步方法：自己指定锁对象<br>给线程起一个有意义的名称<br>避免锁嵌套<br>分配资源前先看能不能收回来<br>尽量不要几个功能使用同一把锁：专锁专用</p>
</blockquote>
</li>
<li><p>什么是活跃性问题？活锁、饥饿和死锁有什么区别？</p>
</li>
</ul>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven项目依赖管理</title>
    <url>/2021/06/12/Maven%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>Maven:</strong> 一个用于自动化构建项目和管理项目依赖的工具<br><strong>自动化构建项目：</strong> 按照企业中主流的项目模板，创建完善的项目结构<br><strong>管理项目依赖：</strong> 配置式添加管理，自动下载和导入</p>
<h2 id="Maven环境配置"><a href="#Maven环境配置" class="headerlink" title="Maven环境配置"></a>Maven环境配置</h2><h3 id="Maven下载"><a href="#Maven下载" class="headerlink" title="Maven下载"></a>Maven下载</h3><p>Maven官网地址：<a href="http://maven.apache.org/">http://maven.apache.org</a></p>
<p><img src="/2021/06/12/Maven%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/Maven%E5%AE%98%E7%BD%91%E5%9B%BE%E7%A4%BA.png" alt="Maven官网图示"><br>点击<code>Download</code>跳转Maven下载界面</p>
<p><img src="/2021/06/12/Maven%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/Maven%E4%B8%8B%E8%BD%BD%E5%9B%BE%E7%A4%BA.png" alt="Maven下载图示"></p>
<h3 id="Maven环境变量配置"><a href="#Maven环境变量配置" class="headerlink" title="Maven环境变量配置"></a>Maven环境变量配置</h3><p>下载最新版zip即可，将下载后的zip包解压到本地任意文件夹下<br>然后打开maven解压后生成的文件夹，进入到bin目录下，复制路径地址</p>
<p><img src="/2021/06/12/Maven%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/Maven%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E5%9B%BE%E7%A4%BA.png" alt="Maven环境变量配置图示"><br>如图所示，复制路径之后，右键我的电脑，点击属性 -&gt; 高级系统设置 -&gt; 环境变量 -&gt; Path -&gt; 新建<br>将复制的Maven路径黏贴到对应位置，点击确定关闭所有对话框</p>
<p>win+R快捷键，输入<code>cmd</code>打开Windows10命令行，输入：<code>mvn -version</code><br>注：一定要在保存环境变量后新打开的命令窗口输入，否则不生效；<br><img src="/2021/06/12/Maven%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/Maven%E7%89%88%E6%9C%AC%E6%9F%A5%E7%9C%8B%E5%9B%BE%E7%A4%BA.png" alt="Maven版本查看图示"></p>
<h3 id="Maven本地仓库配置"><a href="#Maven本地仓库配置" class="headerlink" title="Maven本地仓库配置"></a>Maven本地仓库配置</h3><p>Maven下载jar包默认是下载到C盘用户目录下的.m2文件夹下的，会大量占用C盘空间<br>打开Maven文件夹下的<code>conf</code>文件夹，找到<code>settings.xml</code>文件，将其打开，在settings标签内增加<code>localRepository</code>标签，指定jar包下载位置（本地仓库位置）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- localRepository</span></span><br><span class="line"><span class="comment">   | The path to the local repository maven will use to store artifacts.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   | Default: $&#123;user.home&#125;/.m2/repository</span></span><br><span class="line"><span class="comment">  &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>D:\repository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Maven配置远程阿里云仓库"><a href="#Maven配置远程阿里云仓库" class="headerlink" title="Maven配置远程阿里云仓库"></a>Maven配置远程阿里云仓库</h3><p>Maven默认远程仓库是在国外的，由于网络原因，有时会导致下载jar包特别慢或者下载失败或者下载残缺，从而引起一些奇奇怪怪的问题，可以通过配置更改远程仓库位置，指向国内阿里云仓库<br>在Maven文件夹下的<code>conf</code>文件下的<code>settings.xml</code>文件中<code>mirrors</code>标签中做如下配置即可</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Maven依赖添加"><a href="#Maven依赖添加" class="headerlink" title="Maven依赖添加"></a>Maven依赖添加</h3><p>使用工具创建Maven项目后，会在目录下有一个pom.xml文件，只需要在文件中的<code>dependencies</code>标签中增加对应的依赖引入，maven即可完成对应的关联<br>Maven依赖查询网址：<a href="https://mvnrepository.com/">https://mvnrepository.com</a></p>
<h2 id="Maven基础知识讲解"><a href="#Maven基础知识讲解" class="headerlink" title="Maven基础知识讲解"></a>Maven基础知识讲解</h2><h3 id="Maven仓库"><a href="#Maven仓库" class="headerlink" title="Maven仓库"></a>Maven仓库</h3><ol>
<li>远程仓库/中央仓库<blockquote>
<p>maven默认远程仓库是在国外（<a href="http://repo1.maven.org/maven2/%EF%BC%89%EF%BC%8C%E7%94%B1%E4%BA%8E%E4%BC%97%E6%89%80%E5%91%A8%E7%9F%A5%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%8C%E4%B8%80%E8%88%AC%E9%83%BD%E4%BC%9A%E5%B0%86%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E9%85%8D%E7%BD%AE%E4%B8%BA%E5%9B%BD%E5%86%85%E6%BA%90%EF%BC%8C%E5%85%B7%E4%BD%93%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F%E5%A6%82%E4%B8%8A%E6%89%80%E7%A4%BA%E3%80%82">http://repo1.maven.org/maven2/），由于众所周知的原因，一般都会将远程仓库配置为国内源，具体配置方式如上所示。</a></p>
</blockquote>
</li>
<li>本地仓库<blockquote>
<p>maven默认的本地仓库配置为：${user.home}/.m2/repository；Windows电脑默认就是在C盘用户目录中<code>.m2</code>文件夹下，如果C盘空间不是特别大的话，可以添加如下配置将本地仓库修改到其他盘：</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>D:\repository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>私有服务器<blockquote>
<p>maven一般使用<code>nexus</code>用来做私服，具体搭建方式自行百度；搭建好后将私服作为远程仓库配置即可连接。</p>
</blockquote>
</li>
</ol>
<h3 id="Maven常用命令"><a href="#Maven常用命令" class="headerlink" title="Maven常用命令"></a>Maven常用命令</h3><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">mvn archetype:create -DarchetypeArtifactId=maven-archetype-quickstart -DgroupId=com.ryanote -Dartifact=common</td>
<td align="center">maven新建项目命令，指定相关设置信息</td>
</tr>
<tr>
<td align="center">mvn archetype:generate</td>
<td align="center">maven创建项目命令，之后根据提示设置相关项目信息</td>
</tr>
<tr>
<td align="center">mvn compile</td>
<td align="center">编译源代码</td>
</tr>
<tr>
<td align="center">mvn test-compile</td>
<td align="center">编译测试代码</td>
</tr>
<tr>
<td align="center">mvn test</td>
<td align="center">运行测试</td>
</tr>
<tr>
<td align="center">mvn site</td>
<td align="center">生产site</td>
</tr>
<tr>
<td align="center">mvn package</td>
<td align="center">打包</td>
</tr>
<tr>
<td align="center">mvn install</td>
<td align="center">将jar/war包安装到本地仓库</td>
</tr>
<tr>
<td align="center">mvn install -DMaven.test,skip=true</td>
<td align="center">执行mvn install命令，跳过测试</td>
</tr>
<tr>
<td align="center">mvn install:install-file</td>
<td align="center">安装jar包文件到本地仓库</td>
</tr>
<tr>
<td align="center">mvn clean</td>
<td align="center">清除生产的项目</td>
</tr>
<tr>
<td align="center">mvn eclipse:eclipse</td>
<td align="center">生产eclipse项目</td>
</tr>
<tr>
<td align="center">mvn idea:idea</td>
<td align="center">生产idea项目</td>
</tr>
<tr>
<td align="center">mvn deploy</td>
<td align="center">上传私服</td>
</tr>
<tr>
<td align="center">mvn deploy:deploy-file</td>
<td align="center">上传jar文件到私服</td>
</tr>
<tr>
<td align="center">mvn versions:set -DnewVersion=xx.xx</td>
<td align="center">maven更改版本号</td>
</tr>
<tr>
<td align="center">mvn versions:commit</td>
<td align="center">maven提交版本号更改</td>
</tr>
<tr>
<td align="center">mvn versions:revert</td>
<td align="center">maven回滚版本号更改</td>
</tr>
</tbody></table>
<h3 id="Maven生命周期"><a href="#Maven生命周期" class="headerlink" title="Maven生命周期"></a>Maven生命周期</h3><blockquote>
<p>maven拥有三套独立的生命周期，他们分别是clean、default和site。<br>clean生命周期的目的是清理项目；<br>default生命周期的目的是构建项目；<br>site生周期的目的是建立项目站点。  </p>
</blockquote>
<h4 id="clean生命周期"><a href="#clean生命周期" class="headerlink" title="clean生命周期"></a>clean生命周期</h4><p>clean生周期的目的是清理项目，它包括以下三个阶段。  </p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">pre-clean</td>
<td align="center">执行清理前需要完成的工作</td>
</tr>
<tr>
<td align="center">clean</td>
<td align="center">清理上一次构建过程中生产的文件，如编译后的class文件</td>
</tr>
<tr>
<td align="center">post-clean</td>
<td align="center">执行清理后需要完成的工作</td>
</tr>
</tbody></table>
<p>执行maven命令<code>mvn clean</code>其实就是运行clean阶段，需要注意的是<code>maven在一个生命周期运行某个阶段的时候，他之前的所有阶段都会被运行</code>，<br>也就是说执行<code>mvn clean</code>就是执行<code>mvn pre-clean clean</code>，如果执行<code>mvn post-clean</code>那么<code>pre-clean</code>和<code>clean</code>也会被运行。</p>
<h4 id="default生命周期"><a href="#default生命周期" class="headerlink" title="default生命周期"></a>default生命周期</h4><p>default生命周期定义了构建项目时所需要执行步骤，它是所有生命周期中最核心部分，包含的阶段如下：</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">validate</td>
<td align="center">验证项目结构是否正常，必要的配置文件是否存在</td>
</tr>
<tr>
<td align="center">initialize</td>
<td align="center">做构建前的初始化操作，比如初始化参数、创建必要目录等</td>
</tr>
<tr>
<td align="center">generate-sources</td>
<td align="center">产生在编译过程中需要的员代码</td>
</tr>
<tr>
<td align="center">process-sources</td>
<td align="center">处理源代码，比如过滤值</td>
</tr>
<tr>
<td align="center">generate-resources</td>
<td align="center">生产主代码中的资源在classpath中的包</td>
</tr>
<tr>
<td align="center">process-resources</td>
<td align="center">将资源文件复制到classpath的对应包中</td>
</tr>
<tr>
<td align="center">compile</td>
<td align="center">编译项目中的源代码</td>
</tr>
<tr>
<td align="center">process-classes</td>
<td align="center">生产编译过程中生成的文件</td>
</tr>
<tr>
<td align="center">generate-test-sources</td>
<td align="center">生产编译过程中测试相关的代码</td>
</tr>
<tr>
<td align="center">process-test-sources</td>
<td align="center">处理测试代码</td>
</tr>
<tr>
<td align="center">generate-test-resources</td>
<td align="center">生产测试中资源在classpath中的包</td>
</tr>
<tr>
<td align="center">process-test-resources</td>
<td align="center">将测试资源复制到classpath中</td>
</tr>
<tr>
<td align="center">test-compile</td>
<td align="center">编译测试代码</td>
</tr>
<tr>
<td align="center">process-test-classes</td>
<td align="center">生产编译测试代码过程的文件</td>
</tr>
<tr>
<td align="center">test</td>
<td align="center">运行测试案例</td>
</tr>
<tr>
<td align="center">prepare-package</td>
<td align="center">处理打包前需要初始化的准备工作</td>
</tr>
<tr>
<td align="center">package</td>
<td align="center">将编译后的class和资源打包成压缩包，如jar</td>
</tr>
<tr>
<td align="center">pre-integration-test</td>
<td align="center">做好集成测试前的准备工作，比如集成环境的参数设置</td>
</tr>
<tr>
<td align="center">integration-test</td>
<td align="center">集成测试</td>
</tr>
<tr>
<td align="center">post-integration-test</td>
<td align="center">完成集成测试后的收尾工作，比如清理集成环境的值</td>
</tr>
<tr>
<td align="center">verify</td>
<td align="center">检测测试后的包是否完好</td>
</tr>
<tr>
<td align="center">install</td>
<td align="center">将打包的组件以构件的形式，安装到本地依赖仓库中，以便共享给本地的其他项目</td>
</tr>
<tr>
<td align="center">deploy</td>
<td align="center">运行集成的发布环境，将测试后的最终包以构件的方式发布到远程仓库中，方便所有程序员共享</td>
</tr>
</tbody></table>
<p>最常用的阶段一般为：validate、compile、test、package、verify、install、site、deploy。</p>
<p>详细介绍可以查看：<a href="http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html">http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html</a></p>
<h3 id="Maven-POM-标签大全详解"><a href="#Maven-POM-标签大全详解" class="headerlink" title="Maven POM 标签大全详解"></a>Maven POM 标签大全详解</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0http://maven.apache.org/maven-v4_0_0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--父项目的坐标。如果项目中没有规定某个元素的值，那么父项目中的对应值即为项目的默认值。 坐标包括group ID，artifact ID和 </span></span><br><span class="line"><span class="comment">        version。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--被继承的父项目的构件标识符 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--被继承的父项目的全球唯一标识符 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--被继承的父项目的版本 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 父项目的pom.xml文件的相对路径。相对路径允许你选择一个不同的路径。默认值是../pom.xml。Maven首先在构建当前项目的地方寻找父项 </span></span><br><span class="line"><span class="comment">            目的pom，其次在文件系统的这个位置（relativePath位置），然后在本地仓库，最后在远程仓库寻找父项目的pom。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--声明项目描述符遵循哪一个POM模型版本。模型本身的版本很少改变，虽然如此，但它仍然是必不可少的，这是为了当Maven引入了新的特性或者其他模型变更的时候，确保稳定性。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目的全球唯一标识符，通常使用全限定的包名区分该项目和其他项目。并且构建时生成的路径也是由此生成， 如com.mycompany.app生成的相对路径为：/com/mycompany/app --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>asia.banseon<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 构件的标识符，它和group ID一起唯一标识一个构件。换句话说，你不能有两个不同的项目拥有同样的artifact ID和groupID；在某个 </span></span><br><span class="line"><span class="comment">        特定的group ID下，artifact ID也必须是唯一的。构件是项目产生的或使用的一个东西，Maven为项目产生的构件包括：JARs，源 码，二进制发布和WARs等。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>banseon-maven2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目产生的构件类型，例如jar、war、ear、pom。插件可以创建他们自己的构件类型，所以前面列的不是全部构件类型 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目当前版本，格式为:主版本.次版本.增量版本-限定版本号 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目的名称, Maven产生的文档用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>banseon-maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目主页的URL, Maven产生的文档用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.baidu.com/banseon<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 项目的详细描述, Maven 产生的文档用。 当这个元素能够用HTML格式描述时（例如，CDATA中的文本会被解析器忽略，就可以包含HTML标 </span></span><br><span class="line"><span class="comment">        签）， 不鼓励使用纯文本描述。如果你需要修改产生的web站点的索引页面，你应该修改你自己的索引页文件，而不是调整这里的文档。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>A maven project to study maven.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--描述了这个项目构建环境中的前提条件。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">prerequisites</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--构建该项目或使用该插件所需要的Maven的最低版本 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">prerequisites</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目的问题管理系统(Bugzilla, Jira, Scarab,或任何你喜欢的问题管理系统)的名称和URL，本例为 jira --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">issueManagement</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--问题管理系统（例如jira）的名字， --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">system</span>&gt;</span>jira<span class="tag">&lt;/<span class="name">system</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--该项目使用的问题管理系统的URL --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://jira.baidu.com/banseon<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">issueManagement</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目持续集成信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ciManagement</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--持续集成系统的名字，例如continuum --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">system</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--该项目使用的持续集成系统的URL（如果持续集成系统有web接口的话）。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--构建完成时，需要通知的开发者/用户的配置项。包括被通知者信息和通知条件（错误，失败，成功，警告） --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">notifiers</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--配置一种方式，当构建中断时，以该方式通知用户/开发者 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">notifier</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--传送通知的途径 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--发生错误时是否通知 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sendOnError</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--构建失败时是否通知 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sendOnFailure</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--构建成功时是否通知 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sendOnSuccess</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--发生警告时是否通知 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sendOnWarning</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--不赞成使用。通知发送到哪里 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">address</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--扩展配置项 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">notifier</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">notifiers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ciManagement</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目创建年份，4位数字。当产生版权信息时需要使用这个值。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">inceptionYear</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目相关邮件列表信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mailingLists</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--该元素描述了项目相关的所有邮件列表。自动产生的网站引用这些信息。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mailingList</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--邮件的名称 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--发送邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">post</span>&gt;</span>banseon@126.com<span class="tag">&lt;/<span class="name">post</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">subscribe</span>&gt;</span>banseon@126.com<span class="tag">&lt;/<span class="name">subscribe</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--取消订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">unsubscribe</span>&gt;</span>banseon@126.com<span class="tag">&lt;/<span class="name">unsubscribe</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--你可以浏览邮件信息的URL --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">archive</span>&gt;</span>http:/hi.baidu.com/banseon/demo/dev/<span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mailingList</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mailingLists</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目开发者列表 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">developers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--某个项目开发者的信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">developer</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--SCM里项目开发者的唯一标识符 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>HELLO WORLD<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目开发者的全名 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>banseon<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目开发者的email --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">email</span>&gt;</span>banseon@126.com<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目开发者的主页的URL --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目开发者在项目中扮演的角色，角色元素描述了各种角色 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">roles</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">role</span>&gt;</span>Project Manager<span class="tag">&lt;/<span class="name">role</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">role</span>&gt;</span>Architect<span class="tag">&lt;/<span class="name">role</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">roles</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目开发者所属组织 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">organization</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">organization</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目开发者所属组织的URL --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">organizationUrl</span>&gt;</span>http://hi.baidu.com/banseon<span class="tag">&lt;/<span class="name">organizationUrl</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目开发者属性，如即时消息如何处理等 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dept</span>&gt;</span>No<span class="tag">&lt;/<span class="name">dept</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目开发者所在时区， -11到12范围内的整数。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">timezone</span>&gt;</span>-5<span class="tag">&lt;/<span class="name">timezone</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">developer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">developers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目的其他贡献者列表 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contributors</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--项目的其他贡献者。参见developers/developer元素 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">contributor</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">email</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">organization</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">organizationUrl</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">roles</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">timezone</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">properties</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">contributor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">contributors</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--该元素描述了项目所有License列表。 应该只列出该项目的license列表，不要列出依赖项目的 license列表。如果列出多个license，用户可以选择它们中的一个而不是接受所有license。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">licenses</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--描述了项目的license，用于生成项目的web站点的license页面，其他一些报表和validation也会用到该元素。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">license</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--license用于法律上的名称 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Apache 2<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--官方的license正文页面的URL --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.baidu.com/banseon/LICENSE-2.0.txt<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目分发的主要方式： repo，可以从Maven库下载 manual， 用户必须手动下载和安装依赖 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">distribution</span>&gt;</span>repo<span class="tag">&lt;/<span class="name">distribution</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--关于license的补充信息 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">comments</span>&gt;</span>A business-friendly OSS license<span class="tag">&lt;/<span class="name">comments</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">license</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">licenses</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--SCM(Source Control Management)标签允许你配置你的代码库，供Maven web站点和其它插件使用。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scm</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--SCM的URL,该URL描述了版本库和如何连接到版本库。欲知详情，请看SCMs提供的URL格式和列表。该连接只读。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">connection</span>&gt;</span></span><br><span class="line">            scm:svn:http://svn.baidu.com/banseon/maven/banseon/banseon-maven2-trunk(dao-trunk)</span><br><span class="line">        <span class="tag">&lt;/<span class="name">connection</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--给开发者使用的，类似connection元素。即该连接不仅仅只读 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">developerConnection</span>&gt;</span></span><br><span class="line">            scm:svn:http://svn.baidu.com/banseon/maven/banseon/dao-trunk</span><br><span class="line">        <span class="tag">&lt;/<span class="name">developerConnection</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--当前代码的标签，在开发阶段默认为HEAD --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tag</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指向项目的可浏览SCM库（例如ViewVC或者Fisheye）的URL。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://svn.baidu.com/banseon<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">scm</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--描述项目所属组织的各种属性。Maven产生的文档用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">organization</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--组织的全名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--组织主页的URL --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.baidu.com/banseon<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">organization</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--构建项目需要的信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--该元素设置了项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sourceDirectory</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--该元素设置了项目脚本源码目录，该目录和源码目录不同：绝大多数情况下，该目录下的内容 会被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scriptSourceDirectory</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--该元素设置了项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">testSourceDirectory</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--被编译过的应用程序class文件存放的目录。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">outputDirectory</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--被编译过的测试class文件存放的目录。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">testOutputDirectory</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--使用来自该项目的一系列构建扩展 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">extensions</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--描述使用到的构建扩展。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">extension</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--构建扩展的groupId --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--构建扩展的artifactId --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--构建扩展的版本 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">extension</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--当项目没有规定目标（Maven2 叫做阶段）时的默认值 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">defaultGoal</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--这个元素描述了项目相关的所有资源路径列表，例如和项目相关的属性文件，这些资源被包含在最终的打包文件里。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--这个元素描述了项目相关或测试相关的所有资源路径 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 描述了资源的目标路径。该路径相对target/classes目录（例如$&#123;project.build.outputDirectory&#125;）。举个例 </span></span><br><span class="line"><span class="comment">                    子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven /messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">targetPath</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素里列出。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--描述存放资源的目录，该路径相对POM路径 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--包含的模式列表，例如**/*.xml. --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--排除的模式列表，例如**/*.xml --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">excludes</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--这个元素描述了单元测试相关的所有资源路径，例如和单元测试相关的属性文件。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">testResources</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--这个元素描述了测试相关的所有资源路径，参见build/resources/resource元素的说明 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">testResource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">targetPath</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">excludes</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">testResource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">testResources</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--构建产生的所有文件存放的目录 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--产生的构件的文件名，默认值是$&#123;artifactId&#125;-$&#123;version&#125;。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--当filtering开关打开时，使用到的过滤器属性文件列表 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filters</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--子项目可以引用的默认插件信息。该插件配置项直到被引用时才会被解析或绑定到生命周期。给定插件的任何本地配置都会覆盖这里的配置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--使用的插件列表 。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--plugin元素包含描述插件所需要的信息。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--插件在仓库里的group ID --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--插件在仓库里的artifact ID --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--被使用的插件的版本（或版本范围） --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该元素才被设置成enabled。 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">extensions</span> /&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--execution元素包含了插件执行需要的信息 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">phase</span> /&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--配置的执行目标 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--配置是否被传播到子POM --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--作为DOM对象的配置 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--项目引入插件所需要的额外依赖 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                            ......</span><br><span class="line">                        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--任何配置是否被传播到子项目 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--作为DOM对象的配置 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--使用的插件列表 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">extensions</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                        ......</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--在列的项目构建profile，如果被激活，会修改构建处理 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--根据环境参数或命令行参数激活某个构建处理 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--构建配置的唯一标识符。即用于命令行激活，也用于在继承时合并具有相同标识符的profile。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--自动触发profile的条件逻辑。Activation是profile的开启钥匙。profile的力量来自于它 能够在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。activation元素并不是激活profile的唯一方式。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--profile默认是否激活的标志 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">activeByDefault</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本不是以1.4开头的JDK。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">jdk</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">os</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--激活profile的操作系统的名字 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Windows XP<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--激活profile的操作系统所属家族(如 &#x27;windows&#x27;) --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">family</span>&gt;</span>Windows<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--激活profile的操作系统体系结构 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">arch</span>&gt;</span>x86<span class="tag">&lt;/<span class="name">arch</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--激活profile的操作系统版本 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.2600<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">os</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--如果Maven检测到某一个属性（其值可以在POM中通过$&#123;名称&#125;引用），其拥有对应的名称和值，Profile就会被激活。如果值 字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--激活profile的属性的名称 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">name</span>&gt;</span>mavenVersion<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--激活profile的属性的值 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">value</span>&gt;</span>2.0.3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活 profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">file</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--如果指定的文件存在，则激活profile。 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">exists</span>&gt;</span>/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">exists</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--如果指定的文件不存在，则激活profile。 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">missing</span>&gt;</span>/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">missing</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--构建项目所需要的信息。参见build元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">defaultGoal</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">targetPath</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">filtering</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">directory</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">includes</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">excludes</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">testResources</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">testResource</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">targetPath</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">filtering</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">directory</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">includes</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">excludes</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">testResource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">testResources</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">finalName</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filters</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">extensions</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">phase</span> /&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                                <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                                    ......</span><br><span class="line">                                <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">extensions</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">phase</span> /&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                                ......</span><br><span class="line">                            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">modules</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--发现依赖和扩展的远程仓库列表。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--参见repositories/repository元素 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">name</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">url</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">layout</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--发现插件的远程仓库列表，这些插件用于构建和报表 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">name</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">url</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">layout</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                    ......</span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--不赞成使用. 现在Maven忽略该元素. --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">reports</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--该元素包括使用报表插件产生报表的规范。当用户执行&quot;mvn site&quot;，这些报表就会运行。 在页面导航栏能看到所有报表的链接。参见reporting元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">reporting</span>&gt;</span></span><br><span class="line">                ......</span><br><span class="line">            <span class="tag">&lt;/<span class="name">reporting</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--参见dependencyManagement元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                        ......</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--参见distributionManagement元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">                ......</span><br><span class="line">            <span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--参见properties元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">properties</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--发现依赖和扩展的远程仓库列表。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--包含需要连接到远程仓库的信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--如何处理远程仓库里发布版本的下载 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--当Maven验证构件校验文件失败时该怎么做：ignore（忽略），fail（失败），或者warn（警告）。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的 </span></span><br><span class="line"><span class="comment">                策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>banseon-repository-proxy<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--远程仓库名称 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>banseon-repository-proxy<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--远程仓库URL，按protocol://hostname/path形式 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.1.169:9999/repository/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然 </span></span><br><span class="line"><span class="comment">                而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--发现插件的远程仓库列表，这些插件用于构建和报表 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">            ......</span><br><span class="line">        <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--依赖的group ID --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--依赖的artifact ID --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-artifact<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--依赖的版本号。 在Maven 2里, 也可以配置成版本号的范围。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展名或分类器。类型经常和使用的打包方式对应， </span></span><br><span class="line"><span class="comment">                尽管这也有例外。一些类型的例子：jar，war，ejb-client和test-jar。如果设置extensions为 true，就可以在 plugin里定义新的类型。所以前面的类型的例子不完整。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 依赖的分类器。分类器可以区分属于同一个POM，但不同构建方式的构件。分类器名被附加到文件名的版本号后面。例如，如果你想要构建两个单独的构件成 </span></span><br><span class="line"><span class="comment">                JAR，一个使用Java 1.4编译器，另一个使用Java 6编译器，你就可以使用分类器来生成两个单独的JAR构件。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">classifier</span>&gt;</span><span class="tag">&lt;/<span class="name">classifier</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。 - compile ：默认范围，用于编译 - provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath </span></span><br><span class="line"><span class="comment">                - runtime: 在执行时需要使用 - test: 用于test任务时使用 - system: 需要外在提供相应的元素。通过systemPath来取得 </span></span><br><span class="line"><span class="comment">                - systemPath: 仅用于范围为system。提供相应的路径 - optional: 当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--仅供system范围使用。注意，不鼓励使用这个元素，并且在新的版本中该元素可能被覆盖掉。该元素为依赖规定了文件系统上的路径。需要绝对路径而不是相对路径。推荐使用属性匹配绝对路径，例如$&#123;java.home&#125;。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span><span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--当计算传递依赖时， 从依赖构件列表里，列出被排除的依赖构件集。即告诉maven你只依赖指定的项目，不依赖项目的依赖。此元素主要用于解决版本冲突问题 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--可选依赖，如果你在项目B中把C依赖声明为可选，你就需要在依赖于B的项目（例如项目A）中显式的引用对C的依赖。可选依赖阻断依赖的传递性。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--不赞成使用. 现在Maven忽略该元素. --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">reports</span>&gt;</span><span class="tag">&lt;/<span class="name">reports</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--该元素描述使用报表插件产生报表的规范。当用户执行&quot;mvn site&quot;，这些报表就会运行。 在页面导航栏能看到所有报表的链接。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">reporting</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--true，则，网站不包括默认的报表。这包括&quot;项目信息&quot;菜单中的报表。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">excludeDefaults</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--所有产生的报表存放到哪里。默认值是$&#123;project.build.directory&#125;/site。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">outputDirectory</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--使用的报表插件和他们的配置。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--plugin元素包含描述报表插件需要的信息 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--报表插件在仓库里的group ID --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--报表插件在仓库里的artifact ID --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--被使用的报表插件的版本（或版本范围） --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--任何配置是否被传播到子项目 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--报表插件的配置 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--一组报表的多重规范，每个规范可能有不同的配置。一个规范（报表集）对应一个执行目标 。例如，有1，2，3，4，5，6，7，8，9个报表。1，2，5构成A报表集，对应一个执行目标。2，5，8构成B报表集，对应另一个执行目标 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">reportSets</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--表示报表的一个集合，以及产生该集合的配置 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">reportSet</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--报表集合的唯一标识符，POM继承时用到 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--产生报表集合时，被使用的报表的配置 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--配置是否被继承到子POMs --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--这个集合里使用到哪些报表 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">reports</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">reportSet</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">reportSets</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">reporting</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 继承自该项目的所有子项目的默认依赖信息。这部分的依赖信息不会被立即解析,而是当子项目声明一个依赖（必须描述group ID和 artifact </span></span><br><span class="line"><span class="comment">        ID信息），如果group ID和artifact ID以外的一些信息没有描述，则通过group ID和artifact ID 匹配到这里的依赖，并使用这里的依赖信息。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                ......</span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目分发信息，在执行mvn deploy后表示要发布的位置。有了这些信息就可以把网站部署到远程服务器或者把构件部署到远程仓库。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--部署项目产生的构件到远程仓库需要的信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--是分配给快照一个唯一的版本号（由时间戳和构建流水号）？还是每次都使用相同的版本号？参见repositories/repository元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">uniqueVersion</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>banseon-maven2<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>banseon maven2<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>file://$&#123;basedir&#125;/target/deploy<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">layout</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--构件的快照部署到哪里？如果没有配置该元素，默认部署到repository元素配置的仓库，参见distributionManagement/repository元素 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">uniqueVersion</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>banseon-maven2<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Banseon-maven2 Snapshot Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>scp://svn.baidu.com/banseon:/usr/local/maven-snapshot<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">layout</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--部署项目的网站需要的信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">site</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--部署位置的唯一标识符，用来匹配站点和settings.xml文件里的配置 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>banseon-site<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--部署位置的名称 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>business api website<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--部署位置的URL，按protocol://hostname/path形式 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span></span><br><span class="line">                scp://svn.baidu.com/banseon:/var/www/localhost/banseon-web</span><br><span class="line">            <span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">site</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--项目下载页面的URL。如果没有该元素，用户应该参考主页。使用该元素的原因是：帮助定位那些不在仓库里的构件（由于license限制）。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">downloadUrl</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--如果构件有了新的group ID和artifact ID（构件移到了新的位置），这里列出构件的重定位信息。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relocation</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--构件新的group ID --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--构件新的artifact ID --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--构件新的版本号 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--显示给用户的，关于移动的额外信息，例如原因。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">message</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">relocation</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 给出该构件在远程仓库的状态。不得在本地项目中设置该元素，因为这是工具自动更新的。有效的值有：none（默认），converted（仓库管理员从 </span></span><br><span class="line"><span class="comment">            Maven 1 POM转换过来），partner（直接从伙伴Maven 2仓库同步过来），deployed（从Maven 2实例部 署），verified（被核实时正确的和最终的）。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">status</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--以值替代名称，Properties可以在整个POM中使用，也可以作为触发条件（见settings.xml配置文件里activation元素的说明）。格式是&lt;name&gt;value&lt;/name&gt;。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发核心知识体系精讲——线程8大核心基础(一)</title>
    <url>/2021/11/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B8%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="实现多线程的方法到底是1种还是2种还是4种？"><a href="#实现多线程的方法到底是1种还是2种还是4种？" class="headerlink" title="实现多线程的方法到底是1种还是2种还是4种？"></a>实现多线程的方法到底是1种还是2种还是4种？</h1><h2 id="网上的说法"><a href="#网上的说法" class="headerlink" title="网上的说法"></a>网上的说法</h2><p><img src="/2021/11/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B8%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E7%BD%91%E4%B8%8A%E8%AF%B4%E6%B3%95.png" alt="多线程实现方式网上说法"><br>网上说法很多，有两种、三种、四种，每一种说法看起来都很有说服力，都是从不同的角度进行分析。  </p>
<h2 id="正确的说法"><a href="#正确的说法" class="headerlink" title="正确的说法"></a>正确的说法</h2><p>Oracle官网的文档是如何写的？<br><img src="/2021/11/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B8%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/Orceal%E5%AE%98%E7%BD%91%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95-%E8%8B%B1%E6%96%87.png" alt="Orceal官网多线程实现方法-英文"><br>翻译成中文后如下：<br><img src="/2021/11/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B8%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/Orceal%E5%AE%98%E7%BD%91%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95-%E4%B8%AD%E6%96%87.png" alt="Orceal官网多线程实现方法-中文"><br>如图中描述，第一种是声明成Thread类的子类，第二种方法是实现Runnable接口。<br><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html">oracle官网文档</a></p>
<h3 id="方法一：实现Runnable接口"><a href="#方法一：实现Runnable接口" class="headerlink" title="方法一：实现Runnable接口"></a>方法一：实现Runnable接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableStyle</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> RunnableStyle()).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用Runnable方法实现线程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：继承Thread类"><a href="#方法二：继承Thread类" class="headerlink" title="方法二：继承Thread类"></a>方法二：继承Thread类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadStyle</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ThreadStyle().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用Thread方法实现线程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="两种方法对比"><a href="#两种方法对比" class="headerlink" title="两种方法对比"></a>两种方法对比</h3><h4 id="方法一（实现Runnable接口更好）"><a href="#方法一（实现Runnable接口更好）" class="headerlink" title="方法一（实现Runnable接口更好）"></a>方法一（实现Runnable接口更好）</h4><ul>
<li>首先从架构角度，线程执行的任务，也就是run中运行的具体代码，应该是和Thread类是解耦的；</li>
<li>使用继承Thread类的方法，无法使用线程池；</li>
<li>由于java不支持多继承，所以继承了Thread之后就无法再继承其他类，不便于扩展。</li>
</ul>
<h4 id="两种方法的本质对比"><a href="#两种方法的本质对比" class="headerlink" title="两种方法的本质对比"></a>两种方法的本质对比</h4><h5 id="方法一：最总调用target-run"><a href="#方法一：最总调用target-run" class="headerlink" title="方法一：最总调用target.run()"></a>方法一：最总调用<code>target.run()</code></h5><p><code>target</code>就是通过<code>Thread</code>有参构造传入的<code>Runnable</code>接口的实现类，所以再<code>Thread</code>中最终还是会调用<code>Runnable</code>的实现类重写的<code>run()</code>方法  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    if (target != null) &#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="方法二：run-整个都被重写"><a href="#方法二：run-整个都被重写" class="headerlink" title="方法二：run()整个都被重写"></a>方法二：<code>run()</code>整个都被重写</h5><p><code>run()</code>方法整个都被重写之后，<code>Thread</code>最终就会直接调用被重写后<code>run()</code>方法</p>
<h4 id="如果同时使用两种方法会怎么样？"><a href="#如果同时使用两种方法会怎么样？" class="headerlink" title="如果同时使用两种方法会怎么样？"></a>如果同时使用两种方法会怎么样？</h4><p>代码如下：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BothRunnableThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我来自Runnable&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我来自Thread&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终打印结果是<code>我来自Thread</code>，因为在<code>Thread</code>类中，是先调用<code>Thread</code>类的<code>run()</code>方法，然后<code>target.run()</code>再调用作为参数的Runnable接口的实现的<code>run()</code>方法，<br>而代码中直接重写了<code>Thread</code>的<code>run()</code>方法，就不会再调用<code>target.run()</code>  </p>
<h3 id="总结：最精准的描述"><a href="#总结：最精准的描述" class="headerlink" title="总结：最精准的描述"></a>总结：最精准的描述</h3><ul>
<li>通常我们可以分为两类，Oracle也是这么说的；  </li>
<li>准确的讲，创建线程只有一种方法那就是构建Thread类，而实现线程的执行单元有两种方式。<blockquote>
<p>方法一：实现Runnable接口的run方法，并把Runnable实例传给Thread类；<br>方法二：重写Thread的run方法（继承Thread类）</p>
</blockquote>
</li>
</ul>
<h2 id="经典的错误观点"><a href="#经典的错误观点" class="headerlink" title="经典的错误观点"></a>经典的错误观点</h2><h3 id="线程池创建线程也算是一种新建线程的方法"><a href="#线程池创建线程也算是一种新建线程的方法" class="headerlink" title="线程池创建线程也算是一种新建线程的方法"></a>线程池创建线程也算是一种新建线程的方法</h3><p>对线程池的创建，最终都会调用到如图所示的方法，其中使用了<code>Executors.defaultThreadFactory()</code>，这个工程类就是创建线程池用的<br><img src="/2021/11/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B8%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%88%9B%E5%BB%BA%E5%9B%BE.png" alt="线程池创建图"></p>
<p>最终在默认情况下，使用的<code>DefaultThreadFactory</code>类，如图中所示，最终还是通过<code>Thread</code>类来创建的线程<br><img src="/2021/11/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B8%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/DefaultThreadFactory%E7%B1%BB%E5%9B%BE.png" alt="DefaultThreadFactory类图"></p>
<h3 id="通过Callable和FutureTask创建线程，也算是一种新建线程的方式"><a href="#通过Callable和FutureTask创建线程，也算是一种新建线程的方式" class="headerlink" title="通过Callable和FutureTask创建线程，也算是一种新建线程的方式"></a>通过<code>Callable</code>和<code>FutureTask</code>创建线程，也算是一种新建线程的方式</h3><img src="http://www.plantuml.com/plantuml/svg/RP1D3e8m44RtFSKi8O74FOQDYGSmX7s5KOcbcFuG4-Jkja1BRTnrEgyphr_75OeRRH0kcdDwPGWJ6OUk1Q5vaXPa9fr7pbffWSUwD4mDTrGnSAACsHaEQKmTCsxFFWpV2dahVITRMpyxICEeb50z1D8Mklx5i4UkPAZjZueAyx0WAsq7RAU8C8tbgzAKPWzCSr0VaZG8mlRcJMBLgwXyMli_BYlWWjpn9Cp7PfEwZG4JEMOrZ1vRL4on1RCuRP4CUVufmIkuwpmVWk742KJtNm00">

<p><code>Callable</code>主要是依赖于<code>FutureTask</code>，而FutureTask是继承于<code>Runnable</code>，最后依然还是需要依靠<code>Thread</code>来进行创建线程</p>
<img src="http://www.plantuml.com/plantuml/svg/PP312i8m38RlVOeUDzYUGF4Y-00YkzSkIh7Bf4s7CFhkjhfsizuIykN__qGXWRa92Vpi4CLL0v_PDAgU6uTLlMEUgOoS73a3--uGc8xVWKhWABIE6WcHeI-PvBEAmOi0UvidpNVquy6a5jOk2Ix2FkAY6fuQ1a2oXMgwOSMhRRGOgvxz7vDVGC84vwRZKyO-xmZDaYbKdYLDthRZHkSD">


<h3 id="无返回值是实现Runnable接口，有返回值是实现Callable接口，所以Callable是新的实现线程的方式"><a href="#无返回值是实现Runnable接口，有返回值是实现Callable接口，所以Callable是新的实现线程的方式" class="headerlink" title="无返回值是实现Runnable接口，有返回值是实现Callable接口，所以Callable是新的实现线程的方式"></a>无返回值是实现Runnable接口，有返回值是实现Callable接口，所以Callable是新的实现线程的方式</h3><p>此观点和上面的观点是一样的，<code>Callable</code>接口获取返回值依靠的是<code>FutureTask</code>，而<code>FutureTask</code>依然是对<code>Runnable</code>的实现</p>
<h3 id="定时器创建线程"><a href="#定时器创建线程" class="headerlink" title="定时器创建线程"></a>定时器创建线程</h3><p>代码如下，创建了一个每隔一秒打印线程名称的定时器，定时器的逻辑部分主要是依靠抽象类TimerTask的run()方法来实现的，而TimerTask也是继承与Runnable接口，Timer类内部依然是通过Thread来运行的线程  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoTimerTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">        timer.scheduleAtFixedRate(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">1000</span>,<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="匿名内部类创建线程"><a href="#匿名内部类创建线程" class="headerlink" title="匿名内部类创建线程"></a>匿名内部类创建线程</h3><p>具体代码如下，直接通过匿名内部类重写<code>Thread</code>或者实现<code>Runnable</code>的<code>run()</code>方法，实际上和通过类继承<code>Thread</code>类或者实现<code>Runnable</code>接口去重写<code>run()</code>没有什么区别  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonymousInnerClassDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="典型错误观点总结"><a href="#典型错误观点总结" class="headerlink" title="典型错误观点总结"></a>典型错误观点总结</h3><ul>
<li>多线程的实现方式，在代码中写法千变万化，但其本质万变不离其宗，都是通过之前所说的那两种方法实现的（继承<code>Thread</code>重写<code>run()</code>方法或实现<code>Runnable</code>接口实现<code>run()</code>方法）</li>
</ul>
<h3 id="Lambda表达式创建线程"><a href="#Lambda表达式创建线程" class="headerlink" title="Lambda表达式创建线程"></a>Lambda表达式创建线程</h3><p>代码如下，实际是通过函数式编程实现的，其本质和实现<code>Runnable</code>的匿名内部类没有区别  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lambda</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt; System.out.println(Thread.currentThread().getName())).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="如何从宏观和微观两个方面来提升技术？如何了解技术领域的前沿动态？如何在业务开发中成长？"><a href="#如何从宏观和微观两个方面来提升技术？如何了解技术领域的前沿动态？如何在业务开发中成长？" class="headerlink" title="如何从宏观和微观两个方面来提升技术？如何了解技术领域的前沿动态？如何在业务开发中成长？"></a>如何从宏观和微观两个方面来提升技术？如何了解技术领域的前沿动态？如何在业务开发中成长？</h2><h3 id="宏观上"><a href="#宏观上" class="headerlink" title="宏观上"></a>宏观上</h3><ul>
<li>并不是靠工作年限，有的人工作了5年技术却还只是懂皮毛。  </li>
<li>要有强大的责任心，不放过任何bug，找到原因并去解决，这就是提高。  </li>
<li>主动：永远不会觉得自己的时间多余，重构、优化、学习、总结等。  </li>
<li>敢于承担：虽然这个技术难题以前没有碰到过，但是在一定的了解调研后，敢于承担技术难题，让工作充满挑战，这一次次攻克难关的过程中，进步是飞速的。  </li>
<li>关系产品，关系业务，而不只是写的代码。</li>
</ul>
<h3 id="微观上"><a href="#微观上" class="headerlink" title="微观上"></a>微观上</h3><ul>
<li>看经典书籍（指外国人写的经典的中国译本，比如说Java并发编程实战、自顶向下计算机网络）</li>
<li>看官方文档</li>
<li>英文搜google和stackoverflow</li>
<li>自己动手，实践写demo，尝试用到项目里面</li>
<li>不理解的参考该领域的多个书本，综合判断  </li>
<li>学习开源项目，分析源码（学习synchronized原理，反编译看cpp代码）</li>
</ul>
<h2 id="常见面试问题"><a href="#常见面试问题" class="headerlink" title="常见面试问题"></a>常见面试问题</h2><h3 id="有多少中实现线程大的方法？"><a href="#有多少中实现线程大的方法？" class="headerlink" title="有多少中实现线程大的方法？"></a>有多少中实现线程大的方法？</h3><ul>
<li>从不同的角度看，会有不同的答案</li>
<li>典型答案是两种</li>
<li>我们看原理，两种本质都是一样的</li>
<li>具体展开说其他的方式</li>
<li>结论</li>
</ul>
<h3 id="实现Runnable接口和继承Thread类那种方式更好"><a href="#实现Runnable接口和继承Thread类那种方式更好" class="headerlink" title="实现Runnable接口和继承Thread类那种方式更好"></a>实现<code>Runnable</code>接口和继承<code>Thread</code>类那种方式更好</h3><ul>
<li>从代码架构角度（可以将线程分为两个部分，一是线程运行的具体任务，也就是实现run方法中的内容，二是线程的生命周期，也就是创建线程启动线程运行线程结束线程，这部分是<code>Thread</code>类实现的）  </li>
<li>新建线程大的损耗（继承<code>Thread</code>类的话，每次我们想要运行任务都需要创建一个线程，而实现<code>Runnable</code>接口的话，可以使用线程池，每次都使用同一个线程运行）【继承<code>Thread</code>类应该也是可以使用线程池的，只要不调用<code>start</code>方法去创建线程，线程池需要的是一个<code>Runnable</code>的实现类，而<code>Thread</code>本身也是<code>Runnable</code>接口大的实现类】    </li>
<li>Java不支持双继承</li>
</ul>
<h1 id="怎样才是正确的线程启动方式？"><a href="#怎样才是正确的线程启动方式？" class="headerlink" title="怎样才是正确的线程启动方式？"></a>怎样才是正确的线程启动方式？</h1><h2 id="start-和run-的比较"><a href="#start-和run-的比较" class="headerlink" title="start()和run()的比较"></a><code>start()</code>和<code>run()</code>的比较</h2><p>代码如下： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StartAndRunMethhodd</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable runnable = () -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125;;</span><br><span class="line">        runnable.run();</span><br><span class="line">        <span class="keyword">new</span> Thread(runnable).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main</span><br><span class="line">Thread-0</span><br></pre></td></tr></table></figure>

<h2 id="start-方法原理解读"><a href="#start-方法原理解读" class="headerlink" title="start()方法原理解读"></a><code>start()</code>方法原理解读</h2><h3 id="start-方法的含义"><a href="#start-方法的含义" class="headerlink" title="start()方法的含义"></a><code>start()</code>方法的含义</h3><ul>
<li><p>启动新线程</p>
<blockquote>
<p>当主线程在调用了<code>start</code>方法之后，会告诉jvm需要启动一个新大的线程，至于线程何时能够启动，是由线程调度器决定的，<br>并不是说调用了<code>start</code>方法之后线程就已经开始运行了，调用<code>start</code>方法只是一个通知，有可能立刻就还会执行，也可能会等一会执行，<br>调用<code>start</code>方法之后，是有两个线程在执行的，主线程以及开启的新线程  </p>
</blockquote>
</li>
<li><p>准备工作</p>
<blockquote>
<p>新线程在执行之前是需要做一些准备工作，首先会进入到就绪状态，此时已经获取到了除了cpu之外的其他资源，比如上下文内容等，<br>之后会被调度到执行状态，在执行状态才能去等待cpu资源获取cpu资源</p>
</blockquote>
</li>
<li><p>不能重复调用<code>start()</code></p>
<blockquote>
<p>会抛出异常，如下图，一旦线程开始运行，就会更改状态，运行完毕就会更改为终止状态，无法在切换到其他状态，所以第二次执行就会抛出异常<br><img src="/2021/11/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B8%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/%E5%A4%9A%E6%AC%A1%E6%89%A7%E8%A1%8Cstart%E6%96%B9%E6%B3%95%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8.png" alt="多次执行start方法抛出异常"></p>
</blockquote>
</li>
</ul>
<h3 id="start-源码解析"><a href="#start-源码解析" class="headerlink" title="start()源码解析"></a><code>start()</code>源码解析</h3><h4 id="启动新线程检查线程状态"><a href="#启动新线程检查线程状态" class="headerlink" title="启动新线程检查线程状态"></a>启动新线程检查线程状态</h4><p>如下图，可以看到<code>start</code>方法中，第一步就是先去检查线程的状态是不是0<br><img src="/2021/11/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B8%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/Thread%E4%B8%ADstart%E6%96%B9%E6%B3%95.png" alt="Thread中start方法"><br>线程状态threadStatus字段初始值为0<br><img src="/2021/11/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B8%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/threadStatus%E5%B1%9E%E6%80%A7%E5%88%9D%E5%A7%8B%E4%B8%BA0.png" alt="threadStatus属性初始为0"></p>
<h4 id="加入线程组"><a href="#加入线程组" class="headerlink" title="加入线程组"></a>加入线程组</h4><p>如上面的图所示，可以看到，检查完线程状态，会加入有个group组<code>group.add(this);</code></p>
<h4 id="start0"><a href="#start0" class="headerlink" title="start0()"></a><code>start0()</code></h4><p>之后就会调用<code>start0()</code>方法，<code>start0()</code>方法是一个<code>native</code>方法，是由C++实现的    </p>
<h2 id="run-方法原理解读"><a href="#run-方法原理解读" class="headerlink" title="run()方法原理解读"></a><code>run()</code>方法原理解读</h2><p>直接调用<code>run</code>方法，其实就是调用一个普通的方法，并不会启动新的线程，只是一个对象调用了一个普通的方法。  </p>
<h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><h3 id="一个线程两次调用start-方法，会出现什么情况？为什么？"><a href="#一个线程两次调用start-方法，会出现什么情况？为什么？" class="headerlink" title="一个线程两次调用start()方法，会出现什么情况？为什么？"></a>一个线程两次调用<code>start()</code>方法，会出现什么情况？为什么？</h3><p>刚刚上面已经讲解</p>
<h3 id="既然start-方法会调用run-方法，为什么我们选择调用start-方法，而不是直接调用run-方法呢？"><a href="#既然start-方法会调用run-方法，为什么我们选择调用start-方法，而不是直接调用run-方法呢？" class="headerlink" title="既然start()方法会调用run()方法，为什么我们选择调用start()方法，而不是直接调用run()方法呢？"></a>既然<code>start()</code>方法会调用<code>run()</code>方法，为什么我们选择调用<code>start()</code>方法，而不是直接调用<code>run()</code>方法呢？</h3><p>上面已经讲解</p>
<h1 id="上山容易下山难——如何正确停止线程？"><a href="#上山容易下山难——如何正确停止线程？" class="headerlink" title="上山容易下山难——如何正确停止线程？"></a>上山容易下山难——如何正确停止线程？</h1><h2 id="讲解原理"><a href="#讲解原理" class="headerlink" title="讲解原理"></a>讲解原理</h2><ul>
<li>原理介绍：使用<code>interrupt</code>来通知，而不是强制<blockquote>
<p>interrupt是通过启用一个线程来通知另一个线程停止的操作，java中没有强制停止一个线程的机制，只能做到通知，<br>被停止的线程拥有最高权限，它可以自己判断是否要停止，<br>因为被停止的线程一般收到停止通知之后，会需要做一些收尾工作，比如数据回滚数据保存之类，所以通知线程只能是通知，无法做到强制。</p>
</blockquote>
</li>
</ul>
<h2 id="最佳实践：如何正确停止线程"><a href="#最佳实践：如何正确停止线程" class="headerlink" title="最佳实践：如何正确停止线程"></a>最佳实践：如何正确停止线程</h2><h3 id="通常线程会在什么情况下停止"><a href="#通常线程会在什么情况下停止" class="headerlink" title="通常线程会在什么情况下停止"></a>通常线程会在什么情况下停止</h3><ul>
<li><code>run</code>方法的所有代码都运行完毕，线程会自动停止</li>
<li>有异常出现，并且方法中没有捕获异常会导致线程停止</li>
</ul>
<h3 id="正确的停止的方法：interrupt"><a href="#正确的停止的方法：interrupt" class="headerlink" title="正确的停止的方法：interrupt"></a>正确的停止的方法：interrupt</h3><h4 id="通常线程会在什么情况下停止普通情况"><a href="#通常线程会在什么情况下停止普通情况" class="headerlink" title="通常线程会在什么情况下停止普通情况"></a>通常线程会在什么情况下停止普通情况</h4><p>代码如下所示，<code>Thread.currentThread().isInterrupted()</code>方法是查看线程是否中断，需要不停大的在循环中查看线程状态，才能正确的停止线程，<br>否则的话线程是不会理会停止操作的。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RightWayStopThreadWithoutSleep</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RightWayStopThreadWithoutSleep());</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted() &amp;&amp; num &lt;= Integer.MAX_VALUE/<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (num % <span class="number">10000</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(num+<span class="string">&quot;是10000的倍数&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;任务运行结束了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="线程可能被堵塞"><a href="#线程可能被堵塞" class="headerlink" title="线程可能被堵塞"></a>线程可能被堵塞</h4><p>代码如下所示，我们要做的就是让线程处于<code>sleep</code>的时候收到中断通知  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RightWayStopThreadWithSleep</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Runnable runnable = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (num &lt;= <span class="number">300</span> &amp;&amp; !Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                    <span class="keyword">if</span> (num % <span class="number">100</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                        System.out.println(num+<span class="string">&quot;是100的倍数&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如图所示，当线程处于sleep的时候收到中断通知，会直接抛出异常<br><img src="/2021/11/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B8%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/sleep%E7%8A%B6%E6%80%81%E4%B8%8B%E6%94%B6%E5%88%B0%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD%E9%80%9A%E7%9F%A5.png" alt="sleep状态下收到线程中断通知"></p>
<h4 id="如果线程每次迭代后都堵塞"><a href="#如果线程每次迭代后都堵塞" class="headerlink" title="如果线程每次迭代后都堵塞"></a>如果线程每次迭代后都堵塞</h4><p>代码如下所示，在这种情况下，我们就没必须每次循环都调用<code>Thread.currentThread().isInterrupted()</code>去检查线程是否已经中断，因为每次循环的时候都会进行<code>sleep</code>，<code>sleep</code>对中断做了处理  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RightWayStopThreadWithSleepEveryLoop</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Runnable runnable = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (num &lt;= <span class="number">10000</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (num % <span class="number">100</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(num + <span class="string">&quot;是100的倍数&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    num++;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="while内try-catch的问题"><a href="#while内try-catch的问题" class="headerlink" title="while内try/catch的问题"></a><code>while</code>内<code>try/catch</code>的问题</h4><ul>
<li>如果将<code>try/catch</code>放到循环内部的话，中断会失败，因为上面的代码其实是依靠异常来中断了循环，然后再被循环外面的<code>try/catch</code>处理，而如果把<code>try/catch</code>放到循环里面，就无法依靠异常中断循环，所以循环将会继续  </li>
<li>把<code>try/catch</code>循环里面在while循环条件里面添加上<code>Thread.currentThread().isInterrupted()</code>判断是否中断，这样也是无效的，因为线程在获取到一次标记之后，就会清除标记，所以如果<code>sleep</code>获取了标记，<code>Thread.currentThread().isInterrupted()</code>就无法再成功检查了（极小概率再<code>sleep</code>之后，<code>while</code>循环之前收到中断通知，这样再进行判断的话就会中断循环，但概率极小）  </li>
</ul>
<h4 id="实际开发中的两种最佳实践"><a href="#实际开发中的两种最佳实践" class="headerlink" title="实际开发中的两种最佳实践"></a>实际开发中的两种最佳实践</h4><h5 id="优先选择：传递中断"><a href="#优先选择：传递中断" class="headerlink" title="优先选择：传递中断"></a>优先选择：传递中断</h5><p>如代码中所示，如果我们在调用其他方法的时候，有<code>sleep</code>的操作，那么不应该在方法里面捕获异常，而应该将异常上抛得到<code>run</code>方法里面，否则<code>run</code>方法里面无法感知到线程中断通知  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RightWayStopThreadInProd</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RightWayStopThreadInProd());</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;w&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                throwInMethod();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;收到中断请求&quot;</span>);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">throwInMethod</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="不想或无法传递：恢复中断"><a href="#不想或无法传递：恢复中断" class="headerlink" title="不想或无法传递：恢复中断"></a>不想或无法传递：恢复中断</h5><p>如下代码所示，如果下级方法想要自己处理异常，那么可以调用<code>Thread.currentThread().interrupt()</code>将中断通知恢复，以便于上级<code>run</code>方法感应到中断通知  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RightWayStopThreadInProd2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RightWayStopThreadInProd2());</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;收到中断通知，程序运行结束&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;w&quot;</span>);</span><br><span class="line">            reInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="不应该屏蔽中断"><a href="#不应该屏蔽中断" class="headerlink" title="不应该屏蔽中断"></a>不应该屏蔽中断</h5><p>既不在方法签名中抛出，也不在捕获异常后重新恢复中断，这样会导致上级<code>run</code>方法无法收到中断通知，以至于无法终止操作  </p>
<h3 id="响应中断的方法总结列表"><a href="#响应中断的方法总结列表" class="headerlink" title="响应中断的方法总结列表"></a>响应中断的方法总结列表</h3><ul>
<li>Object.wait() / wait(long) / wait(long, int)</li>
<li>Thread.sleep(long) / sleep(long, int)</li>
<li>Thread.join() / join(long) / join(long, int)</li>
<li>java.util.concurrent.BlockingQueue.task() / put(E)</li>
<li>java.util.concurrent.locks.Lock.lockInterruptibly()</li>
<li>java.util.concurrent.CountDownLatch.await()</li>
<li>java.util.concurrent.CyclicBarrier.await()</li>
<li>java.util.concurrent.Exchanger.exchange(V)</li>
<li>java.nio.channels.InterruptibleChannel 相关方法</li>
<li>java.nio.channels.Selector相关方法</li>
</ul>
<h3 id="正确停止带来的好处"><a href="#正确停止带来的好处" class="headerlink" title="正确停止带来的好处"></a>正确停止带来的好处</h3><p>使用<code>interrupt</code>来停止线程，可以由被停止的线程来判断要不要停止，也可以让被停止大的线程做好一些收尾工作  </p>
<h2 id="停止线程的错误方法"><a href="#停止线程的错误方法" class="headerlink" title="停止线程的错误方法"></a>停止线程的错误方法</h2><h3 id="被弃用的stop，suspend和resume方法"><a href="#被弃用的stop，suspend和resume方法" class="headerlink" title="被弃用的stop，suspend和resume方法"></a>被弃用的<code>stop</code>，<code>suspend</code>和<code>resume</code>方法</h3><ul>
<li>stop方法会导致线程突然停止，这样对线程中运行的代码是非常不友好的，假如正在处理一个任务，想要撤销，有时候会需要对一些数据进行回滚，突然停止会导致数据无法进行处理</li>
<li><code>suspend</code>和<code>resume</code>方法，挂起和唤醒，<code>suspend</code>方法在挂起的时候并不会释放它已经持有大的锁，而如果需要唤醒它的线程需要获取锁才能唤醒，就会导致死锁  </li>
</ul>
<h3 id="用volatile设置boolean标记位"><a href="#用volatile设置boolean标记位" class="headerlink" title="用volatile设置boolean标记位"></a>用<code>volatile</code>设置<code>boolean</code>标记位</h3><h4 id="看上去可行（有些时候确实是可用的）"><a href="#看上去可行（有些时候确实是可用的）" class="headerlink" title="看上去可行（有些时候确实是可用的）"></a>看上去可行（有些时候确实是可用的）</h4><p>代码如下，通过更改<code>canceled</code>字段的值，来使线程停止  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WrongWayVolatile</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> canceled = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (num &lt;= <span class="number">100000</span> &amp;&amp; !canceled)&#123;</span><br><span class="line">                <span class="keyword">if</span> (num % <span class="number">100</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                    System.out.println(num + <span class="string">&quot;是100的倍数&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                num++;</span><br><span class="line">                Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        WrongWayVolatile a = <span class="keyword">new</span> WrongWayVolatile();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(a);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        a.canceled = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="错误之处（有些时候会报错）"><a href="#错误之处（有些时候会报错）" class="headerlink" title="错误之处（有些时候会报错）"></a>错误之处（有些时候会报错）</h4><p>代码如下，生产者以较快的速度生产任务，消费者以较慢的速度消费任务，当队列满了之后，就会将生产者的异步堵塞，而这个时候，即便是更改<code>canceled</code>字段的值，代码也无法检测到  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WrongWayVolatileCantStop</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ArrayBlockingQueue storage = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">10</span>);</span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer(storage);</span><br><span class="line">        Thread producerThread = <span class="keyword">new</span> Thread(producer);</span><br><span class="line">        producerThread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer(storage);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (consumer.needMoreNums())&#123;</span><br><span class="line">            System.out.println(consumer.storage.take()+<span class="string">&quot;被消费了&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者不需要更多数据了&quot;</span>);</span><br><span class="line">        producer.canceled = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> canceled = <span class="keyword">false</span>;</span><br><span class="line">    BlockingQueue storage;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(BlockingQueue storage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.storage = storage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (num &lt;= <span class="number">100000</span> &amp;&amp; !canceled) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num % <span class="number">100</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    storage.put(num);</span><br><span class="line">                    System.out.println(num + <span class="string">&quot;是100的倍数,放入仓库了&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者停止运行&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    BlockingQueue storage;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(BlockingQueue storage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.storage = storage;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">needMoreNums</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Math.random() &gt; <span class="number">0.95</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="修正方案"><a href="#修正方案" class="headerlink" title="修正方案"></a>修正方案</h4><p>修正后的代码如下，使用<code>interrupt()</code>方法中断线程，并在循环的时候检查线程状态  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WrongWayVolatileFixed</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        WrongWayVolatileFixed body = <span class="keyword">new</span> WrongWayVolatileFixed();</span><br><span class="line">        ArrayBlockingQueue storage = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">10</span>);</span><br><span class="line">        Producer producer = body.n<span class="function">ew <span class="title">Producer</span><span class="params">(storage)</span></span>;</span><br><span class="line">        Thread producerThread = <span class="keyword">new</span> Thread(producer);</span><br><span class="line">        producerThread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        Consumer consumer = body.n<span class="function">ew <span class="title">Consumer</span><span class="params">(storage)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (consumer.needMoreNums())&#123;</span><br><span class="line">            System.out.println(consumer.storage.take()+<span class="string">&quot;被消费了&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者不需要更多数据了&quot;</span>);</span><br><span class="line">        producerThread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        BlockingQueue storage;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(BlockingQueue storage)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.storage = storage;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (num &lt;= <span class="number">100000</span> &amp;&amp; !Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (num % <span class="number">100</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                        storage.put(num);</span><br><span class="line">                        System.out.println(num + <span class="string">&quot;是100的倍数,放入仓库了&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;生产者停止运行&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">        BlockingQueue storage;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(BlockingQueue storage)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.storage = storage;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">needMoreNums</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (Math.random() &gt; <span class="number">0.95</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="重要函数的源码解析"><a href="#重要函数的源码解析" class="headerlink" title="重要函数的源码解析"></a>重要函数的源码解析</h2><h3 id="interrupt-方法"><a href="#interrupt-方法" class="headerlink" title="interrupt()方法"></a><code>interrupt()</code>方法</h3><p>如图所示，<code>interrupt()</code>方法中的主要逻辑都是调用<code>interrupt0()</code>方法实现的，<code>interrupt0()</code>方法是一个native方法<br><img src="/2021/11/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B8%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/interrupt%E6%96%B9%E6%B3%95%E4%BB%A3%E7%A0%81%E5%86%85%E5%AE%B9.png" alt="interrupt方法代码内容"><br><img src="/2021/11/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B8%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/interrupt%E6%96%B9%E6%B3%95native%E5%86%85%E5%AE%B9%E8%AE%B2%E8%A7%A3.png" alt="interrupt方法native内容讲解"></p>
<h3 id="判断是否已被中断的相关方法"><a href="#判断是否已被中断的相关方法" class="headerlink" title="判断是否已被中断的相关方法"></a>判断是否已被中断的相关方法</h3><h4 id="static-boolean-interrupted"><a href="#static-boolean-interrupted" class="headerlink" title="static boolean interrupted()"></a>static boolean interrupted()</h4><ul>
<li>返回当前线程是否被中断，获取之后清除当前状态</li>
<li>这个静态方法的目标对象是调用它的线程</li>
<li>如下图，参数为true，表示要清除状态<br><img src="/2021/11/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B8%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/interrupted%E6%96%B9%E6%B3%95%E4%BB%A3%E7%A0%81%E5%86%85%E5%AE%B9.png" alt="interrupted方法代码内容"></li>
</ul>
<h4 id="boolean-isInterrupt"><a href="#boolean-isInterrupt" class="headerlink" title="boolean isInterrupt()"></a>boolean isInterrupt()</h4><ul>
<li>返回当前线程是否被中断，获取之后不清除状态</li>
<li>如下图，参数为false，表示不进行清除<br><img src="/2021/11/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B8%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/isInterrupt%E6%96%B9%E6%B3%95%E4%BB%A3%E7%A0%81%E5%86%85%E5%AE%B9.png" alt="isInterrupt方法代码内容"></li>
</ul>
<h4 id="Thread-interrupted-的目标对象"><a href="#Thread-interrupted-的目标对象" class="headerlink" title="Thread.interrupted()的目标对象"></a>Thread.interrupted()的目标对象</h4><ul>
<li>目标对象是调用它的线程，即便使用的是其他线程的对象调用的这个静态方法，得到的结果依然是当前线程的</li>
<li>如果再main主线程中调用，无论是使用Thread直接调用，还是通过开启的多线程对象调用，得到的结果都是主线程的结果。</li>
</ul>
<h2 id="常见面试问题-1"><a href="#常见面试问题-1" class="headerlink" title="常见面试问题"></a>常见面试问题</h2><h3 id="如何停止线程"><a href="#如何停止线程" class="headerlink" title="如何停止线程"></a>如何停止线程</h3><ul>
<li>原理：用<code>interrupt</code>来请求、好处（使用interrupt停止线程，只是通知线程需要中断，可以给线程预留处理后续数据的时间）</li>
<li>想要停止线程，需要请求方、被停止方、子方法被调用方相互配合（请求方发出中断通知，被停止方需要在循环中监听中断状态，子方法需要将中断异常上抛，或者捕获后重新恢复中断状态）</li>
<li>最后再说错误的方法：<code>stop/suspend</code>已废弃，<code>volatile</code>的boolean无法处理长时间阻塞的情况（<code>stop</code>方法会直接停止线程，导致线程无法正确回滚数据；<code>suspend</code>方法可能会导致死锁；<code>volatile+boolean</code>的方法，在阻塞的情况下是无法中断线程的）</li>
</ul>
<h3 id="如何处理不可中断阻塞"><a href="#如何处理不可中断阻塞" class="headerlink" title="如何处理不可中断阻塞"></a>如何处理不可中断阻塞</h3><ul>
<li>没有通用的处理方法，只能根据不同的场景，尽量使用能够响应线程中断的方法</li>
</ul>
<h1 id="线程的一生——6个状态（生命周期）"><a href="#线程的一生——6个状态（生命周期）" class="headerlink" title="线程的一生——6个状态（生命周期）"></a>线程的一生——6个状态（生命周期）</h1><h2 id="有哪6中状态？每个状态是什么含义？"><a href="#有哪6中状态？每个状态是什么含义？" class="headerlink" title="有哪6中状态？每个状态是什么含义？"></a>有哪6中状态？每个状态是什么含义？</h2><ul>
<li><p>New</p>
<blockquote>
<p>已创建还未启动<br>当我们使用new Thread()创建了一个线程，还没有执行start方法，这个时候这个线程就处于这个状态  </p>
</blockquote>
</li>
<li><p>Runnable</p>
<blockquote>
<p>可运行/运行中<br>一旦线程调用了start方法，就会处于这个状态，有可能这个时候线程调度器还没有分配线程进行执行（此时可以称为可运行状态）<br>cpu分配了资源，进入运行状态，此时为运行中，依然是Runnable状态（运行中）<br>如果cpu调度器将资源突然调度到其他地方，那么该线程依然为Runnable状态（可运行）  </p>
</blockquote>
</li>
<li><p>Blocked</p>
<blockquote>
<p>被阻塞<br>进入synchronized代码块并且没有拿到锁时，处于该状态<br>当线程拿到锁之后，会切换到Runnable状态执行<br>只有synchronized锁，会进入此种状态  </p>
</blockquote>
</li>
<li><p>Waiting</p>
<blockquote>
<p>不计时等待<br>当调用这几个方法的时候，会使线程进入当前状态：Object.wait() \ Thread.join() \ LockSupport.park()<br>当调用这几个方法时，会唤醒等待，使线程重新进入Runnable状态：Object.notify() \ Object.notifyAll() \ LockSupport.unpark()<br>注意：方法都是不带时间的，如果代理时间参数，就会进入到计时等待  </p>
</blockquote>
</li>
<li><p>Timed Waiting </p>
<blockquote>
<p>计时等待<br>调用这几个方法，会进入当前状态：Thread.sleep(time) \ Object.wait(time) \ Thread.join(time) \ LockSupport.parkNanos(time) \ LockSupport.parkUntil(time)<br>当达到等待时间，或者调用这几个方法，会唤醒线程进入Runnable状态：Object.notify() \ Object.notifyAll() \ LockSupport.unpark()</p>
</blockquote>
</li>
<li><p>Terminated  </p>
<blockquote>
<p>已终止<br>当run方法已经执行完毕，会进入当前状态<br>或者抛出一个未捕获的异常，也会进入当前状态  </p>
</blockquote>
</li>
</ul>
<h2 id="状态间的转化图示"><a href="#状态间的转化图示" class="headerlink" title="状态间的转化图示"></a>状态间的转化图示</h2><img src="http://www.plantuml.com/plantuml/svg/fL9VIy9G77tVfzYZ1Ve1UWWqHqWwmHGVCcBfmlddJkOax2aXOvML3wMH5Ma8KVY7Z3GNxiliRlEfhz3r_vpurCE5o_cTUpZdTmz9-F4rN2aqeL22OlVt9wSylC5y0vw_OXuVILfjJW8Hu7L3a_9QEOVPdEwDBSAECAtothyJOVa9yriTNWUvYJ2vSwdLoqhnIwsTmLuMypfSX7rlDfyV4XwNWxHwXsgm_Q6AWbAhODZEwYvkDg_Z9E77q1dUTLwyOOwcGfOaJt6yQGMRsKGqdJkf1BFLP1e4mnmBc2Cw94lrVhMftf-efGxCjfJ2jzAw3G15A6Z7MLbyKPypyB68uYiN4XIQ_PlCDEoy0Usg3Nj5kNiQHy8yomsOEXU8F0lite_GGTvoI378Anu04_SHbW4ZmCa6ezkfH8BbU4k2ug8eqkIv8VXO2x0ySv0UFPw3hB7OecGAZ4Nr3f6kyMScMutHTCB4Ct5Qhp-qFmNr4QQWCGP90JQvVEm3F1CRZGqbCHjIZyg2MjClVg9lMKZzlqKCDh6aXZeSiL0f_m00">

<h3 id="状态之间转换代码演示"><a href="#状态之间转换代码演示" class="headerlink" title="状态之间转换代码演示"></a>状态之间转换代码演示</h3><ul>
<li>NEW -&gt; RUNNABLE -&gt; RUNNABLE -&gt; TERMINATED<blockquote>
<p>代码未执行start方法时状态为 NEW<br>代码执行start方法后状态为 RUNNABLE   （此时无法分辨是还未调用cpu资源还是已经调用cpu资源）<br>run在循环中，状态为 RUNNABLE<br>run方法运行结束后，状态为 TERMINATED</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewRunnableTerminated</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> NewRunnableTerminated());</span><br><span class="line">        System.out.println(thread.getState());</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(thread.getState());</span><br><span class="line">        Thread.sleep(<span class="number">5</span>);</span><br><span class="line">        System.out.println(thread.getState());</span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        System.out.println(thread.getState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>TIMED_WAITING -&gt; BLOCKED -&gt; WAITING<blockquote>
<p>线程1进入了<code>syn()</code>方法，执行了休眠1秒，此时的状态为 TIMED_WAITING<br>因为<code>syn()</code>方法是<code>synchronized</code>修饰的，线程1进入之后，线程2无法再拿到锁，所以此时线程2的状态为  BLOCKED<br>线程1休眠1秒种之后，进入<code>wait()</code>方法，此时状态为  WAITING</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockedWaitingTimedWaiting</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        BlockedWaitingTimedWaiting runnable = <span class="keyword">new</span> BlockedWaitingTimedWaiting();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        thread1.start();</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        thread2.start();</span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        System.out.println(thread1.getState());</span><br><span class="line">        System.out.println(thread2.getState());</span><br><span class="line">        Thread.sleep(<span class="number">1200</span>);</span><br><span class="line">        System.out.println(thread1.getState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        syn();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="阻塞状态是什么？"><a href="#阻塞状态是什么？" class="headerlink" title="阻塞状态是什么？"></a>阻塞状态是什么？</h2><ul>
<li>一般习惯而言，把<code>Blocked</code>（被阻塞）、<code>Waiting</code>（等待）、<code>Timed_Waiting</code>（计时等待）都称为阻塞状态  </li>
<li>不仅仅是<code>Blocked</code>  </li>
</ul>
<h2 id="常见面试问题-2"><a href="#常见面试问题-2" class="headerlink" title="常见面试问题"></a>常见面试问题</h2><h3 id="线程有哪几种状态？生命周期是什么？"><a href="#线程有哪几种状态？生命周期是什么？" class="headerlink" title="线程有哪几种状态？生命周期是什么？"></a>线程有哪几种状态？生命周期是什么？</h3><p>具体回答可以根据上面的线程状态流转图进行回答</p>
<h1 id="Thread和Object类中的重要方法详解"><a href="#Thread和Object类中的重要方法详解" class="headerlink" title="Thread和Object类中的重要方法详解"></a>Thread和Object类中的重要方法详解</h1><h2 id="方法概览"><a href="#方法概览" class="headerlink" title="方法概览"></a>方法概览</h2><table>
<thead>
<tr>
<th align="center">类</th>
<th align="left">方法名</th>
<th align="left">简介</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Thread</td>
<td align="left">sleep相关</td>
<td align="left">本表格的”相关”，指的是重载方法，也就是方法名相同，但参数个数不同，例如sleep有多个方法，只是参数不同，实际作用大同小异</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">join</td>
<td align="left">等待其他线程执行完毕</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">yield相关</td>
<td align="left">放弃已经获取到的cpu资源</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">currentThread</td>
<td align="left">获取当前执行线程的引用</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">start,ren相关</td>
<td align="left">启动线程相关</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">interrupt相关</td>
<td align="left">中断线程</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">stop(),suspend(),resuem()相关</td>
<td align="left">已废弃</td>
</tr>
<tr>
<td align="center">Object</td>
<td align="left">wait/notify/notifyAll相关</td>
<td align="left">让线程暂停时休息和唤醒</td>
</tr>
</tbody></table>
<h2 id="wait，notify，notifyAll方法详解"><a href="#wait，notify，notifyAll方法详解" class="headerlink" title="wait，notify，notifyAll方法详解"></a><code>wait</code>，<code>notify</code>，<code>notifyAll</code>方法详解</h2><h3 id="作用，用法"><a href="#作用，用法" class="headerlink" title="作用，用法"></a>作用，用法</h3><h4 id="阻塞阶段"><a href="#阻塞阶段" class="headerlink" title="阻塞阶段"></a>阻塞阶段</h4><ul>
<li>执行<code>wait</code>方法进入阻塞阶段的时候，必须要拥有monitor锁</li>
<li>进入阻塞阶段之后，直到以下4种情况之一发生时，才会被唤醒<blockquote>
<p>1）另一个线程调用这个对象的<code>notify()</code>方法且刚好被唤醒的是本线程<br>2）另一个线程调用这个对象的<code>notifyAll()</code>方法<br>3）过了<code>wait(long timeout)</code>规定的超时时间，如果传入0就是永远等待<br>4）线程自身调用了interrupt()</p>
</blockquote>
</li>
</ul>
<h4 id="唤醒阶段"><a href="#唤醒阶段" class="headerlink" title="唤醒阶段"></a>唤醒阶段</h4><ul>
<li><code>notify()</code>，随机唤醒一个线程</li>
<li><code>notifyAll()</code>，唤醒所有的线程</li>
</ul>
<h4 id="遇到中断"><a href="#遇到中断" class="headerlink" title="遇到中断"></a>遇到中断</h4><ul>
<li>会抛出<code>InterruptedException</code>异常，然后释放锁</li>
</ul>
<h3 id="代码演示：4种情况"><a href="#代码演示：4种情况" class="headerlink" title="代码演示：4种情况"></a>代码演示：4种情况</h3><h4 id="普通用法"><a href="#普通用法" class="headerlink" title="普通用法"></a>普通用法</h4><blockquote>
<p>代码如下所示<br>我们先启动线程1，使线程1先进入到synchronized代码块中，并且已经执行了wait方法，然后在启动线程2<br>由打印结果我们可以看出来，线程1在执行了wait方法之后，是已经释放锁了的，不然线程2无法进入同步代码块执行notify方法，也无法将线程1唤醒<br>由结果打印顺序也可以看出，我们是先运行了线程1，打印线程已经执行，然后线程2调用notify方法，之后打印输出，然后线程1再打印输出<br>所以，线程2将线程1唤醒之后，线程1是处于阻塞状态，不会立即执行代码，而是会等线程2执行完毕，线程1才能再次获取锁，然后开始执行  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wait</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;已经开始执行了&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    object.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;获取到了锁&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread2</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">                object.notify();</span><br><span class="line">                System.out.println(<span class="string">&quot;线程&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;调用了notify()方法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread1 thread1 = <span class="keyword">new</span> Thread1();</span><br><span class="line">        Thread2 thread2 = <span class="keyword">new</span> Thread2();</span><br><span class="line">        thread1.start();</span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thread-0已经开始执行了</span><br><span class="line">线程Thread-1调用了notify()方法</span><br><span class="line">Thread-0获取到了锁</span><br></pre></td></tr></table></figure>

<h4 id="notify和notifyAll展示"><a href="#notify和notifyAll展示" class="headerlink" title="notify和notifyAll展示"></a>notify和notifyAll展示</h4><blockquote>
<p>代码如下所示<br>线程A和线程B同时启动，然后串行执行同步代码块，线程A执行到wait方法，释放锁，线程B开始执行，线程B执行到wait方法后，释放锁<br>等待200毫秒之后，线程C开始执行，线程C执行了<code>notifyAll</code>方法，唤醒了阻塞中的线程A和线程B，然后线程A和线程B执行结束<br>如果使用的是<code>notify</code>方法的话，那么线程A和线程B只能唤醒一个，另一个将进行无尽的等待</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyAll</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object resourceA = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Runnable r = <span class="keyword">new</span> WaitNotifyAll();</span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        Thread threadC = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (resourceA) &#123;</span><br><span class="line">                    resourceA.notifyAll();</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程C notifyAll&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        threadC.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (resourceA)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;获取到锁&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;即将释放锁&quot;</span>);</span><br><span class="line">                resourceA.wait();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;程序即将结束&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thread-0获取到锁</span><br><span class="line">Thread-0即将释放锁</span><br><span class="line">Thread-1获取到锁</span><br><span class="line">Thread-1即将释放锁</span><br><span class="line">线程C notifyAll</span><br><span class="line">Thread-1程序即将结束</span><br><span class="line">Thread-0程序即将结束</span><br></pre></td></tr></table></figure>

<h4 id="只释放当前monitor展示"><a href="#只释放当前monitor展示" class="headerlink" title="只释放当前monitor展示"></a>只释放当前monitor展示</h4><blockquote>
<p>创建两把锁，A和B<br>线程1先获取锁A，然后获取锁B，然后释放锁A<br>线程2先获取锁A，然后尝试获取锁B<br>从结果可以看出，线程2是无法获取锁B的，因为线程1只释放了锁A<br>只释放当前monitor，不会影响已经拿到的其他monitor</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyReleaseOwnMonitor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Object resourceA = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Object resourceB = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (resourceA) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程1获取到resourceA锁&quot;</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (resourceB) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程1获取到resourceB锁&quot;</span>);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;线程1释放resourceA锁&quot;</span>);</span><br><span class="line">                            resourceA.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (resourceA) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程2获取到resourceA锁&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程2准备获取resourceB锁&quot;</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (resourceB) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程2获取到resourceB锁&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">线程1获取到resourceA锁</span><br><span class="line">线程1获取到resourceB锁</span><br><span class="line">线程1释放resourceA锁</span><br><span class="line">线程2获取到resourceA锁</span><br><span class="line">线程2准备获取resourceB锁</span><br></pre></td></tr></table></figure>

<h3 id="特点，性质"><a href="#特点，性质" class="headerlink" title="特点，性质"></a>特点，性质</h3><ul>
<li>调用wait或者notify或者notifyAll必须先拥有monitor（否则还会抛异常：IllegalMonitorStateException）  </li>
<li>notify只能唤醒一个，这一个是随机唤醒，无法指定  </li>
<li>这三个方法都属于Object类，所以所有对象都可以调用这三个方法  </li>
<li>类似功能的Condition（依赖与Lock锁）</li>
<li>同时持有多把锁大的情况（释放锁的时候要注意是多把锁，需要避免死锁）</li>
</ul>
<h3 id="手写生产者消费者设计模式"><a href="#手写生产者消费者设计模式" class="headerlink" title="手写生产者消费者设计模式"></a>手写生产者消费者设计模式</h3><blockquote>
<p>代码如下所示，使用<code>wait</code>和<code>notify</code>实现生产者消费者</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumerModel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EventStorage eventStorage = <span class="keyword">new</span> EventStorage();</span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer(eventStorage);</span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer(eventStorage);</span><br><span class="line">        <span class="keyword">new</span> Thread(producer).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(consumer).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EventStorage storage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(EventStorage storage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.storage = storage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            storage.put();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EventStorage storage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(EventStorage storage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.storage = storage;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            storage.task();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventStorage</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Date&gt; storage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EventStorage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">this</span>.storage = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (storage.size() == maxSize)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        storage.add(<span class="keyword">new</span> Date());</span><br><span class="line">        System.out.println(<span class="string">&quot;仓库里面有了 &quot;</span>+storage.size()+<span class="string">&quot; 件产品&quot;</span>);</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">task</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (storage.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;拿到了 &quot;</span>+storage.poll() + <span class="string">&quot;,现在仓库还剩&quot;</span>+storage.size());</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常见面试题-1"><a href="#常见面试题-1" class="headerlink" title="常见面试题"></a>常见面试题</h3><h4 id="用程序实现两个线程交替打印0-100的奇偶数"><a href="#用程序实现两个线程交替打印0-100的奇偶数" class="headerlink" title="用程序实现两个线程交替打印0~100的奇偶数"></a>用程序实现两个线程交替打印0~100的奇偶数</h4><ul>
<li><p>基本思路：<code>synchronized</code></p>
<blockquote>
<p>使用synchronized实现代码如下<br>使用位移运算符判断奇偶数进行打印，打印后自增1<br>两个线程使用同一把锁，如果线程抢到了锁，判断不符合自己的条件，就只是空循环，打印也不会加1<br>这个方法的问题就是可能会等导致线程多次抢到锁之后空转  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyPrintOddEvenSyn</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (count &lt; <span class="number">100</span>) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                        <span class="keyword">if</span> ((count &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + count++);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;偶数&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (count &lt; <span class="number">100</span>) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                        <span class="keyword">if</span> ((count &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + count++);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;奇数&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>更好的办法：<code>wait/notify</code></p>
<blockquote>
<p>使用wait/notify的代码如下<br>线程打印完之后，会去唤醒另外一个线程，然后自己进行休眠，线程交替唤醒交替休眠，第一个启动的线程为偶数  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyPrintOddEvenWait</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count ;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> TurningRunner(),<span class="string">&quot;偶数&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> TurningRunner(),<span class="string">&quot;奇数&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TurningRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (count &lt;= <span class="number">100</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;：&quot;</span>+count++);</span><br><span class="line">                    lock.notify();</span><br><span class="line">                    <span class="keyword">if</span> (count &lt;= <span class="number">100</span>)&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="手写生产者消费者设计模式-1"><a href="#手写生产者消费者设计模式-1" class="headerlink" title="手写生产者消费者设计模式"></a>手写生产者消费者设计模式</h4><ul>
<li>上面已经有了具体实现方法</li>
</ul>
<h4 id="为什么wait需要再同步代码块中使用，而sleep不需要"><a href="#为什么wait需要再同步代码块中使用，而sleep不需要" class="headerlink" title="为什么wait需要再同步代码块中使用，而sleep不需要"></a>为什么<code>wait</code>需要再同步代码块中使用，而<code>sleep</code>不需要</h4><blockquote>
<p>java语言设计的时候为了防止死锁<br>假设一个线程在执行代码，后面是调用<code>wait</code>方法，另一个线程后面是<code>notify</code>方法，如果不能同步的话，可能会存在执行到<code>wait</code>之前，先执行了<code>notify</code>方法，这样就会导致第一个线程在调用了wait之后陷入永久等待<br>而<code>sleep</code>所影响的只是当前线程所以可以不在同步代码块中  </p>
</blockquote>
<h4 id="为什么线程通信的方法wait-、notify-、notifyAll-被定义在Object类里面？而sleep定义在Thread类里？"><a href="#为什么线程通信的方法wait-、notify-、notifyAll-被定义在Object类里面？而sleep定义在Thread类里？" class="headerlink" title="为什么线程通信的方法wait()、notify()、notifyAll()被定义在Object类里面？而sleep定义在Thread类里？"></a>为什么线程通信的方法<code>wait()、notify()、notifyAll()</code>被定义在<code>Object</code>类里面？而<code>sleep</code>定义在<code>Thread</code>类里？</h4><blockquote>
<p>因为<code>wait()、notify()、notifyAll()</code>方法是属于锁级别的，而每一个锁都是一个对象<br>java实现锁的原理也是在对象头中做标记<br>如果将这三个方法放到每个线程中，每个线程也可能会持有多把锁，这样每次休眠和唤醒会非常麻烦  </p>
</blockquote>
<h4 id="wait方法是属于Object对象的，那调用Thread-wait会怎么样？"><a href="#wait方法是属于Object对象的，那调用Thread-wait会怎么样？" class="headerlink" title="wait方法是属于Object对象的，那调用Thread.wait会怎么样？"></a><code>wait</code>方法是属于<code>Object</code>对象的，那调用<code>Thread.wait</code>会怎么样？</h4><blockquote>
<p><code>Thread</code>也可以做锁对象，但是<code>Thread</code>比较特殊，最好不要用它来做锁对象<br>在线程退出的时候，会调用<code>Thread</code>类的<code>notifyAll</code>方法，所以如果使用<code>Thread</code>类做锁对象可能会导致线程总是被无故唤醒   </p>
</blockquote>
<h4 id="如何选择用notify还是notifyAll"><a href="#如何选择用notify还是notifyAll" class="headerlink" title="如何选择用notify还是notifyAll"></a>如何选择用<code>notify</code>还是<code>notifyAll</code></h4><blockquote>
<p>主要看是像唤醒多个线程还是一个线程，根据具体情况进行选择  </p>
</blockquote>
<h4 id="notifyAll之后所有的线程都会再次抢夺锁，如果某个线程抢夺失败怎么办？"><a href="#notifyAll之后所有的线程都会再次抢夺锁，如果某个线程抢夺失败怎么办？" class="headerlink" title="notifyAll之后所有的线程都会再次抢夺锁，如果某个线程抢夺失败怎么办？"></a><code>notifyAll</code>之后所有的线程都会再次抢夺锁，如果某个线程抢夺失败怎么办？</h4><blockquote>
<p>其他被唤醒但是没有获得锁的线程，会陷入阻塞状态，继续等待拿到锁  </p>
</blockquote>
<h4 id="用suspend-和resume-来阻塞线程可以吗？为什么？"><a href="#用suspend-和resume-来阻塞线程可以吗？为什么？" class="headerlink" title="用suspend()和resume()来阻塞线程可以吗？为什么？"></a>用<code>suspend()</code>和<code>resume()</code>来阻塞线程可以吗？为什么？</h4><blockquote>
<p>上面已经做出了解释  </p>
</blockquote>
<h2 id="sleep方法详解"><a href="#sleep方法详解" class="headerlink" title="sleep方法详解"></a><code>sleep</code>方法详解</h2><ul>
<li>作用：我只想让线程在预期的时间执行，其他时候不要占用CPU资源  </li>
</ul>
<h3 id="sleep方法不释放锁"><a href="#sleep方法不释放锁" class="headerlink" title="sleep方法不释放锁"></a><code>sleep</code>方法不释放锁</h3><ul>
<li>包括<code>synchronized</code>和<code>lock </code> </li>
<li>和<code>wait</code>不同  </li>
</ul>
<h3 id="sleep方法响应中断"><a href="#sleep方法响应中断" class="headerlink" title="sleep方法响应中断"></a><code>sleep</code>方法响应中断</h3><ul>
<li>抛出<code>InterruptedException</code>异常</li>
<li>清理中断状态<blockquote>
<p>代码如下，在sleep中被中断，还会抛出异常，然后继续执行  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepInterrupted</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SleepInterrupted());</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">6500</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> Date());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我被中断了&quot;</span>);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>sleep方法可以让线程进入Waiting状态，并且不占用CPU资源，但是不释放锁，直到规定时间后再执行，休眠期间如果被中断，会抛出异常并清除中断状态  </li>
</ul>
<h3 id="常见面试题-2"><a href="#常见面试题-2" class="headerlink" title="常见面试题"></a>常见面试题</h3><h4 id="wait-notify、sleep异同（方法属于那个对象？线程状态怎么切换？）"><a href="#wait-notify、sleep异同（方法属于那个对象？线程状态怎么切换？）" class="headerlink" title="wait/notify、sleep异同（方法属于那个对象？线程状态怎么切换？）"></a>wait/notify、sleep异同（方法属于那个对象？线程状态怎么切换？）</h4><ul>
<li><p>相同</p>
<blockquote>
<p>阻塞<br>响应中断</p>
</blockquote>
</li>
<li><p>不同</p>
<blockquote>
<p>同步方法<br>释放锁<br>指定时间<br>所属类</p>
</blockquote>
</li>
</ul>
<h2 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h2><ul>
<li>作用：因为新的线程加入了我们，所以我们要等待他执行完再出发</li>
<li>用法：main等待thread1执行完毕，注意谁等谁</li>
</ul>
<h3 id="普通用法-1"><a href="#普通用法-1" class="headerlink" title="普通用法"></a>普通用法</h3><blockquote>
<p>执行join之后，主线程会进行等待，等子线程执行完毕之后才会继续运行后面的代码  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Join</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;开始等待所有子线程运行结束&quot;</span>);</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;所有子线程执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="遇到中断-1"><a href="#遇到中断-1" class="headerlink" title="遇到中断"></a>遇到中断</h3><blockquote>
<p>join抓取的中断异常是主线程的中断异常</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinInterrupted</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread mainThread = Thread.currentThread();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    mainThread.interrupt();</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程执行完毕&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程中断&quot;</span>);</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;等待子线程执行完毕&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            thread.interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;子线程运行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在join期间，线程是什么状态？：waiting"><a href="#在join期间，线程是什么状态？：waiting" class="headerlink" title="在join期间，线程是什么状态？：waiting"></a>在join期间，线程是什么状态？：waiting</h3><blockquote>
<p>join期间，主线程处于<code>Waiting</code>状态</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinThreadState</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread mainThread = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                    System.out.println(mainThread.getState());</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread-0运行完毕&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;等待子线程运行&quot;</span>);</span><br><span class="line">        thread.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;子线程运行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>CountDownLatch或CyclicBarrier是经过封装的，可以实现和join一样的功能<h3 id="join源码"><a href="#join源码" class="headerlink" title="join源码"></a>join源码</h3><blockquote>
<p>由图可以看出，join方法也是通过wait实现的<br>而在Thread线程结束后，会调用一次notifyAll方法，唤醒线程，具体代码在C++部分<br>这也不能用Thread类做锁的原因  </p>
</blockquote>
</li>
</ul>
<p><img src="/2021/11/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B8%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/join%E6%BA%90%E7%A0%81%E5%9B%BE.png" alt="join源码图"></p>
<blockquote>
<p>线程退出源码</p>
</blockquote>
<p><img src="/2021/11/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B8%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/%E7%BA%BF%E7%A8%8B%E9%80%80%E5%87%BA%E6%BA%90%E7%A0%81.png" alt="线程退出源码"></p>
<h3 id="join等价代码"><a href="#join等价代码" class="headerlink" title="join等价代码"></a>join等价代码</h3><blockquote>
<p>可以使用wait来进行替换，上面的源码已经显示，线程在退出的时候，会唤醒所有的线程，所以在线程运行完毕之后，会唤醒wait的休眠</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinPrinciple</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;开始等待所有子线程运行结束&quot;</span>);</span><br><span class="line"><span class="comment">//        thread1.join();</span></span><br><span class="line">        <span class="keyword">synchronized</span> (thread1)&#123;</span><br><span class="line">            thread1.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;所有子线程执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="面试常见问题"><a href="#面试常见问题" class="headerlink" title="面试常见问题"></a>面试常见问题</h3><h4 id="在join期间，线程处于哪种线程状态？"><a href="#在join期间，线程处于哪种线程状态？" class="headerlink" title="在join期间，线程处于哪种线程状态？"></a>在join期间，线程处于哪种线程状态？</h4><ul>
<li>处于Waiting状态  </li>
</ul>
<h2 id="yield方法"><a href="#yield方法" class="headerlink" title="yield方法"></a>yield方法</h2><ul>
<li>作用：释放我的CPU时间片（释放时间片之后，状态依然是Runnable状态，随时有可能会被CPU调度执行）  </li>
<li>定位：JVM不保证遵循（根据具体的情况，有可能不生效，不同的cpu实现原理也可能会导致有不同的效果）</li>
<li>yield和sleep的区别：是否随时可能再次被调度（sleep线程认为是阻塞的，不会再调度起来，yield则随时可能被调度起来）</li>
</ul>
<h2 id="获取当前执行线程的引用：Thread-currentThread-方法"><a href="#获取当前执行线程的引用：Thread-currentThread-方法" class="headerlink" title="获取当前执行线程的引用：Thread.currentThread()方法"></a>获取当前执行线程的引用：Thread.currentThread()方法</h2><ul>
<li>返回当前所执行的线程的引用  </li>
</ul>
<h2 id="start和run方法"><a href="#start和run方法" class="headerlink" title="start和run方法"></a>start和run方法</h2><ul>
<li>前面已经有介绍</li>
<li>start会启动一个线程，run则只是调用对象的普通方法  </li>
</ul>
<h2 id="stop，suspend，resume方法"><a href="#stop，suspend，resume方法" class="headerlink" title="stop，suspend，resume方法"></a>stop，suspend，resume方法</h2><ul>
<li>已弃用</li>
</ul>
<h1 id="线程的各个属性"><a href="#线程的各个属性" class="headerlink" title="线程的各个属性"></a>线程的各个属性</h1><table>
<thead>
<tr>
<th align="center">属性名称</th>
<th align="left">用途</th>
<th align="left">注意事项</th>
</tr>
</thead>
<tbody><tr>
<td align="center">编号(ID)</td>
<td align="left">每个线程都有自己的ID，用于标识不同的线程</td>
<td align="left">被后续创建大的线程使用；唯一性；不允许被修改</td>
</tr>
<tr>
<td align="center">名称(Name)</td>
<td align="left">作用让用户或者程序员在开发、调试或运行过程中，更容易区分不同的线程、定位问题等。</td>
<td align="left">清晰有意义的名字；默认的名字</td>
</tr>
<tr>
<td align="center">是否是守护线程(isDaemon)</td>
<td align="left">true代表该线程是【守护线程】，false代表线程是非守护线程，也就是【用户线程】</td>
<td align="left">二选一；继承父线程；setDaemon</td>
</tr>
<tr>
<td align="center">优先级(Priority)</td>
<td align="left">优先级这个属性的目的是告诉线程调度器，用户希望哪些线程相对多运行、那些少运行</td>
<td align="left">默认和父线程的优先级相等；共10个等级；默认值是5；不应该依赖</td>
</tr>
</tbody></table>
<h2 id="线程Id"><a href="#线程Id" class="headerlink" title="线程Id"></a>线程Id</h2><ul>
<li>每个线程都有一个Id</li>
<li>线程Id是不能修改的</li>
<li>线程的Id是自增的，从1开始，main线程是第一个Id</li>
<li>但是在main方法里面创建的第一个线程绝对不是2，因为jvm启动大的时候会创建一些其他的线程</li>
<li>Thread类中获取Id的方法入下，<code>threadSeqNumber</code>初始为0，因为<code>++</code>在前，所以第一个线程的Id是1<br><img src="/2021/11/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B8%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/nextThhreadId.png" alt="nextThreadId"></li>
</ul>
<h2 id="线程名字"><a href="#线程名字" class="headerlink" title="线程名字"></a>线程名字</h2><ul>
<li>线程的名称如果没有设置默认是’Thread_0’，后面的数字递增</li>
<li>创建线程如果没有设置名称，会如下图设置一个默认名称，名称后面的编号是递增，从0开始<br><img src="/2021/11/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B8%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/%E7%BA%BF%E7%A8%8B%E9%BB%98%E8%AE%A4%E5%90%8D%E7%A7%B0.png" alt="线程默认名称"><br><img src="/2021/11/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B8%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/%E7%BA%BF%E7%A8%8B%E9%BB%98%E8%AE%A4%E5%90%8D%E7%A7%B0%E7%BC%96%E5%8F%B7%E8%8E%B7%E5%8F%96.png" alt="线程默认名称编号获取"></li>
<li>线程名称如下图，会设置两个名称，一个线程在java层面的名称，一个是在native的名称</li>
<li>设置名称时会判断线程状态，如果线程已经不是未启动状态，无法修改native层面的名称<br><img src="/2021/11/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B8%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E5%90%8D%E7%A7%B0%E6%BA%90%E7%A0%81.png" alt="设置线程名称源码"></li>
</ul>
<h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><ul>
<li>作用：给用户线程提供服务<h3 id="三个特性"><a href="#三个特性" class="headerlink" title="三个特性"></a>三个特性</h3></li>
<li>线程类型默认继承自父线程</li>
<li>被谁启动（通常都是由JVM启动的）</li>
<li>不影响JVM退出（JVM退出时只判断有没有用户线程，不会判断守护线程）</li>
</ul>
<h3 id="守护线程和普通线程的区别"><a href="#守护线程和普通线程的区别" class="headerlink" title="守护线程和普通线程的区别"></a>守护线程和普通线程的区别</h3><ul>
<li>整体无区别（都是为了执行任务，不过有的是用户的任务，有的是JVM的任务）</li>
<li>唯一的区别在于JVM的离开（用户线程会影响JVM是否退出，守护线程不会影响）</li>
</ul>
<h3 id="常见面试问题-3"><a href="#常见面试问题-3" class="headerlink" title="常见面试问题"></a>常见面试问题</h3><ul>
<li><p>守护线程和普通线程的区别</p>
<blockquote>
<p>答案同上</p>
</blockquote>
</li>
<li><p>我们是否需要给线程设置为守护线程</p>
<blockquote>
<p>不应该设置为守护线程，因为如果现在在处理数据，设置成守护线程，JVM退出的时候不会考虑它是否还在运行</p>
</blockquote>
</li>
</ul>
<h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><ul>
<li>优先级一共由10个级别，线程的优先级默认是5</li>
<li>程序设计不应该依赖于优先级<blockquote>
<p>不同的操作系统对优先级的理解是不一样的（每种操作系统的优先级级别设置是不一样的，需要一些映射，这样可能会和原本的期望不一致）<br>优先级会被操作系统修改（）</p>
</blockquote>
</li>
</ul>
<h1 id="未捕获异常如何处理？"><a href="#未捕获异常如何处理？" class="headerlink" title="未捕获异常如何处理？"></a>未捕获异常如何处理？</h1><h2 id="线程未捕获异常UncaughtException应该如何处理？"><a href="#线程未捕获异常UncaughtException应该如何处理？" class="headerlink" title="线程未捕获异常UncaughtException应该如何处理？"></a>线程未捕获异常<code>UncaughtException</code>应该如何处理？</h2><ul>
<li>可以使用<code>UncaughtExceptionHandler</code>类来进行处理</li>
</ul>
<h3 id="为什么要用UncaughtExceptionHandler处理？"><a href="#为什么要用UncaughtExceptionHandler处理？" class="headerlink" title="为什么要用UncaughtExceptionHandler处理？"></a>为什么要用<code>UncaughtExceptionHandler</code>处理？</h3><ul>
<li>主线程可以轻松发现异常，子线程却不行</li>
<li>子线程的异常无法使用传统办法捕获</li>
<li>如果不对子线程的异常进行处理，那么会导致线程中断，任务无法处理，不利于程序的健壮性</li>
</ul>
<h3 id="两种解决办法"><a href="#两种解决办法" class="headerlink" title="两种解决办法"></a>两种解决办法</h3><ul>
<li>方案一（不推荐）：手动在每个run方法里面进行try/catch</li>
<li>方案二（推荐）：利用<code>UncaughtExceptionHandler</code><blockquote>
<p>UncaughtExceptionHandler接口<br><img src="/2021/11/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%AE%B2%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B8%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/UncaughtExceptionHandler%E6%8E%A5%E5%8F%A3%E4%BB%A3%E7%A0%81.png" alt="UncaughtExceptionHandler接口代码"></p>
</blockquote>
<h3 id="异常处理器的调用策略"><a href="#异常处理器的调用策略" class="headerlink" title="异常处理器的调用策略"></a>异常处理器的调用策略</h3></li>
<li>默认线程处理器（ThreadGroup）逻辑如下<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void uncaughtException(Thread t, Throwable e) &#123;</span><br><span class="line">    //默认情况下parent是null</span><br><span class="line">    if (parent != null) &#123;</span><br><span class="line">        parent.uncaughtException(t, e);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //调用Thread.setDefaultUncaughtExceptionHandler(...)</span><br><span class="line">        //方法设置的全局handler进行处理</span><br><span class="line">        Thread.UncaughtExceptionHandler ueh =</span><br><span class="line">            Thread.getDefaultUncaughtExceptionHandler();</span><br><span class="line">        if (ueh != null) &#123;</span><br><span class="line">            ueh.uncaughtException(t, e);</span><br><span class="line">        &#125; else if (!(e instanceof ThreadDeath)) &#123;</span><br><span class="line">            //全局handler也不存在就输出异常栈</span><br><span class="line">            System.err.print(&quot;Exception in thread \&quot;&quot;</span><br><span class="line">                             + t.getName() + &quot;\&quot; &quot;);</span><br><span class="line">            e.printStackTrace(System.err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
代码实现异常捕获器：<br>新建捕获器：  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyUncaughtExceptionHandler</span> <span class="keyword">implements</span> <span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyUncaughtExceptionHandler</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">        Logger logger = Logger.getAnonymousLogger();</span><br><span class="line">        logger.log(Level.WARNING, <span class="string">&quot;线程异常，终止了&quot;</span> + t.getName(), e);</span><br><span class="line">        System.out.println(name + <span class="string">&quot;捕获了异常&quot;</span> + t.getName() + <span class="string">&quot;异常：&quot;</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
具体使用：  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseOwnUncaughtExceptionHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> MyUncaughtExceptionHandler(<span class="string">&quot;捕获器1&quot;</span>));</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> CantCatchDirectly(),<span class="string">&quot;MyThread-1&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">300</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> CantCatchDirectly(),<span class="string">&quot;MyThread-2&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">300</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> CantCatchDirectly(),<span class="string">&quot;MyThread-3&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">300</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> CantCatchDirectly(),<span class="string">&quot;MyThread-4&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常见面试问题-4"><a href="#常见面试问题-4" class="headerlink" title="常见面试问题"></a>常见面试问题</h2><h3 id="Java异常体系"><a href="#Java异常体系" class="headerlink" title="Java异常体系"></a>Java异常体系</h3><h3 id="如何全局处理异常？为什么要全局处理异常？不处理行不行"><a href="#如何全局处理异常？为什么要全局处理异常？不处理行不行" class="headerlink" title="如何全局处理异常？为什么要全局处理异常？不处理行不行?"></a>如何全局处理异常？为什么要全局处理异常？不处理行不行?</h3>上面已经有了讲解<h3 id="run方法是否可以抛出异常？如果抛出异常，线程的状态会怎么样？"><a href="#run方法是否可以抛出异常？如果抛出异常，线程的状态会怎么样？" class="headerlink" title="run方法是否可以抛出异常？如果抛出异常，线程的状态会怎么样？"></a>run方法是否可以抛出异常？如果抛出异常，线程的状态会怎么样？</h3></li>
<li>run方法不能再向上抛出异常</li>
<li>如果是可检查异常，只能再run方法中进行捕获处理</li>
<li>如果是不可检查异常，抛出后，线程会终止运行</li>
</ul>
<h3 id="线程中如何处理某个未处理异常"><a href="#线程中如何处理某个未处理异常" class="headerlink" title="线程中如何处理某个未处理异常"></a>线程中如何处理某个未处理异常</h3><ul>
<li>UncaughtExceptionHandler</li>
</ul>
<h1 id="双刃剑：多线程会导致的问题"><a href="#双刃剑：多线程会导致的问题" class="headerlink" title="双刃剑：多线程会导致的问题"></a>双刃剑：多线程会导致的问题</h1><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><h3 id="什么是线程安全"><a href="#什么是线程安全" class="headerlink" title="什么是线程安全"></a>什么是线程安全</h3><blockquote>
<p>不管业务中遇到怎样的多个线程访问某个对象或者方法的情况，而再编译这个业务逻辑的时候，都不需要额外等地的做任何额外的处理（也就是可以像单线程编程一样），程序也可以正常运行（不会因为多线程而出错，就可以称为线程安全）</p>
</blockquote>
<h3 id="什么情况下会出现线程安全问题，怎么避免？"><a href="#什么情况下会出现线程安全问题，怎么避免？" class="headerlink" title="什么情况下会出现线程安全问题，怎么避免？"></a>什么情况下会出现线程安全问题，怎么避免？</h3><h4 id="运行结果错误：a-多线程下出现消失的请求现象"><a href="#运行结果错误：a-多线程下出现消失的请求现象" class="headerlink" title="运行结果错误：a++多线程下出现消失的请求现象"></a>运行结果错误：a++多线程下出现消失的请求现象</h4><blockquote>
<p>最终代码演示如下所示</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThreadError</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;表面上的结果&quot;</span> + instance.index);</span><br><span class="line">        System.out.println(<span class="string">&quot;正在的运行次数&quot;</span> + realIndex.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;出错的次数&quot;</span> + wrongCount.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> MultiThreadError instance = <span class="keyword">new</span> MultiThreadError();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> CyclicBarrier cyclicBarrier1 = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> CyclicBarrier cyclicBarrier2 = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">static</span> AtomicInteger realIndex = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="keyword">static</span> AtomicInteger wrongCount = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">boolean</span>[] marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">1000000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        marked[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cyclicBarrier2.reset();</span><br><span class="line">                cyclicBarrier1.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cyclicBarrier1.reset();</span><br><span class="line">                cyclicBarrier2.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            realIndex.incrementAndGet();</span><br><span class="line">            <span class="keyword">synchronized</span> (instance) &#123;</span><br><span class="line">                <span class="keyword">if</span> (marked[index] &amp;&amp; marked[index - <span class="number">1</span>]) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;发生了错误&quot;</span> + index);</span><br><span class="line">                    wrongCount.incrementAndGet();</span><br><span class="line">                &#125;</span><br><span class="line">                marked[index] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="活跃性问题：死锁、活锁、饥饿"><a href="#活跃性问题：死锁、活锁、饥饿" class="headerlink" title="活跃性问题：死锁、活锁、饥饿"></a>活跃性问题：死锁、活锁、饥饿</h4><blockquote>
<p>死锁示例代码如下  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThreadError</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> Object o2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MultiThreadError r1 = <span class="keyword">new</span> MultiThreadError();</span><br><span class="line">        MultiThreadError r2 = <span class="keyword">new</span> MultiThreadError();</span><br><span class="line">        r1.flag = <span class="number">1</span>;</span><br><span class="line">        r2.flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">new</span> Thread(r1).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(r2).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;flag = &quot;</span>+flag);</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o1)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (o2)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o2)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (o1)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="对象发布和初始化的时候的安全问题"><a href="#对象发布和初始化的时候的安全问题" class="headerlink" title="对象发布和初始化的时候的安全问题"></a>对象发布和初始化的时候的安全问题</h4><h5 id="什么是发布"><a href="#什么是发布" class="headerlink" title="什么是发布"></a>什么是发布</h5><ul>
<li>对象可以在超过当前类的范围外使用  </li>
<li>public修饰的属性对象  </li>
<li>一个方法return出一个对象  </li>
<li>将一个对象作为参数传到其他类的方法中 </li>
</ul>
<h5 id="什么是逸出"><a href="#什么是逸出" class="headerlink" title="什么是逸出"></a>什么是逸出</h5><ul>
<li>1.方法返回一个private对象（private的本意是不让外部访问）</li>
<li>2.还未完成初始化（构造函数没有完全执行完毕）就把对象提供给外界，比如：<ul>
<li>在构造函数中未初始化完毕就this赋值</li>
<li>隐式逸出——注册监听事件</li>
<li>构造函数中运行线程</li>
</ul>
</li>
</ul>
<h2 id="各种需要考虑线程安全的情况"><a href="#各种需要考虑线程安全的情况" class="headerlink" title="各种需要考虑线程安全的情况"></a>各种需要考虑线程安全的情况</h2><ul>
<li>访问共享的变量或资源，会有并发风险，比如对象的属性、静态变量、共享缓存、数据库等  </li>
<li>所有依赖时序的操作，即使每一步操作都是线程安全的，还是存在并发问题：read-modify-write、check0then-act</li>
<li>不同的数据之间存在捆绑关系的时候</li>
<li>我们使用其他类的时候，如果对方没有声明自己是线程安全的  </li>
</ul>
<h2 id="为什么多线程会带来性能问题"><a href="#为什么多线程会带来性能问题" class="headerlink" title="为什么多线程会带来性能问题"></a>为什么多线程会带来性能问题</h2><h3 id="调度：上下文切换"><a href="#调度：上下文切换" class="headerlink" title="调度：上下文切换"></a>调度：上下文切换</h3><ul>
<li>主要是值当线程发生调度的时候</li>
<li>当可运行的线程数超过了CPU的核数，就会开始调度线程，以便于让每个线程都有机会运行</li>
</ul>
<h4 id="什么是上下文"><a href="#什么是上下文" class="headerlink" title="什么是上下文"></a>什么是上下文</h4><ul>
<li>主要和一些程序计数器相关  </li>
<li>切换的时候首先需要挂起一个线程，将线程的运行状态保存得到内存中的某处</li>
<li>包括线程运行时需要的一些数据</li>
</ul>
<h4 id="缓存开销"><a href="#缓存开销" class="headerlink" title="缓存开销"></a>缓存开销</h4><ul>
<li>CPU为了运行速度，会先在通过计算，在内存中缓存一些可能用到的数据</li>
<li>而进行了上下文切换之后，这些缓存的数据大部分都已经没用了</li>
</ul>
<h4 id="何时会导致密集的上下文切换"><a href="#何时会导致密集的上下文切换" class="headerlink" title="何时会导致密集的上下文切换"></a>何时会导致密集的上下文切换</h4><ul>
<li>频繁的抢锁，频繁的IO操作 </li>
</ul>
<h3 id="协作：内存同步"><a href="#协作：内存同步" class="headerlink" title="协作：内存同步"></a>协作：内存同步</h3><ul>
<li>线程在运行的时候，会在线程内部缓存一些数据，如果使用锁，会强制同步线程的缓存数据和主内存的数据</li>
<li>使线程缓存数据失效，只能使用主内存数据  </li>
</ul>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
</search>
