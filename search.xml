<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>通过gitee和hexo搭建个人博客</title>
    <url>/2021/06/12/%E9%80%9A%E8%BF%87gitee%E5%92%8Chexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul>
<li>git（提供git命令）<a href="https://git-scm.com/">git官网</a></li>
<li>node（hexo依赖）<a href="https://nodejs.org/en/">nodejs官网</a></li>
<li>gitee（事先注册码云账号）<a href="https://gitee.com/">码云主页</a></li>
<li>编辑器（根据个人喜好使用即可）</li>
</ul>
<h2 id="码云配置"><a href="#码云配置" class="headerlink" title="码云配置"></a>码云配置</h2><p>在gitee上创建一个仓库<br><img src="/2021/06/12/%E9%80%9A%E8%BF%87gitee%E5%92%8Chexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/gitee%E6%96%B0%E5%BB%BA%E4%BB%93%E5%BA%93.png" alt="gitee新建仓库"><br>点击Gitee Pages配置博客地址<br><img src="/2021/06/12/%E9%80%9A%E8%BF%87gitee%E5%92%8Chexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/gitee%E9%85%8D%E7%BD%AE%E5%8D%9A%E5%AE%A2.png" alt="gitee配置博客"><br>具体命名格式可查看下面连接<br><a href="https://gitee.com/help/articles/4136#article-header0">gitee帮助中心</a>  </p>
<h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><blockquote>
<p>其他软件安装步骤省略，此处只说说hexo的安装和配置  </p>
</blockquote>
<ul>
<li>通过npm安装hexo<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g hexo 		# -g 指定全局安装，可以使用hexo命令</span><br></pre></td></tr></table></figure></li>
<li>打开工作文件夹，执行以下命令<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo init test		# 初始化创建，会在工作文件夹下创建test文件夹</span><br><span class="line">cd test				# 进入test目录</span><br><span class="line">npm install			# 进一步安装hexo所需文件</span><br></pre></td></tr></table></figure></li>
<li>安装之后可以启动进行预览<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo clean			# 清除所有记录</span><br><span class="line">hexo generate		# 生成静态网页</span><br><span class="line">hexo server     	# 启动服务,默认是在4000端口启动，可使用-p参数指定启动端口</span><br></pre></td></tr></table></figure></li>
<li>访问<a href="http://localhost:4000/">http://localhost:4000</a>预览<br><img src="/2021/06/12/%E9%80%9A%E8%BF%87gitee%E5%92%8Chexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A1%B5.png" alt="hexo默认主页">  </li>
</ul>
<blockquote>
<p>想要更换主题可以访问 <a href="https://hexo.io/themes/">hexo官网主题</a> 预览下载<br>将下载的主题放到themes文件夹下，然后更改_config.yml配置即可</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">sky</span>   <span class="comment">#值为你放在themes文件夹里的主题文件夹名称</span></span><br></pre></td></tr></table></figure>
<p>其他配置可以参考<a href="https://hexo.io/zh-cn/docs/">hexo官方文档</a></p>
<p>新建文章</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new test		# 会在test/source/_posts下会生成test.md文件</span><br></pre></td></tr></table></figure>

<h2 id="上传gitee"><a href="#上传gitee" class="headerlink" title="上传gitee"></a>上传gitee</h2><ul>
<li>需要先安装一个插件  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save  #安装git插件</span><br></pre></td></tr></table></figure></li>
<li>复制刚刚gitee创建的项目的url，打开_config.yml文件进行配置<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://gitee.com/ysymj/ysymj</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo deploy	# 上传到gitee</span><br><span class="line"><span class="meta">#</span><span class="bash">上传时会提示输入gitee的账户密码</span></span><br></pre></td></tr></table></figure></li>
<li>点击仓库主页-&gt;服务-&gt;Gitee Pages<br><img src="/2021/06/12/%E9%80%9A%E8%BF%87gitee%E5%92%8Chexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/gitee%E9%85%8D%E7%BD%AE%E5%8D%9A%E5%AE%A2.png" alt="gitee配置博客">  </li>
<li>点击更新，之后就可以通过配置的网址进行访问了<br><img src="/2021/06/12/%E9%80%9A%E8%BF%87gitee%E5%92%8Chexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2.png" alt="更新博客"></li>
</ul>
<h2 id="hexo博客访问图片问题"><a href="#hexo博客访问图片问题" class="headerlink" title="hexo博客访问图片问题"></a>hexo博客访问图片问题</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-image --save	# 安装hexo插件</span><br></pre></td></tr></table></figure>

<ul>
<li>修改_config.yml配置<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li>
<li>打开<code>/node_modules/hexo-asset-image/index.js</code>文件，将文件内容替换为一下内容<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">&#x27;cheerio&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPosition</span>(<span class="params">str, m, i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.split(m, i).join(m).length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> version = <span class="built_in">String</span>(hexo.version).split(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">hexo.extend.filter.register(<span class="string">&#x27;after_post_render&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> config = hexo.config;</span><br><span class="line">  <span class="keyword">if</span>(config.post_asset_folder)&#123;</span><br><span class="line">        <span class="keyword">var</span> link = data.permalink;</span><br><span class="line">    <span class="keyword">if</span>(version.length &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">Number</span>(version[<span class="number">0</span>]) == <span class="number">3</span>)</span><br><span class="line">       <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">       <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.</span></span><br><span class="line">    <span class="keyword">var</span> endPos = link.lastIndexOf(<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line">    link = link.substring(beginPos, endPos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> toprocess = [<span class="string">&#x27;excerpt&#x27;</span>, <span class="string">&#x27;more&#x27;</span>, <span class="string">&#x27;content&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; toprocess.length; i++)&#123;</span><br><span class="line">      <span class="keyword">var</span> key = toprocess[i];</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">var</span> $ = cheerio.load(data[key], &#123;</span><br><span class="line">        <span class="attr">ignoreWhitespace</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">xmlMode</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">lowerCaseTags</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">decodeEntities</span>: <span class="literal">false</span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      $(<span class="string">&#x27;img&#x27;</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ($(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>))&#123;</span><br><span class="line">            <span class="comment">// For windows style path, we replace &#x27;\&#x27; to &#x27;/&#x27;.</span></span><br><span class="line">            <span class="keyword">var</span> src = $(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span>(!<span class="regexp">/http[s]*.*|\/\/.*/</span>.test(src) &amp;&amp;</span><br><span class="line">               !<span class="regexp">/^\s*\//</span>.test(src)) &#123;</span><br><span class="line">              <span class="comment">// For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed.</span></span><br><span class="line">              <span class="comment">// In addition, to support multi-level local directory.</span></span><br><span class="line">              <span class="keyword">var</span> linkArray = link.split(<span class="string">&#x27;/&#x27;</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">              &#125;);</span><br><span class="line">              <span class="keyword">var</span> srcArray = src.split(<span class="string">&#x27;/&#x27;</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span> &amp;&amp; elem != <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">              &#125;);</span><br><span class="line">              <span class="keyword">if</span>(srcArray.length &gt; <span class="number">1</span>)</span><br><span class="line">                srcArray.shift();</span><br><span class="line">              src = srcArray.join(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">              $(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>, config.root + link + src);</span><br><span class="line">              <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">&quot;update link as:--&gt;&quot;</span>+config.root + link + src);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">&quot;no src attr, skipped...&quot;</span>);</span><br><span class="line">            <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info($(<span class="built_in">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      data[key] = $.html();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new test		# 生成新的文章</span><br></pre></td></tr></table></figure>
<p>执行命令生成新的文章，在生成新的文章的时候，会在同级目录下生成一个同名的文件夹，将图片放在文件夹中，md文件中图片配置为同级目录即可</p>
<h2 id="博客评论功能"><a href="#博客评论功能" class="headerlink" title="博客评论功能"></a>博客评论功能</h2><p>本博客评论功能是基于<code>valine</code>实现。<br>1.注册账号<br>需要登录leancloud（<a href="https://console.leancloud.cn/">https://console.leancloud.cn/</a> ）网站注册账号<br><img src="/2021/06/12/%E9%80%9A%E8%BF%87gitee%E5%92%8Chexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/leancloud%E7%99%BB%E5%BD%95.png" alt="leancloud登录"></p>
<p>2.创建应用<br>登录后点击创建应用，应用名称随便填，一般免费版使用开发板即可，使用商用版也可以，不过需要费出一定的费用。<br><img src="/2021/06/12/%E9%80%9A%E8%BF%87gitee%E5%92%8Chexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/leancloud%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8.png" alt="leancloud创建应用"></p>
<p>3.查看应用key<br>一次点击<code>新建的应用-设置-应用凭证</code>，可以看到入下图，复制AppID和AppKey一会需要用到。<br><img src="/2021/06/12/%E9%80%9A%E8%BF%87gitee%E5%92%8Chexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/leancloud-key%E6%9F%A5%E7%9C%8B.png" alt="leancloud-key查看"></p>
<p>4.改代码<br>在项目的<code>_config.yml</code>中增加以下配置，其中的appId和appKey就是上面复制的AppID和AppKey。    </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">comment:</span></span><br><span class="line">  <span class="attr">appId:</span> <span class="string">leancloud中的AppID</span></span><br><span class="line">  <span class="attr">appKey:</span> <span class="string">leancloud中的AppKey</span></span><br></pre></td></tr></table></figure>
<p>修改模板文件，在对应的模板中增加以下代码，作者的是<code>post.ejs</code>，具体应该会根据模板的不同而有所不同。  </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;comment-container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&#x27;//unpkg.com/valine/dist/Valine.min.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Valine(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">&#x27;#comment-container&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">appId</span>: <span class="string">&#x27;&lt;%- config.comment.appId %&gt;&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">appKey</span>: <span class="string">&#x27;&lt;%- config.comment.appKey %&gt;&#x27;</span></span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>享元模式</title>
    <url>/2021/09/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>运用共享技术来有效地支持大量细粒度对象的复用；<br>它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率。</p>
</blockquote>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li>常常应用于系统底层的开发，以便解决系统的性能问题；  </li>
<li>系统有大量相似对象、需要缓冲池的场景。  </li>
</ul>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>减少对象的创建，降低内存中对象的数量，降低系统的内存，提高效率；  </li>
<li>减少内存之外的其他资源占用。  </li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>关注内/外部状态、关注线程安全问题</li>
<li>使系统、程序逻辑复杂化</li>
</ul>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>享元模式的定义提出了两个要求，细粒度和共享对象。因为要求细粒度，所以不可避免地会使对象数量多且性质相似，此时我们就将这些对象的信息分为两个部分：<strong>内部状态</strong>和<strong>外部状态</strong>  </p>
<ul>
<li><strong>内部状态</strong>： 指对象共享出来的信息，存储在享元信息内部，并且不会随环境的改变而改变。  </li>
<li><strong>外部状态</strong>： 指对象得以依赖的一个标记，随环境的改变而改变，不可共享。 </li>
</ul>
<p>主要角色：<br><strong>抽象享元角色</strong>： 是所有的具体享元类的基类，为具体享元规范要求实现的公共接口，非享元的外部状态以参数的形式通过方法传入；<br><strong>具体享元角色</strong>：实现抽象享元角色中所规定的接口；<br><strong>非享元角色</strong>： 是不可共享的外部状态，它以参数的形式注入具体享元的相关方法中；<br><strong>享元工厂角色</strong>： 负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检查系统中是否存在符合要求的享元对象，如果存在则提供给客户，如果不存在的话，则创建一个新的享元对象。  </p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>我们在工作中，经常有一些需求文档，设计文档，接口文档等等，其实每次的文档格式是基本一样的只是内容不同，所以我们可以把文档模板做成享元对象，只需要每次在里面填充不同的内容即可  </p>
<p>首先我们创建非享元角色，文档内容，就算模板相同，每个模板的具体内容也是不同，属于外部状态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DocContent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DocContent</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建抽象享元角色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Template</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createDoc</span><span class="params">(DocContent content)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体享元角色，其中的<code>templateName</code>字段就是内部状态，每个模板的模板名称是相同的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DocTemplate</span> <span class="keyword">implements</span> <span class="title">Template</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String templateName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DocTemplate</span><span class="params">(String templateName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.templateName = templateName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createDoc</span><span class="params">(DocContent content)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前模板是：&quot;</span>+templateName+<span class="string">&quot;  内容是：&quot;</span>+content.getContent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建享元工厂，这里是使用<code>HashMap</code>来做享元对象的存储，<code>HashMap</code>属于非线程安全的，所以如果是在并发的情况下，可能会有并发问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DocFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String,DocTemplate&gt; TEMPLATE_MAP = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Template <span class="title">getTemplate</span><span class="params">(String templateName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!TEMPLATE_MAP.containsKey(templateName))&#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;新建模板：&quot;</span>+templateName+<span class="string">&quot;   &quot;</span>);</span><br><span class="line">            TEMPLATE_MAP.put(templateName,<span class="keyword">new</span> DocTemplate(templateName));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> TEMPLATE_MAP.get(templateName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体调用，这里使用随机数连续10次调用来查看输出内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] templateNames = &#123;<span class="string">&quot;需求文档&quot;</span>,<span class="string">&quot;接口文档&quot;</span>,<span class="string">&quot;设计文档&quot;</span>,<span class="string">&quot;简历&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DocFactory factory = <span class="keyword">new</span> DocFactory();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            String templateName = templateNames[(<span class="keyword">int</span>) (Math.random() * templateNames.length)];</span><br><span class="line">            Template template = factory.getTemplate(templateName);</span><br><span class="line">            template.createDoc(<span class="keyword">new</span> DocContent(templateName+<span class="string">&quot;的内容是&quot;</span>+i+<span class="string">&quot;.....&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果，从结果中可以看出，每一种模板在第一次使用的时候会创建新的，但是后续再次调用的时候就不会再新创建对象，而模板的内容每次调用都是不一样的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">新建模板:  接口文档   当前模板是:  接口文档  内容是:  接口文档的内容是0.....</span><br><span class="line">新建模板:  设计文档   当前模板是:  设计文档  内容是:  设计文档的内容是1.....</span><br><span class="line">新建模板:  需求文档   当前模板是:  需求文档  内容是:  需求文档的内容是2.....</span><br><span class="line">当前模板是:  设计文档  内容是:  设计文档的内容是3.....</span><br><span class="line">当前模板是:  设计文档  内容是:  设计文档的内容是4.....</span><br><span class="line">当前模板是:  接口文档  内容是:  接口文档的内容是5.....</span><br><span class="line">新建模板:  简历   当前模板是:  简历  内容是:  简历的内容是6.....</span><br><span class="line">当前模板是:  接口文档  内容是:  接口文档的内容是7.....</span><br><span class="line">当前模板是:  设计文档  内容是:  设计文档的内容是8.....</span><br><span class="line">当前模板是:  设计文档  内容是:  设计文档的内容是9.....</span><br></pre></td></tr></table></figure>

<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><img src="http://www.plantuml.com/plantuml/svg/XKzB3e8m4Dtt5BC4eru0D25-ua8CYUnDhICsWK9AnHZYtQrIclgBgqxdpVkndDOrp4isAuL2eQ0bbUGDLGXR9Rd8W7L0G6w4S3tA8sK8AHPL_hXgILFo0p29-gTrF4VBKFqdb_LEbihrYuK-gAtSXxiom8OM693glCyvW_-EqDvUF9UKgL9UdNP7BcWECQt2pcde99j2keYJTPGkTd6Km0G4Nc15wzFZVEhvDeYjag7gP-zBSh-BumGDnsFBVjyxIGYn5WOnJPvYlx0NQ3GQEDWT">




]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>代理模式</title>
    <url>/2021/09/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>为其他对象提供一种代理，以控制对这个对象的访问<br>代理对象在客户端和目标对象之间起到中介的作用  </p>
</blockquote>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>代理模式能将代理对象与真实被调用的目标对象分离</li>
<li>一定程度上降低了系统的耦合度，扩展性好</li>
<li>保护目标对象</li>
<li>增强目标对象</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>代理模式会造成系统设计中类的数目增加   </li>
<li>在客户端和目标对象增加一个代理对象，会造成请求处理速度变慢  </li>
<li>增加系统的复杂度  </li>
</ul>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><blockquote>
<p>JDk的静态代理要求目标对象和代理对象都要实现相同的接口。然后提供给客户端使用。这个代理对客户端是可见的。</p>
</blockquote>
<h2 id="JDk动态代理"><a href="#JDk动态代理" class="headerlink" title="JDk动态代理"></a>JDk动态代理</h2><blockquote>
<p>JDk的动态代理要求目标对象必须实现接口，因为它创建代理对象的时候是根据接口创建的，如果不实现接口，jdk无法给目标对象创建代理对象，被代理对象可以实现多个接口，创建代理时指定创建某个接口的代理对象就可以调用该接口中定义的方法了。</p>
</blockquote>
<h2 id="CGLib动态代理"><a href="#CGLib动态代理" class="headerlink" title="CGLib动态代理"></a>CGLib动态代理</h2><blockquote>
<p>jdk给目标类提供动态代理要求目标类必须实现接口，当一个目标类不实现接口时，jdk是无法为其提供动态代理的，cglib却能给这样的类提供动态代理。Spring在给某个类提供动态代理时，会自动在jdk动态代理和cglib动态代理中动态选择。</p>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2021/07/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>单例模式是java中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。这种模式设计到一个单一的类，该类负责创建自己的对象，同时保证只有单个对象被创建，这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。  </p>
<ul>
<li>单例类只能有一个实例。</li>
<li>单例类必须自己创建自己的唯一实例。</li>
<li>单例类必须给所有其他对象提供这一实例。</li>
</ul>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>意图：</strong> 保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br><strong>主要解决：</strong> 一个全局使用的类频繁地创建与销毁。<br><strong>何时使用：</strong> 当你想控制实例数目，节省系统资源的时候。  </p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul>
<li>构造函数私有。  </li>
<li>判断系统是否已经有这个单例，如果有则返回，如果没有则创建。  </li>
</ul>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例；</li>
<li>避免对资源的多重占用。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</li>
</ul>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>创建一个Singleton类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个Singleton对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取唯一可以用对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//让构造函数私有化，这样改类就不能在外部实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从Singleton类中获取唯一对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//无法通过new调用</span></span><br><span class="line">        <span class="comment">//Singleton singleton = new Singleton();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取唯一可用对象</span></span><br><span class="line">        Singleton instance = Singleton.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><img src="http://www.plantuml.com/plantuml/svg/Iyv9B2vM2CxCIyz9BSdFg-PwshhYwSQ6frFMFzdHy7Bkp6SDZK_NpNkohrj1eQ0eioon95MXk2In93CPeKSXCmyeb9US2jIxvcdhHeYkPzDsFjiy5QYhD2a7g1f3KtfgYITKduOcr_FbZS_cT3wRr_AoOS7JzhtFfcv0s0VNew6fKArGorNBXJ15rmx9I2kuIm00">

<h3 id="单例模式的几种实现方式"><a href="#单例模式的几种实现方式" class="headerlink" title="单例模式的几种实现方式"></a>单例模式的几种实现方式</h3><h4 id="1-饿汉式（静态变量）"><a href="#1-饿汉式（静态变量）" class="headerlink" title="1.饿汉式（静态变量）"></a>1.饿汉式（静态变量）</h4><p><strong>是否懒加载：</strong> 否<br><strong>是否线程安全：</strong> 是<br><strong>描述：</strong> 这种方式比较常用，但是容易产生垃圾。<br><strong>优点：</strong> 没有加锁，执行效率会提高。<br><strong>缺点：</strong> 类加载时就初始化，浪费内存空间。<br>它基于classloader机制避免了多线程的同步问题，不过，instance在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用getInstance方法，但是也不能确定有其他的方式（或其他的静态方法）导致类装载，这时候初始化instance显然没有达到懒加载的效果。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-饿汉式（静态代码块）"><a href="#2-饿汉式（静态代码块）" class="headerlink" title="2.饿汉式（静态代码块）"></a>2.饿汉式（静态代码块）</h4><p><strong>是否懒加载：</strong> 否<br><strong>是否线程安全：</strong> 是<br><strong>描述：</strong> 这种方式比较常用，但是容易产生垃圾。<br><strong>优点：</strong> 没有加锁，执行效率会提高。<br><strong>缺点：</strong> 类加载时就初始化，浪费内存空间。<br>这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候就执行静态代码块中的代码，初始化类的实例。优点和缺点和上面也是一样的。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-懒汉式，线程不安全"><a href="#3-懒汉式，线程不安全" class="headerlink" title="3.懒汉式，线程不安全"></a>3.懒汉式，线程不安全</h4><p><strong>是否懒加载：</strong> 是<br><strong>是否线程安全：</strong> 否<br><strong>描述：</strong> 这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁synchronize，所以严格意义上它并不算单例模式。这种方式懒加载很明显，不要求线程安全，在多线程不能正常工作。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-懒汉式，线程安全"><a href="#4-懒汉式，线程安全" class="headerlink" title="4.懒汉式，线程安全"></a>4.懒汉式，线程安全</h4><p><strong>是否懒加载：</strong> 是<br><strong>是否多线程安全：</strong> 是<br><strong>描述：</strong> 这种方式具备很好的lazy loading，能够在多线程中很好的工作，但是效率很低，99%情况下不需要同步。<br><strong>优点：</strong> 第一次调用才初始化，避免内存浪费。<br><strong>缺点：</strong> 必须加锁synchronize才能保证单例，但加锁会影响效率。<br>getInstance()的性能对应用程序不是很关键（该方法使用不太频繁）。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-双重锁-双重校验锁"><a href="#5-双重锁-双重校验锁" class="headerlink" title="5.双重锁/双重校验锁"></a>5.双重锁/双重校验锁</h4><p>是否懒加载：是<br>是否多线程安全：是<br>描述：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。<br>getInstance()的性能对应用程序很关键，参数需要添加volatile关键字防止指令重排  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-登记式-静态内部类"><a href="#6-登记式-静态内部类" class="headerlink" title="6.登记式/静态内部类"></a>6.登记式/静态内部类</h4><p><strong>是够懒加载：</strong> 是<br><strong>是否多线程安全：</strong> 是<br><strong>描述：</strong> 这种方式能达到双检锁方式一样的效果，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式，这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。<br>这种方式利用了classloader机制来保证初始化instance时只有一个线程，它跟饿汉式不同的是：饿汉式只要类被装载了，那么instance就会被实例化（没有达到懒加载的效果），而这种方式是Singleton类被装载了，instance不一定被初始化，因为SingletonHolder类没有被主动使用，自由通过显式调用getInstance方法时，才会显式装载SingletonHolder类，从而实例化instance。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-枚举"><a href="#7-枚举" class="headerlink" title="7.枚举"></a>7.枚举</h4><p><strong>是否懒加载：</strong> 是<br><strong>是否多线程安全：</strong> 是<br><strong>描述：</strong> 这种方式还没有被广泛使用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。这种方式是Effective Java作者Josh Bloch提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    INSTANCE;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whateverMethod</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="通过反射或序列化破解单例"><a href="#通过反射或序列化破解单例" class="headerlink" title="通过反射或序列化破解单例"></a>通过反射或序列化破解单例</h3><h4 id="反射破解"><a href="#反射破解" class="headerlink" title="反射破解"></a>反射破解</h4><p>单例类（以双检锁为例）：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException, InvocationTargetException, NoSuchMethodException </span>&#123;</span><br><span class="line">        Singleton instance = Singleton.getInstance();</span><br><span class="line">        System.out.println(instance);</span><br><span class="line">        Class c1 = instance.getClass();</span><br><span class="line">        Constructor constructor1 = c1.getDeclaredConstructor(<span class="keyword">null</span>);</span><br><span class="line">        constructor1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        System.out.println(constructor1.newInstance());</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; c2 = Class.forName(<span class="string">&quot;com.Singleton&quot;</span>);</span><br><span class="line">        Constructor constructor2 = c2.getDeclaredConstructor(<span class="keyword">null</span>);</span><br><span class="line">        constructor2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        System.out.println(constructor2.newInstance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过<code>getClass()</code>或者<code>Class.forName()</code>获取class对象，然后通过无参构造创建对象。  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">com.Singleton@1b6d3586</span><br><span class="line">com.Singleton@4554617c</span><br><span class="line">com.Singleton@74a14482</span><br></pre></td></tr></table></figure>

<h4 id="反序列化破解"><a href="#反序列化破解" class="headerlink" title="反序列化破解"></a>反序列化破解</h4><p>如果单例类实现了<code>Serializable</code>接口进行序列化，可以通过反序列化破解。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先将对象序列化到文件，然后从文件中读取对象。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        Singleton instance = Singleton.getInstance();</span><br><span class="line">        System.out.println(instance);</span><br><span class="line">        ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;D:/test.txt&quot;</span>));</span><br><span class="line">        objectOutputStream.writeObject(instance);</span><br><span class="line"></span><br><span class="line">        ObjectInputStream ous = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:/test.txt&quot;</span>));</span><br><span class="line">        Object o = ous.readObject();</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">com.Singleton@1b6d3586</span><br><span class="line">com.Singleton@312b1dae</span><br></pre></td></tr></table></figure>

<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><blockquote>
<p>反射破解是通过调用构造方法进行实例化，只需要在构造方法中跑出异常即可。  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>反序列化方式可以通过增加<code>readResolve()</code>方法解决，这个方法是基于回调的，反序列化时，如果定义了<code>readResolve()</code>则直接返回此方法指定的对象，而不需要再创建新的对象。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用第六种枚举类型实现单例模式，可以避免反射和序列化破解。  </p>
</blockquote>
<ul>
<li>jdk在反射的底层代码中限制了枚举不能通过<code>newInstance()</code>方法获取对象，里面判断类型是否是枚举，如果是直接抛出异常。  </li>
<li>枚举类型在序列化时是将枚举值的name存放到文件中的，反序列化时通过调用<code>valueOf()</code>方法获取对象。  </li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>原型模式</title>
    <url>/2021/09/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。<br>不需要知道任何细节，不调用构造函数。  </p>
</blockquote>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li>类初始化消耗较多资源  </li>
<li>new产生的一个对象需要非常繁琐的过程，（数据准备，访问权限等）  </li>
<li>构造函数比较复杂  </li>
<li>循环体重生产大量对象  </li>
</ul>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>原型模式性能比直接new一个对象性能高  </li>
<li>简化创建过程  </li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>必须配备克隆方法  </li>
<li>对克隆复杂对象或对克隆出的对象进行复杂改造时，容易引入风险  </li>
<li>深拷贝、浅拷贝要运用得当    </li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>假设一个场景，我们要发送大量邮件，邮件的标题发送地址内容，都是不同的或者有部分相同，而创建一个邮件对象假如耗时比较长，我们就可以用克隆来实现   </p>
<p>只要对象类实现<code>Cloneable</code>接口，然后重写<code>clone</code>方法就可以实现简单的克隆</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mail</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line">    <span class="keyword">private</span> String mailAddress;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMailAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mailAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMailAddress</span><span class="params">(String mailAddress)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mailAddress = mailAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTitle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mail <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Mail) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>clone</code>方法中可以根据具体情况添加业务逻辑，具体调用如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Mail mail = <span class="keyword">new</span> Mail();</span><br><span class="line">        Mail clone = mail.clone();</span><br><span class="line">        System.out.println(mail);</span><br><span class="line">        System.out.println(clone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">com.ys.Mail@7f31245a</span><br><span class="line">com.ys.Mail@6d6f6e28</span><br></pre></td></tr></table></figure>

<p>原型模式的克隆是分深克隆和浅克隆的，需要注意使用场景；</p>
<ul>
<li><strong>浅克隆</strong> ：创建一个新的对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。</li>
<li><strong>深克隆</strong> ：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。</li>
</ul>
<p>假设我们给对象类增加一个发送日期的字段，并给日期设置值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Mail mail = <span class="keyword">new</span> Mail();</span><br><span class="line">        mail.setDate(<span class="keyword">new</span> Date(<span class="number">0L</span>));</span><br><span class="line">        Mail clone = mail.clone();</span><br><span class="line">        System.out.println(mail);</span><br><span class="line">        System.out.println(clone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Mail&#123;date=Thu Jan 01 08:00:00 CST 1970&#125;com.ys.Mail@330bedb4</span><br><span class="line">Mail&#123;date=Thu Jan 01 08:00:00 CST 1970&#125;com.ys.Mail@2503dbd3</span><br></pre></td></tr></table></figure>

<p>修改我们克隆出来的对象的日期</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Mail mail = <span class="keyword">new</span> Mail();</span><br><span class="line">        mail.setDate(<span class="keyword">new</span> Date(<span class="number">0L</span>));</span><br><span class="line">        Mail clone = mail.clone();</span><br><span class="line">        clone.getDate().setTime(<span class="number">1630809727754L</span>);</span><br><span class="line">        System.out.println(mail);</span><br><span class="line">        System.out.println(clone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Mail&#123;date=Sun Sep 05 10:42:07 CST 2021&#125;com.ys.Mail@330bedb4</span><br><span class="line">Mail&#123;date=Sun Sep 05 10:42:07 CST 2021&#125;com.ys.Mail@2503dbd3</span><br></pre></td></tr></table></figure>

<p>会发现两个对象依然是不同的对象，但是日期却同时都被修改了<br>在debug模式下可以看出原因，两个对象引用的日期对象依然是同一个对象，就导致两个对象同时被修改<br><img src="/2021/09/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8Fdubug%E5%9B%BE.png" alt="原型模式dubug图"></p>
<p>解决办法就可以使用深克隆</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mail</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line">    <span class="keyword">private</span> String mailAddress;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> Date date;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Mail&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;date=&quot;</span> + date +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>+<span class="keyword">super</span>.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDate</span><span class="params">(Date date)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.date = date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMailAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mailAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMailAddress</span><span class="params">(String mailAddress)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mailAddress = mailAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTitle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mail <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Mail clone = (Mail) <span class="keyword">super</span>.clone();</span><br><span class="line">            clone.date = (Date) date.clone();</span><br><span class="line">            <span class="keyword">return</span> clone;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点看<code>clone</code>方法中的修改，对日期类型也进行了克隆。<br><img src="/2021/09/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E6%B7%B1%E5%85%8B%E9%9A%86debug%E5%9B%BE.png" alt="原型模式深克隆debug图"><br>从图中可以看到，日期类型已经不是同一个对象了。</p>
<h4 id="使用序列化实现深克隆"><a href="#使用序列化实现深克隆" class="headerlink" title="使用序列化实现深克隆"></a>使用序列化实现深克隆</h4><p>上面所描述的深克隆方法，每次如果添加了对象属性都需要在<code>clone</code>方法中进行维护才能实现深克隆，通过序列化实现深克隆可以解决这种问题<br>对象类实现<code>Serializable</code>接口<br>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mail</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line">    <span class="keyword">private</span> String mailAddress;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> Date date;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Mail&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;date=&quot;</span> + date +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>+<span class="keyword">super</span>.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mail <span class="title">mailClone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建流对象</span></span><br><span class="line">        ByteArrayOutputStream bos = <span class="keyword">null</span>;</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayInputStream bis = <span class="keyword">null</span>;</span><br><span class="line">        ObjectInputStream ois= <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//序列化</span></span><br><span class="line">            bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line">            oos.writeObject(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//反序列化</span></span><br><span class="line">            bis = <span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">            ois = <span class="keyword">new</span> ObjectInputStream(bis);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (Mail) ois.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (bos != <span class="keyword">null</span>)</span><br><span class="line">                    bos.close();</span><br><span class="line">                <span class="keyword">if</span> (oos != <span class="keyword">null</span>)</span><br><span class="line">                    oos.close();</span><br><span class="line">                <span class="keyword">if</span> (bis != <span class="keyword">null</span>)</span><br><span class="line">                    bis.close();</span><br><span class="line">                <span class="keyword">if</span> (ois != <span class="keyword">null</span>)</span><br><span class="line">                    ois.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDate</span><span class="params">(Date date)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.date = date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMailAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mailAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMailAddress</span><span class="params">(String mailAddress)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mailAddress = mailAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTitle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义mailClone方法，通过对当前对象序列化然后反序列化的方法，来达到深克隆的目的，这种方法如果在对象类中新增了对象属性，不需要再进行刻意维护<br>调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Mail mail = <span class="keyword">new</span> Mail();</span><br><span class="line">        mail.setDate(<span class="keyword">new</span> Date(<span class="number">0L</span>));</span><br><span class="line">        Mail clone = mail.mailClone();</span><br><span class="line">        clone.getDate().setTime(<span class="keyword">new</span> Date().getTime());</span><br><span class="line">        System.out.println(mail);</span><br><span class="line">        System.out.println(clone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Mail&#123;date=Thu Jan 01 08:00:00 CST 1970&#125;com.ys.Mail@7ea987ac</span><br><span class="line">Mail&#123;date=Sat Sep 11 19:06:14 CST 2021&#125;com.ys.Mail@5b480cf9</span><br></pre></td></tr></table></figure>


<h2 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h2><img src="http://www.plantuml.com/plantuml/svg/oymhIIrAIqnELN3EoSzBJKpAIQskvU9ApaaiBbRmJSpCKSZCBSX9pKtDAob6KiBrTDsyvtqRu0BF-fO-xL_yihttQTlCP93WisaxdssUoWKs0IoWeQa0D1XkT4XgSKarLq5fKavcia9nIM89a2hBpqnHo4tCpDC8BYdAp4kFZbL8B4elXca4csMZfmVMomK0">

<h2 id="克隆模式破解单例"><a href="#克隆模式破解单例" class="headerlink" title="克隆模式破解单例"></a>克隆模式破解单例</h2><p>以最简单的饿汉式单例为例，当单例类实现了<code>Cloneable</code>接口，并实现了<code>clone</code>方法就可以克隆产生多个实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Singleton clone = (Singleton) <span class="keyword">super</span>.clone();</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> copy mutable state here, so the clone can&#x27;t change the internals of the original</span></span><br><span class="line">            <span class="keyword">return</span> clone;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton instance = Singleton.getInstance();</span><br><span class="line">        Singleton clone = instance.clone();</span><br><span class="line">        System.out.println(instance);</span><br><span class="line">        System.out.println(clone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">com.ys.Singleton@7f31245a</span><br><span class="line">com.ys.Singleton@6d6f6e28</span><br></pre></td></tr></table></figure>

<p>解决办法：第一，不实现Cloneable接口，第二，在clone方法中返回会getInstance()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">com.ys.Singleton@7f31245a</span><br><span class="line">com.ys.Singleton@7f31245a</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>外观模式</title>
    <url>/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>外观模式又叫门面模式，是一种通过为多个复杂子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体细节，这样会大大降低应用程序的复杂度，提高程序的可维护性。</p>
</blockquote>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>外观模式包含以下主要角色：  </p>
<ul>
<li>外观角色： 为多个子系统提供一个共同的接口。  </li>
<li>子系统角色： 实现系统的部分功能，客户可以通过外观角色访问它。  </li>
<li>客户角色： 通过一个外观角色访问各个子系统的功能。   </li>
</ul>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li>子系统越来越复杂，增加外观模式提供简单调用接口。  </li>
<li>构建多层系统结构，利用外观对象作为每层的入口，简化层间调用。  </li>
</ul>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>简化了调用过程，无需深入了解子系统，防止带来风险。  </li>
<li>减少系统依赖、松散耦合。  </li>
<li>更好的划分访问层次。  </li>
<li>符合迪米特法则，即最少知道原则。  </li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>增加子系统、扩展子系统行为容易引入风险。  </li>
<li>不符合开闭原则。  </li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>假设我们现在有三个系统，<code>SubSystem01</code>、<code>SubSystem02</code>、<code>SubSystem03</code>，每个系统里面都有各自的逻辑处理方法；<br>我们现在有一个需求，需要调用三个系统联合去处理一个业务，那么就需要分别创建出<code>SubSystem01</code>、<code>SubSystem02</code>、<code>SubSystem03</code>系统的实例，然后调用对应的方法执行业务逻辑，<br>如果对象的创建，或者需要调用的方法很繁琐，那么每次处理逻辑，都要进行这块调用的处理，就很麻烦；<br>所以我们可以将这几个系统作为子系统，然后以一个高层系统(外观角色)进行封装，对外暴露一个相对简单的接口。</p>
<p>子系统1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubSystem01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子系统01的method1方法被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子系统2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubSystem02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子系统02的method2方法被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子系统3：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubSystem03</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子系统03的method3方法被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>外观角色：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Facade</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    SubSystem01 obj1 = <span class="keyword">new</span> SubSystem01();</span><br><span class="line">    SubSystem02 obj2 = <span class="keyword">new</span> SubSystem02();</span><br><span class="line">    SubSystem03 obj3 = <span class="keyword">new</span> SubSystem03();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        obj1.method1();</span><br><span class="line">        obj2.method2();</span><br><span class="line">        obj3.method3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Facade facade = <span class="keyword">new</span> Facade();</span><br><span class="line">        facade.method();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">子系统01的method1方法被调用</span><br><span class="line">子系统02的method2方法被调用</span><br><span class="line">子系统03的method3方法被调用</span><br></pre></td></tr></table></figure>

<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><img src="http://www.plantuml.com/plantuml/svg/TT6n3e8m40RW_PxYHXWmqeugeo-0ct4eq60DK4ABnY3lhXL2ggKtzl-QtlKWhvXIU6GvApWE0FYfjC_IfzAytiOeirkC1spumpuEmjsV94OIHn9NKYEf8wcHNzhsMILol4jHOCtrLHP1E8mm0apDskqDuEhOnyag9pvELpdzvIUkzCAKPdhHJ3H1gZlHbESBigvK8KuNvy_Ulw8eiOVn1SGNK03pF6wIUO5l">


]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂方法模式</title>
    <url>/2021/08/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>工厂方法模式属于类的创建型模式又被称为多态工厂模式。工厂方法模式的意义在于定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类中，核心工厂类不再负责产品的创建，仅负责声明具体工厂子类必须实现的接口。<br>这样进一步抽象画的好处是使得工厂方法模式可以使系统在不修改具体工厂角色的情况下引进新的产品。</p>
</blockquote>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><blockquote>
<p>1）创建对象需要大量重复的代码<br>2）客户端（应用层）不依赖于产品类实例如何被创建、实现等细节<br>3）一个类通过其子类来指定创建哪个对象  </p>
</blockquote>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>用户只需要关系所需产品对应的工厂，无须关心创建细节。  </li>
<li>加入新产品符合开闭原则，提高可扩展性。  </li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>类的个数容易过多，增加复杂度。  </li>
<li>增加了系统的抽象性和理解难度。  </li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="创建抽象产品类"><a href="#创建抽象产品类" class="headerlink" title="创建抽象产品类"></a>创建抽象产品类</h4><blockquote>
<p>我们创建一个电脑的抽象产品类，他有一个抽象方法用于启动电脑</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产品的抽象方法，由具体的产品类去实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建具体产品类"><a href="#创建具体产品类" class="headerlink" title="创建具体产品类"></a>创建具体产品类</h4><blockquote>
<p>接着我们创建各个品牌的电脑，他们都继承了他们的父类Computer，并实现了父类的start方法。</p>
</blockquote>
<p><strong>联想电脑</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LenovoComputer</span> <span class="keyword">extends</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;联想电脑启动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>惠普电脑</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HpComputer</span> <span class="keyword">extends</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;惠普电脑启动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>华硕电脑</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsusComputer</span> <span class="keyword">extends</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;华硕电脑启动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>创建一个工厂抽象类，具体创建产品的代码由工厂抽象类的子类去实现</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工厂方法创建产品接口抽象化，将具体创建产品的代码写到工厂方法子类中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Computer <span class="title">createComputer</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>创建联想电脑的工厂实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LenovoComputerFactory</span> <span class="keyword">extends</span> <span class="title">ComputerFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">createComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LenovoComputer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>创建惠普电脑的工厂实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HpComputerFactory</span> <span class="keyword">extends</span> <span class="title">ComputerFactory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">createComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HpComputer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>创建华硕电脑的工厂实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsusComputerFactory</span> <span class="keyword">extends</span> <span class="title">ComputerFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">createComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AsusComputer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>客户端调用</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过工厂方法的子类去创建对应的工厂类</span></span><br><span class="line">        <span class="comment">//每次增加新的产品，只需要新建一个抽象工厂方法的子类即可，不会对现有的产品产生影响</span></span><br><span class="line">        ComputerFactory computerFactory = <span class="keyword">new</span> HpComputerFactory();</span><br><span class="line">        Computer computer = computerFactory.createComputer();</span><br><span class="line">        computer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h2><img src="http://www.plantuml.com/plantuml/svg/IqmgBYbAJ2vHICv9B2vMSCxFBIWjIIsgvdewjUtfvCPdNNjVR5puRDhEPvkdlj_Jywn_mfDziv_ldlzaHmEor8jrAvzEQ7coOnL4rzDryvxtRU0gA4tAoKnMI8HPKPQVcQ9GN99OLAAXQSrLoyK5iTEnkBGOPgz2QaL9QbuAfaE0baDCXLZ-V5OBilrS3lvbgKL5cIcf2b1BaUsghaLOvfEQbr-MJpVhF0heO5KYzZXq0mhb5rKg02tQllHfNzFpZRiX9WCPHCKbMDVJjHE0wd74ADnpoKMfYIMfC2xEw8Kv2Jqi44w5k0JPQlpX0vBjcFrqzwvdyoU0P9VtGa8LvbISBiITA0Qf8n59QP0wC2IrkAGQfWEOG4jWYJKtCJDF8xYaA3ClFJfM8R4elLXJ0QAH2oNls-ZfOKijN6Xv5gGCQunn8UKsa2AC44Er3nPS8AKWjtDXJmPmQSm8W4a10000">
















































]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>创建者模式</title>
    <url>/2021/08/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8